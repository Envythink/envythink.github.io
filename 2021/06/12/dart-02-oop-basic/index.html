<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Dart面向对象基础 | 余思博客</title><meta name="keywords" content="dart"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="方法（函数）方法定义Dart是一个面向对象的语言，因此函数也是对象，属于Function对象。方法定义格式如下： 1234返回类型 方法名(参数1,参数2,...) &amp;#123;    方法体...    return 返回值;&amp;#125; 可以看到它其实和Java中方法的定义很像，所不同的是最前面没有方法的访问修饰符。 Dart中的方法的返回值类型和参数类型都可以省略。这里面还有一个箭头语法&#x3D;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Dart面向对象基础">
<meta property="og:url" content="http://envyzhan.asia/2021/06/12/dart-02-oop-basic/index.html">
<meta property="og:site_name" content="余思博客">
<meta property="og:description" content="方法（函数）方法定义Dart是一个面向对象的语言，因此函数也是对象，属于Function对象。方法定义格式如下： 1234返回类型 方法名(参数1,参数2,...) &amp;#123;    方法体...    return 返回值;&amp;#125; 可以看到它其实和Java中方法的定义很像，所不同的是最前面没有方法的访问修饰符。 Dart中的方法的返回值类型和参数类型都可以省略。这里面还有一个箭头语法&#x3D;&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png">
<meta property="article:published_time" content="2021-06-12T09:55:30.000Z">
<meta property="article:modified_time" content="2022-09-12T08:35:09.064Z">
<meta property="article:author" content="余思">
<meta property="article:tag" content="dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://envyzhan.asia/2021/06/12/dart-02-oop-basic/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dart面向对象基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 16:35:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="余思博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">255</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">余思博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Dart面向对象基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-12T09:55:30.000Z" title="发表于 2021-06-12 17:55:30">2021-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T08:35:09.064Z" title="更新于 2022-09-12 16:35:09">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dart/">dart</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>Dart是一个面向对象的语言，因此函数也是对象，属于Function对象。方法定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回类型 方法名(参数1,参数2,...) &#123;</span><br><span class="line">    方法体...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它其实和Java中方法的定义很像，所不同的是最前面没有方法的访问修饰符。</p>
<p>Dart中的方法的返回值类型和参数类型都可以省略。这里面还有一个箭头语法<code>=&gt; expr</code>，它其实是<code>&#123; return expr &#125;;</code>的缩写，只适用于一个表达式。方法都有返回值，如果没有指定，那么默认<code>return null</code>最后一句执行。</p>
<p>举个例子，下面的代码表示输出用户输入的参数信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main(List args)&#123;</span><br><span class="line">  print(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何让用户输入信息呢？在Dart中只需进入到该文件，然后使用<code>dart 文件名.dart</code>命令，后面再跟上需要输入的参数即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\DartProjects\hellodart\dart_basic\function&gt; dart myfunction.dart 1 &quot;test&quot; True</span><br><span class="line">[1, test, True]</span><br></pre></td></tr></table></figure>
<p>再来看一个有返回值的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  print(getPersonInfo(&quot;张三&quot;, 25));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getPersonInfo(String username,int age)&#123;</span><br><span class="line">  return &quot;name=$username,age=$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//name=张三,age=25</span><br></pre></td></tr></table></figure>
<p>再来看一下有返回值的情况以及使当方法体只有一个表达式时可以使用的箭头语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  print(getPersonInfo(&quot;张三&quot;, 25));  //name=张三,age=25</span><br><span class="line">  print(getPersonInfo2(&quot;李四&quot;, 26));  //name=李四,age=26</span><br><span class="line">  print(getPersonInfo3(&quot;王五&quot;, 27));  //null，因为该方法没有返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getPersonInfo(String username,int age)&#123;</span><br><span class="line">  return &quot;name=$username,age=$age&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPersonInfo2(username,age) =&gt; &quot;name=$username,age=$age&quot;;</span><br><span class="line"></span><br><span class="line">getPersonInfo3(String username,int age)&#123;</span><br><span class="line">  print(&quot;name=$username,age=$age&quot;);  //name=王五,age=27</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意方法的返回类型和参数的类型都是可以省略的，因此上述getPersonInfo3方法可修改为如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPersonInfo3(username,age)&#123;</span><br><span class="line">  print(&quot;name=$username,age=$age&quot;);  //name=王五,age=27</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，如果方法的返回值不是void，那么请不要省略方法的返回类型。</p>
<p>由于getPersonInfo3方法中只有一个表达式，因此也可以使用箭头语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPersonInfo3(username,age) =&gt;print(&quot;name=$username,age=$age&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数有两种，一种是可选命名参数<code>&#123;param1,param2&#125;</code>；另一种则是可选位置参数<code>[param1,param2]</code>。</p>
<h5 id="可选命名参数"><a href="#可选命名参数" class="headerlink" title="可选命名参数"></a>可选命名参数</h5><p>可选命名参数，即使用<code>&#123;&#125;</code>括起来，表明是可选命名参数，如<code>&#123;param1,param2&#125;</code>。可选命名参数在源码中使用较多。</p>
<p>举个例子，假设printPersonInfo方法总共传入了三个参数，其中name是必须传入的参数，而age和gender参数可以不传，此时代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  printPersonInfo(&quot;张三&quot;);  //username=张三, age=null, gender=null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonInfo(String username,&#123;int? age,String? gender&#125;)&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在int和String后面添加了一个问号，表示使用对应的可空类型。然后我们尝试依次传入对应参数，方法和执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  printPersonInfo(&quot;张三&quot;);  //username=张三, age=null, gender=null</span><br><span class="line">  printPersonInfo(&quot;李四&quot;,age: 26);  //username=李四, age=26, gender=null</span><br><span class="line">  printPersonInfo(&quot;王五&quot;,age: 28,gender: &quot;男&quot;);  //username=王五, age=28, gender=男</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonInfo(String username,&#123;int? age,String? gender&#125;)&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于此处采用的是可选命名参数，因此方法中参数的传入顺序与方法中定义的顺序可以不一致，因为它通过名称来定位参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printPersonInfo(&quot;张三&quot;,age: 26,gender: &quot;男&quot;);  //username=张三, age=26, gender=男</span><br><span class="line">printPersonInfo(&quot;张三&quot;,gender: &quot;男&quot;,age: 26);  //username=张三, age=26, gender=男</span><br></pre></td></tr></table></figure>
<h5 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h5><p>可选位置参数，即使用<code>[]</code>括起来，表明是可选位置参数，如<code>[param1,param2]</code>。举个例子，假设printPersonInfo方法总共传入了三个参数，其中name是必须传入的参数，而age和gender参数可以不传，此时代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonInfo2(String username,[int? age,String? gender])&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们尝试依次传入对应参数，方法和执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  printPersonInfo2(&quot;李四&quot;);  //username=李四, age=null, gender=null</span><br><span class="line">  printPersonInfo2(&quot;李四&quot;,28);  //username=李四, age=28, gender=null</span><br><span class="line">  printPersonInfo2(&quot;李四&quot;,28,&quot;男&quot;);  //username=李四, age=28, gender=男</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonInfo2(String username,[int? age,String? gender])&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于此处采用的是可选位置参数，因此方法中参数的传入顺序与方法中定义的顺序必须保持一致，因为它通过参数在参数列表中的位置来定位参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printPersonInfo2(&quot;李四&quot;,28,&quot;男&quot;);  //username=李四, age=28, gender=男</span><br><span class="line">printPersonInfo2(&quot;李四&quot;,&quot;男&quot;,28);  //这是错误的调用方式</span><br></pre></td></tr></table></figure>

<p>请注意，如果存在具体参数，那么可选参数必须在具体参数之后声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printPersonInfo(String username,&#123;int? age,String? gender&#125;)&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonInfo2(String username,[int? age,String? gender])&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说可选参数（无论是命名参数还是位置参数），都必须在具体参数之后声明，否则程序会抛异常。</p>
<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>开发者可以给可选参数指定默认值，这样如果可选参数不传入值，则使用该默认值。如果传入值，则使用传入值取代默认值。通常默认参数的值为null。注意默认值只能是编译时的常量。</p>
<p>举个例子，printUserInfo方法总共传入了三个参数，其中username是必须传入的参数，而age和gender参数可以不传，同时我们设置了age默认值为30，gender默认值为女，这样其实这两个可选参数就是非空类型，所以类型后面就不用添加问号了，此时代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printUserInfo(String username,&#123;int age =30,String gender = &quot;女&quot;&#125;)&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们尝试依次传入对应参数，方法和执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  printUserInfo(&quot;张三&quot;);  //username=张三, age=30, gender=女</span><br><span class="line">  printUserInfo(&quot;张三&quot;,age: 26);  //username=张三, age=26, gender=女</span><br><span class="line">  printUserInfo(&quot;张三&quot;,age: 26,gender: &quot;男&quot;);  //username=张三, age=26, gender=男</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printUserInfo(String username,&#123;int age =30,String gender = &quot;女&quot;&#125;)&#123;</span><br><span class="line">  print(&quot;username=$username, age=$age, gender=$gender&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>在Dart语言中，函数返回值有如下特点：<br>（1）所有的函数都有返回值；<br>（2）如果没有指定函数的返回值，则默认返回值为null；<br>（3）没有返回值的函数，系统会在最后添加隐式的return语句。</p>
<h3 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h3><p>前面说过Dart是一个面向对象的语言，因此方法也是对象，属于Function对象。方法可以作为对象赋值给其他变量，也可以作为参数传递给其他方法。</p>
<p>下面的例子就演示了方法作为对象赋值给其他变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var func = printHello;</span><br><span class="line">  func();  //hello,world</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printHello()&#123;</span><br><span class="line">  print(&quot;hello,world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，由于方法也是对象，属于Function类型，因此上述的func变量也可以改成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function func = printHello;</span><br></pre></td></tr></table></figure>
<p>下面再来看一下例子，这个例子说明了方法也可以作为参数传递给其他方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var list = [1,2,3,4];</span><br><span class="line">  list.forEach(print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个list的forEach方法源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void forEach(void action(E element)) &#123;</span><br><span class="line">    for (E element in this) action(element);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再来看一个例子，现在有一个整数类型的列表，我们希望它所有元素都变成原来的2倍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var list = [1,3,5,7];</span><br><span class="line">  print(getNewList(list, transferTwice));  //[2, 6, 10, 14]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List getNewList(List list,int transferTwice(int num))&#123;</span><br><span class="line">  for(var i = 0;i&lt; list.length;i++)&#123;</span><br><span class="line">    list[i] = transferTwice(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int transferTwice(int number)&#123;</span><br><span class="line">  return number*2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>匿名方法其实就是没有名字的方法，定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(参数1,参数2,...)&#123;</span><br><span class="line">    方法体...</span><br><span class="line">    return 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名方法的特性有两点：<br>（1）可赋值给变量，通过变量来进行调用；<br>（2）可在其他方法中直接调用或者传递给其他方法。</p>
<h5 id="匿名方法赋值给变量，通过变量来进行调用"><a href="#匿名方法赋值给变量，通过变量来进行调用" class="headerlink" title="匿名方法赋值给变量，通过变量来进行调用"></a>匿名方法赋值给变量，通过变量来进行调用</h5><p>下面的例子是没有参数的匿名方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var func = ()&#123;</span><br><span class="line">    print(&quot;hello&quot;);  //hello</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来一个具有参数的匿名方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var func = (name)&#123;</span><br><span class="line">    print(&quot;hello,$name&quot;);  //hello,world</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  func(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看一个比较有意思的语法<code>()()</code>，即我们可以将匿名方法传入第一个括号中，然后通过第二个括号来调用这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(()&#123;</span><br><span class="line">       print(&quot;hello&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> )();</span><br></pre></td></tr></table></figure>
<p>但是不建议大家这样使用，这样会极大的降低代码的可读性，增加维护的难度。</p>
<h5 id="匿名方法可在其他方法中直接调用或者传递给其他方法"><a href="#匿名方法可在其他方法中直接调用或者传递给其他方法" class="headerlink" title="匿名方法可在其他方法中直接调用或者传递给其他方法"></a>匿名方法可在其他方法中直接调用或者传递给其他方法</h5><p>还记得之前我们在方法对象中的一个例子，将整型列表中的所有元素都变成原来的2倍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var list = [1,3,5,7];</span><br><span class="line">  print(getNewList(list, transferTwice));  //[2, 6, 10, 14]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List getNewList(List list,int transferTwice(int num))&#123;</span><br><span class="line">  for(var i = 0;i&lt; list.length;i++)&#123;</span><br><span class="line">    list[i] = transferTwice(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int transferTwice(int number)&#123;</span><br><span class="line">  return number*2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们尝试使用匿名方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var list2 = [1,3,5,7];</span><br><span class="line">  print(getNewList(list2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List getNewList(List list)&#123;</span><br><span class="line">  var func = (int num)&#123;return num*2;&#125;;</span><br><span class="line">  for(var i = 0;i&lt; list.length;i++)&#123;</span><br><span class="line">    list[i] = func(list[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是一个方法（对象），它定义在其他方法内部，能够访问外部方法内的局部变量，并持有其状态。即通过闭包可以访问其他方法内定义的局部变量。</p>
<p>举个例子，如下所示就是闭包的一个经典例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var func = a();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function a()&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line"></span><br><span class="line">  printCount()&#123;</span><br><span class="line">    print(count++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return printCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下上述方法，执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>当然了，闭包也可以使用匿名函数来实现，使用匿名函数作为闭包是比较常用的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var f = b();</span><br><span class="line">  f();</span><br><span class="line">  f();</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function b()&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  return ()&#123;</span><br><span class="line">    print(count++);</span><br><span class="line">    return;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>（1）使用关键字class声明一个类；（2）使用关键字new创建一个对象，new可以省略；（3）所有的类都继承自Object类。</p>
<p>声明一个类和创建一个对象的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person();  // 等同于 var person = new Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>（1）属性（成员变量）就是类中定义的变量，注意类中所有的属性都会隐式的定义setter方法（final关键字修饰的属性除外，它只有getter方法），针对非空的属性会额外定义getter方法。<br>（2）注意属性的getter和setter方法都是默认生成的。<br>（3）属性和方法都是通过<code>.</code>来访问的，同时<strong>方法不能被重载</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person();  // 等同于 var person = new Person();</span><br><span class="line"></span><br><span class="line">  person.info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String name = &quot;&quot;;</span><br><span class="line">  int age = 18;</span><br><span class="line">  String? nickName;</span><br><span class="line"></span><br><span class="line">  void info()&#123;</span><br><span class="line">    print(&quot;name=$name,age=$age,nickName=$nickName&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意在Dart2中，如果某个变量为非空类型，那么它必须初始化，如果变量为空类型，那么可以不进行初始化，且默认值就是null。因此上述方法执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=,age=18,nickName=null</span><br></pre></td></tr></table></figure>
<p>由于final关键字修饰的属性是只读的，因此开发者不能对其进行修改。再次强调，Dart中的<strong>方法不能被重载</strong>。</p>
<h3 id="类及成员可见性"><a href="#类及成员可见性" class="headerlink" title="类及成员可见性"></a>类及成员可见性</h3><p>（1）Dart中的可见性是以library(库)为单位；<br>（2）默认情况下，每一个Dart文件就是一个库；<br>（3）使用<code>_</code>表示库的私有性；<br>（4）使用<code>import</code>关键字来导入库。</p>
<p>举个例子，我们将之前的Person类抽离出来，放到与main方法同级的包中，之后发现main方法是找不到这个Person对象的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-b6ed8d1c09af1173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>解决办法就是在main方法中通过import语句导入该Persoon类<code>import &#39;Person.dart&#39;;</code>。</p>
<p>再来看个例子，我们在Person类中的name属性前面加上一个<code>_</code>，则表示此属性为私有属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  String _name = &quot;&quot;;</span><br><span class="line">  int age = 18;</span><br><span class="line">  String? nickName;</span><br><span class="line"></span><br><span class="line">  String address = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  void info()&#123;</span><br><span class="line">    print(&quot;name=$_name,age=$age,nickName=$nickName&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就意味着系统就不会给这个name属性添加setter和getter方法，所以你在main方法中获取和修改name属性的值就会抛异常：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-205923a0e36723e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性，顾名思义就是它的值是通过计算得到的，本身不会存储值。计算属性赋值，其实就是通过计算转换得到其他实例变量。</p>
<p>下面是一个使用对象属性的方式来计算矩形面积的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var rectangle = Rectangle();</span><br><span class="line">  rectangle.width = 10;</span><br><span class="line">  rectangle.height = 20;</span><br><span class="line"></span><br><span class="line">  print(rectangle.area());  //200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle&#123;</span><br><span class="line">  num width = 0;</span><br><span class="line">  num height = 0;</span><br><span class="line"></span><br><span class="line">  num area()&#123;</span><br><span class="line">    return width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于面积会随着长和宽的变化而发生变动，因此可以将这个面积定义为一个计算属性，代码修改为如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var rectangle = Rectangle();</span><br><span class="line">  rectangle.width = 10;</span><br><span class="line">  rectangle.height = 20;</span><br><span class="line"></span><br><span class="line">  print(rectangle.area);  //200</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle&#123;</span><br><span class="line">  num width = 0;</span><br><span class="line">  num height = 0;</span><br><span class="line"></span><br><span class="line">  num get area&#123;</span><br><span class="line">    return width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到计算属性的定义与方法不同，它没有参数列表<code>()</code>，同时在返回类型与方法名称之间有一个get关键字，最重要的是由于它是一个属性，因此在调用的时候不能携带<code>()</code>。</p>
<p>由于area属性只有一个表达式，因此可以将其进行简化为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var rectangle = Rectangle();</span><br><span class="line">  rectangle.width = 10;</span><br><span class="line">  rectangle.height = 20;</span><br><span class="line"></span><br><span class="line">  print(rectangle.area);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle&#123;</span><br><span class="line">  num width = 0;</span><br><span class="line">  num height = 0;</span><br><span class="line"></span><br><span class="line">  num get area =&gt; width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时我们还可以给计算属性赋值值，注意里面只能传入一个参数，因此这里尝试将面积除以20来得到它的宽度，根据面积同时求宽和高是不可能的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var rectangle = Rectangle();</span><br><span class="line">  rectangle.width = 10;</span><br><span class="line">  rectangle.height = 20;</span><br><span class="line"></span><br><span class="line">  rectangle.area = 200;</span><br><span class="line">  print(rectangle.width);  //10</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle&#123;</span><br><span class="line">  num width = 0;</span><br><span class="line">  num height = 0;</span><br><span class="line"></span><br><span class="line">  num get area =&gt; width * height;</span><br><span class="line">  void set area (num value)&#123;</span><br><span class="line">     width = value /20;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h3 id="常规构造方法"><a href="#常规构造方法" class="headerlink" title="常规构造方法"></a>常规构造方法</h3><p>构造方法就是在创建对象时被调用的方法，和其他方法所不同的是，构造方法的名称就是类名。</p>
<p>如果没有自定义构造方法，那么会有一个默认的构造方法。如果存在自定义的构造方法，那么默认的构造方法无效。构造方法不能重载。</p>
<p>举个例子，下面的例子中就给User类添加了一个无参数的构造方法，并在函数中给User类的两个成员变量初始化了值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var user = User();</span><br><span class="line">  user.name = &quot;张三&quot;;</span><br><span class="line">  user.age = 26;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  late final String gender;</span><br><span class="line"></span><br><span class="line">  User()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，只有类中没有自定义构造方法，那么系统才会有一个默认的构造方法。如果存在自定义的构造方法，那么默认的构造方法就不会提供（开发者也不能手动提供），这样就不会与方法不允许重载相悖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var user = User(&quot;李四&quot;,28);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  late final String gender;</span><br><span class="line"></span><br><span class="line">  //有两个参数的构造方法</span><br><span class="line">  User(String name,int age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这种携带参数的构造方法使用较为频繁，于是Dart语言对此提供了语法糖，可将如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User(String name,int age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>简化为如下，即直接将传入的参数赋值给类对应的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(this.name,this.age);</span><br></pre></td></tr></table></figure>
<p>这个方法后面也可以跟语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User(this.name,this.age)&#123;</span><br><span class="line">  print(&quot;hello,world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下完整的代码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var user = User(&quot;李四&quot;,28);</span><br><span class="line">  print(user.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  User(this.name,this.age)&#123;</span><br><span class="line">    print(&quot;hello,$name&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下main方法，可以看到输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,李四</span><br><span class="line">28</span><br></pre></td></tr></table></figure>
<p>原因在于使用语法糖的形式给属性赋值（<code>this.name,this.age</code>），它其实是在构造方法执行之前执行，这也是使用语法糖和直接定义构造方法的区别。举个例子，我们尝试直接在构造方法中给一个final类型变量赋值（注意gender前面没有使用late关键字），这是不允许的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  final String gender;</span><br><span class="line"></span><br><span class="line">  User(String name,int age,String gender)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.gender = gender;  //错误的方式</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-eb163f07e9a80210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>但是在语法糖中我们却是可以对gender变量进行赋值，原因在于final属性的赋值需要在构造方法执行之前执行，而语法糖中的属性赋值就是在构造方法执行之前执行，所以程序就可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(this.name,this.age,this.gender);</span><br></pre></td></tr></table></figure>
<h3 id="命名构造方法"><a href="#命名构造方法" class="headerlink" title="命名构造方法"></a>命名构造方法</h3><p>如果开发者想实现构造方法的重载，可以使用命名构造方法，即采用<code>类名.方法</code>的形式来实现。</p>
<p>如下所示的例子就使用了两个构造方法，其中第一个是常规有参构造，第二个则是命名构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var user = User(&quot;李四&quot;,28,&quot;男&quot;);</span><br><span class="line">  var user2 = User.withName(&quot;张三&quot;);</span><br><span class="line">  var user3 = User.withAge(30);</span><br><span class="line">  var user4 = User.withGender(&quot;女&quot;);</span><br><span class="line"></span><br><span class="line">  print(user.age);  //28</span><br><span class="line">  print(user2.name);  //张三</span><br><span class="line">  print(user3.age);  //30</span><br><span class="line">  print(user4.gender);  //女</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">  late String name;</span><br><span class="line">  late int age;</span><br><span class="line"></span><br><span class="line">  late final String gender;</span><br><span class="line"></span><br><span class="line">  User(this.name,this.age,this.gender);</span><br><span class="line"></span><br><span class="line">  User.withName(String name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  User.withAge(int age)&#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  User.withGender(String gender)&#123;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><p>（1）如果类是不可变状态，那么可以将对象定义为编译时常量。<br>（2）使用const关键字来声明构造方法，并且所有属性都是final修饰。<br>（3）使用const关键字来声明对象，const可以省略。</p>
<p>如下所示的例子，就很好的说明了常量构造方法的三个特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  const person = Person(&quot;李四&quot;,28,&quot;男&quot;);  //等同于 const person = const Person(&quot;李四&quot;,28,&quot;男&quot;);</span><br><span class="line">  person.name = &quot;&quot;;  //程序会抛异常，被final修饰的变量无法被修改</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final int age ;</span><br><span class="line"></span><br><span class="line">  final String gender;</span><br><span class="line"></span><br><span class="line">  const Person(this.name,this.age,this.gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><p>（1）工厂构造方法类似于设计模式中的工厂模式；<br>（2）在构造方法前面添加一个factory关键字，就能实现一个工厂构造方法；<br>（3）在工厂构造方法中可以返回对象。</p>
<p>如下所示的例子，就很好的说明了工厂构造方法的三个特点：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-5485f1e1d3c7546d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到命名构造方法是不能返回值，而工厂构造方法是可以返回对象的。正确代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var book = Book(&quot;三国演义&quot;);</span><br><span class="line">  print(book.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line"> final String name;</span><br><span class="line"></span><br><span class="line"> factory Book(String name)&#123;</span><br><span class="line">   print(&quot;the dart&quot;);</span><br><span class="line">   return Book._internal(name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Book._internal(this.name)&#123;</span><br><span class="line">   print(&quot;hello,world&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the dart</span><br><span class="line">hello,world</span><br><span class="line">三国演义</span><br></pre></td></tr></table></figure>
<h3 id="构造方法初始化列表"><a href="#构造方法初始化列表" class="headerlink" title="构造方法初始化列表"></a>构造方法初始化列表</h3><p>前面我们说过final属性的赋值需要在构造方法执行之前执行，除了前面所说的通过语法糖可以给final类型赋值，还可以通过构造方法初始化列表来实现，因为它也是在构造方法执行之前执行。</p>
<p>构造方法初始化列表使用逗号来分隔初始化表达式，且常用于设置final关键字修饰的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person.withMap(Map.fromIterables([&quot;name&quot;,&quot;age&quot;], [&quot;张三&quot;,18]));</span><br><span class="line">  print(person.name);  //张三</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final int age;</span><br><span class="line"></span><br><span class="line">  //通过语法糖实现final类型赋值在构造方法之前执行</span><br><span class="line">  Person(this.name, this.age);</span><br><span class="line"></span><br><span class="line">  //通过构造函数初始化列表实现final类型赋值在构造方法之前执行</span><br><span class="line">  Person.withMap(Map map) : name= map[&quot;name&quot;],age= map[&quot;age&quot;]&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个构造方法初始化列表就是使用常规或者命名构造方法，通过传入的参数来给final类型的属性赋值，且这个过程会在构造方法执行之前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person.withMap(Map.fromIterables([&quot;name&quot;,&quot;age&quot;], [&quot;张三&quot;,18]));</span><br><span class="line">  print(person.name);  //张三</span><br><span class="line"></span><br><span class="line">  var person2 = Person.withParam(&quot;王五&quot;, 20);</span><br><span class="line">  print(person2.age);  //20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  final String name;</span><br><span class="line">  final int age;</span><br><span class="line"></span><br><span class="line">  //通过语法糖实现final类型赋值在构造方法之前执行</span><br><span class="line">  // Person(this.name, this.age);</span><br><span class="line"></span><br><span class="line">  //通过构造函数初始化列表实现final类型赋值在构造方法之前执行</span><br><span class="line">  Person.withMap(Map map) : name= map[&quot;name&quot;],age= map[&quot;age&quot;]&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person.withParam(String name,int age) : name=name,age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>（1）可以使用static关键字来实现类级别的变量和方法；<br>（2）在同一个类中，静态成员不能访问非静态成员，但是非静态成员可以访问静态成员；<br>（3）类中的常量需要使用<code>static const</code>关键字来修饰。</p>
<p>如下例子就在Page类中定义了一个静态变量currentPage和静态方法prevPage，但是请注意，main方法中创建的page对象<strong>无法访问</strong>这两个静态成员，这两个静态成员只能通过类名来访问，这一点与Java不同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var page = Page();</span><br><span class="line">  page.nextPage();</span><br><span class="line"></span><br><span class="line">  //在外部类中，只能通过类名来访问静态成员</span><br><span class="line">  Page.currentPage;</span><br><span class="line">  Page.prevPage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page&#123;</span><br><span class="line">  //在类中定义常量必须使用static const来定义</span><br><span class="line">  static const int maxPage = 100;</span><br><span class="line">  </span><br><span class="line">  static int currentPage =10;</span><br><span class="line"></span><br><span class="line">  //上一页</span><br><span class="line">  static void prevPage()&#123;</span><br><span class="line">    currentPage--;</span><br><span class="line">    print(&quot;上一页...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //下一页</span><br><span class="line">  void nextPage()&#123;</span><br><span class="line">    currentPage++;</span><br><span class="line">    print(&quot;下一页...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象操作符"><a href="#对象操作符" class="headerlink" title="对象操作符"></a>对象操作符</h3><h5 id="类型转换as"><a href="#类型转换as" class="headerlink" title="类型转换as"></a>类型转换as</h5><p>下面有一个例子，定义了一个Person类，然后在main方法中定义了person变量，首先给person变量赋值为空字符串，之后赋值给Person对象，这样这个person变量的类型其实就是Dynamic类型，所以开发者无法调用Person类型的info方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person;</span><br><span class="line">  person = &quot;&quot;;</span><br><span class="line">  person = Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String? name;</span><br><span class="line">  int? age;</span><br><span class="line"></span><br><span class="line">  void info()&#123;</span><br><span class="line">    print(&quot;name=$name,age=$age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时就可以使用类型转换as运算符了，只需在mian方法中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(person as Person).info();</span><br></pre></td></tr></table></figure>
<p>注意这样使用的前提是这个person对象曾经被赋值过Person类型的值，否则是无法这样使用的。</p>
<h5 id="是否指定类型is、is"><a href="#是否指定类型is、is" class="headerlink" title="是否指定类型is、is!"></a>是否指定类型is、is!</h5><p>开发者可以使用is或者is!来判断对象是否为某种类型，格式为<code>object is/is! type</code>，这个一般在条件判断中使用较多，根据不同的条件调用对应的方法。</p>
<h5 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作.."></a>级联操作<code>..</code></h5><p>下面所示的是一般我们给某个对象赋值的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = new Person();</span><br><span class="line">  person.name = &quot;张三&quot;;</span><br><span class="line">  person.age = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String? name;</span><br><span class="line">  int? age;</span><br><span class="line"></span><br><span class="line">  void info()&#123;</span><br><span class="line">    print(&quot;name=$name,age=$age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中可以使用级联操作来直接给对象赋值，<code>..</code>返回的是当前对象，因此就可以像调用链一样给对象赋值。此时main方法代码可由如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = new Person();</span><br><span class="line">  person.name = &quot;张三&quot;;</span><br><span class="line">  person.age = 20;</span><br><span class="line">  person.info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换为下面的级联操作，这种在日常开发中使用非常频繁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  new Person()..name = &quot;张三&quot;..age = 20..info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象call方法"><a href="#对象call方法" class="headerlink" title="对象call方法"></a>对象call方法</h3><p>前面说过Dart中的方法可作为对象来使用的，实际上反过来，对象也可以作为方法来使用。</p>
<p>如果某个类实现了call方法，那么该类的对象就可以作为方法来进行使用。</p>
<p>举个例子，下面的代码就是给Person类创建一个对象，然后给这个对象赋值属性并调用info方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person();</span><br><span class="line">  person.name = &quot;张三&quot;;</span><br><span class="line">  person.age = 20;</span><br><span class="line"></span><br><span class="line">  person.info();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String? name;</span><br><span class="line">  int? age;</span><br><span class="line"></span><br><span class="line">  void info()&#123;</span><br><span class="line">    print(&quot;name=$name,age=$age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们尝试实现一个call方法，那么此时这个person对象就是一个方法了，我们就可以像调用方法一样调用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person();</span><br><span class="line">  person.name = &quot;张三&quot;;</span><br><span class="line">  person.age = 20;</span><br><span class="line"></span><br><span class="line">  person();  //类实现了call方法，那么这个类的实例对象，就能像方法一样被调用执行了</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String? name;</span><br><span class="line">  int? age;</span><br><span class="line"></span><br><span class="line">  void call()&#123;</span><br><span class="line">    print(&quot;name=$name,age=$age&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述main方法执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=张三,age=20</span><br></pre></td></tr></table></figure>
<p>这call方法比较特殊，只需要名称为call即可，对于参数列表和返回值类型不做任何要求。下面的例子就是call方法携带参数且有返回值的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()&#123;</span><br><span class="line">  var person = Person();</span><br><span class="line">  String result = person(&quot;李四&quot;,28);</span><br><span class="line">  print(result);  //name=李四,age=28</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">  String? name;</span><br><span class="line">  int? age;</span><br><span class="line"></span><br><span class="line">  String call(String name,int age)&#123;</span><br><span class="line">    return &quot;name=$name,age=$age&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这种方式不建议使用，毕竟对象和方法还是有区别。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://envyzhan.asia">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.asia/2021/06/12/dart-02-oop-basic/">http://envyzhan.asia/2021/06/12/dart-02-oop-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.asia" target="_blank">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/dart/">dart</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/11/1-druid-database-connection-pool-experience/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Druid数据库连接池使用体验</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/10/dart-01-basic-grammar/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dart基础语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/10/dart-01-basic-grammar/" title="Dart基础语法"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-10</div><div class="title">Dart基础语法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">余思</div><div class="author-info__description">记录成长路上的点滴</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">255</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:envyzhan@aliyun.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问余思博客，一个技术博主的成长试验田！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">方法（函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.1.</span> <span class="toc-text">方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.</span> <span class="toc-text">可选参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.0.1.</span> <span class="toc-text">可选命名参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.2.0.2.</span> <span class="toc-text">可选位置参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.0.3.</span> <span class="toc-text">默认参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.0.4.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.5.</span> <span class="toc-text">方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">匿名方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F%EF%BC%8C%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.6.0.1.</span> <span class="toc-text">匿名方法赋值给变量，通过变量来进行调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95%E5%8F%AF%E5%9C%A8%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E6%88%96%E8%80%85%E4%BC%A0%E9%80%92%E7%BB%99%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.6.0.2.</span> <span class="toc-text">匿名方法可在其他方法中直接调用或者传递给其他方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.0.7.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.0.1.</span> <span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.2.</span> <span class="toc-text">属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%8A%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.0.3.</span> <span class="toc-text">类及成员可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">2.0.4.</span> <span class="toc-text">计算属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.1.</span> <span class="toc-text">常规构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.2.</span> <span class="toc-text">命名构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.3.</span> <span class="toc-text">常量构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.4.</span> <span class="toc-text">工厂构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">3.0.5.</span> <span class="toc-text">构造方法初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">3.0.6.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.0.7.</span> <span class="toc-text">对象操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2as"><span class="toc-number">3.0.7.0.1.</span> <span class="toc-text">类型转换as</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8Bis%E3%80%81is"><span class="toc-number">3.0.7.0.2.</span> <span class="toc-text">是否指定类型is、is!</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.7.0.3.</span> <span class="toc-text">级联操作..</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1call%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.8.</span> <span class="toc-text">对象call方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/" title="聊一聊六种常用的属性配置读取方式"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="聊一聊六种常用的属性配置读取方式"/></a><div class="content"><a class="title" href="/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/" title="聊一聊六种常用的属性配置读取方式">聊一聊六种常用的属性配置读取方式</a><time datetime="2024-03-02T02:55:30.000Z" title="发表于 2024-03-02 10:55:30">2024-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/" title="聊一聊九种常用的分布式ID生成方案"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="聊一聊九种常用的分布式ID生成方案"/></a><div class="content"><a class="title" href="/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/" title="聊一聊九种常用的分布式ID生成方案">聊一聊九种常用的分布式ID生成方案</a><time datetime="2024-02-03T06:55:27.000Z" title="发表于 2024-02-03 14:55:27">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/" title="巧用分页列表缓存，快速响应用户请求"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="巧用分页列表缓存，快速响应用户请求"/></a><div class="content"><a class="title" href="/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/" title="巧用分页列表缓存，快速响应用户请求">巧用分页列表缓存，快速响应用户请求</a><time datetime="2023-05-28T08:55:30.000Z" title="发表于 2023-05-28 16:55:30">2023-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/" title="基于请求参数校验的接口幂等性实现方案"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于请求参数校验的接口幂等性实现方案"/></a><div class="content"><a class="title" href="/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/" title="基于请求参数校验的接口幂等性实现方案">基于请求参数校验的接口幂等性实现方案</a><time datetime="2023-05-10T02:55:30.000Z" title="发表于 2023-05-10 10:55:30">2023-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/" title="Redis各种数据类型巧用"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis各种数据类型巧用"/></a><div class="content"><a class="title" href="/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/" title="Redis各种数据类型巧用">Redis各种数据类型巧用</a><time datetime="2023-04-20T02:55:30.000Z" title="发表于 2023-04-20 10:55:30">2023-04-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2024  余思博客,记录成长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '9996b44b488f2fc52124',
      clientSecret: '6bec0f8e9c032eeae6211a5d4cffa3c97e2d4a64',
      repo: 'blogcomment',
      owner: 'Envythink',
      admin: ['Envythink'],
      id: '5d14acd48f29f6904cde128138cb297d',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>