<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2022-09-11T09:59:13.683Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Druid数据库连接池使用体验</title>
    <link href="http://envyzhan.asia/2022/03/11/1-druid-database-connection-pool-experience/"/>
    <id>http://envyzhan.asia/2022/03/11/1-druid-database-connection-pool-experience/</id>
    <published>2022-03-11T09:55:30.000Z</published>
    <updated>2022-09-11T09:59:13.683Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中我们我们使用较多的则是Spring默认的HikariDataSource数据库连接池，但是它无法提供可视化监控SQL这一能力，而这在很多场景下往往又是我们需要的功能，因此今天来学习阿里开源的一款优秀的数据库连接池—Druid。Druid能够提供强大的SQL监控和功能扩展能力，允许开发者根据需要进行二次开发。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>首先我们使用传统的方式，快速搭建一个具备查询用户信息的简单项目。</p><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>druid-sql</code>的SpringBoot项目，选择<code>spring web</code>、<code>mybatis framework</code>和<code>mysql driver</code>依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-927a0caa070c04b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-927a0caa070c04b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>第二步，修改<code>application.properties</code>配置文件信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></tbody></table></figure></div><p>第三步，创建<code>book</code>这一数据表：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USE druid_sql;</span><br><span class="line">DROP TABLE IF EXISTS book;</span><br><span class="line">CREATE TABLE book ( </span><br><span class="line">id INT auto_increment PRIMARY KEY, </span><br><span class="line">name VARCHAR ( 255 ), </span><br><span class="line">price INT, </span><br><span class="line">description VARCHAR ( 500 )</span><br><span class="line">) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;</span><br></pre></td></tr></tbody></table></figure></div><p>第四步，创建Book实体类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Book {</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer price;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    //省略getter和setter方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第五步，创建BookMapper的接口文件：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper {</span><br><span class="line">    List&lt;Book&gt; selectBookByName(String name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第六步，创建BookMapper的XML文件：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span><br><span class="line">&lt;mapper namespace="com.melody.druidsql.mapper.BookMapper"&gt;</span><br><span class="line">    &lt;select id="selectBookByName" resultType="com.melody.druidsql.entity.Book"&gt;</span><br><span class="line">        select * from book where name=#{name}</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>第七步，新建BookService类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService {</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line">    </span><br><span class="line">    public List&lt;Book&gt; selectBookByName(String name){</span><br><span class="line">        return bookMapper.selectBookByName(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第八步，新建BookController类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/book")</span><br><span class="line">    public List&lt;Book&gt; selectBookByName(String name){</span><br><span class="line">        return bookService.selectBookByName(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第九步，添加数据进行测试，这些都是比较常规的操作了。通过查看源码，可以发现它使用的是HikariDataSource数据库连接池：</p><h3 id="接入Druid"><a href="#接入Druid" class="headerlink" title="接入Druid"></a>接入Druid</h3><p>第一步，在POM文件中新增如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>第二步，修改<code>application.properties</code>配置文件信息。首先配置WebStatFilter，它用于采集<code>web-jdbc</code>所关联的监控数据：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Druid相关配置</span><br><span class="line"># 开启WebStatFilter</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line"># 配置拦截规则，这里设置所有</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line"># 排除一些不会涉及到 SQL 查询的 URL</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line"># 开启 session 统计功能</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line"># 缺省 sessionStatMaxCount 值为 1000 ，开发者可按需进行配置</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=1000</span><br></pre></td></tr></tbody></table></figure></div><p>其次，配置StatViewServlet相关配置项，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 配置StatViewServlet</span><br><span class="line"># 启用内置的监控页面</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line"># 内置监控页面的 URL 地址</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line"># 开启 Reset All 功能，注意值设置为false，按钮会显示，但是点击没有反应</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line"># 设置监控页面登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=melody</span><br><span class="line"># 设置监控页面登录密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=melody</span><br><span class="line"># 设置白名单（如果allow没有配置或者为空，表示允许所有访问）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=127.0.0.1</span><br><span class="line"># 黑名单（注意 deny 的优先级高于 allow，即只有在 deny 列表中，那么即使在 allow 列表中，也会被拒绝）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.deny=</span><br></pre></td></tr></tbody></table></figure></div><p>最后设置过滤器， stat 过滤器用于监控 SQL 执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 过滤器设置</span><br><span class="line">spring.datasource.druid.filters=stat</span><br></pre></td></tr></tbody></table></figure></div><p>第三步，启动项目进行测试。首先访问<code>http://localhost:8080/druid/login.html</code>链接，页面如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-03744985a23bf3db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-03744985a23bf3db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后输入刚才设置的melody/melody信息进行登录，登录界面如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e4a2e4f739b4df75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e4a2e4f739b4df75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到Druid自带了很多功能，如：数据源、SQL监控、SQL防火墙、Web应用、URI监控、Session监控、Spring监控和JSON API等。</p><p>先不管这些功能，我们先尝试访问一下如下链接：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/book?name=java</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到页面已经可以显示数据了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-5fc1a6112dd47f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-5fc1a6112dd47f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>再看一下SQL监控，这里也将我们刚才调用接口执行SQL的执行过程给记录了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>以上就是Druid的初体验了，接下来我们来分析Druid首页导航栏上的各个模块。</p><h1 id="Druid连接池介绍"><a href="#Druid连接池介绍" class="headerlink" title="Druid连接池介绍"></a>Druid连接池介绍</h1><h3 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h3><p>Druid连接池是阿里巴巴开源的数据库连接池项目。Druid连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防SQL注入，内置Loging能诊断Hack应用行为。</p><h3 id="竞品对比"><a href="#竞品对比" class="headerlink" title="竞品对比"></a>竞品对比</h3><p><a href="https://upload-images.jianshu.io/upload_images/8964398-28d99044bf93c0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-28d99044bf93c0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看出，Druid连接池在性能、监控、诊断、安全、扩展性这些方面远远超出竞品。</p><p>对于连接池来说，连接池本身的性能消耗在整个调用链路中通常占比不大，连接池的性能关键点是，连接是否LRU的方式重用，是否支持PSCache<code>（PreparedStatementCache）</code>才是性能的关键点。当然DruidDataSource在没有使用Filter没有打开testOnBorrow的情况下，裸测也是极好。</p><h3 id="为监控而生"><a href="#为监控而生" class="headerlink" title="为监控而生"></a>为监控而生</h3><p>Druid连接池最初就是为监控系统采集jdbc运行信息而生的，它内置了StatFilter功能，能采集非常完备的连接池执行信息。</p><p>Druid连接池内置了能和Spring/Servlet关联监控的实现，使得监控Web应用特别方便。</p><p>Druid连接池内置了一个监控页面，提供了非常完备的监控信息，可以快速诊断系统的瓶颈。</p><h5 id="监控信息采集的StatFilter"><a href="#监控信息采集的StatFilter" class="headerlink" title="监控信息采集的StatFilter"></a>监控信息采集的StatFilter</h5><p>Druid连接池的监控信息主要是通过StatFilter采集的，采集的信息非常全面，包括SQL执行、并发、慢查、执行时间区间分布等。</p><h5 id="监控不影响性能"><a href="#监控不影响性能" class="headerlink" title="监控不影响性能"></a>监控不影响性能</h5><p>Druid增加StatFilter之后，能采集大量统计信息，同时对性能基本没有影响。StatFilter对CPU和内存的消耗都极小，对系统的影响可以忽略不计。监控不影响性能是Druid连接池的重要特性。</p><h5 id="SQL参数化合并监控"><a href="#SQL参数化合并监控" class="headerlink" title="SQL参数化合并监控"></a>SQL参数化合并监控</h5><p>实际业务中，如果SQL不是走<code>PreparedStatement</code>，SQL没有参数化，这时SQL需要参数化合并监控才能真实反映业务情况。如下SQL：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id = 1</span><br><span class="line">select * from t where id = 2</span><br><span class="line">select * from t where id = 3</span><br></pre></td></tr></tbody></table></figure></div><p>参数化后：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id = ?</span><br></pre></td></tr></tbody></table></figure></div><p>参数化合并监控是基于<code>SQL Parser</code>语法解析实现的，是Druid连接池独一无二的功能。</p><h5 id="执行次数、返回行数、更新行数和并发监控"><a href="#执行次数、返回行数、更新行数和并发监控" class="headerlink" title="执行次数、返回行数、更新行数和并发监控"></a>执行次数、返回行数、更新行数和并发监控</h5><p>StatFilter能采集到每个SQL的执行次数、返回行数总和、更新行数总和、执行中次数和和最大并发。并发监控的统计是在SQL执行开始对计数器加一，结束后对计数器减一实现的。可以采集到每个SQL的当前并发和采集期间的最大并发。</p><h5 id="慢查监控"><a href="#慢查监控" class="headerlink" title="慢查监控"></a>慢查监控</h5><p>缺省执行耗时超过3秒的被认为是慢查，统计项中有包括每个SQL的最后发生的慢查的耗时和发生时的参数。</p><h5 id="Exception监控"><a href="#Exception监控" class="headerlink" title="Exception监控"></a>Exception监控</h5><p>如果SQL执行时抛出了Exception，SQL统计项上会Exception有最后的发生时间、堆栈和Message，根据这些信息可以很容易定位错误原因。</p><h5 id="区间分布"><a href="#区间分布" class="headerlink" title="区间分布"></a>区间分布</h5><p>SQL监控项上，执行时间、读取行数、更新行数都有区间分布，将耗时分布成8个区间：</p><ul><li>0 - 1 耗时0到1毫秒的次数</li><li>1 - 10 耗时1到10毫秒的次数</li><li>10 - 100 耗时10到100毫秒的次数</li><li>100 - 1,000 耗时100到1000毫秒的次数</li><li>1,000 - 10,000 耗时1到10秒的次数</li><li>10,000 - 100,000 耗时10到100秒的次数</li><li>100,000 - 1,000,000 耗时100到1000秒的次数</li><li>1,000,000 - 耗时1000秒以上的次数</li></ul><p>记录耗时区间的发生次数，通过区间分布，可以很方便看出SQL运行的极好、普通和极差的分布。 耗时区分分布提供了“执行+RS时分布”，是将执行时间+ResultSet持有时间合并监控，这个能方便诊断返回行数过多的查询。</p><h3 id="诊断支持"><a href="#诊断支持" class="headerlink" title="诊断支持"></a>诊断支持</h3><p>Druid连接池内置了LogFilter，将Connection/Statement/ResultSet相关操作的日志输出，可以用于诊断系统问题，也可以用于Hack一个不熟悉的系统。</p><p>LogFilter可以输出连接申请/释放，事务提交回滚，Statement的<code>Create/Prepare/Execute/Close</code>，ResultSet的<code>Open/Next/Close</code>，通过LogFilter可以详细诊断一个系统的Jdbc行为。同时LogFilter有Log4j、Log4j2、Slf4j、CommsLog等实现。</p><h3 id="防SQL注入"><a href="#防SQL注入" class="headerlink" title="防SQL注入"></a>防SQL注入</h3><p>SQL注入攻击是黑客对数据库进行攻击的常用手段，Druid连接池内置了WallFilter提供防SQL注入功能，在不影响性能的同时防御SQL注入攻击。</p><h5 id="基于语意的防SQL注入"><a href="#基于语意的防SQL注入" class="headerlink" title="基于语意的防SQL注入"></a>基于语意的防SQL注入</h5><p>Druid连接池内置了一个功能完备的SQL Parser，能够完整解析mysql、sql server、oracle、postgresql的语法，通过语意分析能够精确识别SQL注入攻击。</p><h5 id="极低的漏报率和误报率"><a href="#极低的漏报率和误报率" class="headerlink" title="极低的漏报率和误报率"></a>极低的漏报率和误报率</h5><p>基于SQL语意分析，大量应用和反馈，使得Druid的防SQL注入拥有极低的漏报率和误报率。</p><h5 id="防注入对性能影响极小"><a href="#防注入对性能影响极小" class="headerlink" title="防注入对性能影响极小"></a>防注入对性能影响极小</h5><p>内置参数化后的Cache、高性能手写的Parser，使得打开防SQL注入对应用的性能基本不受影响。</p><p>更多Druid的详细介绍，可以参考 <a href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D">这里</a> ，了解更多。</p><h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>Druid内置提供了一个StatViewServlet用于展示Druid的统计信息，这个StatViewServlet的用途包括：（1）提供监控信息展示的html页面；（2）提供监控信息的JSON API。</p><p>首先我们查看一下这个StatViewServlet类的信息，可以发现它是一个静态内部类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class StatViewServlet {</span><br><span class="line">    private boolean enabled;</span><br><span class="line">    private String urlPattern;</span><br><span class="line">    private String allow;</span><br><span class="line">    private String deny;</span><br><span class="line">    private String loginUsername;</span><br><span class="line">    private String loginPassword;</span><br><span class="line">    private String resetEnable;</span><br><span class="line"></span><br><span class="line">    //setter和setter方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>也就是说，如果我们要配置StatViewServlet，启用内置的监控页面，首先需要在<code>application.properties</code>文件中新增如下配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br></pre></td></tr></tbody></table></figure></div><p>其次设置监控页面的访问URL地址，可通过urlPattern属性设置，如下设置时的内置监控页面的首页是<code>/druid/index.html</code>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br></pre></td></tr></tbody></table></figure></div><p>开发者可以通过loginUsername和loginPassword属性来设置登录信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.login-username=melody</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=melody</span><br></pre></td></tr></tbody></table></figure></div><p>由于StatViewSerlvet展示出来的监控信息是系统运行的内部情况，因此数据比较敏感，如果开发者想要实现访问控制，可以配置allow和deny这两个属性。</p><p>allow用于设置白名单（如果allow没有配置或者为空，表示允许所有访问），而deny用于设置黑名单，注意 deny 的优先级高于 allow，如果在deny列表中，就算在allow列表中，也会被拒绝：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.allow=127.0.0.1</span><br><span class="line">spring.datasource.druid.stat-view-servlet.deny=</span><br></pre></td></tr></tbody></table></figure></div><p>在StatViewSerlvet输出的html页面中，有一个功能是Reset All，即执行这个操作后，会清零所有计数器，并重新计数。开发者你可通过resetEnable属性来实现该功能的启用与否：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br></pre></td></tr></tbody></table></figure></div><p>如果开发者想要配置Web关联监控，那么可以查看后面关于 <strong>URI监控</strong> 模块内容；配置Spring关联监控，那么可以查看后面关于 <strong>Web应用</strong> 模块内容。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE">这里</a> ，了解更多。</p><h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><p>数据源详细记录了当前项目所使用的数据源信息，如登录用户名、地址、数据库类型、驱动类型、filter类名、连接设置、事务设置等内容：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-464c8a4260f09661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-464c8a4260f09661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><code>DruidDataSource</code>是数据源属性配置类，查看一下该类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource, MBeanRegistration {</span><br><span class="line">    private static final Log LOG = LogFactory.getLog(DruidDataSource.class);</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private volatile long recycleErrorCount;</span><br><span class="line">    private long connectCount;</span><br><span class="line">    private long closeCount;</span><br><span class="line">    private volatile long connectErrorCount;</span><br><span class="line">    private long recycleCount;</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该类继承自DruidAbstractDataSource类，这个类是数据源属性的抽象类，之所以将数据源定义为抽象类是为了让其他子类可以在此基础上进行扩展，因为DruidDataSource大部分属性都是参考DBCP的：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-ac78acbe6c121104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-ac78acbe6c121104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>一般来说，开发者只需配置url（并不是此处看到的jdbcUrl），username、password和max-active这四项：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.druid.username=root</span><br><span class="line">spring.datasource.druid.password=root</span><br><span class="line">spring.datasource.druid.max-active=20</span><br></pre></td></tr></tbody></table></figure></div><p>当然了，Druid也会根据URL来自动识别驱动类名称，无须开发者手动添加。举个例子，如果使用的是常见数据库如MySQL，可以使用旧的连接信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></tbody></table></figure></div><p>不需要在加一层druid前缀，这一点还是很方便的。如果连接的数据库是非常见数据库，那么必须添加driverClassName属性。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE">这里</a> ，了解更多。</p><h1 id="SQL监控"><a href="#SQL监控" class="headerlink" title="SQL监控"></a>SQL监控</h1><p>请注意，要想使用SQL监控，首先必须设置对应的过滤器，这些过滤器都需要实现<code>com.alibaba.druid.filter</code>接口，可以看到它也有很多子类：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e62cb3e239f1e317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e62cb3e239f1e317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>由于此处是监控SQL，因此需要配置StatFilter，即在<code>application.properties</code>文件中新增如下配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=stat</span><br></pre></td></tr></tbody></table></figure></div><p>如果你想使用后续的SQL防火墙，就需要使用wall这一配置项，自然想使用log4j2，就配置这一项，这些在数据源模块的Filter类名中就可以得到体现：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a8116c204dac6432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a8116c204dac6432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>SQL监控模块主要用于监控SQL，并展示SQL的执行数、执行时间、最慢、事务执行、错误数、更新行数、读取行数、执行中、最大并发、执行时间分布、执行+RS时分布、读取行分布和更新行分布等信息，其实这就是让开发者对整个项目中执行的SQL都有一个全局的了解：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>StatFilter的别名是stat，这个别名映射配置信息保存在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>文件中。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilte">这里</a> ，了解更多。</p><h1 id="内置Filter的别名"><a href="#内置Filter的别名" class="headerlink" title="内置Filter的别名"></a>内置Filter的别名</h1><p>在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>文件中配置了如下Filter的别名，因为我们是通过对应Filter的类名来设置对应的Filter别名，多个Filter可以组合使用：</p><table><thead><tr><th>Filter的类名</th><th>Filter别名</th></tr></thead><tbody><tr><td>default</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>stat</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>mergeStat</td><td>com.alibaba.druid.filter.stat.MergeStatFilter</td></tr><tr><td>counter</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>encoding</td><td>com.alibaba.druid.filter.encoding.EncodingConvertFilter</td></tr><tr><td>log4j</td><td>com.alibaba.druid.filter.logging.Log4jFilter</td></tr><tr><td>log4j2</td><td>com.alibaba.druid.filter.logging.Log4j2Filter</td></tr><tr><td>slf4j</td><td>com.alibaba.druid.filter.logging.Slf4jLogFilter</td></tr><tr><td>commonlogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr><tr><td>commonLogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr><tr><td>wall</td><td>com.alibaba.druid.wall.WallFilter</td></tr><tr><td>config</td><td>com.alibaba.druid.filter.config.ConfigFilter</td></tr><tr><td>haRandomValidator</td><td>com.alibaba.druid.pool.ha.selector.RandomDataSourceValidateFilter</td></tr></tbody></table><h1 id="SQL防火墙"><a href="#SQL防火墙" class="headerlink" title="SQL防火墙"></a>SQL防火墙</h1><p>WallFilter用于实现SQL防火墙，首先我们查看一下这个WallFilter类的信息，可以发现它是一个类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WallFilter extends FilterAdapter implements WallFilterMBean {</span><br><span class="line">    private static final Log LOG = LogFactory.getLog(WallFilter.class);</span><br><span class="line">    private boolean inited = false;</span><br><span class="line">    private WallProvider provider;</span><br><span class="line">    private String dbTypeName;</span><br><span class="line">    private WallConfig config;</span><br><span class="line">    private volatile boolean logViolation = false;</span><br><span class="line">    private volatile boolean throwException = true;</span><br><span class="line">    public static final String ATTR_SQL_STAT = "wall.sqlStat";</span><br><span class="line">    public static final String ATTR_UPDATE_CHECK_ITEMS = "wall.updateCheckItems";</span><br><span class="line">    private static final ThreadLocal&lt;List&lt;Integer&gt;&gt; tenantColumnsLocal = new ThreadLocal();</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果开发者想要启用这个WallFilter，那么需要在<code>application.properties</code>配置文件中通过Filter类名来进行设置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=wall</span><br></pre></td></tr></tbody></table></figure></div><p>当然了，还可以结合其他Filter一起使用，如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=wall,stat</span><br></pre></td></tr></tbody></table></figure></div><p>但是这样设置会造成拦截检测的时间不在StatFilter统计的SQL执行时间内，所以如果希望拦截检测的时间在StatFilter统计的SQL执行时间内，需要调整两者的执行顺序：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=stat,wall</span><br></pre></td></tr></tbody></table></figure></div><p>SQL防火墙主要分为5大部分：防御统计、表访问统计、函数调用统计、SQL防御统计的黑白名单。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter">这里</a> ，了解更多。</p><h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><p>它可以展示当前应用中的相关信息，如ContextPath、最大并发、请求次数、Jdbc执行数、读取行数和更新行数等一系列信息。</p><h1 id="URI监控"><a href="#URI监控" class="headerlink" title="URI监控"></a>URI监控</h1><p>WebStatFilter用于采集<code>web-jdbc</code>关联监控的数据，首先我们查看一下这个WebStatFilter类的信息，可以发现它是一个静态内部类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static class WebStatFilter {</span><br><span class="line">    private boolean enabled;</span><br><span class="line">    private String urlPattern;</span><br><span class="line">    private String exclusions;</span><br><span class="line">    private String sessionStatMaxCount;</span><br><span class="line">    private String sessionStatEnable;</span><br><span class="line">    private String principalSessionName;</span><br><span class="line">    private String principalCookieName;</span><br><span class="line">    private String profileEnable;</span><br><span class="line"></span><br><span class="line">    //setter和setter方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>因此我们首先需要在<code>application.properties</code>配置文件中开启WebStatFilter：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br></pre></td></tr></tbody></table></figure></div><p>如果开发者想要针对部分URL进行拦截，那么可以使用如下配置，此处拦截所有，即所有的API访问都会被记录：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br></pre></td></tr></tbody></table></figure></div><p>当然了有些不会涉及到 SQL 查询的API，我们是希望可以排除掉，那么可以配置如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br></pre></td></tr></tbody></table></figure></div><p>当我们需要开启session统计功能时，可以使用如下配置项：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br></pre></td></tr></tbody></table></figure></div><p>想要设置sessionStatMaxCount的值时，可以使用如下配置项，该值缺省为1000：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=1000</span><br></pre></td></tr></tbody></table></figure></div><p>如果开发者想让Druid知道当前的session的用户是谁，可以配置<code>principalSessionName</code>，注意这个参数的值是user信息保存在session中的 <code>sessionName</code>，如果你session中保存的是非string类型的对象，那么需要重载toString方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.principal-session-name=</span><br></pre></td></tr></tbody></table></figure></div><p>如果你的user信息是存在cookie中，那么可以使用下面的方式同样可以配置<code>principalSessionName</code>，进而也能让Druid知道当前的session的用户是谁：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.principal-cookie-name=</span><br></pre></td></tr></tbody></table></figure></div><p>自Druid0.2.7版本开始就支持profile，配置profileEnable就能够监控单个url调用的sql列表：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.profile-enable=</span><br></pre></td></tr></tbody></table></figure></div><p>可以开启一下profile试试，然后多次调用book这一API，结果如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-b9001756a15eae1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-b9001756a15eae1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter">这里</a> ，了解更多。</p><h1 id="Spring监控"><a href="#Spring监控" class="headerlink" title="Spring监控"></a>Spring监控</h1><p>Druid提供了Spring和Jdbc的关联监控，在使用的时候需要先阅读文档然后进行相应的配置，可点击 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_Druid%E5%92%8CSpring%E5%85%B3%E8%81%94%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE">这里</a> 进行阅读。</p><h1 id="JSON-API"><a href="#JSON-API" class="headerlink" title="JSON API"></a>JSON API</h1><p>如果开发者觉得此处展示的数据不太美观，那么可以根据提供的API来获取信息后自行展示。</p><h1 id="去除广告"><a href="#去除广告" class="headerlink" title="去除广告"></a>去除广告</h1><p>一般来说为了支持开源，不建议随便把广告去掉，但是在企业里面这个广告实在是有损形象，所以考虑再三还是决定去掉广告。</p><p>首先F12查看源码：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4c2f1511e7e14519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4c2f1511e7e14519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>然后分析发现广告是由<code>commons.js</code>文件带出来的，该文件存放于<code>ruid-xxx.jar!/support/http/resources/js/common.js</code>文件中，可以访问<code>http://localhost:8080/druid/js/common.js</code>链接进行确认：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-64924e3ef6aaae90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-64924e3ef6aaae90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-982331f760d53d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-982331f760d53d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>再来查看一下该网页的源代码：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-caa0e16dc86036ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-caa0e16dc86036ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p> 调用的是init方法，再阅读一下源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init : function() {</span><br><span class="line"> this.buildFooter();</span><br><span class="line"> druid.lang.init();</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line">buildFooter : function() {</span><br><span class="line"> var html ='';</span><br><span class="line"> $(document.body).append(html);</span><br><span class="line">},,</span><br></pre></td></tr></tbody></table></figure></div><p>确认一下，也就说这个buildFooter方法用于显示页面底部的广告，而这个方法则是在init方法中调用的：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-244a08d9a9c460d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-244a08d9a9c460d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>所以要想去除广告，不调用这个buildFooter方法即可，但是源码这种除非反编译，否则是无法修改的。不过可以换种实现方式，可以写一个过滤器，先过滤对于<code>commons.js</code>文件的请求，之后再读取<code>commons.js</code>文件内容，并将<code>this.buildFooter();</code>这行代码用空字符串取代，最后再将这个文件返回就行。</p><h3 id="手动注册方式"><a href="#手动注册方式" class="headerlink" title="手动注册方式"></a>手动注册方式</h3><p>定义一个filter包，并在里面定义一个DeleteADFilter类需要实现Filter接口并重写其中的doFilter方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(urlPatterns ="/druid/js/common.js")</span><br><span class="line">public class DeleteADFilter implements Filter {</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br><span class="line">        servletResponse.resetBuffer();</span><br><span class="line">        String content =  Utils.readFromResource("support/http/resources/js/common.js");</span><br><span class="line">        content =  content.replace("this.buildFooter();","");</span><br><span class="line">        servletResponse.getWriter().write(content);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意过滤的url地址必须和原地址保持一致，然后在项目启动类上扫描一下我们添加的DeleteADFilter类：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan("com.melody.druidsql.filter")</span><br><span class="line">public class DruidSqlApplication {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(DruidSqlApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后重新启动项目，访问首页或者其他页面，可以发现广告已经去掉了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-195ad4c95546559a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-195ad4c95546559a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>注意不能将项目启动类上的<code>@ServletComponentScan("com.melody.druidsql.filter")</code>注解去掉，转而在DeleteADFilter类上添加<code>@Component</code>，因为前者是注册，后者则是扫描，作用不同。相反如果你使用了<code>@ServletComponentScan</code>注解，那么Servlet可以直接通过<code>@WebServlet</code>注解自动注册；Filter可以直接通过<code>@WebFilter</code>注解自动注册；Listener可以直接通过<code>@WebListener</code>注解自动注册。</p><h3 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h3><p>当然了除了上面的手动注册方式外，我们还可以使用自动注册的方式。只需定义一个<code>DruidSqlConfiguration</code>类，然后提供一个<code>FilterRegistrationBean</code>实例即可，我们可以在该方法中书写拦截广告的逻辑：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DruidSqlConfiguration {</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnProperty(name = {"spring.datasource.druid.stat-view-servlet.enabled"},havingValue = "true")</span><br><span class="line">    public FilterRegistrationBean removeAdFilterRegistrationBean(DruidStatProperties druidStatProperties){</span><br><span class="line">        //获取Web监控页面的参数</span><br><span class="line">        DruidStatProperties.StatViewServlet statViewServlet = druidStatProperties.getStatViewServlet();</span><br><span class="line">        //提取common.js的配置路径</span><br><span class="line">        String urlPattern = statViewServlet.getUrlPattern() != null? statViewServlet.getUrlPattern():"/druid/*";</span><br><span class="line">        String commonJsPattern = urlPattern.replaceAll("\\*","js/common.js");</span><br><span class="line">        //定义过滤器</span><br><span class="line">        Filter filter = new Filter() {</span><br><span class="line">            @Override</span><br><span class="line">            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br><span class="line">                String content = Utils.readFromResource("support/http/resources/js/common.js");</span><br><span class="line">                content =  content.replace("this.buildFooter();","");</span><br><span class="line">                servletResponse.getWriter().write(content);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        FilterRegistrationBean registrationBean = new FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(filter);</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这种方式相比于前面那种更为巧妙，尤其是在当还需要往Spring容器主注册其他Bean的时候。</p><p>当然了，还有许多功能，如数据库多数据源、配置数据库加密、保存Druid的监控记录等等，这些都将会在后续文章中进行介绍。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中我们我们使用较多的则是Spring默认的HikariDataS</summary>
      
    
    
    
    <category term="mysql" scheme="http://envyzhan.asia/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://envyzhan.asia/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+OAuth2实现单点登录</title>
    <link href="http://envyzhan.asia/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/"/>
    <id>http://envyzhan.asia/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/</id>
    <published>2021-01-15T11:23:04.000Z</published>
    <updated>2021-03-01T03:52:15.256Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我们知道分布式系统由多个不同的子系统组成，但是我们希望在使用系统的时只需登录一次就能访问该系统，而不用多次登录，因此单点登录是一个很常见的需求。</p><p>在《OAuth2.0+JWT实现单点登录》一文中，我们使用<code>OAuth2+JWT</code>这一技术实现了单点登录，其实正确来说我们实现的是无状态登录，只是这种无状态登录满足单点登录的要求。</p><p>前面也说了无状态存在一些缺点，因此接下来我们尝试使用另一种技术，使用SpringBoot+OAuth2.0并结合<code>@EnableOAuth2Sso</code>注解这一方式来实现单点登录。</p><p>请注意上述两种实现方案都有其比较适合的场景，因此具体选择哪种需要结合实际情况来进行选择。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>前面我们都是将授权服务器和资源服务器分开搭建，本篇出于简单考虑，就直接将两者放在一个服务器上，名称统一为“统一认证中心”。此案例除了授权服务器外，还需要多个客户端应用，这里就提供两个。各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器+资源服务器</td><td align="center">2019</td></tr><tr><td align="center">client-app1</td><td align="center">客户端1</td><td align="center">2020</td></tr><tr><td align="center">client-app2</td><td align="center">客户端2</td><td align="center">2021</td></tr></tbody></table><p>可以看到此处的<code>auth-server</code>项目充当授权服务器和资源服务器的角色，<code>client-app1</code>和<code>client-app2</code>项目分别扮演子系统角色，之后当用户从<code>client-app1</code>上登录成功后，此时也能访问到<code>client-app2</code>，这样我们就能验证单点登录功能配置成功了。</p><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>oauth2-sso</code>，之后我们将在这个父工程中搭建子项目。</p><h3 id="统一认证中心搭建"><a href="#统一认证中心搭建" class="headerlink" title="统一认证中心搭建"></a>统一认证中心搭建</h3><p>在<code>oauth2-sso</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security下的Cloud Security和Cloud OAuth2：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-52eb10c01bb4d121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-52eb10c01bb4d121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将<strong>父工程<code>oauth2-sso</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;oauth2-sso&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;oauth2-sso&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;SpringBoot+OAuth2实现单点登录&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，由于此项目需要充当授权服务器和资源服务器的角色，因此需要在这个项目的启动类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class AuthServerApplication {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(AuthServerApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，接下来我们开始对授权服务器进行配置，由于此处的资源服务器和授权服务器放在一起，因此对于授权服务器的配置非常简单。新建一个config包，并在该包内新建一个<code>AuthServerConfig</code>类，注意它需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthServerConfig extends AuthorizationServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.inMemory().withClient("envythink")</span><br><span class="line">                .secret(passwordEncoder.encode("1234"))</span><br><span class="line">                .autoApprove(true)</span><br><span class="line">                .redirectUris("http://127.0.0.1:2020/login","http://127.0.0.1:2021/login")</span><br><span class="line">                .scopes("user")</span><br><span class="line">                .accessTokenValiditySeconds(7200)</span><br><span class="line">                .authorizedGrantTypes("authorization_code");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处我们只是简单的配置了客户端的信息，且配置的非常简单，直接将客户端信息保存在内存中。<br><strong>第四步</strong>，在config包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Order(1)</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception {</span><br><span class="line">        web.ignoring().antMatchers("/login.html","/css/**","/js/**","/images/**");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.requestMatchers()</span><br><span class="line">                .antMatchers("/login")</span><br><span class="line">                .antMatchers("/oauth/authorize")</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage("/login.html")</span><br><span class="line">                .loginProcessingUrl("/login")</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy")</span><br><span class="line">                .password(passwordEncoder().encode("1234"))</span><br><span class="line">                .roles("admin");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们首先提供了一个返回<code>BCryptPasswordEncoder</code>实例的方法，之后重写了<code>configure(WebSecurity web)</code>方法，该方法用户放开对静态资源的访问权限。接着重写了<code>configure(HttpSecurity http)</code>方法，在该方法中我们对认证相关的端点进行放行，同时自定义了登录页面和登录接口。然后重写了<code>configure(AuthenticationManagerBuilder auth)</code>方法，我们在该方法中定义了一个用户，该用户信息均保存在内存中。最后还有一个非常重要的地方，需要在配置类上添加<code>@Order(1)</code>注解，用于提升Spring Security框架的优先级，默认数字越小，优先级越大。</p><p><strong>第五步</strong>，由于上面定义的<code>SecurityConfig</code>和<code>AuthServerConfig</code>都是授权服务器提供的，因此我们还需要提供一个暴露用户信息的接口。（此处由于授权服务器和资源服务器放在一起，因此可直接定义。但是当授权服务器和资源服务器是分开搭建时，此时由资源服务器提供该接口。）</p><p>在<code>auth-server</code>项目内新建一个controller包，并在该包内新建一个<code>UserController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController {</span><br><span class="line">    @GetMapping("/user")</span><br><span class="line">    public Principal getCurrentUser(Principal principal){</span><br><span class="line">        return principal;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第六步</strong>，在项目<code>resource/static</code>目录下新建一个<code>login.html</code>文件，具体内容可以下载本项目源码进行查看。</p><p><strong>第七步</strong>，在项目的<code>application.properties</code>配置文件内配置项目的端口号，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=2019</span><br></pre></td></tr></tbody></table></figure></div><p>这样我们就搭建完成了统一认证中心。</p><h3 id="客户端搭建"><a href="#客户端搭建" class="headerlink" title="客户端搭建"></a>客户端搭建</h3><p>接下来我们开始搭建客户端，在<code>oauth2-sso</code>父工程中新建一个子模块，名称为<code>client-app1</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security下的Cloud Security和Cloud OAuth2：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-80c702da9ea04b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-80c702da9ea04b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将新创建的<code>client-app1</code>项目配置到父工程<code>oauth2-sso</code>项目的pom.xml依赖文件中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app1&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，新建一个config包，并在该包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableOAuth2Sso</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上述代码非常简单，表示<code>client-app1</code>项目中所有的接口都需要经过认证之后才能访问，同时还需要在该类上添加<code>@EnableOAuth2Sso</code>注解，表示开启单点登录功能。</p><p><strong>第三步</strong>，新建一个controller包，并在该包内新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        return authentication.getName()+ Arrays.toString(authentication.getAuthorities().toArray());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们定义了一个<code>/hello</code>接口，该接口的作用是返回当前登录用户的姓名和角色信息。</p><p><strong>第四步</strong>，在项目的<code>application.properties</code>配置文件内配置项目的端口号和OAuth2的相关信息，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">security.oauth2.client.client-secret=1234</span><br><span class="line">security.oauth2.client.client-id=envythink</span><br><span class="line">security.oauth2.client.user-authorization-uri=http://127.0.0.1:2019/oauth/authorize</span><br><span class="line">security.oauth2.client.access-token-uri=http://127.0.0.1:2019/oauth/token</span><br><span class="line">security.oauth2.resource.user-info-uri=http://127.0.0.1:2019/user</span><br><span class="line"></span><br><span class="line">server.port=2020</span><br><span class="line">server.servlet.session.cookie.name=s1</span><br></pre></td></tr></tbody></table></figure></div><p>在上面的配置中，<code>client-secret</code>表示客户端密码；<code>client-id</code>表示客户端ID；<code>user-authorization-uri</code>表示用户授权的端点；<code>access-token-uri</code>表示获取令牌的端点；<code>user-info-uri</code>表示从资源服务器上获取信息的接口；之后就是配置项目端口号和cookie的名称，这样我们就完成了客户端1的配置。</p><p><strong>由于客户端1和客户端2的配置完成一致，只有最后项目名称和端口以及cookie的不同，因此关于客户端2的创建工作就省略。</strong></p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>接下来分别启动项目，开始进行测试。首先我们在浏览器中输入<code>http://127.0.0.1:2020/hello</code>链接，尝试去访问客户端1中的hello接口，此时页面会跳转到统一认证中心进行认证：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-50090f4eea535698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-50090f4eea535698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后用户以envy/1234进行登录，此时页面会跳转到<code>http://127.0.0.1:2020/hello</code>链接，并显示以下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-fba9ee4092d3dbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-fba9ee4092d3dbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>此时当开发者直接去访问客户端2的hello接口时，也就是<code>http://127.0.0.1:2021/hello</code>链接，可以看到页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-461349ad25c650d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-461349ad25c650d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到用户不需要再次登录，也能访问到客户端2中的hello接口，这样我们就实现了单点登录这一功能。</p><h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><p>为了更好的对上述内容进行分析，接下来我们将通过请求流程来进一步分析：</p><p>（1）当我们访问<code>client-app1</code>项目的hello接口时，由于此接口被保护，只有通过认证后才能访问，因此此时我们的请求会被拦截下来，系统会将我们重定向到<code>client-app1</code>项目的login接口，也就是登录页面：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-8b19c69f207e626a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-8b19c69f207e626a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>（2）当我们去访问<code>client-app1</code>项目的login接口时，由于我们配置了<code>@EnableOAuth2Sso</code>注解，因此请求会被再次拦截下来，单点登录拦截器会根据我们在<code>application.properties</code>配置文件中的配置，自动发起请求去获取授权码：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-448a24a30974081d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-448a24a30974081d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>（3）由于（2）发送的请求是请求<code>auth-server</code>授权服务器上的内容，因此这个请求也需要先登录才能访问，所以会再次重定向到<code>auth-server</code>授权服务器的登录页面，也就是我们看到的统一认证中心页面：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-099325fcf486b516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-099325fcf486b516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>（4）在统一认证中心用户成功登录之后，会继续执行（2）中的请求，此时就能获取到授权码了。</p><p>（5）在获取到授权码之后，此时会重定向到<code>client-app1</code>项目的login页面，而实际上<code>client-app1</code>项目是没有登录页面的，因此这个请求依旧会被拦截，此时拦截到的地址中包含授权码。拿着授权码在<code>OAuth2ClientAuthenticationProcessingFilter</code>类中向<code>auth-server</code>发起请求请求就能得到<code>access_token</code>了。</p><p>（6）在获取到<code>access_token</code>之后，接下来就向我们配置的<code>user-info-uri</code>地址发送请求，来获取登录的用户信息。在拿到用户信息之后，接下来会在<code>client-app1</code>项目上重写执行一次Spring Security的登录流程，这样完成了接口信息的获取。</p><p>以上就是如何使用Spring Boot+OAuth2.0来实现单点登录这一功能的相关分析。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;我们知道分布式系统由多个不同的子系统组成，但是我们希望在使用系统的时只需登</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0+JWT实现单点登录</title>
    <link href="http://envyzhan.asia/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/"/>
    <id>http://envyzhan.asia/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/</id>
    <published>2021-01-12T11:23:04.000Z</published>
    <updated>2021-03-01T03:51:50.278Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>通过前面几篇的学习，我们对OAuth2.0中的四种授权模式有了较为清晰的认识，同时可以发现这些文章都是侧重于OAuth2.0的登录流程，而对于登录的一些细节并没有过多的深究，其实这些细节在实际开发过程中也非常重要，因此接下来开始对登录中的一些细节进行深度分析。</p><p>我们知道传统的Web应用都是采用Session来记录用户认证信息，这一方式可以理解为是一种有状态的登录，实际上还可以采用无状态这种方式来实现这一目的，最为代表的就是JWT。无状态登录很容易实现单点登录这一功能，因此对于无状态登录的研究对于提升自身技术水平有非常大的帮助。</p><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>所谓的有状态服务是指服务端需要记录每次会话的客户信息，并据此识别客户端身份，验证通过后根据客户端身份进行请求处理，如Tomcat中的session就是此类的具体实现。当用户登录成功后，会将用户的信息保存在服务端的Session中，并将sessionId放在Cookie中用于返回给用户。等到用户下次访问的时候，用户会携带含有Cookie信息的请求到服务器，服务器会验证sessionId是否合法，当验证无误通过后会据此找到用户信息。</p><p>但是这种方式存在一些缺陷，当时间不断累计，服务端会保存大量的数据，这势必会增加服务端压力，还有由于服务器中保存的是用户的状态，因此对于集群化部署不太友好，极易造成用户信息访问断层现象。</p><p><strong>基于有状态实现的登录流程：</strong><br>1、用户输入用户名和密码，点击提交；<br>2、调用 login()命令, 后端程序会根据用户名密码生成sessionId并保存在数据库中；<br>3、用户登录之后，需要通过这个sessionId取出相关的基本信息。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>说完了有状态，接下来学习无状态，单纯的介绍无状态似乎意义不大，因此结合目前流行的微服务架构来讲显得更有说服力。</p><p>我们知道微服务集群中每个服务对外都使用RESTful风格的接口，而RESTful风格有一个重要的规范就是“服务无状态性”。怎么理解这个“服务无状态性”呢？这里有两点需要注意：（1）服务端不保存客户端请求发起者的信息；（2）客户端的每次请求中必须包含描述发送者的信息，以便服务端通过这些信息唯一确定其身份。</p><p>那么问题来了，无状态相比于有状态有哪些优势呢？首先由于客户端发起的请求中已经包含了其发送者的描述信息，因此并不要求多次发送请求访问的必须是同一台服务器，这使得服务器集群化成为可能；其次，由于存在集群化部署，极大地降低了服务端的压力。</p><p><strong>基于无状态实现的登录流程：</strong><br>1、用户输入用户名和密码，点击提交；<br>2、调用 login()命令, 后端程序会将用户信息加密并编码成一个token，之后将其返回给客户端；<br>3、此后客户端每次发送请求都需要携带token，服务端对该token进行解密和验证，确认通过后即能获取用户基本信息。</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><p><a href="https://jwt.io/">JWT</a>，全称为Json Web Token，它是一种JSON风格、轻量级的授权和身份认证规范，可以实现无状态、分布式的Web应用授权：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c941d19cc6deed69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c941d19cc6deed69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>JWT作为一种规范，并没有和语言进行绑定，因此不同的语言对此都有具体的实现。常用的Java语言实现是jjwt，其开源地址为<code>https://github.com/jwtk/jjwt</code>。</p><h3 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h3><p>JWT的原理是，服务端认证以后，生成一个 SON对象并返回给用户，就像下面这样：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "name": "envy",</span><br><span class="line">  "role": "admin",</span><br><span class="line">  "expires": "2021-01-02 10:01:06"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后用户与服务端进行通信的时候，都需要携带这个JSON对象。服务端完全靠这个JSON对象来确定用户身份。当然了，为了防止用户篡改数据，服务端会在生成这个JSON对象的时候，会加上签名，这一点后续会介绍。这样服务端无需保存任何session数据，也就是说此时服务端变成无状态了，进而比较容易实现扩展。</p><h3 id="JWT数据格式"><a href="#JWT数据格式" class="headerlink" title="JWT数据格式"></a>JWT数据格式</h3><p>首先看一下实际的JWT实例，如下图所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f675af1bfe72e7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f675af1bfe72e7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到这个JWT是一个非常长的字符串，中间用点号<code>(.)</code>分隔成三部分。请注意，实际的JWT内部是没有换行的，此处只是为了便于展示才将它写成了四行。</p><p>JWT包含三部分数据，一是Header（头部）、二是Playload（载荷）、三是Signature（签名）。写成一行就是<code>Header.Payload.Signature</code>这一格式，也就是如下所示的格式：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-b2bd42188a16f39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-b2bd42188a16f39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一部分</strong>：Header（头部），它是一个JSON对象，用于描述JWT的元数据。举个例子，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "alg": "HS256",</span><br><span class="line">  "typ": "JWT"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>它通常包括两个部分：(1)加密算法，这个开发者可以自定义；(2)声明类型，此处就是JWT。在上面代码中，alg属性表示签名的算法（algorithm），默认是HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。通常我们会对头部使用Base64URL进行编码，进而得到第一部分数据，但是这种编码方式是可逆的，安全性不高。</p><p><strong>第二部分</strong>：Playload（载荷），它也是一个JSON对象，用于存放实际需要传递的数据，说白了就是有效数据。在其官方文档(RFC7519)中规定了7个可供选择的字段，如下所示：<br>(1)iss(issuer)表示签发人；(2)exp(expiration time)表示token过期时间；(3)sub(subject)表示主题；(4)aud(audience)表示受众；(5)nbf(Not Before)表示生效时间；(6)iat(Issued At)表示签发时间；(7)jti(JWT ID)表示编号。</p><p>当然，除了官方字段，开发者还可以在此部分定义私有字段，举个例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "sub": "1234567890",</span><br><span class="line">  "name": "Envy Think",</span><br><span class="line">  "admin": true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>请注意，JWT默认是不加密的，任何人都可以读到，因此不能把私密信息存放在此部分。同样我们会对其使用Base64URL进行编码，进而得到第二部分数据。</p><p><strong>第三部分</strong>：Signature（签名），Signature部分是对前两部分的签名，用于防止数据篡改。</p><p>首先需要在服务器上指定一个密钥（secret），该密钥只有服务器才知道，不能泄露给用户，之后使用<code>Header</code>里面指定的签名算法（默认是<code>HMAC SHA256</code>）来按照下面的公式产生签名：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></tbody></table></figure></div><p>在计算出签名之后，将<code>Header</code>、<code>Payload</code>、<code>Signature</code>这三部分拼成一个字符串，注意各个部分之间使用点号<code>(.)</code>进行分割，之后就可以返回给用户。</p><p>在前面我们多次提到，Header和Payload串型化均采用了Base64URL算法，该算法和Base64算法基本类似，但是存在一些不同的地方。我们知道JWT作为一个令牌（token），在某些场景下会放在URL中，如<code>https://api.example.com/?token=xxx</code>。Base64中存在三个特殊字符<code>+</code>、<code>/</code>和<code>=</code>，由于它们在URL中有特殊含义，因此要被替换掉，其中<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code>，这就是Base64URL算法。</p><h3 id="JWT数据流转"><a href="#JWT数据流转" class="headerlink" title="JWT数据流转"></a>JWT数据流转</h3><p>下面是JWT数据流转的示意图：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-63c740a0519c7652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-63c740a0519c7652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>乍一看可能觉得JWT模式与四种授权模式中的密码模式非常相似，其实两者是存在一个较为明显的区别。JWT模式下服务端不保存用户信息，且不要求客户端对于服务端高度信任。也正是由于JWT签发的令牌token中已经包含了用户身份信息，且每次请求时都会携带上，因此服务端无需保存用户信息，毫无疑问这是非常符合RESTful的无状态要求。</p><h3 id="JWT缺点"><a href="#JWT缺点" class="headerlink" title="JWT缺点"></a>JWT缺点</h3><p>尽管JWT存在上述所列的优点，但是JWT也存在一些问题，具体如下所示：<br>（1）续签问题。这也是JWT被许多人嗤之以鼻的原因，我们知道传统的cookie+session方案支持续签，但是JWT由于服务端不保存用户信息，因此很难解决续签问题。当然开发者可以引入Redis来解决这个问题，但是这并不是单纯的使用JWT。<br>（2）注销问题。尽管JWT模式下的服务端不保存用户信息，但是开发者可以通过修改secret来实现注销，当服务端的secret被修改后，请注意已经颁发的未过期的令牌token就会认证失败，进而实现注销这一目的，但是这种方式肯定没有传统注销那样简单。<br>（3）密码重置问题。请注意当用户将密码进行重置后，之前的令牌token依旧可以访问系统，此时就需要强制修改secret。<br>（4）由于注销问题和密码重置问题，因此一般建议不同的用户采用不同的secret，以增强安全性。</p><h3 id="OAuth2中存在的问题"><a href="#OAuth2中存在的问题" class="headerlink" title="OAuth2中存在的问题"></a>OAuth2中存在的问题</h3><p>在《一个完整的授权码模式实例》一文中我们知道，当授权服务器派发了access_token之后，客户端便拿着access_token去资源服务器请求资源，此时资源服务器需要校验access_token信息，因此我们需要在资源服务器上配置<code>RemoteTokenServices</code>，进而让资源服务器进行校验，如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RemoteTokenServices tokenServices(){</span><br><span class="line">    RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">    services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">    services.setClientId("envythink");</span><br><span class="line">    services.setClientSecret("1234");</span><br><span class="line">    return services;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>毫无疑问这段代码在高并发情况下执行是有问题的，如果使用JWT将用户信息保持在JWT中，那么就能解决上述问题。</p><h1 id="密码模式使用JWT"><a href="#密码模式使用JWT" class="headerlink" title="密码模式使用JWT"></a>密码模式使用JWT</h1><p>前面也提到JWT模式和密码模式流程非常相似，因此这里就以密码模式为例来进行升级改造。</p><h3 id="授权服务器改造"><a href="#授权服务器改造" class="headerlink" title="授权服务器改造"></a>授权服务器改造</h3><p>首先打开<code>auth_server</code>授权服务器，找到其中的<code>AccessTokenConfig</code>类，将里面的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    private String SIGNING_KEY = "envythink";</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JwtAccessTokenConverter jwtAccessTokenConverter(){</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        return converter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处我们在tokenStore方法中提供的是一个<code>JwtTokenStore</code>实例。如果不采用JWT模式，那么之前我们将access_token无论是存储在内存还是Redis中，最后都是需要将access_token保存下来的，这样当客户端携带access_token请求服务端的时候，服务端还需要对其进行校验。但是如果我们采用了JWT这一模式，那么服务端就无需保存access_token，因为用户信息都保存在jwt中，因此此处配置的JwtTokenStore其实并不是用于存储access_token。</p><p>在<code>JwtTokenStore</code>实例化的过程中我们还传入了一个<code>JwtAccessTokenConverter</code>对象，这个<code>JwtAccessTokenConverter</code>对象可以实现用户信息和JWT字符串的相互转换，也就是可以从JWT字符串中取出用户信息或者将用户信息转为JWT字符串。需要说明的是，在JWT字符串生成的时候，我们还需要生成一个签名，这个签名非常重要。</p><p>注意JWT默认生成的信息主要包含用户角色、名称等，当开发者希望在生成的JWT字符串中包含其他信息，那么可以自定义一个类，然后实现<code>TokenEnhancer</code>接口即可。新建一个<code>CustomAdditionalInformation</code>类，并实现<code>TokenEnhancer</code>接口，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomAdditionalInformation implements TokenEnhancer {</span><br><span class="line">    @Override</span><br><span class="line">    public OAuth2AccessToken enhance(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication) {</span><br><span class="line">        Map&lt;String,Object&gt; info = oAuth2AccessToken.getAdditionalInformation();</span><br><span class="line">        info.put("author","余思");</span><br><span class="line">        ((DefaultOAuth2AccessToken)oAuth2AccessToken).setAdditionalInformation(info);</span><br><span class="line">        return oAuth2AccessToken;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到笔者自定义了一个<code>CustomAdditionalInformation</code>类，实现了<code>TokenEnhancer</code>接口，并重写了该接口的enhance方法。请注意，enhance方法中的<code>OAuth2AccessToken</code>对象其实就是已经生成的access_token信息，我们可以从<code>OAuth2AccessToken</code>对象中取出已经生成的额外信息，并在此基础上添加自己所添加的信息即可。需要说明的是，我们在<code>AccessTokenConfig</code>类中配置的<code>JwtAccessTokenConverter</code>，它也是一个<code>TokenEnhancer</code>实例。</p><p>接下来需要修改<code>AuthorizationServerConfig</code>类，主要是对tokenServices方法进行修改，修改后的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private CustomAdditionalInformation customAdditionalInformation;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line"></span><br><span class="line">    TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();</span><br><span class="line">    tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter,customAdditionalInformation));</span><br><span class="line">    services.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    return services;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们只是实例化了一个<code>TokenEnhancerChain</code>对象，并将之前定义的<code>jwtAccessTokenConverter</code>、<code>customAdditionalInformation</code>两个实例注入进来并构成一个集合，最后将其作为<code>TokenEnhancerChain</code>对象的属性进行设置。</p><h3 id="资源服务器改造"><a href="#资源服务器改造" class="headerlink" title="资源服务器改造"></a>资源服务器改造</h3><p>在完成了对授权服务器的改造之后，接下来我们开始对资源服务器进行改造。首先打开<code>user-server</code>资源服务器，我们将<code>auth_server</code>授权服务器中的<code>AccessTokenConfig</code>类复制一份到其config包中，之后我们在资源服务器上就不再需要配置远程校验地址，只需配置一个<code>TokenStore</code>即可。打开config包下面的<code>ResourceServerConfig</code>类，将其中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenStore(tokenStore);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处我们将之前在<code>AccessTokenConfig</code>类中配置的tokenStore实例注入进来，这样系统会自动调用<code>JwtAccessTokenConverter</code>对象将jwt进行解析，jwt中由于已经保存了用户的基本信息，因此就不需要服务端来校验access_token了。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在完成对授权服务器和资源服务器的改造之后，注意此时我们无需关注应用端，因此对其无需进行改造，同时处于测试方便的考虑，这里使用Postman来对项目进行测试。</p><p>启动授权服务器和资源服务器，首先我们向授权服务器请求access_token：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-93e5d9b1508d1521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-93e5d9b1508d1521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到我们获取到了jwt字符串，也就是此处的access_token，同时可以看到我们之前自定义的author字段也已经有值了。当然如果开发者想验证access_token中包含的信息是否是之前介绍过的内容，此时可以利用Base64URL解码工具来进行解码，也可以使用<code>check_token</code>接口来进行解析：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-d1e196b99a7d7053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-d1e196b99a7d7053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>此时就能看到jwt字符串中保存的用户信息了。在获取到<code>access_token</code>之后，接下来我们就可以去访问资源服务器中的资源了，如访问<code>hello</code>接口，注意此时需要在请求头中携带<code>access_token</code>信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-3151c8c4663d64a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-3151c8c4663d64a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到此时我们就获取到了hello接口中的信息，也就是通过上面的配置我们成功的将OAuth2.0和JWT结合起来进行使用了。</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>现在问题来了，前面介绍的access_token是如何变成了jwt呢？jwt和认证信息又是如何实现自动转换的呢？接下来我们通过阅读源码来解答这些疑问。</p><p>首先思考一个问题，acess_token是在什么地方生成的？此时就需要回到auth-server授权服务器的<code>AuthorizationServerConfig</code>类中，可以看到我们定义了一个<code>tokenServices</code>方法，在该方法中我们构建了一个<code>DefaultTokenServices</code>对象，查看<code>DefaultTokenServices</code>类的源码，可以看到里面有一个名为<code>createAccessToken</code>的方法，该方法的源码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private OAuth2AccessToken createAccessToken(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken) {</span><br><span class="line">    DefaultOAuth2AccessToken token = new DefaultOAuth2AccessToken(UUID.randomUUID().toString());</span><br><span class="line">    int validitySeconds = this.getAccessTokenValiditySeconds(authentication.getOAuth2Request());</span><br><span class="line">    if (validitySeconds &gt; 0) {</span><br><span class="line">        token.setExpiration(new Date(System.currentTimeMillis() + (long)validitySeconds * 1000L));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    token.setRefreshToken(refreshToken);</span><br><span class="line">    token.setScope(authentication.getOAuth2Request().getScope());</span><br><span class="line">    return (OAuth2AccessToken)(this.accessTokenEnhancer != null ? this.accessTokenEnhancer.enhance(token, authentication) : token);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>简单分析一下该方法：<br>（1）可以看到默认生成的<code>access_token</code>其实是一个UUID字符串；<br>（2）调用<code>getAccessTokenValiditySeconds()</code>方法来获取<code>access_token</code>的有效期。查看一下这个<code>getAccessTokenValiditySeconds()</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected int getAccessTokenValiditySeconds(OAuth2Request clientAuth) {</span><br><span class="line">    if (this.clientDetailsService != null) {</span><br><span class="line">        ClientDetails client = this.clientDetailsService.loadClientByClientId(clientAuth.getClientId());</span><br><span class="line">        Integer validity = client.getAccessTokenValiditySeconds();</span><br><span class="line">        if (validity != null) {</span><br><span class="line">            return validity;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return this.accessTokenValiditySeconds;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它首先通过客户端Id去数据库中查询得到客户端信息，其次调用客户端的<code>getAccessTokenValiditySeconds()</code>方法来得到有效期，其实这个就是我们之前配置的<code>access_token</code>的有效期，注意单位为秒。<br>（3）回到<code>createAccessToken()</code>方法中，接着判断<code>access_token</code>设置的有效期是否大于0，如果大于0则调用<code>setExpiration()</code>方法来设置过期时间，过期时间就是在系统当前时间的基础上加上用户设置的过期时间，由于用户设置的过期时间单位为秒，因此需要乘以1000，将其转换为毫秒。<br>（4）接着调用<code>setRefreshToken()</code>方法来设置刷新token，同时调用<code>setScope()</code>方法来设置授权范围scope。请注意，刷新token的生成过程也是在<code>createAccessToken()</code>方法中完成的，这个过程和<code>access_token</code>生成的过程类似，因此就跳过介绍。<br>（5）在return语句中会对<code>accessTokenEnhancer</code>是否存在进行判断，如果不为空，则调用<code>accessTokenEnhancer.enhance()</code>方法对其进行处理，其实这就是将<code>access_token</code>转换为jwt字符串的过程。</p><p>前面也说了此处<code>accessTokenEnhancer</code>的实现类为<code>TokenEnhancerChain</code>，查看一下其源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TokenEnhancerChain implements TokenEnhancer {</span><br><span class="line">    private List&lt;TokenEnhancer&gt; delegates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    public TokenEnhancerChain() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setTokenEnhancers(List&lt;TokenEnhancer&gt; delegates) {</span><br><span class="line">        this.delegates = delegates;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {</span><br><span class="line">        OAuth2AccessToken result = accessToken;</span><br><span class="line"></span><br><span class="line">        TokenEnhancer enhancer;</span><br><span class="line">        for(Iterator var4 = this.delegates.iterator(); var4.hasNext(); result = enhancer.enhance(result, authentication)) {</span><br><span class="line">            enhancer = (TokenEnhancer)var4.next();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到里面定义了一个delegates属性，里面保存了我们定义的<code>TokenEnhancer</code>，前面也说了我们在<code>auth-server</code>授权服务器中定义了<code>jwtAccessTokenConverter</code>和<code>customAdditionalInformation</code>，也就是说<code>access_token</code>信息其实就是在这两个类中进行二次处理。处理的顺序是依照集合中保存的顺序，也就是先在<code>jwtAccessTokenConverter</code>中进行处理，之后在<code>customAdditionalInformation</code>中进行处理，这个顺序不能发生颠倒，这也就意味着开发人员在<code>auth-server</code>授权服务器中应当首先注入<code>JwtAccessTokenConverter</code>对象，之后才注入<code>CustomAdditionalInformation</code>对象。</p><p>需要说明的是，无论是<code>JwtAccessTokenConverter</code>，还是<code>CustomAdditionalInformation</code>，其中核心的方法都是enhance方法。首先查看一下<code>JwtAccessTokenConverter</code>类中enhance方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {</span><br><span class="line">    DefaultOAuth2AccessToken result = new DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">    Map&lt;String, Object&gt; info = new LinkedHashMap(accessToken.getAdditionalInformation());</span><br><span class="line">    String tokenId = result.getValue();</span><br><span class="line">    if (!info.containsKey("jti")) {</span><br><span class="line">        info.put("jti", tokenId);</span><br><span class="line">    } else {</span><br><span class="line">        tokenId = (String)info.get("jti");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    result.setAdditionalInformation(info);</span><br><span class="line">    result.setValue(this.encode(result, authentication));</span><br><span class="line">    OAuth2RefreshToken refreshToken = result.getRefreshToken();</span><br><span class="line">    if (refreshToken != null) {</span><br><span class="line">        DefaultOAuth2AccessToken encodedRefreshToken = new DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">        encodedRefreshToken.setValue(refreshToken.getValue());</span><br><span class="line">        encodedRefreshToken.setExpiration((Date)null);</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Map&lt;String, Object&gt; claims = this.objectMapper.parseMap(JwtHelper.decode(refreshToken.getValue()).getClaims());</span><br><span class="line">            if (claims.containsKey("jti")) {</span><br><span class="line">                encodedRefreshToken.setValue(claims.get("jti").toString());</span><br><span class="line">            }</span><br><span class="line">        } catch (IllegalArgumentException var11) {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; refreshTokenInfo = new LinkedHashMap(accessToken.getAdditionalInformation());</span><br><span class="line">        refreshTokenInfo.put("jti", encodedRefreshToken.getValue());</span><br><span class="line">        refreshTokenInfo.put("ati", tokenId);</span><br><span class="line">        encodedRefreshToken.setAdditionalInformation(refreshTokenInfo);</span><br><span class="line">        DefaultOAuth2RefreshToken token = new DefaultOAuth2RefreshToken(this.encode(encodedRefreshToken, authentication));</span><br><span class="line">        if (refreshToken instanceof ExpiringOAuth2RefreshToken) {</span><br><span class="line">            Date expiration = ((ExpiringOAuth2RefreshToken)refreshToken).getExpiration();</span><br><span class="line">            encodedRefreshToken.setExpiration(expiration);</span><br><span class="line">            token = new DefaultExpiringOAuth2RefreshToken(this.encode(encodedRefreshToken, authentication), expiration);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        result.setRefreshToken((OAuth2RefreshToken)token);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这段代码较长，但是逻辑较为清晰：<br>（1）首先实例化一个<code>DefaultOAuth2AccessToken</code>对象，之后调用<code>getAdditionalInformation()</code>方法将<code>accessToken</code>中的额外信息提取出来，注意<code>accessToken</code>默认是没有附加信息的；<br>（2）调用<code>result.getValue()</code>方法得到之前生成的UUID字符串，并判断（1）得到的附加信息中是否包含<code>jti</code>，如果不包含则将其放入其中，如果包含则直接获取其信息，并将其值作为tokenId的值。之后就是将获取到的额外信息和值添加到result中。<br>（3）调用<code>encode()</code>方法来对result对象进行编码，并将结果作为新的access_token，注意这个编码的过程其实就是将用户信息转换为jwt字符串的过程。<br>（4）接下来就是设置token的刷新问题，首先判断<code>refreshToken</code>是否不为空，如果不为空，同时token为jwt字符串，那么就需要一个解码操作，否则直接刷新token。请注意，如果<code>refreshToken</code>为<code>ExpiringOAuth2RefreshToken</code>的实例，那么就说明<code>refreshToken</code>已经过期了，此时需要重新生成一个<code>refreshToken</code>。</p><p>在（3）中我们提到，会调用<code>encode()</code>方法来对result对象进行编码，而这个也是将用户信息转换为jwt字符串的过程。查看一下该方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected String encode(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {</span><br><span class="line">    String content;</span><br><span class="line">    try {</span><br><span class="line">        content = this.objectMapper.formatMap(this.tokenConverter.convertAccessToken(accessToken, authentication));</span><br><span class="line">    } catch (Exception var5) {</span><br><span class="line">        throw new IllegalStateException("Cannot convert access token to JSON", var5);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    String token = JwtHelper.encode(content, this.signer).getEncoded();</span><br><span class="line">    return token;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它首先会将<code>accessToken</code>和用户信息<code>authentication</code>生成一个字符串，之后调用<code>JwtHelper.encode()</code>方法来对生成的字符串进行编码，最后就返回了一个jwt字符串。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;通过前面几篇的学习，我们对OAuth2.0中的四种授权模式有了较为清晰的认</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>授权码模式实例优化</title>
    <link href="http://envyzhan.asia/2021/01/09/oauth2-7-authorization-code-pattern-optimization/"/>
    <id>http://envyzhan.asia/2021/01/09/oauth2-7-authorization-code-pattern-optimization/</id>
    <published>2021-01-09T11:23:04.000Z</published>
    <updated>2021-03-01T03:51:23.769Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>一般来说，<code>access_token</code>令牌肯定不会像之前那样存在内存中，通常我们都会将其存入Redis数据库中。在实际开发过程中，不仅仅是令牌，对于客户端信息，我们同样需要将其存入数据库中，还有对于第三方应用而言，前面的配置都显得过于臃肿，因此接下来就尝试对上述一些问题进行细致分析。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>同样由于授权码模式的完整性，这里依旧选择使用授权码模式进行分析。授权码模式中各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h3 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h3><p>使用Maven新建一个空白的父工程，名称为<code>authorization-code-redis</code>，之后我们将在这个父工程中搭建子项目。</p><h3 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h3><p>在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下五个依赖：Web、Spring Cloud Security、Spring Cloud OAuth2、Redis、MySQL依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到既然是需要将令牌存入Redis，客户端信息存入MySQL，那么就需要添加对应的依赖。<br><strong>第一步</strong>，将<strong>父工程<code>authorization-code-redis</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;authorizationcoderedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;authorization-code-redis&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0令牌持久化&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy").password(new BCryptPasswordEncoder().encode("1234")).roles("admin")</span><br><span class="line">                .and()</span><br><span class="line">                .withUser("hello").password(new BCryptPasswordEncoder().encode("1234")).roles("user");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().formLogin()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。</p><h1 id="Redis存储令牌"><a href="#Redis存储令牌" class="headerlink" title="Redis存储令牌"></a>Redis存储令牌</h1><p>完成了用户的基本信息配置后，接下来开始配置授权服务器。在前面授权码模式一文中，对于授权码我们使用<code>InMemoryAuthorizationCodeServices</code>存储在内存中；对于令牌我们使用<code>InMemoryTokenStore</code>存储在内存中。对于授权码来说，使用一次之后就会失效，因此将其存在内存中是可以的，但是令牌一般都是有使用期限的，在该期限内是可以多次使用的，因此将其也存在内存中并不是最佳的方式。</p><p><code>TokenStore</code>用于将生成的token存放在何处，这是一个接口，查看该接口的实现类：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到它提供了多种方式来存储令牌：<br>（1）<code>InMemoryTokenStore</code>，这是系统默认的存储方式。顾名思义就是将令牌<code>access_token</code>存入内存中，在单体应用中是没有任何问题，但是在分布式环境下就会出现很多问题。<br>（2）<code>JdbcTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入数据库中，这样便于在多应用之间共享令牌数据。<br>（3）<code>JwkTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入JSON Web Key中。<br>（4）<code>JwtTokenStore</code>，请注意，这个其实并不是存储，因为使用jwt之后，生成的jwt中就存有用户的所有信息。因为服务端是不用保存令牌，也就是无状态登录。<br>（5）<code>RedisTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入Redis中。</p><p>尽管系统提供了5种存储令牌的方式，但是在实际开发过程中用的多的还是<code>RedisTokenStore</code>和<code>JwtTokenStore</code>这两种。<code>JwtTokenStore</code>这种方式非常复杂，后续会进行学习。这里主要学习使用<code>RedisTokenStore</code>来存储令牌。</p><p><strong>第三步</strong>，在<code>application.properties</code>配置文件中添加Redis配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br><span class="line"></span><br><span class="line">spring.redis.host=192.168.59.100</span><br><span class="line">spring.redis.port=6371</span><br><span class="line">spring.redis.database=0</span><br><span class="line">spring.redis.password=envy123</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new RedisTokenStore(redisConnectionFactory);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们提供一个<code>TokenStore</code>实例，准确来说是<code>RedisTokenStore</code>实例，该实例表示将生成的token存放在Redis中。</p><h1 id="客户端信息入库"><a href="#客户端信息入库" class="headerlink" title="客户端信息入库"></a>客户端信息入库</h1><p>在前面我们都是使用了类似于下面的代码，将客户端信息存储在了内存中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient("envythink").secret(new BCryptPasswordEncoder().encode("1234"))</span><br><span class="line">            .resourceIds("res1").authorizedGrantTypes("authorization_code","refresh_token")</span><br><span class="line">            .scopes("all").redirectUris("http://127.0.0.1:8082/index.html");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>但是在实际工作中绝不会这么操作，一是这里直接将客户端信息在代码中固定化了，不利于后续维护；二是客户端信息是比较多的，直接将其存储在内存中会占用大量的内存资源，这是极为不可取的，因此正确的做法是将其存储在数据库中。</p><p>与用户相关的UserDetailsService接口相类似，客户端信息主要与ClientDetailsService接口相关。查看一下该接口的实现类：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a3c7f7cb4699fd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a3c7f7cb4699fd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到它有两个实现类，分别是<code>InMemoryClientDetailsService</code>和<code>JdbcClientDetailsService</code>。显然前者用于将数据存入内存中，后者用于存入数据库中。查看一下<code>JdbcClientDetailsService</code>的源码，可以发现它很长，这里主要关注它无参数的构造方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public JdbcClientDetailsService(DataSource dataSource) {</span><br><span class="line">    this.updateClientDetailsSql = DEFAULT_UPDATE_STATEMENT;</span><br><span class="line">    this.updateClientSecretSql = "update oauth_client_details set client_secret = ? where client_id = ?";</span><br><span class="line">    this.insertClientDetailsSql = "insert into oauth_client_details (client_secret, resource_ids, scope, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove, client_id) values (?,?,?,?,?,?,?,?,?,?,?)";</span><br><span class="line">    this.selectClientDetailsSql = "select client_id, client_secret, resource_ids, scope, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove from oauth_client_details where client_id = ?";</span><br><span class="line">    this.passwordEncoder = NoOpPasswordEncoder.getInstance();</span><br><span class="line">    Assert.notNull(dataSource, "DataSource required");</span><br><span class="line">    this.jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">    this.listFactory = new DefaultJdbcListFactory(new NamedParameterJdbcTemplate(this.jdbcTemplate));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里面其实就是对系统自带的<code>oauth_client_details</code>表进行了增改查操作，因此我们完全可以从这个方法中推断出这个<code>oauth_client_details</code>表的创建语法，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `oauth_client_details`;</span><br><span class="line">CREATE TABLE  `oauth_client_details`(</span><br><span class="line">  `client_id` varchar(48) NOT NULL,</span><br><span class="line">  `client_secret` varchar(256) DEFAULT NULL,</span><br><span class="line">  `resource_ids` varchar(256) DEFAULT NULL,</span><br><span class="line">  `scope` varchar(256) DEFAULT NULL,</span><br><span class="line">  `authorized_grant_types` varchar(256) DEFAULT NULL,</span><br><span class="line">  `web_server_redirect_uri` varchar(256) DEFAULT NULL,</span><br><span class="line">  `authorities` varchar(256) DEFAULT NULL,</span><br><span class="line">  `access_token_validity` int(11) DEFAULT NULL,</span><br><span class="line">  `refresh_token_validity` int(11) DEFAULT NULL,</span><br><span class="line">  `additional_information` varchar(4096) DEFAULT NULL,</span><br><span class="line">  `autoapprove` varchar(256) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY(`client_id`)</span><br><span class="line">)ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，新建一个名为oauth2的数据库，之后运行上述创建数据表的SQL。</p><p><strong>第六步</strong>，在<code>application.properties</code>配置文件中添加MySQL配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.url=jdbc:mysql:///oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.main.allow-bean-definition-overriding=true</span><br></pre></td></tr></tbody></table></figure></div><p>注意最后需要添加<code>spring.main.allow-bean-definition-overriding=true</code>这一行代码，因为我们既然是自定义ClientDetailsService，那么就需要设置允许将自定义的实例覆盖系统默认的实例。</p><p><strong>第七步</strong>，在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ClientDetailsService clientDetailsService(){</span><br><span class="line">        return new JdbcClientDetailsService(dataSource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService());</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {</span><br><span class="line">        security.checkTokenAccess("permitAll()")</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.withClientDetails(clientDetailsService());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //授权码依旧存在内存中</span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices(){</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，我们将其配置在MySQL数据库中。<br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h3 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h3><p><strong>请注意此处资源服务器搭建和授权码模式时的步骤完全一样，这里将之前搭建的过程给搬运过来而已。</strong></p><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>authorization-code-redis</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices(){</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">        services.setClientId("envythink");</span><br><span class="line">        services.setClientSecret("1234");</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("admin/hello")</span><br><span class="line">    public String admin(){</span><br><span class="line">        return "admin";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h3 id="客户端（第三方应用）优化"><a href="#客户端（第三方应用）优化" class="headerlink" title="客户端（第三方应用）优化"></a>客户端（第三方应用）优化</h3><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下两个依赖：Web和Thymeleaf依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>authorization-code-redis</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 授权码模式实例优化&lt;/h1&gt;</span><br><span class="line">&lt;a href="http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html"&gt;第三方登录&lt;/a&gt;</span><br><span class="line">&lt;h1 th:text="${msg}"&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>该页面的意思是点击超链接，就可以实现第三方登录，超链接中的参数如下所示：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为code，表示响应一个授权码。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scop</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个h1标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在h1标签中显示出来。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController {</span><br><span class="line">    @Autowired</span><br><span class="line">    TokenTask tokenTask;</span><br><span class="line">    @GetMapping("/index.html")</span><br><span class="line">    public String hello(String code, Model model) {</span><br><span class="line">        model.addAttribute("msg", tokenTask.getData(code));</span><br><span class="line">        return "index";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们在此处的HelloController类中定义了一个hello方法，该方法用于访问<code>/index.html</code>接口。可以看到此时我们是通过调用<code>tokenTask.getData()</code>方法来获取对应的信息。</p><p>接着我们新建一个component包，并在该包内新建一个TokenTask类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TokenTask {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public String access_token = "";</span><br><span class="line">    public String refresh_token = "";</span><br><span class="line"></span><br><span class="line">    public String getData(String code) {</span><br><span class="line">        if ("".equals(access_token) &amp;&amp; code != null) {</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add("code", code);</span><br><span class="line">            map.add("client_id", "envythink");</span><br><span class="line">            map.add("client_secret", "1234");</span><br><span class="line">            map.add("redirect_uri", "http://127.0.0.1:8082/index.html");</span><br><span class="line">            map.add("grant_type", "authorization_code");</span><br><span class="line">            Map&lt;String, String&gt; resp = restTemplate.postForObject("http://127.0.0.1:8080/oauth/token", map, Map.class);</span><br><span class="line">            access_token = resp.get("access_token");</span><br><span class="line">            refresh_token = resp.get("refresh_token");</span><br><span class="line">            return loadDataFromResServer();</span><br><span class="line">        } else {</span><br><span class="line">            return loadDataFromResServer();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private String loadDataFromResServer() {</span><br><span class="line">        try {</span><br><span class="line">            HttpHeaders headers = new HttpHeaders();</span><br><span class="line">            headers.add("Authorization", "Bearer " + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange("http://127.0.0.1:8081/admin/hello", HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            return entity.getBody();</span><br><span class="line">        } catch (RestClientException e) {</span><br><span class="line">            return "未加载";</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = "0 55 0/1 * * ？")</span><br><span class="line">    public void tokenTask() {</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add("client_id", "envythink");</span><br><span class="line">        map.add("client_secret", "1234");</span><br><span class="line">        map.add("refresh_token", refresh_token);</span><br><span class="line">        map.add("grant_type", "refresh_token");</span><br><span class="line">        Map&lt;String, String&gt; resp = restTemplate.postForObject("http://127.0.0.1:8080/oauth/token", map, Map.class);</span><br><span class="line">        access_token = resp.get("access_token");</span><br><span class="line">        refresh_token = resp.get("refresh_token");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析，在<code>getData()</code>方法中，当<code>access_token</code>为空字符串且code不为空时，说明此时是刚拿到授权码的时候，准备去申请令牌了。在拿到令牌之后，将<code>access_token</code>和<code>refresh_token</code>分别赋值给全局变量，之后调用<code>loadDataFromResServer()</code>方法去资源服务器请求资源。</p><p>除此之外，这里还定义了一个<code>tokenTask()</code>方法，这是一个定时任务，每隔115分钟去刷新<code>access_token</code>，注意笔者将<code>access_token</code>的有效期设置为120分钟了。</p><p>之后就是启动项目进行测试了，由于这个过程较为简单，因此这里就直接跳过。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;一般来说，&lt;code&gt;access_token&lt;/code&gt;令牌肯定不会像</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的客户端模式实例</title>
    <link href="http://envyzhan.asia/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/"/>
    <id>http://envyzhan.asia/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/</id>
    <published>2021-01-07T11:23:04.000Z</published>
    <updated>2021-03-01T03:50:55.619Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究客户端模式，深入理解其中的各个流程。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>客户端模式又称为凭证式模式，当某些应用是纯后端应用没有前端时，就可以使用客户端模式，即在命令行下请求令牌。客户端模式是指客户端使用自己的名义而不是用户的名义向服务器提供者申请授权。严格来说，客户端模式并不能算作OAuth协议要解决的问题的一种解决方案，但是对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是较为方便的。它涉及到资源所有者、客户端（第三方应用）、授权服务器和资源服务器这三个角色。客户端模式涉及到的各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>client</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>client</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将<strong>父工程<code>client</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;client&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0客户端模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy").password(new BCryptPasswordEncoder().encode("1234")).roles("admin")</span><br><span class="line">                .and()</span><br><span class="line">                .withUser("hello").password(new BCryptPasswordEncoder().encode("1234")).roles("user");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时对其他页面访问我们没有进行权限控制。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {</span><br><span class="line">        security.checkTokenAccess("permitAll()")</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient("envythink").secret(new BCryptPasswordEncoder().encode("1234"))</span><br><span class="line">                .resourceIds("res1").authorizedGrantTypes("refresh_token","client_credentials")</span><br><span class="line">                .scopes("all").redirectUris("http://127.0.0.1:8082/index.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices(){</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>client_credentials</code>。</strong><br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>client</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>client</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices(){</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">        services.setClientId("envythink");</span><br><span class="line">        services.setClientSecret("1234");</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("admin/hello")</span><br><span class="line">    public String admin(){</span><br><span class="line">        return "admin";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>client</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下三个依赖：Web和Thymeleaf依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>client</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 客户端模式实例&lt;/h1&gt;</span><br><span class="line">&lt;a href="http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html"&gt;第三方登录&lt;/a&gt;</span><br><span class="line">&lt;h1 th:text="${msg}"&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>该页面的意思是点击超链接，就可以实现第三方登录，超链接中的参数如下所示：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为code，表示响应一个授权码。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scop</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个h1标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在h1标签中显示出来。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/index.html")</span><br><span class="line">    public String hello(String code, Model model){</span><br><span class="line">        if(code!=null){</span><br><span class="line">            MultiValueMap&lt;String,String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add("code",code);</span><br><span class="line">            map.add("client_id", "envythink");</span><br><span class="line">            map.add("client_secret","1234");</span><br><span class="line">            map.add("redirect_uri","http://127.0.0.1:8082/index.html");</span><br><span class="line">            map.add("grant_type","authorization_code");</span><br><span class="line">            Map&lt;String,String&gt; respMap= restTemplate.postForObject("http://127.0.0.1:8080/oauth/token",map, Map.class);</span><br><span class="line">            String access_token = respMap.get("access_token");</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line"></span><br><span class="line">            HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">            httpHeaders.add("Authorization","Bearer"+access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(httpHeaders);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange("http://127.0.0.1:8081/admin/hello", HttpMethod.GET,httpEntity,String.class);</span><br><span class="line">            model.addAttribute("msg",entity.getBody());</span><br><span class="line">        }</span><br><span class="line">        return "index";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们在此处的HelloController类中先定义了一个hello方法，该方法用于访问<code>/login.html</code>接口。接着定义了一个login方法，该方法用于处理<code>/login</code>接口，它通过使用restTemplate对象来发送一个POST请求，请注意在此POST请求中的<code>grant_type</code>参数的值为client_credentials，表示此为客户端模式。通过这个POST请求，我们可以获取授权服务器返回的<code>access_token</code>信息。之后我们就提取出<code>access_token</code>信息，并再次使用restTemplate对象来发送一个GET请求去访问资源服务器，并将获取到的数据放在model中进行返回。</p><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></tbody></table></figure></div><p>请注意，如果在上面提示缺少一个<code>RestTemplate</code>对象，那么就需要开发者自行提供一个Bean方法用于返回一个<code>RestTemplate</code>实例。以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来在<code>client-app</code>项目的测试文件中新建一个contextLoads方法，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ClientAppApplicationTests {</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() {</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add("client_id", "envythink");</span><br><span class="line">        map.add("client_secret", "1234");</span><br><span class="line">        map.add("grant_type", "client_credentials");</span><br><span class="line">        Map&lt;String, String&gt; resp = restTemplate.postForObject("http://127.0.0.1:8080/oauth/token", map, Map.class);</span><br><span class="line">        String access_token = resp.get("access_token");</span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        headers.add("Authorization", "Bearer " + access_token);</span><br><span class="line">        HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; entity = restTemplate.exchange("http://127.0.0.1:8081/hello", HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">        System.out.println(entity.getBody());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后再运行该方法，当控制台输出hello字样时，则表明项目测试通过了。这样就说明我们的授权码模式实例就配置成功了。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的密码模式实例</title>
    <link href="http://envyzhan.asia/2021/01/05/oauth2-5-a-complete-example-of-password-pattern/"/>
    <id>http://envyzhan.asia/2021/01/05/oauth2-5-a-complete-example-of-password-pattern/</id>
    <published>2021-01-05T11:23:04.000Z</published>
    <updated>2021-03-01T03:50:28.905Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究密码模式，深入理解其中的各个流程。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>密码模式是用户把用户密码直接告诉客户端（第三方应用），客户端使用这些信息向授权服务器申请令牌。这就需要用户对客户端高度信任，如客户端和服务提供商是同一家公司。它涉及到资源所有者、客户端（第三方应用）、授权服务器和资源服务器这四个角色。由于用户就是笔者，因此无需提供项目实例，而其他三者这里就提供各自的项目实例，各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>password</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>password</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将<strong>父工程<code>password</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;password&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;password&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0密码模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception {</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy").password(new BCryptPasswordEncoder().encode("1234")).roles("admin")</span><br><span class="line">                .and()</span><br><span class="line">                .withUser("hello").password(new BCryptPasswordEncoder().encode("1234")).roles("user");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().formLogin()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时此处提供了一个<code>authenticationManagerBean()</code>方法，该方法用于返回一个<code>AuthenticationManager</code>对象，因为使用了密码模式就要求用户输入密码，那么就需要对密码进行验证。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@EnableAuthorizationServer</span><br><span class="line">@Configuration</span><br><span class="line">public class AuthorizationServerConfig  extends AuthorizationServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {</span><br><span class="line">        security.checkTokenAccess("permitAll()")</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient("envythink").secret(new BCryptPasswordEncoder().encode("1234"))</span><br><span class="line">                .resourceIds("res1").authorizedGrantTypes("password","refresh_token")</span><br><span class="line">                .scopes("all").redirectUris("http://127.0.0.1:8082/index.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {</span><br><span class="line">        endpoints.authenticationManager(authenticationManager).tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>password</code>，表示使用密码模式。</strong><br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。<strong>首先注入之前在<code>SecurityConfig</code>类中定义的<code>AuthenticationManager</code>实例对象，接着去掉之前在授权码模式中添加的<code>AuthorizationCodeServices</code>配置，采用刚刚注入的<code>AuthenticationManager</code>实例对象。先调用<code>authenticationManager()</code>方法将注入的<code>AuthenticationManager</code>实例对象设置进去。</strong>接着调用<code>tokenServices()</code>方法，来配置token的存储位置。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>password</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>password</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices(){</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">        services.setClientId("envythink");</span><br><span class="line">        services.setClientSecret("1234");</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("admin/hello")</span><br><span class="line">    public String admin(){</span><br><span class="line">        return "admin";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>password</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下两个依赖：Web和Thymeleaf依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>password</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>login.html</code>文件，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style="text-align: center"&gt;</span><br><span class="line">    &lt;h1&gt;你好余思！&lt;/h1&gt;</span><br><span class="line">    &lt;form action="/login" method="post"&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;用户名：&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type="text" name="username"&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;密码：&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type="password" name="password"&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;button type="submit" value="登录"&gt;登录&lt;/button&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;h1 th:text="${msg}"&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处定义了一个登陆页面，内容非常简单，因此就不过多介绍。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/index.html")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "login";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @PostMapping("/login")</span><br><span class="line">    public String login(String username, String password, Model model){</span><br><span class="line">        MultiValueMap&lt;String,String&gt; map =new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add("username",username);</span><br><span class="line">        map.add("password",password);</span><br><span class="line">        map.add("client_secret","1234");</span><br><span class="line">        map.add("client_id","envythink");</span><br><span class="line">        map.add("grant_type","password");</span><br><span class="line">        Map&lt;String,String&gt; respMap= restTemplate.postForObject("http://127.0.0.1:8080/oauth/token",map, Map.class);</span><br><span class="line">        String access_token = respMap.get("access_token");</span><br><span class="line">        System.out.println(access_token);</span><br><span class="line"></span><br><span class="line">        HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">        httpHeaders.add("Authorization","Bearer"+access_token);</span><br><span class="line">        HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(httpHeaders);</span><br><span class="line">        ResponseEntity&lt;String&gt; entity = restTemplate.exchange("http://127.0.0.1:8081/admin/hello", HttpMethod.GET,httpEntity,String.class);</span><br><span class="line">        model.addAttribute("msg",entity.getBody());</span><br><span class="line">        return "login";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们在此处的HelloController类中先定义了一个hello方法，该方法用于访问<code>/login.html</code>接口。接着定义了一个login方法，该方法用于处理<code>/login</code>接口，也就是之前提交表单之后的逻辑。也就是先获取用户提交的信息，然后通过使用restTemplate对象来发送一个POST请求，请注意在此POST请求中的<code>grant_type</code>参数的值为password，表示此为密码模式。通过这个POST请求，我们可以获取授权服务器返回的<code>access_token</code>信息，就像下面这样的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{access_token=2c54bdde-0f8b-4af0-98f2-39d381972fcd,token_type=bearer,refresh_token=9r82beif-9e6h-5y8i-93f6-93gy77uiw59d,expires_in=7199,scope=all}</span><br></pre></td></tr></tbody></table></figure></div><p>之后我们就提取出<code>access_token</code>信息，并再次使用restTemplate对象来发送一个GET请求去访问资源服务器，并将获取到的数据放在model中进行返回。<br><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></tbody></table></figure></div><p>请注意，如果在上面提示缺少一个<code>RestTemplate</code>对象，那么就需要开发者自行提供一个Bean方法用于返回一个<code>RestTemplate</code>实例。以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来打开浏览器，访问<code>http://127.0.0.1:8082/index.html</code>链接，此时页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c0d21b4be6cf5b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c0d21b4be6cf5b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>然后用户输入在授权服务器中配置的用户信息，之后点击登录按钮进行登录，登录成功后的页面如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6043832eea1d876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f6043832eea1d876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到其下方多出了一个admin字段，这其实就是<code>/admin/hello</code>接口提供的信息。这样就说明我们的密码模式实例就配置成功了。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的简化模式实例</title>
    <link href="http://envyzhan.asia/2021/01/03/oauth2-4-a-complete-example-of-simple-pattern/"/>
    <id>http://envyzhan.asia/2021/01/03/oauth2-4-a-complete-example-of-simple-pattern/</id>
    <published>2021-01-03T11:23:04.000Z</published>
    <updated>2021-03-01T03:47:38.241Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们搭建了一个完整的授权码模式实例，接下来就尝试搭建另一个完整的模式实例—简化模式。考虑到后续学习的方便性，这里选择从零开始搭建，而非在此前授权码模式的基础上进行修改，这样能更加直观感受到简化模式和授权码模式的区别。注意所有加粗的地方均表示简化模式与授权码模式的区别，也就是不同之处。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>简化模式又称为隐藏式模式，当某些Web应用是纯前端应用没有后端时，就可以使用简化模式。简化模式允许授权服务器直接向前端颁发令牌，这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。它的特点就是通过客户端的服务器与授权服务器进行交互，涉及到资源所有者（用户）、客户端（第三方应用）、授权服务器和资源服务器这四个角色。由于用户就是笔者，因此无需提供项目实例，而其他三者这里就提供各自的项目实例，各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>implicit</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>implicit</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将<strong>父工程<code>implicit</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;implicit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;implicit&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0简化模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy").password(new BCryptPasswordEncoder().encode("1234")).roles("admin")</span><br><span class="line">                .and()</span><br><span class="line">                .withUser("hello").password(new BCryptPasswordEncoder().encode("1234")).roles("user");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时对其他页面访问我们没有进行权限控制。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {</span><br><span class="line">        security.checkTokenAccess("permitAll()")</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient("envythink").secret(new BCryptPasswordEncoder().encode("1234"))</span><br><span class="line">                .resourceIds("res1").authorizedGrantTypes("refresh_token","implicit")</span><br><span class="line">                .scopes("all").redirectUris("http://127.0.0.1:8082/index.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices(){</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>implicit</code>。</strong></p><p>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>由于简化模式不存在服务端，因此我们只能通过使用js来请求资源服务器上的数据，故资源服务器需要支持跨域。</p><p><strong>第一步</strong>，在<code>implicit</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>implicit</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。回到子模块<code>user-server</code>中，在其项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@CrossOrigin(value = "*")</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("admin/hello")</span><br><span class="line">    public String admin(){</span><br><span class="line">        return "admin";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>可以看到此处在<code>HelloController</code>类上添加了<code>@CrossOrigin(value = "*")</code>注解，表示在Spring Boot中对访问该类下所有接口都允许跨域，注意允许任何域访问。</strong><br><strong>第四步</strong>，其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices(){</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">        services.setClientId("envythink");</span><br><span class="line">        services.setClientSecret("1234");</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().cors();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<strong>同时添加了<code>.cors()</code>选项用于开始Spring Security对于跨域的支持。（此处的SpringSecurity跨域配置是在Spring Boot支持跨域的基础上进行的。）</strong><br><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p>前面也说了由于简化模式不存在服务端，因此第三方应用就只能通过使用js来请求资源服务器上的数据。</p><p><strong>第一步</strong>，在<code>implicit</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择Web依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>implicit</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/static</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;script src="/jquery-3.5.0.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 简化模式实例&lt;/h1&gt;</span><br><span class="line">&lt;a href="http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=token&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html"&gt;第三方登录(简化模式)&lt;/a&gt;</span><br><span class="line">&lt;div id="app"&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var hash = window.location.hash;//提取出参数，类似这种格式#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582&amp;token_type=bearer&amp;expires_in=7199</span><br><span class="line">    if(hash &amp;&amp; hash.length&gt;0){</span><br><span class="line">        var params = hash.substring(1).split("&amp;");//#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582</span><br><span class="line">        var token = params[0].split("=");//[access_token,b1740984-3d4a-4b64-8509-9891a4d6a582]</span><br><span class="line">        $.ajax({</span><br><span class="line">            type: 'get',</span><br><span class="line">            headers: {</span><br><span class="line">                'Authorization': 'Bearer'+ token[1]</span><br><span class="line">            },</span><br><span class="line">            url: 'http://127.0.0.1:8081/admin/hello',</span><br><span class="line">            success: function (msg){</span><br><span class="line">                $("#app").html(msg)</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>请注意<code>resources/static</code>目录下的文件是不需要经过控制器就能访问的。接下来解释该页面代码的含义：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为token，表示响应一个令牌。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scope</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个id为app的标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以通过ajax拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在id为app的标签中显示出来。</p><p>也就是说当用户登录成功后，会自动重定向到<code>http://127.0.0.1:8082/index.html</code>页面，并在该链接中添加一个锚点参数，类似于如下所示的URL：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8082/index.html#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582&amp;token_type=bearer&amp;expires_in=7199</span><br></pre></td></tr></tbody></table></figure></div><p>因此我们需要使用js来提取出<code>#</code>后面的参数，并进一步解析出<code>access_token</code>参数的值。之后我们将<code>access_token</code>参数放在请求头中，并发起一个ajax请求，并将获取到的数据在id为app的标签中显示出来。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来打开浏览器，访问<code>http://127.0.0.1:8082/index.html</code>链接，此时页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-1a0bece75b048efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-1a0bece75b048efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接着点击第三方登录这一超链接，之后页面会跳转到授权服务器的默认登录页面：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-666a83f8434afd40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-666a83f8434afd40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>然后用户输入在授权服务器中配置的用户信息，之后点击登录按钮进行登录，登录成功后的页面如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-aa58d40fe2c976b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-aa58d40fe2c976b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>在上述页面中出现了一个提示，询问是否授权“envythink”这一用户去访问被保护的资源。我们点击Approve也就是批准，之后点击下方的Authorize按钮，此时页面就会自动跳转到第三方页面中：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-9413bd760e69932c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-9413bd760e69932c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>注意看，可以发现此时的地址栏中多了锚点参数，里面包含了<code>access_token</code>，之后就携带这个<code>access_token</code>参数向资源服务器发起ajax请求来获取<code>/admin/hello</code>接口的信息，页面就会显示出一个admin信息。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们搭建了一个完整的授权码模式实例，接下来就尝试搭建另一个完整的模式实</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的授权码模式实例</title>
    <link href="http://envyzhan.asia/2021/01/02/oauth2-3-a-complete-example-of-authorization-code-pattern/"/>
    <id>http://envyzhan.asia/2021/01/02/oauth2-3-a-complete-example-of-authorization-code-pattern/</id>
    <published>2021-01-02T08:23:04.000Z</published>
    <updated>2021-03-01T03:47:08.120Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究授权码模式，深入理解其中的各个流程。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>授权码模式是功能最完整、流程最严谨的授权模式。它的特点就是通过客户端的服务器与授权服务器进行交互，涉及到资源所有者（用户）、客户端（第三方应用）、授权服务器和资源服务器这四个角色。由于用户就是笔者，因此无需提供项目实例，而其他三者这里就提供各自的项目实例，各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>authorization-code</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>authorization-code</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第一步</strong>，将<strong>父工程<code>authorization-code</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"</span><br><span class="line">         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;authorizationcode&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;authorization-code&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0授权码模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser("envy").password(new BCryptPasswordEncoder().encode("1234")).roles("admin")</span><br><span class="line">                .and()</span><br><span class="line">                .withUser("hello").password(new BCryptPasswordEncoder().encode("1234")).roles("user");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().formLogin()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。</p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore(){</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@EnableAuthorizationServer</span><br><span class="line">@Configuration</span><br><span class="line">public class AuthorizationServerConfig  extends AuthorizationServerConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices(){</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {</span><br><span class="line">        security.checkTokenAccess("permitAll()")</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient("envythink").secret(new BCryptPasswordEncoder().encode("1234"))</span><br><span class="line">                .resourceIds("res1").authorizedGrantTypes("authorization_code","refresh_token")</span><br><span class="line">                .scopes("all").redirectUris("http://127.0.0.1:8082/index.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices(){</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。你可能会有疑问，在前面学习四种授权模式的时候，这四种并不包括<code>refresh_token</code>这种类型，的确，但是在实际开发过程中，我们都将其看做是其中的一种。<br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>authorization-code</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>authorization-code</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices(){</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl("http://127.0.0.1:8080/oauth/check_token");</span><br><span class="line">        services.setClientId("envythink");</span><br><span class="line">        services.setClientSecret("1234");</span><br><span class="line">        return services;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {</span><br><span class="line">        resources.resourceId("res1").tokenServices(tokenServices());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers("/admin/**").hasRole("admin")</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("admin/hello")</span><br><span class="line">    public String admin(){</span><br><span class="line">        return "admin";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>authorization-code</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下两个依赖：Web和Thymeleaf依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第二步</strong>，在父工程<code>authorization-code</code>项目的pom.xml依赖文件中新增如下所示配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 授权码模式实例&lt;/h1&gt;</span><br><span class="line">&lt;a href="http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html"&gt;第三方登录&lt;/a&gt;</span><br><span class="line">&lt;h1 th:text="${msg}"&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>该页面的意思是点击超链接，就可以实现第三方登录，超链接中的参数如下所示：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为code，表示响应一个授权码。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scop</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个h1标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在h1标签中显示出来。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/index.html")</span><br><span class="line">    public String hello(String code, Model model){</span><br><span class="line">        if(code!=null){</span><br><span class="line">            MultiValueMap&lt;String,String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add("code",code);</span><br><span class="line">            map.add("client_id", "envythink");</span><br><span class="line">            map.add("client_secret","1234");</span><br><span class="line">            map.add("redirect_uri","http://127.0.0.1:8082/index.html");</span><br><span class="line">            map.add("grant_type","authorization_code");</span><br><span class="line">            Map&lt;String,String&gt; respMap= restTemplate.postForObject("http://127.0.0.1:8080/oauth/token",map, Map.class);</span><br><span class="line">            String access_token = respMap.get("access_token");</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line"></span><br><span class="line">            HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">            httpHeaders.add("Authorization","Bearer"+access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(httpHeaders);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange("http://127.0.0.1:8081/admin/hello", HttpMethod.GET,httpEntity,String.class);</span><br><span class="line">            model.addAttribute("msg",entity.getBody());</span><br><span class="line">        }</span><br><span class="line">        return "index";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我们在此处的HelloController类中定义了一个hello方法，该方法用于访问<code>/index.html</code>接口。首先判断code是否为空，不为空则说明是通过授权服务器重定向到这个地址，那么接下来我们做如下两个操作：<br>（1）根据拿到的<code>authorization_code</code>去请求<code>http://127.0.0.1:8080/oauth/token</code>地址，进而获取到Token，返回的数据如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "access_token": "562hjse9-7297-ni0j-n8j9-980nbuo94jh3",</span><br><span class="line">    "token_type": "bearer",</span><br><span class="line">    "refresh_token": "9biw85jt-2805-be9t-xt8i-oby038h9m7e8",</span><br><span class="line">    "expires_in": 3792,</span><br><span class="line">    "scop": "all"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其中的<code>access_token</code>就是我们向资源服务器请求数据时所需要的令牌；<code>refresh_token</code>则是后期我们刷新token所需要的令牌；<code>expires_in</code>表示token剩余的有效期时间。<br>（2）拿着获取到的<code>access_token</code>令牌，去资源服务器请求资源，注意<code>access_token</code>是通过请求头来传递的，最后将从资源服务器中获取到的数据返回到Model中进行展示。<br><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></tbody></table></figure></div><p>请注意，如果在上面提示缺少一个<code>RestTemplate</code>对象，那么就需要开发者自行提供一个Bean方法用于返回一个<code>RestTemplate</code>实例。以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来打开浏览器，访问<code>http://127.0.0.1:8082/index.html</code>链接，此时页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-843921ad4f92f2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-843921ad4f92f2f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接着点击第三方登录这一超链接，之后页面会跳转到授权服务器的默认登录页面：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-666a83f8434afd40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-666a83f8434afd40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>然后用户输入在授权服务器中配置的用户信息，之后点击登录按钮进行登录，登录成功后的页面如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-7cee9d006c85177b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-7cee9d006c85177b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>在上述页面中出现了一个提示，询问是否授权“envythink”这一用户去访问被保护的资源。我们点击Approve也就是批准，之后点击下方的Authorize按钮，此时页面就会自动跳转到第三方页面中：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-5f048661d693af7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-5f048661d693af7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>注意看，可以发现此时的地址栏中多了一个code参数，这个code参数就是授权服务器给的授权码，之后拿着这个授权码就可以去请求<code>access_token</code>，授权码使用一次就会失效。同时页面显示出一个admin信息，这个就是从资源服务器上获取到的<code>/admin/hello</code>接口的信息。</p><p>当然由于我们在授权服务器中配置了两个用户，因此当大家使用hello/1234这个用户去登录时，该用户不具备admin角色，因此无法获取到<code>/admin/hello</code>接口的信息，此时页面还会抛出如下所示错误：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-2e57f9e3b1eb734b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-2e57f9e3b1eb734b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>这样就说明我们的授权码模式实例就配置成功了。</p><h1 id="刷新token"><a href="#刷新token" class="headerlink" title="刷新token"></a>刷新token</h1><p>接下来学习四种模式均具有的刷新token功能，这里笔者以授权码模式为例进行学习。</p><p>当开发者启动授权码模式下的授权服务器时，可以看到在Endpoints一栏中出现了很多接口，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-d94b091bd93523a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-d94b091bd93523a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>前面一些actuator都是对于项目的健康监测接口，而后面一些oauth接口才是我们需要注意的地方。下面通过一张表格来对oauth相关的接口进行介绍：</p><table><thead><tr><th align="center">接口(Endpoints)</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>/oauth/authorize</code></td><td align="center">授权的接口</td></tr><tr><td align="center"><code>/oauth/token</code></td><td align="center">用于获取令牌的接口</td></tr><tr><td align="center"><code>/oauth/confirm_access</code></td><td align="center">用户确认授权提交的接口(也就是<code>auth-server</code>询问用户是否授权哪个页面的提交地址)</td></tr><tr><td align="center"><code>/oauth/error</code></td><td align="center">授权出错的接口</td></tr><tr><td align="center"><code>/oauth/check_token</code></td><td align="center">校验<code>access_token</code>的接口</td></tr><tr><td align="center"><code>/oauth/token_key</code></td><td align="center">提供公钥的接口</td></tr></tbody></table><p>需要注意的是，这里的<code>/oauth/token</code>接口除了用于获取令牌之外，还可以用来刷新令牌。在用户获取令牌的时候，除了用到<code>access_token</code>之外，还有一个<code>refresh_token</code>字段，该字段用于刷新令牌。也就是说在刷新令牌的时候，必须携带上<code>refresh_token</code>字段，当令牌刷新完成之后，之前使用过的<code>access_token</code>令牌就会失效。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0四种授权模式</title>
    <link href="http://envyzhan.asia/2021/01/01/oauth2-2-four-authorization-pattern/"/>
    <id>http://envyzhan.asia/2021/01/01/oauth2-2-four-authorization-pattern/</id>
    <published>2021-01-01T11:23:04.000Z</published>
    <updated>2021-03-01T03:45:43.376Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在《OAuth2.0的一个简单解释》一文中，我们对OAuth2.0的含义和设计思想有了一个较为清晰的认识，那么接下来就学习OAuth2.0中的四种授权模式。</p><h1 id="OAuth2角色"><a href="#OAuth2角色" class="headerlink" title="OAuth2角色"></a>OAuth2角色</h1><p>在学习授权模式之前，了解OAuth2中的4种基本角色对于学习和理解OAuth的工作原理有重要意义。<br>（1）资源所有者：资源所有者即用户，具有头像、照片、视频等资源；<br>（2）客户端：客户端即第三方应用，如前一篇中提到的知乎；<br>（3）授权服务器：授权服务器用来验证用户提供的信息是否正确，并返回一个令牌给第三方应用；<br>（4）资源服务器：资源服务器是提供给用户资源的服务器，如头像、照片、视频等资源。</p><p>通常来说，授权服务器和资源服务器可以是同一台服务器。</p><h1 id="OAuth2授权流程"><a href="#OAuth2授权流程" class="headerlink" title="OAuth2授权流程"></a>OAuth2授权流程</h1><p>在熟悉了OAuth2中的4个基本角色以后，接下来开始学习OAuth2的授权流程，具体的流程如下：<br>（1）客户端（第三方应用）向用户请求授权；<br>（2）用户单击客户端所呈现的服务授权页面上的同意授权按钮后，服务端返回一个授权许可凭证给客户端；<br>（3）客户端拿着授权许可凭证去授权服务器申请令牌；<br>（4）授权服务器验证信息无误后，发放令牌给客户端；<br>（5）客户端拿着令牌去资源服务器访问资源；<br>（6）资源服务器验证令牌无误后开放资源访问。</p><p>上述是一个大致的流程，因为OAuth2有4种不同的授权模式，每种授权模式的授权流程又存在一定的差异，不过大致流程如下图所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-50ff005daf3354a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-50ff005daf3354a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><h1 id="OAuth2授权模式"><a href="#OAuth2授权模式" class="headerlink" title="OAuth2授权模式"></a>OAuth2授权模式</h1><p>OAuth2.0的标准是<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>&nbsp;文件。该文件首先解释 OAuth 是什么：</p><blockquote><p>OAuth引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p></blockquote><p>也就是说OAuth的核心是向第三方应用颁发令牌。之后RFC 6749接着写道：</p><blockquote><p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。<br>从RFC 6749中可以知道OAuth 2.0规定了四种获得令牌的流程。开发者可以根据自己的实际情况来选择最适合的一种，进而向第三方应用颁发令牌。</p></blockquote><p>OAuth2.0支持下面四种授权方式：授权码模式、简化模式、密码模式和客户端模式。<br>（1）<strong>授权码模式</strong>：授权码模式(authorization code)是功能最完整、流程最严谨的授权模式。它的特点就是通过客户端的服务器与授权服务器进行交互，国内常见的第三方平台登录功能基本上都是使用这种模式。</p><p>（2）<strong>简化模式</strong>：简化模式不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌，一般若网站是纯静态页面，则可以采用这种方式。</p><p>（3）<strong>密码模式</strong>：密码模式是用户把用户密码直接告诉客户端，客户端使用这些信息向授权服务器申请令牌。这就需要用户对客户端高度信任，如客户端和服务提供商是同一家公司。</p><p>（4）<strong>客户端模式</strong>：客户端模式是指客户端使用自己的名义而不是用户的名义向服务器提供者申请授权。严格来说，客户端模式并不能算作OAuth协议要解决的问题的一种解决方案，但是对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是较为方便的。</p><p>请注意，不管哪一种授权模式，第三方应用在申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>授权码（authorization code）模式，指的是第三方应用先申请一个授权码，然后再用该码来获取令牌。这种方式是最常用的流程，安全性也最高，它适用于那些有后端的Web应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>在授权码模式中，分为授权服务器和资源服务器，授权服务器用来派发Token，拿着Token就可以去资源服务器获取资源，资源服务器和授权服务器可以分开，也可以合并，通常都是合并。</p><p>笔者之前开发过微信支付，里面涉及到的微信授权使用的就是授权码模式，因此这里以个人博客接入微信授权为例进行介绍。（微信授权就是微信登录）</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-bdb6a72d7438016d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-bdb6a72d7438016d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>第一步，笔者在个人博客的登录页面放上一个微信登录选项(其实是一个超链接)，此时博客就相当于第三方应用。之后用户A（笔者博客的用户）点击这个超链接就会去请求授权服务器（其实是微信授权服务器）。用户A点击的过程其实就是博客向用户A要授权的过程。即上图1步。</p><p>第二步，用户A点击了超链接之后，向授权服务器发送请求，笔者博客上让用户点击的超链接可能URL如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appId=envythink&amp;response_type=code&amp;scope=snsapi_base&amp;redirect_uri=http://envythink.com#wechat_redirect</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个URL中有一些参数，这些都是我们后续会使用到的参数。这里简单说一下这些参数，appId表示应用id，这个是从微信开放平台申请得到的。其实从这里也就能看出授权服务器在进行校验的时候，一是校验应用的Id，二是检验用户身份。response_type表示授权类型，使用授权码模式时值为code，后续会拿着这个code来换取网页授权access_token。scope表示应用授权作用域，也就是笔者博客拿着用户的token能获取用户的什么信息，一般都是一些非敏感的基本信息。redirect_uri表示用户登录成功或者失败后跳转的地址，请注意在跳转的时候会携带授权码code。即上图2、3步。</p><p>第三步，笔者博客网站拿着第二步中获取到的授权码code及其他信息去微信授权服务器请求令牌，微信授权服务器在校验这些数据之后，会发送一个令牌回来，也就是access_token：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "access_token":"ACCESS_TOKEN",</span><br><span class="line">  "expires_in":7200,</span><br><span class="line">  "refresh_token":"REFRESH_TOKEN",</span><br><span class="line">  "openid":"OPENID",</span><br><span class="line">  "scope":"SCOPE" </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>请注意微信的授权服务器校验数据的过程是在后端完成的，不是使用js来完成的。即上图4、5步。</p><p>第四步，拿着第三步获取到的令牌access_token就可以去请求用户信息。即上图6步。如果觉得笔者介绍的不够详细，可以参看 <a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">阮一峰博客</a>。</p><p>通常我们都认为授权码模式是4种模式中最安全的一种模式，因为此种模式下的<code>access_token</code>不经过浏览器或者移动端，而是直接从后台发送到授权服务器上，这在一定程度上减少了<code>access_token</code>泄露的风险。</p><h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>简化模式又称为隐藏式模式，当某些Web应用是纯前端应用没有后端时，就可以使用简化模式。简化模式允许授权服务器直接向前端颁发令牌，这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-69452fe419134a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-69452fe419134a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>第一步，笔者在个人博客的登录页面放上一个微信登录的超链接，该超链接可能URL如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appId=envythink&amp;response_type=token&amp;scope=snsapi_base&amp;redirect_uri=http://envythink.com#wechat_redirect</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到上述URL中的参数和授权码模式非常相似，不同的是response_type参数的值变成了token，它表示授权服务器直接返回令牌access_token。</p><p>第二步，用户点击第一步中的超链接，页面跳转到微信登录页面，之后用户进行登录。即上图1、2步。</p><p>第三步，用户登录成功后，页面会自动重定向到redirect_uri参数所指定的URL，同时携带令牌access_token，这样用户在前端就能获取到令牌access_token。请注意，令牌的位置是URL锚点（fragment），而不是查询字符串（querystring），那是因为OAuth 2.0允许跳转网址是HTTP协议，因此就可能存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，这样就减少了令牌泄漏的风险。即上图3步。</p><p>第四步，拿着第三步获取到的令牌access_token就可以去请求用户信息。即上图4步。</p><p>很明显这种方式是很不安全的，它直接将令牌传给前端，因此只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉后令牌就失效。</p><h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>如果用户高度信任某个应用，RFC6749也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p><p>密码模式在SpringCloud项目中应用非常广泛，尤其是服务之间的调用，使用密码模式进行鉴权是非常合适的，这一点笔者在SpringCloud那部分进行了介绍，这里就不赘述了。</p><p>密码模式有一个前提就是用户高度信任第三方应用，因此如果笔者在个人博客中接入了微信登录并且采用了密码模式，那么就需要用户在笔者博客中输入微信用户名和密码，这肯定是不合适的，因此说密码模式要求用户高度信任第三方应用。</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-bc947f66b45b96e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-bc947f66b45b96e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>第一步，笔者在个人博客的登录页面放上一个微信登录的超链接，用户点击该链接就会跳转到一个登陆页面，之后用户输入用户名和密码，并点击登录。</p><p>第二步，当用户点击第一步中的登录按钮后，笔者博客会使用类似下面的URL来发送一个post请求：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?response_type=password&amp;client_id=envythink&amp;username=envythink&amp;password=1234</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到上述URL中的参数和授权码模式差别较大，<code>response_type</code>参数的值变成了password，表示密码，注意这里没有重定向的<code>redirect_uri</code>，因此此处不需要重定向。即上图1步。</p><p>第三步，微信服务器会校验用户名和密码，校验成功后会在HTTP响应中直接将<code>access_token</code>返回给客户端。即上图2步。</p><p>第四步，拿着第三步获取到的令牌<code>access_token</code>就可以去请求用户信息。即上图3步。</p><p>可以看到此种方式需要用户给出自己的用户名/密码，因此风险较大，只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>客户端模式又称为凭证式模式，当某些应用是纯后端应用没有前端时，就可以使用客户端模式，即在命令行下请求令牌：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a2cede0004ac1e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a2cede0004ac1e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>第一步，客户端会使用类似下面的URL来发送一个get请求：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.open.weixin.qq.com/connect/oauth2/authorize?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到上述URL中的参数和授权码模式差别较大，参数变为了<code>grant_type</code>，值为<code>client_credential</code>，它用于获取<code>access_token</code>。<code>client_id</code>和<code>client_secret</code>这两个参数用来确认客户端的身份。即上图1步。</p><p>第二步，微信服务器会校验客户端信息，校验成功后会在HTTP响应中直接将<code>access_token</code>返回给客户端。即上图2步。</p><p>第三步，拿着第二步获取到的令牌<code>access_token</code>就可以去请求用户信息。即上图3步。</p><p>可以很明显的发现在此过程中并不涉及到用户，那是因为客户端模式给出的令牌是针对第三方应用的，而不是针对用户，也就是说会存在多个用户共享同一个令牌的情况。</p><h1 id="令牌使用"><a href="#令牌使用" class="headerlink" title="令牌使用"></a>令牌使用</h1><p>笔者个人博客网站在拿到令牌以后，就可以向微信服务器的API请求用户基本信息数据了。请注意此时，每个发到API的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Authorization: Bearer ACCESS_TOKEN" \</span><br><span class="line">"https://api.b.com"</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到在上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h1 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h1><p>我们知道令牌是存在有效期的，如果令牌过了有效期，需要用户重新走一遍上述流程来申请一个新的令牌，这势必会大大降低用户的体验感，因此OAuth2.0在设计的时候就考虑到允许用户自动更新令牌。</p><p>具体做法是：微信服务器颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（也就是<code>refresh_token</code>字段）。在令牌到期之前，用户可以使用<code>refresh_token</code>去发一个请求，进而更新令牌。类似的请求如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://open.weixin.qq.com/oauth/token?</span><br><span class="line">grant_type=refresh_token&amp;</span><br><span class="line">client_id=CLIENT_ID&amp;</span><br><span class="line">client_secret=CLIENT_SECRET&amp;</span><br><span class="line">refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到上面URL中，<code>grant_type</code>参数值为<code>refresh_token</code>，它表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认客户端身份，而<code>refresh_token</code>参数就是用于更新令牌的令牌。当微信服务器验证通过后，就会颁发新的令牌，这样就实现了令牌的自动更新。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在《OAuth2.0的一个简单解释》一文中，我们对OAuth2.0的含义和</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0的一个简单解释</title>
    <link href="http://envyzhan.asia/2021/01/01/oauth2-1-a-simple-explanation/"/>
    <id>http://envyzhan.asia/2021/01/01/oauth2-1-a-simple-explanation/</id>
    <published>2021-01-01T02:23:04.000Z</published>
    <updated>2021-03-01T03:44:11.172Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>乘着年尾还有点时间，打算将今年学到的OAth2相关知识进行总结，一来是便于自己对知识点的汇总，二来是怕自己遗忘，写几篇笔记来进行记录。</p><h1 id="OAth2"><a href="#OAth2" class="headerlink" title="OAth2"></a>OAth2</h1><h3 id="快递员问题"><a href="#快递员问题" class="headerlink" title="快递员问题"></a>快递员问题</h3><p>一开始我也不太明白OAth2这个概念，直到某一天看到阮一峰写的OAth2博客，才对OAth2有了一个更为清晰的理解和认识。他通过一个快递员问题，从身边的事物入手，来理解OAth2的概念。</p><p>假设笔者住在一个大型的居民小区，小区有门禁系统，任何人进入的时候需要输入密码。笔者非常喜欢淘货，每天都有快递员来送货，因此笔者必须找到一个办法，让快递员通过门禁系统，进入小区进而给我派件。现在问题来了，如果我把我的密码告诉快递员，那么快递员就拥有了和我一样的权限，这似乎不太合适。还有万一我修改了密码，那我必须告诉所有的快递员，这样它们才能继续进入小区。</p><p>那么问题来了，有没有一种办法可以让快递员既可以自由的进出小区，又无需知道小区居民的用户密码，而且他唯一的权限就是派件，其他需要密码的场合，他都不能进，没有对应的权限。</p><h3 id="授权机制的设计"><a href="#授权机制的设计" class="headerlink" title="授权机制的设计"></a>授权机制的设计</h3><p>针对上述问题，笔者设计了一套授权机制。</p><p><strong>第一步</strong>，在门禁系统的密码输入器下面增加一个按钮，叫做”获取授权”。快递员首先需要按这个按钮，去申请授权。</p><p><strong>第二步</strong>，快递员在按下按钮以后，屋主（也就是笔者）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p><p>笔者确认请求属实，就点击确认按钮告诉门禁系统，笔者同意给予快递员进入小区的授权。</p><p><strong>第三步</strong>，门禁系统得到笔者的确认以后，会向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（如七天）有效。</p><p><strong>第四步</strong>，快递员向门禁系统输入令牌，进入小区。</p><p>这里有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？那是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h3 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h3><p>我们把上面的例子搬到互联网，这就是OAuth的设计思想。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p>简单说，OAuth就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><h3 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h3><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是存在三点差异，如下所示：</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong>&nbsp;这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（<code>authorization grant</code>），即四种颁发令牌的方式，适用于不同的互联网场景。</p><p>以上就是阮一峰大佬对于OAuth2的理解，个人觉得这个理解非常到位，且通俗易懂，非常适合入门理解OAuth2。</p><h1 id="个人理解的OAuth2"><a href="#个人理解的OAuth2" class="headerlink" title="个人理解的OAuth2"></a>个人理解的OAuth2</h1><p>接下来笔者将从自己的理解来谈一谈OAuth2。</p><p>OAuth是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等〉，而在这个过程中无须将用户名和密码提供给第三方应用。</p><p>实现这一功能是通过提供一个令牌(token)，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站在特定的时段内访问特定的资源。这样，OAuth让用户可以授权第三方网站灵活地访问存储在另外一些资源服务器的特定信息，而非所有内容。</p><p>例如，用户想通过QQ登录知乎，此时知乎就是一个第三方应用，知乎要访问用户的一些基本信息就需要得到用户的授权，如果用户把自己的QQ用户名和密码告诉知乎，那么知乎就能访问用户的所有数据，并且只有用户修改密码才能收回授权，这种授权方式安全隐患很大，如果使用OAuth，就能很好地解决这一问题。</p><p>采用令牌的方式可以让用户灵活地对第三方应用授权或者收回权限。</p><p>OAuth2是OAuth协议的下一版本，但不向下兼容OAuth1.0 。OAuth2关注客户端开发者的简易性，同时为Web 应用、桌面应用、移动设备、起居室设备提供专门的认证流程。</p><p>传统的Web开发登录认证一般都是基于Session的，但是在前后端分离的架构中继续使用Session会有许多不便，因为移动端(Android、iOS、微信小程序等)要么不支持Cookie(微信小程序)，要么使用非常不便，对于这些问题，使用OAuth2认证都能解决，因此OAuth2对于解决信息授权与认证有非常大的帮助。</p><p>（完）</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;乘着年尾还有点时间，打算将今年学到的OAth2相关知识进行总结，一来是便于</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>集群环境下SpringSecurity处理Session</title>
    <link href="http://envyzhan.asia/2020/12/28/springsecurity-20-spring-security-procesing-session-in-cluster-environment/"/>
    <id>http://envyzhan.asia/2020/12/28/springsecurity-20-spring-security-procesing-session-in-cluster-environment/</id>
    <published>2020-12-28T11:23:04.000Z</published>
    <updated>2021-03-01T08:13:59.337Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>通过前面《内存保存用户+自动踢掉登录用户》、《传统方式+JPA+自动踢掉登录用户》、《前后端分离+JPA+自动踢掉登录用户》三篇的学习，我们已经对SpringSecurity中如何自动踢掉已登录用户有了较为清晰的认识，不过前面学习的都是基于单体应用，当项目是集群化部署时，上述配置还能使用么？如果不能使用，那么应该采用什么方式呢？带着这些问题我们来进入本篇的学习。</p><p>注意本篇使用的操作系统为Windows，所涉及到的Redis和Nginx均是在Windows上面部署的。</p><h1 id="集群会话方案"><a href="#集群会话方案" class="headerlink" title="集群会话方案"></a>集群会话方案</h1><p>在传统的单体服务架构中，通常只有一台服务器，因此就不存在Session共享问题。但是在分布式或者集群项目中，Session共享是一个必须面对的问题。</p><p>下面是一个简单的集群项目架构图：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-1bf72eddc663accb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-1bf72eddc663accb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>从图中可以知道，当客户端发起一个请求，此时请求到达Nginx上，被Nginx转发到TomcatA上，之后TomcatA往Session中保存了一份数据，之后客户端又发起一次请求，但是这个请求被Nginx转发到TomcatB上，由于TomcatB中不存在之前的Session信息，因此无法从中获取数据。</p><p>这个现象在分布式或者集群项目中非常常见，也是必须面对的问题。通常而言有如下三种方案来解决上述问题，分别是Session共享、Session拷贝（同步）和粘滞会话，下面分别进行学习。</p><h3 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h3><p>对于上述这一类问题，目前比较主流的解决方案就是将各个服务之间需要共享的数据保存在一个公共的服务器上（通常是Redis），示意图如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-3a915c544e1b68eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-3a915c544e1b68eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到，当所有的Tomcat需要往Session中写入数据时，只需都往Redis中写入；而当所有的Tomcat需要读取Session中的数据时，只需从Redis中读取即可。这样不同的服务就可以使用相同的Session数据。</p><p>上述方案可以由开发者来手动实现，即手动往Redis中存储数据和读取数据，可以借助于使用Redis可视化工具或者命令来实现这个功能，但是不太建议开发者手动来实现。</p><p>比较理想的就是使用<code>Spring Session</code>来实现这一功能，<code>Spring Session</code>使用Spring中的代理过滤器，将所有的Session操作拦截下来，自动的将数据同步到Redis中，或者从Redis中读取数据。</p><p>因此，对于开发者来说，使用<code>Spring Session</code>之后，所有关于Session的操作都是透明的，就像操作普通的Session一样来操作分布式或者集群中的Session。</p><h3 id="Session拷贝（同步）"><a href="#Session拷贝（同步）" class="headerlink" title="Session拷贝（同步）"></a>Session拷贝（同步）</h3><p>所谓的Session拷贝，是指不使用Redis，而是直接在各个Tomcat之间进行Session的数据拷贝，毫无疑问这种方式效率低下，且可变性差。当上述三个Tomcat中的任意一个的Session发生变化时，都需要将这些变化拷贝到其他两个，这样会加重开发者的工作量，尤其是当Tomcat的数据非常庞大的时候，这个任务几乎就完不成了，因此Session拷贝这种方式现在几乎都不会使用了。</p><h3 id="粘滞会话"><a href="#粘滞会话" class="headerlink" title="粘滞会话"></a>粘滞会话</h3><p>所谓的粘滞会话，是指将相同IP发来的请求通过Nginx路由到同一个Tomcat上去，这样就不需要进行Session共享和拷贝了。这的确是一种方案，而且Nginx是支持根据IP地址来路由的，但是在一些极端情况下，可能会导致负载失衡。因为大部分情况下，大家都是使用同一个公网IP，因此极易造成负载失衡。</p><p>综合上述三种方案，目前比较流行的方案就是Session共享，接下来就结合实例来学习如何使用Session共享。</p><h1 id="Session共享实例"><a href="#Session共享实例" class="headerlink" title="Session共享实例"></a>Session共享实例</h1><p><strong>第一步</strong>，使用IDEA创建一个名为<code>security-session</code>的SpringBoot工程，并选择如下所示的依赖：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-b522dc87ef35d022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-b522dc87ef35d022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>或者在pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，在application.yml配置文件中新增如下配置，主要是配置Redis和Security信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SpringSecurity配置</span><br><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: envy</span><br><span class="line">      password: 1234</span><br><span class="line">  # Redis配置</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 5000ms</span><br><span class="line">    database: 0</span><br><span class="line">    password: 1234</span><br><span class="line"># SpringBoot属性</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></tbody></table></figure></div><p>此处由于着重学习Spring Session的相关内容，因此用户信息就直接配置在该文件中，同时设置默认端口为8080，在集群部署后，后面可以通过它来知道请求来自哪个SpringBoot应用。<br><strong>第三步</strong>，新建一个controller包，并在里面新建一个HelloController类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @Value("${server.port}")</span><br><span class="line">    private Integer port;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/set")</span><br><span class="line">    public String set(HttpSession session){</span><br><span class="line">        session.setAttribute("user","envy");</span><br><span class="line">        return String.valueOf(port);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("/get")</span><br><span class="line">    public String get(HttpSession session){</span><br><span class="line">        return session.getAttribute("user") +":"+port;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到代码非常简单，这里读取配置文件中<code>server.port</code>的端口信息，之后定义get和set方法来返回信息。</p><p>前面也说了这里以集群方式来启动SpringBoot应用，这样为了后续方便获取每一个请求来自于哪个SpringBoot，可以在每次请求时返回当前服务的端口号，因此笔者在上面使用了<code>server.port</code>。当然开发者也可以使用<code>spring.application.name</code>配置。</p><p>之后启动Redis服务，注意必须以<code>redis-server redis.windows.conf</code>命令来启动，否则无法将配置的密码等属性加载到Redis中，之后保持此窗口一直处于运行状态：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-d8224a094b698db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-d8224a094b698db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接着打包项目，进入到项目生成的target目录，依次使用如下命令来启动两个SpringBoot实例，这里仅仅是以不同端口来加以区分：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start /min java -jar security-session-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">start /min java -jar security-session-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>接着打开浏览器，访问<code>http://localhost:8080/set</code>，向8080这个服务的Session中保存一个变量。其实用户第一次访问时，页面会自动跳转到登录页面，用户输入用户名和密码后完成登录。登录成功后，另开启一个DOS窗口，查看一下此时Redis中的数据：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-27792e67338bbcd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-27792e67338bbcd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后再访问<code>http://localhost:8081/get</code>链接，可可以看到页面就显示了8080服务中session的信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-4ddff134f938a25a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-4ddff134f938a25a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到此时session共享就已经实现了。</p><h3 id="Security配置"><a href="#Security配置" class="headerlink" title="Security配置"></a>Security配置</h3><p>通过前面的配置，我们已经成功实现了Session共享，接下来尝试按照《前后端分离+JPA+自动踢掉登录用户》一文中的配置来对并发管理进行设置。</p><p>新建一个config包，并在里面新建一个<code>SercurityConfig</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage("/login")</span><br><span class="line">                .loginProcessingUrl("/login")</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement().maximumSessions(1)</span><br><span class="line">                .maxSessionsPreventsLogin(true);</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后测试多端登录，你会发现这个配置不起任何作用，也就是说同一用户可以在多个浏览器上同时登录系统。</p><p>那么问题来了，为什么上述的配置会失效呢？这里需要回忆《传统方式+JPA+自动踢掉登录用户》和《前后端分离+JPA+自动踢掉登录用户》这两文中的内容了，我们说过SpringSecurity中与Session存储相关的接口为<code>SessionRegistry</code>，而它只有一个实现类<code>SessionRegistryImpl</code>，用于对会话信息进行统一管理，需要注意的是<code>SessionRegistryImpl</code>是基于内存的维护，而不是Session的维护。此处我们使用<code>Spring Session</code>+Redis实现了Session共享，但是由于<code>SessionRegistryImpl</code>依旧采用的是基于内存维护，因此上述配置就会失效。如果开发者需要实现上述功能，那么就需要将<code>SessionRegistryImpl</code>修改为基于Session共享的维护。</p><p>我们这样想，既然SpringSecurity中与Session存储相关的接口为<code>SessionRegistry</code>，而它只有一个实现类<code>SessionRegistryImpl</code>，同时又是基于内存维护的，如果我们需要基于Session共享，那么最简单最便捷的方式就是提供一个<code>SessionRegistry</code>的实现类，然后在这个实现类中实现基于Session共享的逻辑。</p><p>的确，这种方式扩展性非常好，于是<code>Spring Session</code>为开发者提供了<code>SessionRegistry</code>基于Session共享的实现类<code>SpringSessionBackedSessionRegistry</code>。查看一下该类的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class SpringSessionBackedSessionRegistry&lt;S extends Session&gt; implements SessionRegistry {</span><br><span class="line">    private final FindByIndexNameSessionRepository&lt;S&gt; sessionRepository;</span><br><span class="line"></span><br><span class="line">    public SpringSessionBackedSessionRegistry(FindByIndexNameSessionRepository&lt;S&gt; sessionRepository) {</span><br><span class="line">        Assert.notNull(sessionRepository, "sessionRepository cannot be null");</span><br><span class="line">        this.sessionRepository = sessionRepository;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; getAllPrincipals() {</span><br><span class="line">        throw new UnsupportedOperationException("SpringSessionBackedSessionRegistry does not support retrieving all principals, since Spring Session provides no way to obtain that information");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public List&lt;SessionInformation&gt; getAllSessions(Object principal, boolean includeExpiredSessions) {</span><br><span class="line">        Collection&lt;S&gt; sessions = this.sessionRepository.findByPrincipalName(this.name(principal)).values();</span><br><span class="line">        List&lt;SessionInformation&gt; infos = new ArrayList();</span><br><span class="line">        Iterator var5 = sessions.iterator();</span><br><span class="line"></span><br><span class="line">        while(true) {</span><br><span class="line">            Session session;</span><br><span class="line">            do {</span><br><span class="line">                if (!var5.hasNext()) {</span><br><span class="line">                    return infos;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                session = (Session)var5.next();</span><br><span class="line">            } while(!includeExpiredSessions &amp;&amp; Boolean.TRUE.equals(session.getAttribute(SpringSessionBackedSessionInformation.EXPIRED_ATTR)));</span><br><span class="line"></span><br><span class="line">            infos.add(new SpringSessionBackedSessionInformation(session, this.sessionRepository));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public SessionInformation getSessionInformation(String sessionId) {</span><br><span class="line">        S session = this.sessionRepository.findById(sessionId);</span><br><span class="line">        return session != null ? new SpringSessionBackedSessionInformation(session, this.sessionRepository) : null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void refreshLastRequest(String sessionId) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void registerNewSession(String sessionId, Object principal) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void removeSessionInformation(String sessionId) {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected String name(Object principal) {</span><br><span class="line">        return (new TestingAuthenticationToken(principal, (Object)null)).getName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>通过对<code>SessionRegistryImpl</code>和<code>SpringSessionBackedSessionRegistry</code>这两个类的源码，我们知道基于内存和基于Session的区别是非常明显的，前者是定义ConcurrentMap对象，然后根据对象的方法来进行操作；而后者是通过使用<code>FindByIndexNameSessionRepository</code>接口，通过调用接口的方法来实现操作。</p><p>仿照之前的逻辑，开发者需要提供一个<code>SpringSessionBackedSessionRegistry</code>实例，并且将其配置到sessionManagement中，这样session的并发数据的维护就交由<code>SpringSessionBackedSessionRegistry</code>来负责了，不再是之前的<code>SessionRegistryImpl</code>。</p><p>修改<code>SecurityConfig</code>类中的代码为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private FindByIndexNameSessionRepository sessionRepository;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SpringSessionBackedSessionRegistry sessionRegistry(){</span><br><span class="line">        return new SpringSessionBackedSessionRegistry(sessionRepository);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable()</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .maximumSessions(1)</span><br><span class="line">                .maxSessionsPreventsLogin(true)</span><br><span class="line">                .sessionRegistry(sessionRegistry());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里自动注入了一个<code>private FindByIndexNameSessionRepository sessionRepository;</code>对象，之后将其作为参数传入<code>SpringSessionBackedSessionRegistry</code>实例化对象中。</p><p>之后将项目进行打包，之后重新运行下述命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start /min java -jar security-session-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">start /min java -jar security-session-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></tbody></table></figure></div><p>之后进行多端登录测试，由于我们配置了一个用户同时只能在一个平台上登录，且禁止用户新的登录，因此当用户在Chrome浏览器上登录后，就无法在Edge浏览器上登录，且此时会提示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-28e3c1848f7ea1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-28e3c1848f7ea1a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>到现在我们就实现了集群或者分布式项目的“自动踢掉登录用户”这一功能。</p><p>为了让我们的例子变得更加像集群化部署项目，因此接下来引入Nginx，实现负载均衡。</p><h3 id="引入Nginx"><a href="#引入Nginx" class="headerlink" title="引入Nginx"></a>引入Nginx</h3><p>进入到Nginx安装目录的conf目录下，笔者路径为<code>D:\Nginx\nginx-1.18.0\conf</code>，之后在其目录下新建vhost目录。之后在conf目录下的<code>nginx.conf</code>文件中新增如下配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include vhost/*.conf;</span><br></pre></td></tr></tbody></table></figure></div><p>注意添加的位置：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-bbb1bb48c6b6365a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-bbb1bb48c6b6365a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>通过上述配置，我们就能更好的自定义配置信息，不至于增加主配置文件的大小。</p><p>之后进入vhost目录，在其中新建一个<code>think.com.conf</code>文件，然后在里面添加如下配置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream envy.com {</span><br><span class="line">    server 127.0.0.1:8080 weight=1;</span><br><span class="line">server 127.0.0.1:8081 weight=2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">server {</span><br><span class="line">  listen 8083;</span><br><span class="line">  server_name think.com;</span><br><span class="line"></span><br><span class="line">  location / {</span><br><span class="line">    proxy_pass http://envy.com;</span><br><span class="line">proxy_redirect default;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在上面的例子中，通过使用upstream指令定义了一个名为envy.com的负载均衡器，此处的名称可以随意指定，不一定是一个域名。后面的server表示真实服务器群组，后接真实服务器的IP地址，后面的weight表示服务权重，权重越大则将有更大比例的请求从Nginx上转发到该服务上。</p><p>之后是一个server块，里面的listen表示当前Nginx实例的监听端口为8083，server_name表示Nginx实例名称为<code>think.com</code>，注意这个名称必须与文件名保存一致(conf后缀除外)。location中的proxy_pass表示请求转发的地址，<code>/</code>表示将拦截到的所有请求都转发到之前配置好的服务集群中。proxy_redirect表示设置当发生重定向请求时，Nginx会自动修正响应头数据。默认是Tomcat返回重定向，此时重定向的地址为Tomcat的地址，我们需要将其修改为Nginx的地址。</p><p>配置完后，打开<code>C:\Windows\System32\drivers\etc\hosts</code>文件，在里面新增一条DNS解析记录：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 think.com envy.com</span><br></pre></td></tr></tbody></table></figure></div><p>之后启动Nginx，保持之前启动的两个SpringBoot实例和Redis一直处于运行状态。之后打开Chrome浏览器，访问<code>http://think.com:8083/set</code>链接，之后输入用户信息进行登录，这表示向Session中保存数据，之后该请求到达Nginx上，Nginx再将其转发到上述两个Spring Boot实例中的任意一个。</p><p>如下图，表示端口为8081的SpringBoot实例处理了这个<code>/set</code>接口：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-371885939486ce2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-371885939486ce2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后再次访问<code>/get</code>接口，如下所示，可以看到该接口是被端口号为8080的SpringBoot实例处理了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-8246c23bd16c78bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-8246c23bd16c78bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>本篇对在集群和分布式环境中SpringSecurity处理Session的有关内容进行了较为细致的学习，这样后续在实际工作中会更加轻车熟路。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;通过前面《内存保存用户+自动踢掉登录用户》、《传统方式+JPA+自动踢掉登</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>防御固定会话攻击</title>
    <link href="http://envyzhan.asia/2020/12/26/springsecurity-19-defending-against-fixed-session-attacks/"/>
    <id>http://envyzhan.asia/2020/12/26/springsecurity-19-defending-against-fixed-session-attacks/</id>
    <published>2020-12-26T11:23:04.000Z</published>
    <updated>2021-03-01T08:13:24.500Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面《自动踢掉登录用户》一文中，我们通过使用SpringSecurity中的Session并发控制实现了像QQ一样的功能，即当用户在一台设备上登录成功，之后会自动踢掉另一台设备上的已登录。</p><p>其实SpringSecurity中的Session功能非常强大，本篇要学的就是是什么是会话固定攻击以及SpringSecurity中如何防御会话固定攻击，此时就需要使用到Session。</p><h3 id="项目实例化"><a href="#项目实例化" class="headerlink" title="项目实例化"></a>项目实例化</h3><p><strong>第一步</strong>，使用IDEA创建一个名为<code>fixation-attack</code>的SpringBoot工程，并在其pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，在<code>application.yml</code>配置文件中新增用户信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: envy</span><br><span class="line">      password: 1234</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，新建controller包，并在里面新建一个<code>HelloController</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello,world!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，启动项目进行测试。用户访问<code>/hello</code>接口就会跳转到<code>/login</code>页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示既定的hello,world!信息。</p><h1 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h1><p>在学习会话固定攻击之前，首先来学习什么是<code>HttpSession</code>。<code>HttpSession</code>是一个服务端的概念，服务端生成的<code>HttpSession</code>都会有一个对应的sessionid，之后这个sessionid会通过cookie传递给前端，前端以后发生请求的时候会携带这个sessionid，然后服务端会将该sessionid和服务器的某一个<code>HttpSession</code>对应起来，进而形成会话。</p><p>前面说过关闭浏览器并不会导致服务端的<code>HttpSession</code>失效，如果想让服务端的<code>HttpSession</code>失效，开发者可以通过手动调用<code>HttpSession#invalidate</code>方法，或者等到session过期时间让它自动过期，再有就是重启服务端。</p><p>但还是有人觉得，关闭浏览器之后session也就失效了？原因在于<strong>默认情况下关闭浏览器会导致保存在浏览器中的sessionid丢失</strong>，这样当浏览器重新打开并访问服务端时，服务端会给浏览器重新分配一个sessionid，这个重新分配的sessionid肯定和之前的<code>HttpSession</code>是对应不上的，因此就产生了session失效的错觉。</p><p>前面也着重说明了是在默认情况下，言外之意开发者可以通过手动配置，使得浏览器重启之后的sessionid不丢失，毫无疑问这种配置可能会带来一定的安全隐患，因此不太建议开发者修改默认的配置。</p><p>以之前初始化项目中用户访问<code>/hello</code>接口为例，当服务端生成sessionid之后，返回给前端的响应头如下图所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-ba768083be1ac19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-ba768083be1ac19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到在服务端的响应头中有一个<code>Set-Cookie</code>字段，该字段指示浏览器更新sessionid，同时请注意它还有一个<code>HttpOnly</code>属性，这个表示通过JS脚本时无法获取到Cookie信息的，这样可以有效防止XSS攻击。</p><p>之后当浏览器再去发送请求的时候，就会自觉携带这个jsessionid，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-7467071fd9e4b721.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-7467071fd9e4b721.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>以上就是HttpSession相关的基础内容，接下来开始学习会话固定攻击的相关内容。</p><h1 id="会话固定攻击"><a href="#会话固定攻击" class="headerlink" title="会话固定攻击"></a>会话固定攻击</h1><p>一般来说，只要开发者不关闭浏览器，且服务端的<code>HttpSession</code>也没有过期，那么维系服务端和浏览器的sessionid是不变的，而会话固定攻击(<code>session fixation attack</code>)则是利用这一机制，借助受害者用相同的会话ID来获取认证和授权，然后利用该会话ID来劫持受害者的会话，以此冒充受害者，进而造成会话固定攻击。</p><p>这里以淘宝网站为例，介绍一般的会话固定攻击流程，如下所示：<br>（1）攻击者自己可以正常访问淘宝，在访问过程中，淘宝网给攻击者分配了一个sessionid；<br>（2）攻击者利用自己拿到的sessid来构造一个淘宝网站的链接，并将该链接发送给受害者；<br>（3）受害者使用该链接登录淘宝网，由于该链接中存在sessionid，因此可以成功登录，之后一个合法的会话就成功建立了；<br>（4）攻击者利用手中获取的session来冒充受害者，进而进行登录。</p><p>如果淘宝网还支持URL重写，那么此时攻击将变得更加容易。所谓的URL重写，是指如果用户在浏览器中禁用了Cookie，那么sessionid也无法使用，此时有的服务器就支持将sessionid放在请求地址中，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.taobao.com;jsessionid=xxxxxxxxxx</span><br></pre></td></tr></tbody></table></figure></div><p>因此如果服务端支持类似上述的URL重写，那么对于攻击者来说，按照上面的攻击流程来构造类似的请求地址是非常简单的。但是这种请求地址在SpringSecurity中默认是无法使用的，前面我们说过SpringSecurity默认禁止请求URL地址中包含分号。</p><h1 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h1><p>从上面的会话固定攻击流程中可以看出上述问题的核心在于sessionid是固定不变的，也就是说如果用户在未登录时拿到的是一个sessionid，而登录之后服务端重新给用户分配一个sessionid，这样两个不同的sessionid就能防止固定会话攻击的发生。</p><p>由于本项目在初始化的时候就使用了SpringSecurity，因此开发者无需担心会话固定攻击，因为SpringSecurity默认对此进行了防御。</p><p>那么问题来说，SpringSecurity是如何防御会话固定攻击的呢？其实主要体现在如下三个方面：<br>（1）SpringSecurity的<code>StrictHttpFirewall</code>中的<code>setAllowSemicolon</code>方法默认不允许请求地址中出现分号；<br>（2）在前一篇提到过，响应的Set-Cookie字段中有HttpOnly属性，这种方式避免通过XSS攻击来获取Cookie中的会话信息进而形成会话固定攻击。<br>（3）既然问题的核心是sessionid不发生变化，那么就让sessionid变化一下即可。</p><p>解决办法如下：新建一个config包，并在里面新建一个SecurityConfig类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionFixation().migrateSession();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>注意这个<code>sessionFixation</code>选项有4个值，分别为<code>migrateSession</code>、<code>none</code>、<code>changeSessionId</code>和<code>newSession</code>，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-49b3a907a5c1389b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-49b3a907a5c1389b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>其中<code>migrateSession</code>表示在登录成功之后，创建一个新的会话，并将旧session中的信息复制到新的session中，SpringSecurity中默认使用此种方式。<code>none</code>表示不做任何事，即继续使用旧的session。<code>changeSessionId</code>表示session不会变化，仅仅修改sessionid的值，这其实就使用到了Servlet容器提供的防御会话固定攻击。<code>newSession</code>表示登录后创建一个新的session。</p><p>前面也说了SpringSecurity中默认使用的是<code>migrateSession</code>，也就是说当用户匿名访问的时候使用的是一个sessionid，当用户成功登录之后会使用另一个sessionid，这样就可以有效避免会话固定攻击。</p><p>无论使用何种方案，上述三种均能有效防御会话固定攻击。</p><h1 id="文章小结"><a href="#文章小结" class="headerlink" title="文章小结"></a>文章小结</h1><p>通过本文的学习，我们对SpringSecurity中固定会话攻击有了一个清晰的认识，同时也学会了如何防御固定会话攻击。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面《自动踢掉登录用户》一文中，我们通过使用SpringSecurity</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>自带防火墙学习</title>
    <link href="http://envyzhan.asia/2020/12/24/springsecurity-18-bring-your-own-firewall-to-learn/"/>
    <id>http://envyzhan.asia/2020/12/24/springsecurity-18-bring-your-own-firewall-to-learn/</id>
    <published>2020-12-24T11:23:04.000Z</published>
    <updated>2021-03-01T08:12:44.299Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对SpringSecurity中用户登录相关内容进行了深度学习，接下来开始学习SpringSecurity自带的防火墙，了解和使用防火墙对于提升系统的安全性有重要帮助。</p><h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>在学习SpringSecurity之前，我们对Shiro框架进行了学习，发现它非常轻量，没有这么复杂的功能和配置。同时随着对SpringSecurity框架的深度学习，我们发现它底层其实用的还是Servlet的那套东西？就前面所述的自动踢掉登录用户这一功能来说，开发者完全可以自定义一个Filter来实现请求拦截，而且逻辑和配置非常简单。</p><p>尽管是可以这么操作，但是笔者不建议大家这样操作，因为我们自定义Filter可能仅仅是为了让认证和授权等功能变得简单，但是却忽略了安全等问题，显然安全必须是首要考虑的。</p><p>其实各种各样的Web攻击每天都在发生，可能你感知不到，那是因为有系统在保护着，小到系统本身自带的攻击防御，大到公司的防火墙。如果你自定义了Filter，那么你就需要针对不同的攻击，书写对应的代码来防护，毫无疑问，这就要求开发者不仅对一些常见的Web攻击，如固定会话攻击，CSRF攻击等有较为详细的了解，而且还具备一定的安全防御知识，这势必会增加开发者的学习负担，因此使用SpringSecurity的好处就是开发者既不需要知道这些攻击，又不需要具备防御这些攻击的知识，只需按照既定的配置规则来进行相应的设置即可。</p><h3 id="项目实例化"><a href="#项目实例化" class="headerlink" title="项目实例化"></a>项目实例化</h3><p><strong>第一步</strong>，使用IDEA创建一个名为<code>security-firewall</code>的SpringBoot工程，并在其pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，在<code>application.yml</code>配置文件中新增用户信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: envy</span><br><span class="line">      password: 1234</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，新建controller包，并在里面新建一个<code>HelloController</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello,world!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，启动项目进行测试。用户访问<code>/hello</code>接口就会跳转到<code>/login</code>页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示既定的hello,world!信息。</p><h1 id="HttpFirewall"><a href="#HttpFirewall" class="headerlink" title="HttpFirewall"></a>HttpFirewall</h1><p>SpringSecurity提供了一个<code>HttpFirewall</code>接口用于配置请求防火墙信息，它可以自动处理一些非法请求。查看一下该接口的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface HttpFirewall {</span><br><span class="line">    FirewalledRequest getFirewalledRequest(HttpServletRequest var1) throws RequestRejectedException;</span><br><span class="line"></span><br><span class="line">    HttpServletResponse getFirewalledResponse(HttpServletResponse var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个接口里面包含了两个方法，用于获取通过防火墙的请求和相应信息。接着查看该接口的实现类：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f1461cd02a17b590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f1461cd02a17b590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到它有两个实现类，一个是<code>StrictHttpFirewall</code>表示严格模式的防火墙设置，另一个则是<code>DefaultHttpFirewall</code>表示默认的防火墙设置。从实现类的名字中就能看出<code>StrictHttpFirewall</code>类比<code>DefaultHttpFirewall</code>类限制多一些，自然安全性更高一些。请注意，SpringSecurity中默认使用的实现类是<code>StrictHttpFirewall</code>。</p><h1 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h1><p>接下来学习SpringSecurity中一些常用的防御措施，主要包括：（1）只允许执行白名单中的方法；（2）请求地址中不能包含分号；（3）请求地址必须是标准化的URL；（4）请求地址中不能包含不可打印的ASCII字符；（5）请求地址中不能出现双斜杠；（6）请求地址中不能出现<code>%</code>；（7）请地址中不能包含反斜杠<code>\</code>或者反斜杠编码后的字符，诸如<code>%2F</code>等；（8）请求地址中不能包含<code>.</code>编码后的<code>%2e</code>或者<code>%2E</code>。</p><h3 id="只允许执行白名单中的方法"><a href="#只允许执行白名单中的方法" class="headerlink" title="只允许执行白名单中的方法"></a>只允许执行白名单中的方法</h3><p>对于HTTP请求来说，并不是所有的方法都能被执行，只允许白名单中的方法才可以执行。</p><p>查看一下<code>StrictHttpFirewall</code>类中如下一段源码，就能明白其中的原理：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class StrictHttpFirewall implements HttpFirewall {</span><br><span class="line">  ......</span><br><span class="line">  private Set&lt;String&gt; allowedHttpMethods = createDefaultAllowedHttpMethods();</span><br><span class="line">  private static Set&lt;String&gt; createDefaultAllowedHttpMethods() {</span><br><span class="line">        Set&lt;String&gt; result = new HashSet();</span><br><span class="line">        result.add(HttpMethod.DELETE.name());</span><br><span class="line">        result.add(HttpMethod.GET.name());</span><br><span class="line">        result.add(HttpMethod.HEAD.name());</span><br><span class="line">        result.add(HttpMethod.OPTIONS.name());</span><br><span class="line">        result.add(HttpMethod.PATCH.name());</span><br><span class="line">        result.add(HttpMethod.POST.name());</span><br><span class="line">        result.add(HttpMethod.PUT.name());</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">  private void rejectForbiddenHttpMethod(HttpServletRequest request) {</span><br><span class="line">        if (this.allowedHttpMethods != ALLOW_ANY_HTTP_METHOD) {</span><br><span class="line">            if (!this.allowedHttpMethods.contains(request.getMethod())) {</span><br><span class="line">                throw new RequestRejectedException("The request was rejected because the HTTP method \"" + request.getMethod() + "\" was not included within the whitelist " + this.allowedHttpMethods);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面首先定义了一个集合对象<code>allowedHttpMethods</code> ，里面存放的都是允许的HTTP方法，之后调用<code>createDefaultAllowedHttpMethods()</code>方法来返回上述<code>allowedHttpMethods</code>对象。之后里面还定义了一个<code>rejectForbiddenHttpMethod()</code>方法来判断当前方法是否允许访问。也就是说只有HTTP请求方法是DELETE、GET、HEAD、OPTIONS、PATCH、POST和PUT，即<code>allowedHttpMethods</code>对象中包含的HTTP请求方法才能发生成功，除此之外的其他方法都会抛出<code>RequestRejectedException</code>异常。</p><p>如果开发者想发送其他的HTTP请求方法，如TRACE，那么只需自己提供一个<code>StrictHttpFirewall</code>实例即可。</p><p>新建一个config包，并在该包内新建一个<code>SecurityConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    HttpFirewall httpFirewall(){</span><br><span class="line">        StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">        Set&lt;String&gt; allowedHttpMethods = new HashSet&lt;&gt;();</span><br><span class="line">        allowedHttpMethods.add("TRACE");</span><br><span class="line">        strictHttpFirewall.setAllowedHttpMethods(allowedHttpMethods);</span><br><span class="line">        return strictHttpFirewall;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>通过上述配置，现在SpringSecurity只允许TRACE方法发送请求了。如果开发者想允许所有的HTTP请求方法都发送成功，那么只需将上述代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    HttpFirewall httpFirewall(){</span><br><span class="line">        StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">        strictHttpFirewall.setUnsafeAllowAnyHttpMethod(true);</span><br><span class="line">        return strictHttpFirewall;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到上面我们调用了<code>setUnsafeAllowAnyHttpMethod()</code>方法，该方法表示不对任何的HTTP请求方法进行校验。</p><h3 id="请求地址中不能包含分号"><a href="#请求地址中不能包含分号" class="headerlink" title="请求地址中不能包含分号"></a>请求地址中不能包含分号</h3><p>为了后续演示需要，在<code>HelloController</code>类中新增一个<code>/world</code>接口，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/world")</span><br><span class="line">public String world(@RequestParam("sex") String sex){</span><br><span class="line">    return sex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后启动项目，访问<code>/world?sex=male</code>接口就会跳转到<code>/login</code>页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示male信息。</p><p>假设用户不小心将<code>?</code>号输成了<code>;</code>号，此时页面就会报错，因为SpringSecurity请求地址中是不能包含<code>;</code>号，如果包含了则报错：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-514de4b42576bfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-514de4b42576bfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>那么什么时候请求地址中会包含<code>;</code>号呢？当开发者在使用Shiro框架的时候，如果禁用了Cookie，那么jessionid就会出现在地址栏中，类似于下面的样子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/world;jsessionid=xsaove7963rbfviq1</span><br></pre></td></tr></tbody></table></figure></div><p>很明显这种传递jsessionid的方式是非常不安全的，但是Shiro居然支持这种方式。不过在SpringSecurity中，这种传递参数的方式被禁用了。因此在SpringSecurity中，如果开发者希望地址栏中能出现<code>;</code>，那么就需要通过<code>setAllowSemicolon(true)</code>来进行允许，其中的<code>Semicolon</code>就是指分号。只需将之前httpFirewall方法中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpFirewall httpFirewall(){</span><br><span class="line">    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">    strictHttpFirewall.setAllowSemicolon(true);</span><br><span class="line">    return strictHttpFirewall;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后重新启动项目，访问<code>/world;?sex=male</code>接口就会跳转到<code>/login</code>页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示male信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-95992c3994726083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-95992c3994726083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>需要注意的是，在URL地址栏中<code>;</code>号编码后就成了<code>%3b</code>或者<code>%3B</code>，因此三者只需要填一个即可。</p><p><strong>2020年12月更新以下内容，需要引起格外注意。</strong></p><p>Spring3.2引入了一个<code>@MatrixVariable</code>注解，该注解扩展了请求参数的传递格式，支持参数之间使用<code>;</code>号进行分隔，这个注解引入的真是不友好。SpringSecurity默认禁止了这种传参方式，因此如果开发者想在SpringSecurity中使用<code>@MatrixVariable</code>注解，那么就得在SpringSecurity中添加对应的配置。</p><p>为了后续演示需要，在<code>HelloController</code>类中新增一个<code>/movie</code>接口，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/movie/{id}")</span><br><span class="line">public String movie(@PathVariable Integer id, @MatrixVariable String name){</span><br><span class="line">    return String.format("id is:" +id+", name is:"+name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>光那样还不够，我们还需要在config包内新建一个<code>MyWebMvcConfig</code>类，在里面配置一下，使得<code>;</code>号不被自动移除：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig extends WebMvcConfigurationSupport {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configurePathMatch(PathMatchConfigurer configurer) {</span><br><span class="line">        UrlPathHelper urlPathHelper = new UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(false);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>请注意此时需要确保在SpringSecurity中已经配置了允许URL中存在<code>;</code>号，也就是配置了下面的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    HttpFirewall httpFirewall(){</span><br><span class="line">        StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">        strictHttpFirewall.setAllowSemicolon(true);</span><br><span class="line">        return strictHttpFirewall;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后重启项目，访问<code>/movie/100;name=book</code>接口就会跳转到/login页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-06b534b5ace1e2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-06b534b5ace1e2e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>从返回结果中就能看出此时<code>@MatrixVariable</code>注解就已经生效了。</p><h3 id="请求地址必须是标准化的URL"><a href="#请求地址必须是标准化的URL" class="headerlink" title="请求地址必须是标准化的URL"></a>请求地址必须是标准化的URL</h3><p>什么样的URL才是标准化的URL？对于这个问题，我们需要从四个方面来进行判断。查看一下<code>StrictHttpFirewall#isNormalized</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static boolean isNormalized(HttpServletRequest request) {</span><br><span class="line">      if (!isNormalized(request.getRequestURI())) {</span><br><span class="line">          return false;</span><br><span class="line">      } else if (!isNormalized(request.getContextPath())) {</span><br><span class="line">          return false;</span><br><span class="line">      } else if (!isNormalized(request.getServletPath())) {</span><br><span class="line">          return false;</span><br><span class="line">      } else {</span><br><span class="line">          return isNormalized(request.getPathInfo());</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从上述代码中可以知道，它需要判断URL的四部分内容是否是标准化的，其中<code>request.getRequestURI()</code>方法用于获取请求host之外的字符；<code>request.getContextPath()</code>方法用于获取上下文路径，如果项目名映射为<code>/</code>，那么此处返回空；<code>request.getServletPath()</code>方法用于获取请求的Servlet路径；<code>request.getPathInfo()</code>方法用于获取除去contextPath和servletPath之外的其他内容，判断的依旧就是以上四个方法的返回值中都不能包含<code>./</code>、<code>/../</code>和<code>/.</code>三者中的任意一个。</p><p>以之前访问<code>/movie/100;name=book</code>接口为例，首先修改该接口的方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/movie/{id}")</span><br><span class="line">public String movie(@PathVariable String id, @MatrixVariable String name){</span><br><span class="line">    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">    System.out.println("requestURI is:"+request.getRequestURI());</span><br><span class="line">    System.out.println("contextPath is:"+request.getContextPath());</span><br><span class="line">    System.out.println("servletPath is:"+request.getServletPath());</span><br><span class="line">    System.out.println("pathInfo is:"+request.getPathInfo());</span><br><span class="line">    return String.format("id is:" +id+", name is:"+name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>也就是说完整的URL为<code>http://localhost:8080/movie/100;name=book</code>，接下来依次输出上述四个方法的执行结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requestURI is:/movie/100;name=book</span><br><span class="line">contextPath is:</span><br><span class="line">servletPath is:/movie/100</span><br><span class="line">pathInfo is:null</span><br></pre></td></tr></tbody></table></figure></div><h3 id="请求地址中不能包含不可打印的ASCII字符"><a href="#请求地址中不能包含不可打印的ASCII字符" class="headerlink" title="请求地址中不能包含不可打印的ASCII字符"></a>请求地址中不能包含不可打印的ASCII字符</h3><p>还是那句话，通过阅读源码来进行学习。查看一下<code>StrictHttpFirewall#containsOnlyPrintableAsciiCharacters1</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static boolean containsOnlyPrintableAsciiCharacters(String uri) {</span><br><span class="line">      int length = uri.length();</span><br><span class="line"></span><br><span class="line">      for(int i = 0; i &lt; length; ++i) {</span><br><span class="line">          char c = uri.charAt(i);</span><br><span class="line">          if (c &lt; ' ' || c &gt; '~') {</span><br><span class="line">              return false;</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到当字符小于空格（ASCII值为<code>\u0020</code>），或者大于<code>~</code>（ASCII值为<code>\u007e</code>）时，就是不可打印的ASCII字符，开发者需要尽量进行规避。</p><h3 id="请求地址中不能出现双斜杠"><a href="#请求地址中不能出现双斜杠" class="headerlink" title="请求地址中不能出现双斜杠"></a>请求地址中不能出现双斜杠</h3><p>查看一下<code>StrictHttpFirewall#setAllowUrlEncodedDoubleSlash</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setAllowUrlEncodedDoubleSlash(boolean allowUrlEncodedDoubleSlash) {</span><br><span class="line">      if (allowUrlEncodedDoubleSlash) {</span><br><span class="line">          this.urlBlacklistsRemoveAll(FORBIDDEN_DOUBLE_FORWARDSLASH);</span><br><span class="line">      } else {</span><br><span class="line">          this.urlBlacklistsAddAll(FORBIDDEN_DOUBLE_FORWARDSLASH);</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到，它通过判断<code>allowUrlEncodedDoubleSlash</code>属性（默认值为false）是否为真来调用不同的方法，并传入<code>FORBIDDEN_DOUBLE_FORWARDSLASH</code>参数。查看这个<code>FORBIDDEN_DOUBLE_FORWARDSLASH</code>属性的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final List&lt;String&gt; FORBIDDEN_DOUBLE_FORWARDSLASH = Collections.unmodifiableList(Arrays.asList("//", "%2f%2f", "%2f%2F", "%2F%2f", "%2F%2F"));</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里默认的禁止双重转发列表为<code>"//", "%2f%2f", "%2f%2F", "%2F%2f", "%2F%2F"</code>，也就是说如果请求地址中出现双斜杠（<code>//</code>使用URL地址编码后为<code>%2F%2F</code>，因此<code>"//", "%2f%2f", "%2f%2F", "%2F%2f", "%2F%2F"</code>应视为同一个）后，那么该请求地址也将被拒绝访问。</p><p>如果开发者想允许请求地址中出现<code>//</code>，那么只需通过<code>setAllowUrlEncodedDoubleSlash(true)</code>来进行允许，其中的<code>Slash</code>就是指斜杠。只需将之前httpFirewall方法中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpFirewall httpFirewall(){</span><br><span class="line">    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">    strictHttpFirewall.setAllowUrlEncodedDoubleSlash(true);</span><br><span class="line">    return strictHttpFirewall;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="请求地址中不能出现百分号"><a href="#请求地址中不能出现百分号" class="headerlink" title="请求地址中不能出现百分号"></a>请求地址中不能出现百分号</h3><p>查看一下<code>StrictHttpFirewall#setAllowUrlEncodedPercent</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void setAllowUrlEncodedPercent(boolean allowUrlEncodedPercent) {</span><br><span class="line">      if (allowUrlEncodedPercent) {</span><br><span class="line">          this.encodedUrlBlacklist.remove("%25");</span><br><span class="line">          this.decodedUrlBlacklist.remove("%");</span><br><span class="line">      } else {</span><br><span class="line">          this.encodedUrlBlacklist.add("%25");</span><br><span class="line">          this.decodedUrlBlacklist.add("%");</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里默认禁止URL中出现百分号，开发者可以通过<code>setAllowUrlEncodedPercent(true)</code>来进行允许，其中的<code>Percent</code>就是指百分号。只需将之前httpFirewall方法中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpFirewall httpFirewall(){</span><br><span class="line">    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">    strictHttpFirewall.setAllowUrlEncodedPercent(true);</span><br><span class="line">    return strictHttpFirewall;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="请求地址中不能出现正反斜杠"><a href="#请求地址中不能出现正反斜杠" class="headerlink" title="请求地址中不能出现正反斜杠"></a>请求地址中不能出现正反斜杠</h3><p>当请求地址中包含斜杠编码后的字符<code>%2F</code>或者<code>%2f</code>，那么该请求将会被拒绝。</p><p>当请求地址中包含反斜杠<code>\</code>或者反斜杠<code>\</code>编码后的字符<code>"\\", "%5c", "%5C"</code>，那么该请求也会被拒绝。</p><p>查看一下<code>StrictHttpFirewall#setAllowBackSlash</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setAllowBackSlash(boolean allowBackSlash) {</span><br><span class="line">      if (allowBackSlash) {</span><br><span class="line">          this.urlBlacklistsRemoveAll(FORBIDDEN_BACKSLASH);</span><br><span class="line">      } else {</span><br><span class="line">          this.urlBlacklistsAddAll(FORBIDDEN_BACKSLASH);</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>其中的<code>BackSlash</code>就是反斜杠，可以看到，它通过判断<code>allowBackSlash</code>属性（默认值为false）是否为真来调用不同的方法，并传入<code>FORBIDDEN_BACKSLASH</code>参数。查看这个<code>FORBIDDEN_BACKSLASH</code>属性的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final List&lt;String&gt; FORBIDDEN_BACKSLASH = Collections.unmodifiableList(Arrays.asList("\\", "%5c", "%5C"));</span><br></pre></td></tr></tbody></table></figure></div><p>开发者如果希望请求地址允许出现正反斜杠，可以通过<code>setAllowBackSlash(true)</code>并且<code>setAllowUrlEncodedSlash(true)</code>这两个方法来进行设置。将之前httpFirewall方法中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpFirewall httpFirewall(){</span><br><span class="line">    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">    strictHttpFirewall.setAllowUrlEncodedSlash(true);</span><br><span class="line">    strictHttpFirewall.setAllowBackSlash(true);</span><br><span class="line">    return strictHttpFirewall;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="请求地址中不能包含点号"><a href="#请求地址中不能包含点号" class="headerlink" title="请求地址中不能包含点号"></a>请求地址中不能包含点号</h3><p>当请求地址中包含点号(<code>.</code>)编码后的字符<code>%2e</code>或者<code>%2E</code>，那么该请求将会被拒绝。</p><p>查看一下<code>StrictHttpFirewall#setAllowUrlEncodedPeriod</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setAllowUrlEncodedPeriod(boolean allowUrlEncodedPeriod) {</span><br><span class="line">        if (allowUrlEncodedPeriod) {</span><br><span class="line">            this.encodedUrlBlacklist.removeAll(FORBIDDEN_ENCODED_PERIOD);</span><br><span class="line">        } else {</span><br><span class="line">            this.encodedUrlBlacklist.addAll(FORBIDDEN_ENCODED_PERIOD);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>其中的<code>Period</code>就是点号，可以看到，它通过判断<code>allowUrlEncodedPeriod</code>属性（默认值为false）是否为真来调用不同的方法，并传入<code>FORBIDDEN_ENCODED_PERIOD</code>参数。查看这个<code>FORBIDDEN_ENCODED_PERIOD</code>属性的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final List&lt;String&gt; FORBIDDEN_ENCODED_PERIOD = Collections.unmodifiableList(Arrays.asList("%2e", "%2E"));</span><br></pre></td></tr></tbody></table></figure></div><p>开发者如果希望请求地址允许出现点号(<code>.</code>)，可以通过<code>setAllowUrlEncodedPeriod(true)</code>这一方法来进行设置。将之前httpFirewall方法中的代码修改为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpFirewall httpFirewall(){</span><br><span class="line">    StrictHttpFirewall strictHttpFirewall = new StrictHttpFirewall();</span><br><span class="line">    strictHttpFirewall.setAllowUrlEncodedPeriod(true);</span><br><span class="line">    return strictHttpFirewall;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>需要强调的是，上面所述的限制都是针对请求的<code>RequestURI</code>进行限制，而不是针对请求参数。当开发者的请求格式为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/hello?name=envy</span><br></pre></td></tr></tbody></table></figure></div><p>此时上述所述的限制对其没有任何影响。查看一下<code>StrictHttpFirewall</code>类中相关的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class StrictHttpFirewall implements HttpFirewall {</span><br><span class="line">    public FirewalledRequest getFirewalledRequest(HttpServletRequest request) throws RequestRejectedException {</span><br><span class="line">        this.rejectForbiddenHttpMethod(request);</span><br><span class="line">        this.rejectedBlacklistedUrls(request);</span><br><span class="line">        this.rejectedUntrustedHosts(request);</span><br><span class="line">        if (!isNormalized(request)) {</span><br><span class="line">            throw new RequestRejectedException("The request was rejected because the URL was not normalized.");</span><br><span class="line">        } else {</span><br><span class="line">            String requestUri = request.getRequestURI();</span><br><span class="line">            if (!containsOnlyPrintableAsciiCharacters(requestUri)) {</span><br><span class="line">                throw new RequestRejectedException("The requestURI was rejected because it can only contain printable ASCII characters.");</span><br><span class="line">            } else {</span><br><span class="line">                return new FirewalledRequest(request) {</span><br><span class="line">                    public void reset() {</span><br><span class="line">                    }</span><br><span class="line">                };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void rejectedBlacklistedUrls(HttpServletRequest request) {</span><br><span class="line">        Iterator var2 = this.encodedUrlBlacklist.iterator();</span><br><span class="line"></span><br><span class="line">        String forbidden;</span><br><span class="line">        do {</span><br><span class="line">            if (!var2.hasNext()) {</span><br><span class="line">                var2 = this.decodedUrlBlacklist.iterator();</span><br><span class="line"></span><br><span class="line">                do {</span><br><span class="line">                    if (!var2.hasNext()) {</span><br><span class="line">                        return;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    forbidden = (String)var2.next();</span><br><span class="line">                } while(!decodedUrlContains(request, forbidden));</span><br><span class="line"></span><br><span class="line">                throw new RequestRejectedException("The request was rejected because the URL contained a potentially malicious String \"" + forbidden + "\"");</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            forbidden = (String)var2.next();</span><br><span class="line">        } while(!encodedUrlContains(request, forbidden));</span><br><span class="line"></span><br><span class="line">        throw new RequestRejectedException("The request was rejected because the URL contained a potentially malicious String \"" + forbidden + "\"");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static boolean encodedUrlContains(HttpServletRequest request, String value) {</span><br><span class="line">        return valueContains(request.getContextPath(), value) ? true : valueContains(request.getRequestURI(), value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static boolean decodedUrlContains(HttpServletRequest request, String value) {</span><br><span class="line">        if (valueContains(request.getServletPath(), value)) {</span><br><span class="line">            return true;</span><br><span class="line">        } else {</span><br><span class="line">            return valueContains(request.getPathInfo(), value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static boolean valueContains(String value, String contains) {</span><br><span class="line">        return value != null &amp;&amp; value.contains(contains);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到<code>getFirewalledRequest</code>方法获取的就是<code>RequestURI</code>。</p><p>需要说明的是，开发者可以通过上述配置来手动修改SpringSecurity中默认的相关配置，但是笔者不建议开发者对上述配置进行修改，因为每一条限制规则都有它存在的理由，开发者仅仅为了，满足当前的需要而开放某条限制，可能会带来目前无法预知的安全风险，因此使用默认的配置能杜绝这种未知风险的发生。</p><p>ok，那么本篇关于SpringSecurity自带防火墙的学习就到此为止，后续学习其他内容。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对SpringSecurity中用户登录相关内容进行了深度学习，接</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离+JPA+自动踢掉登录用户</title>
    <link href="http://envyzhan.asia/2020/12/23/springsecurity-17-front-and-back-end-separation-jpa-automatically-kick-off-login-users/"/>
    <id>http://envyzhan.asia/2020/12/23/springsecurity-17-front-and-back-end-separation-jpa-automatically-kick-off-login-users/</id>
    <published>2020-12-23T11:23:04.000Z</published>
    <updated>2021-03-01T08:12:06.190Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前一篇《自动踢掉登录用户》一文中，我们采用的是前后端不分离模式，但是在前后端分离盛行的当下，有必要对此模式下的自动踢掉用户进行学习。同时在前一文中，用户信息都是配置在内存中，而实际工作中都是将其放入数据库中，因此需要切换数据源为数据库。需要注意的是，在使用SpringSecurity中的Session做并发处理时，直接将内存中的用户切换为数据库中的用户，也就是将内存源切换为数据库源是会出现问题的，接下来就来细说这个问题。</p><h3 id="前后端分离项目实例化"><a href="#前后端分离项目实例化" class="headerlink" title="前后端分离项目实例化"></a>前后端分离项目实例化</h3><p>考虑到此处主要学习如何在前后端分离模式下，实现自动踢掉登录用户，因此就只是单纯的将用户存储在数据库中，而不进行任何的权限控制。同时此处登录使用JSON格式。</p><p><strong>第一步</strong>，使用IDEA创建一个名为<code>kickoffuser-json</code>的SpringBoot工程，并在其pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，新建entity包，并在其中创建用户类User，里面代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Entity(name = "t_user")</span><br><span class="line">public class User implements UserDetails {</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    //    @Getter(value = AccessLevel.NONE)</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    //    @Getter(value = AccessLevel.NONE)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() {</span><br><span class="line">        return password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() {</span><br><span class="line">        return username;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，新建repository包，并在里面新建一个<code>UserRepository</code>接口，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User,Long&gt; {</span><br><span class="line">    User findUserByUsername(String username);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，新建service包，并在里面新建一个<code>MyUserDetailService</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyUserDetailService implements UserDetailsService {</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {</span><br><span class="line">        User user= userRepository.findUserByUsername(username);</span><br><span class="line">        if(user==null){</span><br><span class="line">            throw new UsernameNotFoundException("用户不存在");</span><br><span class="line">        }</span><br><span class="line">        return user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，新建controller包，并在里面新建一个<code>HelloController</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello,world!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第六步</strong>，新建filter包，并在里面新建一个<code>EnvyLoginFilter</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EnvyLoginFilter extends UsernamePasswordAuthenticationFilter {</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {</span><br><span class="line">        if(!request.getMethod().equals("POST")){</span><br><span class="line">            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());</span><br><span class="line">        }else{</span><br><span class="line">            //判断请求类型</span><br><span class="line">            if(request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) ||request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)){</span><br><span class="line">                //说明此时使用的JSON方式</span><br><span class="line">                Map&lt;String,String&gt; loginData = new HashMap&lt;&gt;();</span><br><span class="line">                try{</span><br><span class="line">                    loginData = new ObjectMapper().readValue(request.getInputStream(),Map.class);</span><br><span class="line">                }catch (IOException e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                String username =loginData.get(getUsernameParameter());</span><br><span class="line">                String password =loginData.get(getPasswordParameter());</span><br><span class="line"></span><br><span class="line">                username = username != null ?username.trim():"";</span><br><span class="line">                password = password != null ?password:"";</span><br><span class="line"></span><br><span class="line">                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username,password);</span><br><span class="line">                this.setDetails(request,authenticationToken);</span><br><span class="line">                return this.getAuthenticationManager().authenticate(authenticationToken);</span><br><span class="line">            }else {</span><br><span class="line">                //说明此时使用的是Key/Value键值对方式</span><br><span class="line">                return super.attemptAuthentication(request,response);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第七步</strong>，新建config包，并在里面新建一个<code>SecurityConfig</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailService myUserDetailService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.userDetailsService(myUserDetailService);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception {</span><br><span class="line">        web.ignoring().antMatchers("/js/**", "/css/**","/login.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public EnvyLoginFilter envyLoginFilter() throws Exception {</span><br><span class="line">        EnvyLoginFilter envyLoginFilter = new EnvyLoginFilter();</span><br><span class="line">        //设置登录成功时的逻辑</span><br><span class="line">        envyLoginFilter.setAuthenticationSuccessHandler((httpServletRequest,httpServletResponse,authentication)-&gt;{</span><br><span class="line">            httpServletResponse.setContentType("application/json;charset=utf-8");</span><br><span class="line">            PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            User user = (User) authentication.getPrincipal();</span><br><span class="line">            user.setPassword(null);</span><br><span class="line">            map.put("status",200);</span><br><span class="line">            map.put("user",user);</span><br><span class="line">            out.write(new ObjectMapper().writeValueAsString(map));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        envyLoginFilter.setAuthenticationFailureHandler((httpServletRequest,httpServletResponse,exception)-&gt;{</span><br><span class="line">            httpServletResponse.setContentType("application/json;charset=utf-8");</span><br><span class="line">            PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">            Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put("status",401);</span><br><span class="line">            if (exception instanceof LockedException) {</span><br><span class="line">                map.put("msg", "账户被锁定，请联系管理员!");</span><br><span class="line">            } else if (exception instanceof BadCredentialsException) {</span><br><span class="line">                map.put("msg", "账户名或密码输入错误，请重新输入！");</span><br><span class="line">            } else if (exception instanceof DisabledException) {</span><br><span class="line">                map.put("msg", "账户被禁用，请联系管理员!");</span><br><span class="line">            } else if (exception instanceof AccountExpiredException) {</span><br><span class="line">                map.put("msg", "账户已过期，请联系管理员!");</span><br><span class="line">            } else if (exception instanceof CredentialsExpiredException) {</span><br><span class="line">                map.put("msg", "密码已过期，请联系管理员!");</span><br><span class="line">            }</span><br><span class="line">            else {</span><br><span class="line">                map.put("msg", "登录失败！");</span><br><span class="line">            }</span><br><span class="line">            out.write(new ObjectMapper().writeValueAsString(map));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        });</span><br><span class="line">        envyLoginFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        envyLoginFilter.setFilterProcessesUrl("/goLogin");</span><br><span class="line">        return envyLoginFilter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage("/login.html")</span><br><span class="line">                .loginProcessingUrl("/goLogin")</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        http.addFilterAt(envyLoginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第八步</strong>，数据库和JPA配置。修改<code>application.yml</code>配置文件，在里面新增如下配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">    url: jdbc:mysql:///kickuser?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">  jpa:</span><br><span class="line">    database: mysql</span><br><span class="line">    database-platform: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: true</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        dialect: org.hibernate.dialect.MySQL8Dialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第九步</strong>，启动项目进行测试。请注意，由于此处EnvyLoginFilter实例仅仅配置了使用JSON格式登录成功和失败时的处理逻辑，因此当开发者使用FORM表单登录提交时的成功与否均无法处理，这一点很容易出错，需要开发者引起高度注意。</p><p>可以看到初始化项目仅仅是实现了使用数据库保存用户，同时用户采用JSON格式登录这些功能，并未实现本篇介绍的自动踢掉登录用户这一功能，那么接下来就在此基础上实现本篇功能。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>通过前一篇《JPA+自动踢掉登录用户》一文的学习，我们知道在前后端不分离模式下，采用数据库保存用户，那么需要将自定义的User类重写<code>equals</code>和<code>hashCode</code>方法，之后按照之前的方式配置即可。</p><p>但是你会发现上述配置似乎是无效的，原因在于此处我们采用的是前后端分离模式下的，基于数据库保存用户的认证，同时使用自定义的过滤器替代了默认的<code>UsernamePasswordAuthenticationFilter</code>，这样导致前一篇所介绍的基于session的配置都失效了。因此所有相关的配置我们应当在自定义的<code>EnvyLoginFilter</code>中进行配置，包括<code>SessionAuthenticationStrategy</code>等亦是如此。</p><p>可能需要修改甚至增加一些代码逻辑，但是这对于理解SpringSecurity是有一定帮助的。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>接下来就在本篇第一部分“前后端分离项目初始化”基础上对代码进行修改和增加，以实现自动踢掉登录用户这一功能。</p><p><strong>第一步</strong>，重写自定义用户类User的<code>equals()</code>和<code>hashCode()</code>方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Entity(name = "t_user")</span><br><span class="line">public class User implements UserDetails {</span><br><span class="line">    ......</span><br><span class="line">    public boolean equals(Object rhs) {</span><br><span class="line">        return rhs instanceof User ? this.username.equals(((User)rhs).username) : false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int hashCode() {</span><br><span class="line">        return this.username.hashCode();</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，新建bean包，并在里面新建一个响应状态类<code>ResponseBean</code>，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseBean {</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    private ResponseBean() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private ResponseBean(Integer status, String message, Object object) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static ResponseBean build(){</span><br><span class="line">        return new ResponseBean();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，只有信息</span><br><span class="line">    public static ResponseBean ok(String message){</span><br><span class="line">        return new ResponseBean(200,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，有信息和数据</span><br><span class="line">    public static ResponseBean ok(String message,Object object){</span><br><span class="line">        return new ResponseBean(200,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，只有信息</span><br><span class="line">    public static ResponseBean error(String message){</span><br><span class="line">        return new ResponseBean(500,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，有信息和数据</span><br><span class="line">    public static ResponseBean error(String message,Object object){</span><br><span class="line">        return new ResponseBean(500,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() {</span><br><span class="line">        return status;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setStatus(Integer status) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getMessage() {</span><br><span class="line">        return message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setMessage(String message) {</span><br><span class="line">        this.message = message;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getObject() {</span><br><span class="line">        return object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setObject(Object object) {</span><br><span class="line">        this.object = object;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，回到自定义的SecurityConfig类中。前面说过我们需要提供一个<code>SessionRegistryImpl</code>的实例，之后由于处理session并发的是<code>ConcurrentSessionControlAuthenticationStrategy</code>，因此我们还需要提供一个<code>ConcurrentSessionControlAuthenticationStrategy</code>实例，然后设置它的处理并发数。</p><p>首先进行第一步，在<code>SecurityConfig</code>类中提供一个<code>SessionRegistryImpl</code>实例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">SessionRegistryImpl sessionRegistry(){</span><br><span class="line">    return new SessionRegistryImpl();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后在<code>SecurityConfig#envyLoginFilter()</code>方法中提供一个<code>ConcurrentSessionControlAuthenticationStrategy</code>实例，并进行对应设置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public EnvyLoginFilter envyLoginFilter() throws Exception {</span><br><span class="line">    EnvyLoginFilter envyLoginFilter = new EnvyLoginFilter();</span><br><span class="line">    //设置登录成功时的逻辑</span><br><span class="line">    envyLoginFilter.setAuthenticationSuccessHandler(</span><br><span class="line">        //逻辑省略</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">   //设置登录失败时的逻辑</span><br><span class="line">   envyLoginFilter.setAuthenticationFailureHandler(</span><br><span class="line">        //逻辑省略</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">    envyLoginFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">    envyLoginFilter.setFilterProcessesUrl("/goLogin");</span><br><span class="line">    ConcurrentSessionControlAuthenticationStrategy sessionStrategy = new ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());</span><br><span class="line">    sessionStrategy.setMaximumSessions(1);</span><br><span class="line">    envyLoginFilter.setSessionAuthenticationStrategy(sessionStrategy);</span><br><span class="line">    return envyLoginFilter;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里我们传入一个<code>SessionRegistryImpl</code>对象来实例化<code>ConcurrentSessionControlAuthenticationStrategy</code>对象，之后设置session并发数为1，最后再将其配置给自定义的envyLoginFilter对象。</p><p>可能你会好奇为什么需要配置这些，而在前一篇文章中什么都没做，原因在于使用默认的类，系统都自动配置好了，而自定义类并没有这些功能，因此需要开发者自己来手动配置。</p><p>还没有完，<strong>第四步</strong>，处理session时还需要使用到一个关键的名为<code>ConcurrentSessionFilter</code>的过滤器，本来这个过滤器开发者是不用修改的，但是这个过滤器中使用到了<code>SessionRegistryImpl</code>，而我们已经自定义了<code>SessionRegistryImpl</code>，因此就需要重新配置该过滤器。修改<code>SecurityConfig#configure(HttpSecurity http)</code>方法中的代码为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage("/login.html")</span><br><span class="line">            .loginProcessingUrl("/goLogin")</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    http.addFilterAt(new ConcurrentSessionFilter(sessionRegistry(),event-&gt;{</span><br><span class="line">        HttpServletResponse response = event.getResponse();</span><br><span class="line">        response.setContentType("application/json;charset=utf-8");</span><br><span class="line">        response.setStatus(401);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.write(new ObjectMapper().writeValueAsString(ResponseBean.error("您已在另一台设备登录，本次登录已下线!")));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    }),ConcurrentSessionFilter.class);</span><br><span class="line"></span><br><span class="line">    http.addFilterAt(envyLoginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们使用自定义的<code>ConcurrentSessionFilter</code>过滤器替代了系统默认的<code>ConcurrentSessionFilter</code>过滤器，只不过没起名字而已。同时查看这个<code>ConcurrentSessionFilter</code>的构造方法可知，该方法需要<code>SessionRegistry</code>和<code>SessionInformationExpiredStrategy</code>这两个参数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentSessionFilter(SessionRegistry sessionRegistry, SessionInformationExpiredStrategy sessionInformationExpiredStrategy) {</span><br><span class="line">        Assert.notNull(sessionRegistry, "sessionRegistry required");</span><br><span class="line">        Assert.notNull(sessionInformationExpiredStrategy, "sessionInformationExpiredStrategy cannot be null");</span><br><span class="line">        this.sessionRegistry = sessionRegistry;</span><br><span class="line">        this.sessionInformationExpiredStrategy = sessionInformationExpiredStrategy;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>因此这里的<code>SessionRegistry</code>我们就使用了前面配置的<code>SessionRegistry</code>实例，而<code>SessionInformationExpiredStrategy</code>对象则是通过一个lambda表达式来创建该对象。其实这个<code>SessionInformationExpiredStrategy</code>对象就是处理session过期后的回调函数，也就是当用户在被另一个登录用户踢下线之后，开发者想给该用户什么下线提示，此时就可以在这个方法内完成。</p><p>你以为这就完了么？不是的，还有<strong>最后一步</strong>，需要将用户登录的session信息进行保存，因此需要回到<code>EnvyLoginFilter#EnvyLoginFilter()</code>方法中，修改里面的内容如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {</span><br><span class="line">    if(!request.getMethod().equals("POST")){</span><br><span class="line">        throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());</span><br><span class="line">    }else{</span><br><span class="line">        //判断请求类型</span><br><span class="line">        if(request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) ||request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)){</span><br><span class="line">            //说明此时使用的JSON方式</span><br><span class="line">            Map&lt;String,String&gt; loginData = new HashMap&lt;&gt;();</span><br><span class="line">            try{</span><br><span class="line">                loginData = new ObjectMapper().readValue(request.getInputStream(),Map.class);</span><br><span class="line">            }catch (IOException e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            String username =loginData.get(getUsernameParameter());</span><br><span class="line">            String password =loginData.get(getPasswordParameter());</span><br><span class="line"></span><br><span class="line">            username = username != null ?username.trim():"";</span><br><span class="line">            password = password != null ?password:"";</span><br><span class="line"></span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(username,password);</span><br><span class="line">            this.setDetails(request,authenticationToken);</span><br><span class="line"></span><br><span class="line">            User user = new User();</span><br><span class="line">            user.setUsername(username);</span><br><span class="line">            sessionRegistry.registerNewSession(request.getSession(true).getId(),user);</span><br><span class="line"></span><br><span class="line">            return this.getAuthenticationManager().authenticate(authenticationToken);</span><br><span class="line">        }else {</span><br><span class="line">            //说明此时使用的是Key/Value键值对方式</span><br><span class="line">            return super.attemptAuthentication(request,response);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实就是新增了如下内容：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//新增内容</span><br><span class="line">User user = new User();</span><br><span class="line">user.setUsername(username);</span><br><span class="line">sessionRegistry.registerNewSession(request.getSession(true).getId(),user);</span><br></pre></td></tr></tbody></table></figure></div><p>这里我们重新实例化了一个User，并设置该name属性为当前登录用户，之后手动调用<code>sessionRegistry.registerNewSession(request.getSession(true).getId(),user);</code>方法来保存当前用户登录的session信息。</p><p>在完成上述配置后，接下来就可以进行多端测试，可以发现当用户被人踢下线时，系统会有<code>您已在另一台设备登录，本次登录已下线!</code>这一提示信息。</p><p>那么本篇关于前后端分离模式下的，基于数据库保存用户，实现自定踢掉登录用户的学习就到此为止，后续学习其他内容。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前一篇《自动踢掉登录用户》一文中，我们采用的是前后端不分离模式，但是在前</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>传统方式+JPA+自动踢掉登录用户</title>
    <link href="http://envyzhan.asia/2020/12/22/springsecurity-16-traditional-way-jpa-automaticallly-kick-off-login-users/"/>
    <id>http://envyzhan.asia/2020/12/22/springsecurity-16-traditional-way-jpa-automaticallly-kick-off-login-users/</id>
    <published>2020-12-22T11:23:04.000Z</published>
    <updated>2021-03-01T08:11:30.725Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在《自动踢掉登录用户》一文中，出于简单考率，我们将用户信息保存在内存中，但是在实际工作中都是将用户信息保存早数据库中。看到这里，小伙伴是不是觉得只需将数据库保存用户替换为内存保存用户，完全没必要新开一篇文章，是的通常都是可以直接这么操作，但是这里仅仅这么操作是不行的，因此此处有必要单独进行介绍。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>考虑到此处主要学习如何在前后端不分离模式下，实现自动踢掉登录用户，因此就只是单纯的将用户存储在数据库中，而不进行任何的权限控制。</p><p><strong>第一步</strong>，使用IDEA创建一个名为<code>kickoffuser-jpa</code>的SpringBoot工程，并在其pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，新建entity包，并在其中创建用户类User，里面代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Entity(name = "t_user")</span><br><span class="line">public class User implements UserDetails {</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    //    @Getter(value = AccessLevel.NONE)</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    //    @Getter(value = AccessLevel.NONE)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() {</span><br><span class="line">        return password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() {</span><br><span class="line">        return username;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，新建repository包，并在里面新建一个<code>UserRepository</code>接口，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends JpaRepository&lt;User,Long&gt; {</span><br><span class="line">    User findUserByUsername(String username);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，新建service包，并在里面新建一个<code>MyUserDetailService</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyUserDetailService implements UserDetailsService {</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {</span><br><span class="line">        User user= userRepository.findUserByUsername(username);</span><br><span class="line">        if(user==null){</span><br><span class="line">            throw new UsernameNotFoundException("用户不存在");</span><br><span class="line">        }</span><br><span class="line">        return user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，新建controller包，并在里面新建一个<code>HelloController</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello,world!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第六步</strong>，在static目录下新建一个login.html文件，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body {</span><br><span class="line">        background: #353f42;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    * {</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .main {</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        padding-left: 25px;</span><br><span class="line">        padding-right: 25px;</span><br><span class="line">        padding-top: 15px;</span><br><span class="line">        width: 350px;</span><br><span class="line">        height: 350px;</span><br><span class="line">        background: #FFFFFF;</span><br><span class="line">        /*以下css用于让登录表单垂直居中在界面,可删除*/</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        margin-top: -175px;</span><br><span class="line">        margin-left: -175px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title {</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 40px;</span><br><span class="line">        line-height: 40px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title span {</span><br><span class="line">        font-size: 18px;</span><br><span class="line">        color: #353f42;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title-msg {</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 64px;</span><br><span class="line">        line-height: 64px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title:hover {</span><br><span class="line">        cursor: default;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title-msg:hover {</span><br><span class="line">        cursor: default;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .title-msg span {</span><br><span class="line">        font-size: 12px;</span><br><span class="line">        color: #707472;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .input-content {</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 120px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .input-content input {</span><br><span class="line">        width: 330px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border: 1px solid #dad9d6;</span><br><span class="line">        background: #ffffff;</span><br><span class="line">        padding-left: 10px;</span><br><span class="line">        padding-right: 10px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .enter-btn {</span><br><span class="line">        width: 350px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background: #0bc5de;</span><br><span class="line">        line-height: 40px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 0px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .foor {</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: auto;</span><br><span class="line">        color: #9b9c98;</span><br><span class="line">        font-size: 12px;</span><br><span class="line">        margin-top: 20px;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .enter-btn:hover {</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        background: #1db5c9;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .foor div:hover {</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        color: #484847;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .left {</span><br><span class="line">        float: left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    .right {</span><br><span class="line">        float: right;</span><br><span class="line">    }</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class="main"&gt;</span><br><span class="line">    &lt;div class="title"&gt;</span><br><span class="line">        &lt;span&gt;密码登录&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class="title-msg"&gt;</span><br><span class="line">        &lt;span&gt;请输入登录账户和密码&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form class="login-form" method="post" novalidate action="/goLogin"&gt;</span><br><span class="line">        &lt;!--输入框--&gt;</span><br><span class="line">        &lt;div class="input-content"&gt;</span><br><span class="line">            &lt;!--autoFocus--&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type="text" autocomplete="off"</span><br><span class="line">                       placeholder="用户名" name="username" required/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div style="margin-top: 16px"&gt;</span><br><span class="line">                &lt;input type="password"</span><br><span class="line">                       autocomplete="off" placeholder="登录密码" name="password" required maxlength="32"/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--登入按钮--&gt;</span><br><span class="line">        &lt;div style="text-align: center"&gt;</span><br><span class="line">            &lt;button type="submit" class="enter-btn"&gt;登录&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class="foor"&gt;</span><br><span class="line">            &lt;div class="left"&gt;&lt;span&gt;忘记密码 ?&lt;/span&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class="right"&gt;&lt;span&gt;注册账户&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第七步</strong>，新建config包，并在里面新建一个<code>SecurityConfig</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailService myUserDetailService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.userDetailsService(myUserDetailService);</span><br><span class="line">        super.configure(auth);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception {</span><br><span class="line">        web.ignoring().antMatchers("/js/**", "/css/**", "/login.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage("/login.html")</span><br><span class="line">                .loginProcessingUrl("/goLogin")</span><br><span class="line">                .usernameParameter("username")</span><br><span class="line">                .passwordParameter("password")</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl("/logout")</span><br><span class="line">                .logoutSuccessHandler((httpServletRequest,httpServletResponse,authentication)-&gt;{</span><br><span class="line">                    httpServletResponse.setContentType("text/html;charset=utf-8");</span><br><span class="line">                    PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">                    out.write("注销登录成功!");</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                }).and().sessionManagement().maximumSessions(1);</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第八步</strong>，数据库和JPA配置。修改<code>application.yml</code>配置文件，在里面新增如下配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql:///kickuser?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">  jpa:</span><br><span class="line">    database: mysql</span><br><span class="line">    database-platform: mysql</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: true</span><br><span class="line">    properties:</span><br><span class="line">      hibernate:</span><br><span class="line">        dialect: org.hibernate.dialect.MySQL8Dialect</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第九步</strong>，启动项目进行测试。打开Chrome浏览器，访问<code>/hello</code>接口，页面跳到登录页面，输入用户名和密码后点击登录，之后页面显示<code>/hello</code>接口信息。之后打开另一个Edge浏览器，访问<code>/hello</code>接口，之后输入用户信息完成登录，并显示<code>/hello</code>接口信息，接着回到Chrome浏览器，刷新之前的页面，发现页面依旧是显示<code>/hello</code>接口信息，并没有显示之前的踢掉用户信息提示，即登录成功不会踢掉已经登录的用户。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>在解决这个问题之前，我们需要明白SpringSecurity是如何保存用户对象及Session信息的。</p><p>在SpringSecurity中，与Session存储相关的接口为<code>SessionRegistry</code>，查看一下该接口的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface SessionRegistry {</span><br><span class="line">    List&lt;Object&gt; getAllPrincipals();</span><br><span class="line"></span><br><span class="line">    List&lt;SessionInformation&gt; getAllSessions(Object var1, boolean var2);</span><br><span class="line"></span><br><span class="line">    SessionInformation getSessionInformation(String var1);</span><br><span class="line"></span><br><span class="line">    void refreshLastRequest(String var1);</span><br><span class="line"></span><br><span class="line">    void registerNewSession(String var1, Object var2);</span><br><span class="line"></span><br><span class="line">    void removeSessionInformation(String var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到里面有6个方法，第一个<code>getAllPrincipals</code>方法表示获取所有的用户信息；第二个<code>getAllSessions</code>方法表示获取所有的Session信息；第三个<code>getSessionInformation</code>方法表示获取某个session信息；第四个<code>refreshLastRequest</code>方法表示获取刷新最近的请求；第五个<code>registerNewSession</code>方法表示将新生成的session进行保存；第六个<code>removeSessionInformation</code>方法表示删除某个session信息；</p><p>该接口只有一个实现类<code>SessionRegistryImpl</code>，用于对会话信息进行统一管理，查看一下该类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class SessionRegistryImpl implements SessionRegistry, ApplicationListener&lt;SessionDestroyedEvent&gt; {</span><br><span class="line">    protected final Log logger = LogFactory.getLog(SessionRegistryImpl.class);</span><br><span class="line">    private final ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals;</span><br><span class="line">    private final Map&lt;String, SessionInformation&gt; sessionIds;</span><br><span class="line"></span><br><span class="line">    public SessionRegistryImpl() {</span><br><span class="line">        this.principals = new ConcurrentHashMap();</span><br><span class="line">        this.sessionIds = new ConcurrentHashMap();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public SessionRegistryImpl(ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals, Map&lt;String, SessionInformation&gt; sessionIds) {</span><br><span class="line">        this.principals = principals;</span><br><span class="line">        this.sessionIds = sessionIds;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; getAllPrincipals() {</span><br><span class="line">        return new ArrayList(this.principals.keySet());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public List&lt;SessionInformation&gt; getAllSessions(Object principal, boolean includeExpiredSessions) {</span><br><span class="line">        //代码省略</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public SessionInformation getSessionInformation(String sessionId) {</span><br><span class="line">        //代码省略</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void registerNewSession(String sessionId, Object principal) {</span><br><span class="line">        Assert.hasText(sessionId, "SessionId required as per interface contract");</span><br><span class="line">        Assert.notNull(principal, "Principal required as per interface contract");</span><br><span class="line">        if (this.getSessionInformation(sessionId) != null) {</span><br><span class="line">            this.removeSessionInformation(sessionId);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (this.logger.isDebugEnabled()) {</span><br><span class="line">            this.logger.debug("Registering session " + sessionId + ", for principal " + principal);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.sessionIds.put(sessionId, new SessionInformation(principal, sessionId, new Date()));</span><br><span class="line">        this.principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; {</span><br><span class="line">            if (sessionsUsedByPrincipal == null) {</span><br><span class="line">                sessionsUsedByPrincipal = new CopyOnWriteArraySet();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ((Set)sessionsUsedByPrincipal).add(sessionId);</span><br><span class="line">            if (this.logger.isTraceEnabled()) {</span><br><span class="line">                this.logger.trace("Sessions used by '" + principal + "' : " + sessionsUsedByPrincipal);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            return (Set)sessionsUsedByPrincipal;</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void removeSessionInformation(String sessionId) {</span><br><span class="line">        Assert.hasText(sessionId, "SessionId required as per interface contract");</span><br><span class="line">        SessionInformation info = this.getSessionInformation(sessionId);</span><br><span class="line">        if (info != null) {</span><br><span class="line">            if (this.logger.isTraceEnabled()) {</span><br><span class="line">                this.logger.debug("Removing session " + sessionId + " from set of registered sessions");</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            this.sessionIds.remove(sessionId);</span><br><span class="line">            this.principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; {</span><br><span class="line">                if (this.logger.isDebugEnabled()) {</span><br><span class="line">                    this.logger.debug("Removing session " + sessionId + " from principal's set of registered sessions");</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                sessionsUsedByPrincipal.remove(sessionId);</span><br><span class="line">                if (sessionsUsedByPrincipal.isEmpty()) {</span><br><span class="line">                    if (this.logger.isDebugEnabled()) {</span><br><span class="line">                        this.logger.debug("Removing principal " + info.getPrincipal() + " from registry");</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    sessionsUsedByPrincipal = null;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                if (this.logger.isTraceEnabled()) {</span><br><span class="line">                    this.logger.trace("Sessions used by '" + info.getPrincipal() + "' : " + sessionsUsedByPrincipal);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                return sessionsUsedByPrincipal;</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>由于此处仅仅是关注session信息的存储，因此将其他与之关系不大的方法的实现逻辑给删除了。接下来对上述代码进行一个较为简单的介绍：<br>（1）首先定义了一个principals对象，该对象是一个ConcurrentMap类型，这是一个支持并发访问的map集合，集合中的Key为用户的主体(principal)，通常来说principal就是用户对象，这一点可以从<code>getAllPrincipals()</code>方法的源码中得到验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt; getAllPrincipals() {</span><br><span class="line">    return new ArrayList(this.principals.keySet());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>集合的Value则是一个set集合，这个集合中保存了该用户的所有sessionid，这一点可以从<code>getAllSessions()</code>方法的源码中得到验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;SessionInformation&gt; getAllSessions(Object principal, boolean includeExpiredSessions) {</span><br><span class="line">        Set&lt;String&gt; sessionsUsedByPrincipal = (Set)this.principals.get(principal);</span><br><span class="line">        if (sessionsUsedByPrincipal == null) {</span><br><span class="line">            return Collections.emptyList();</span><br><span class="line">        } else {</span><br><span class="line">            List&lt;SessionInformation&gt; list = new ArrayList(sessionsUsedByPrincipal.size());</span><br><span class="line">            Iterator var5 = sessionsUsedByPrincipal.iterator();</span><br><span class="line"></span><br><span class="line">            while(true) {</span><br><span class="line">                SessionInformation sessionInformation;</span><br><span class="line">                do {</span><br><span class="line">                    do {</span><br><span class="line">                        if (!var5.hasNext()) {</span><br><span class="line">                            return list;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        String sessionId = (String)var5.next();</span><br><span class="line">                        sessionInformation = this.getSessionInformation(sessionId);</span><br><span class="line">                    } while(sessionInformation == null);</span><br><span class="line">                } while(!includeExpiredSessions &amp;&amp; sessionInformation.isExpired());</span><br><span class="line"></span><br><span class="line">                list.add(sessionInformation);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>（2）之后定义一个sessionIds对象，Key为sessionId，Value为<code>SessionInformation</code>类型，这一点可以从<code>registerNewSession()</code>方法内如下代码得到验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.sessionIds.put(sessionId, new SessionInformation(principal, sessionId, new Date()));</span><br></pre></td></tr></tbody></table></figure></div><p>（3）当有新的session需要添加时，会调用<code>registerNewSession()</code>方法，该方法里面有如下核心代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">this.principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; {</span><br><span class="line">    if (sessionsUsedByPrincipal == null) {</span><br><span class="line">        sessionsUsedByPrincipal = new CopyOnWriteArraySet();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ((Set)sessionsUsedByPrincipal).add(sessionId);</span><br><span class="line">    if (this.logger.isTraceEnabled()) {</span><br><span class="line">        this.logger.trace("Sessions used by '" + principal + "' : " + sessionsUsedByPrincipal);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return (Set)sessionsUsedByPrincipal;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></div><p>调用<code>principals.compute()</code>方法往principals这个ConcurrentMap类型对象中新增session信息，注意key就是principal。<br>（4）当用户注销登录，则调用<code>removeSessionInformation()</code>方法来将session信息进行移除，核心代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">this.sessionIds.remove(sessionId);</span><br><span class="line">this.principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; {</span><br><span class="line">if (this.logger.isDebugEnabled()) {</span><br><span class="line">    this.logger.debug("Removing session " + sessionId + " from principal's set of registered sessions");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sessionsUsedByPrincipal.remove(sessionId);</span><br><span class="line">    if (sessionsUsedByPrincipal.isEmpty()) {</span><br><span class="line">        if (this.logger.isDebugEnabled()) {</span><br><span class="line">            this.logger.debug("Removing principal " + info.getPrincipal() + " from registry");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        sessionsUsedByPrincipal = null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (this.logger.isTraceEnabled()) {</span><br><span class="line">        this.logger.trace("Sessions used by '" + info.getPrincipal() + "' : " + sessionsUsedByPrincipal);</span><br><span class="line">    }</span><br><span class="line">        return sessionsUsedByPrincipal;</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它会调用<code>sessionIds.remove()</code>方法来移除sessionid，之后调用<code>principals.computeIfPresent()</code>方法来删除session信息。</p><p>通过上述分析，我们就知道这个ConcurrentMap集合principals，它的Key是principal对象，既然使用对象做Key，那么就需要重写equals和hashCode方法，否则第一次存完数据，后期就无法找到它。关于这一部分内容则是Java集合相关的内容，笔者在后续会有一套笔记介绍这些内容。</p><p>你可能觉得好像我们之前在使用基于内存来保存用户时，好像也没有重写equals和hashCode方法，真的是这样么，查看一下当时的User类，注意使用的是自带的User类，包所在位置为<code>org.springframework.security.core.userdetails</code>。可以看到其实该类默认已经重写了equals和hashCode方法：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-81f9b9d489ce372e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-81f9b9d489ce372e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>所以我们就知道了，使用基于内存保存用户方式之所以没出错，是因为它默认重写了equals和hashCode方法，但是此处我们自定义的用户并没有重写这两个方法，因此就无法实现既定功能。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>修改用户自定义的User类，在里面重写equals和hashCode方法，可以仿照系统提供的User类中的那两个方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object rhs) {</span><br><span class="line">    return rhs instanceof User ? this.username.equals(((User)rhs).username) : false;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() {</span><br><span class="line">    return this.username.hashCode();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>当然用户也可以根据自己的逻辑来进行实现，如下所示的实现逻辑：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) {</span><br><span class="line">    if (this == o) return true;</span><br><span class="line">    if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">    User user = (User) o;</span><br><span class="line">    return Objects.equals(username, user.username);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() {</span><br><span class="line">    return Objects.hash(username);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在完成上述配置以后，重启项目，再次测试多端登录，你就会发现可以踢掉已经登录的用户。当然了本篇不仅仅只限于使用Spring Data JPA的情况，当开发者使用了Mybatis等其他ORM框架时，也只需和本文一样，重写ConcurrentMap集合principals对象的Key类型的<code>equals</code>和<code>hashCode</code>方法。</p><p>ok，那么本篇关于基于数据库保存用户的，前后端不分离模式下的自动踢掉登录用户的学习就到此为止，后续学习其他内容。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在《自动踢掉登录用户》一文中，出于简单考率，我们将用户信息保存在内存中，但</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>内存保存用户+自动踢掉登录用户</title>
    <link href="http://envyzhan.asia/2020/12/21/springsecurity-15-save-users-in-memory-and-automatically-kick-off-login-users/"/>
    <id>http://envyzhan.asia/2020/12/21/springsecurity-15-save-users-in-memory-and-automatically-kick-off-login-users/</id>
    <published>2020-12-21T11:23:04.000Z</published>
    <updated>2021-03-01T08:10:58.450Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>经过前面的学习，我们已经对SpringSecurity用户登录内容有了较为深刻的认识，接下来学习一个较为有意思的功能—自动踢掉登录用户。</p><p>你可能不知道什么是“自动踢掉登录用户”，但是你可能遇到过这种场景：当你在A电脑上登录了QQ，然后再在B电脑上登录时，QQ就会将你从A电脑上踢下线，也就是告知你同一时刻同一平台你只能登录一个实例。</p><p>从本篇文章开始，如果没有特殊说明，那么都是新建一个gitee分支，在新的项目上进行编码。在gitee上新建一个kickoff-user分支，然后将本地分支切换过去，接下来开始进行代码逻辑编写。</p><h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>在实际工作中，出于安全考量，我们可能要求某个系统只允许一个用户在一个终端上登录，更有甚者要求一个用户在一个设备上登录。如钉钉，这款软件就规定用户最多只能在三台手机上登录（仅仅针对手机端），显然这就是对用户登录的设备进行了绑定。</p><p>需要说明的是，终端和设备两者是不同的，终端包括PC、手机端等方式，而设备就是指单纯的某台具体的手机。</p><p>要实现上述功能，即一个用户无法同时在两台设备上登录，可以有两种实现思路：<br>（1）后来的登录用户踢掉前面已经登录的用户，QQ就是这种方式；<br>（2）如果用户已经登录，那么就不允许后来者登录，一般银行就是采用这种方式。</p><p>既然上述两种思路都能实现上述功能，那么具体选择哪种则需要结合具体的使用场景。庆幸的是SpringSecurity对这两种思路都提供了具体的实现，下面将分别进行介绍。</p><h3 id="项目实例化"><a href="#项目实例化" class="headerlink" title="项目实例化"></a>项目实例化</h3><p><strong>第一步</strong>，使用IDEA创建一个名为<code>kickoff-user</code>的SpringBoot工程，并在其pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第二步</strong>，新建config包，并在该包内新建一个<code>SecurityConfig</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() {</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationManager authenticationManager() throws Exception {</span><br><span class="line">        return super.authenticationManager();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    protected UserDetailsService userDetailsService() {</span><br><span class="line">        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername("envy").password("1234").roles("admin").build());</span><br><span class="line">        return manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception {</span><br><span class="line">        web.ignoring().antMatchers("/js/**", "/css/**","/login.html");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage("/login.html")</span><br><span class="line">                .loginProcessingUrl("/login")</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处使用了基于内存的验证方式，同时自定义了登录表单，且登录页面为<code>/login.html</code>，同时登录页面处理逻辑使用的是默认的接口<code>/login</code>，前者是GET方式，后者则是POST方式。<br><strong>第三步</strong>，在static目录下新建登录页面<code>login.html</code>，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div align="center"&gt;</span><br><span class="line">    &lt;h1&gt;用户登录&lt;/h1&gt;</span><br><span class="line">    &lt;form action="/login" method="post"&gt;</span><br><span class="line">        &lt;input type="text" placeholder="请输入用户名" name="username"&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type="password" placeholder="请输入密码" name="password"&gt;&lt;br&gt;</span><br><span class="line">        &lt;button type="submit"&gt;登录&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，新建controller包，并在里面新建一个<code>HelloController</code>类，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello,world!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第五步</strong>，启动项目进行测试。用户访问<code>/hello</code>接口就会跳转到<code>/login.html</code>页面，输入正确的用户名和密码后，点击登录即可完成登录，页面显示既定的<code>hello,world!</code>信息。</p><h3 id="踢掉已经登录用户"><a href="#踢掉已经登录用户" class="headerlink" title="踢掉已经登录用户"></a>踢掉已经登录用户</h3><p>如果想用新登录的用户来踢掉已经登录的用户，开发者只需将最大会话数设置为1，这样就能保证每次该用户只有一个会话。</p><p>在<code>SecurityConfig#configure(HttpSecurity http)</code>方法内新增如下配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            ......</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实就是增加了一个<code>sessionManagement</code>配置项，并设置最大会话数<code>maximumSessions</code>的值为1，这样如果该用户再次登录时，系统就会自动将前面已登录的用户踢掉。</p><p>接下来就是启动项目，开始测试，准备两个浏览器，一个Chrome，一个FireFox或者微软自带的Edge浏览器（别用IE）：<br>第一步，使用Chrome浏览器访问<code>/hello</code>接口，页面跳转到登录页面，输入正确信息后，页面跳转到<code>/hello</code>接口，并显示<code>hello,world!</code>；<br>第二步，使用FireFox或者微软自带的Edge浏览器，访问<code>/hello</code>接口，页面跳转到登录页面，输入正确信息后，页面跳转到<code>/hello</code>接口，并显示<code>hello,world!</code>；<br>第三步，刷新Chrome浏览器此时的页面，即<code>/hello</code>接口页面，可以发现页面显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-46793c56884f8644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-46793c56884f8644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到此时页面已经出现提示信息，告知我们此会话已过期（可能是由于同一用户尝试多个并发登录）。</p><h3 id="禁止用户新的登录"><a href="#禁止用户新的登录" class="headerlink" title="禁止用户新的登录"></a>禁止用户新的登录</h3><p>如果开发者不想让之前已经登录的用户下线，那么可以通过禁止用户新的登录这一方式来实现。</p><p>在<code>SecurityConfig#configure(HttpSecurity http)</code>方法内新增如下配置信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            ......</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(1)</span><br><span class="line">            .maxSessionsPreventsLogin(true);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到此处仅仅在之前的基础上添加了<code>maxSessionsPreventsLogin(true)</code>这一配置。之后启动项目进行测试，发现当用在进行上述测试第三步的时候，页面跳转到了<code>http://localhost:8080/login.html?error</code>页面，同时清空了用户输入的信息，这一就使得用户无法新登录。但是当用户从第一步中使用的Chrome浏览器上退出时，第二步中依旧无法完成登录功能，这样就导致只要用户之前登录过系统，无论其是否退出，后续都无法在其他平台上登录，这和我们预想的压根不一样。</p><p>其实仅仅上述配置是不够的，我们还需要提供一个<code>HttpSessionEventPublisher</code>实例。在<code>SecurityConfig</code>类中新增如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">HttpSessionEventPublisher httpSessionEventPublisher(){</span><br><span class="line">    return new HttpSessionEventPublisher();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>问题来了，为什么需要提供一个<code>HttpSessionEventPublisher</code>实例，原因在于SpringSecurity是通过监听Session的销毁事件来及时清理Session的记录。我们知道，当用户从不同的浏览器登录后，它都会有对应的Session，然后用户注销登录后，那么对应的Session就会失效。但是Session默认的失效是通过调用<code>StandardSession#invalidate()</code>方法来实现的，而这一生效事件无法被Spring容器所感知到，这样会导致用户注销登录之后，SpringSecurity没有及时清理会话信息表，认为用户有依旧还在线，进而导致用户无法重新登录。</p><p>通过提供一个<code>HttpSessionEventPublisher</code>实例就能解决这个问题，查看一下这个<code>HttpSessionEventPublisher</code>的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class HttpSessionEventPublisher implements HttpSessionListener {</span><br><span class="line">    private static final String LOGGER_NAME = HttpSessionEventPublisher.class.getName();</span><br><span class="line"></span><br><span class="line">    public HttpSessionEventPublisher() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ApplicationContext getContext(ServletContext servletContext) {</span><br><span class="line">        return SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void sessionCreated(HttpSessionEvent event) {</span><br><span class="line">        HttpSessionCreatedEvent e = new HttpSessionCreatedEvent(event.getSession());</span><br><span class="line">        Log log = LogFactory.getLog(LOGGER_NAME);</span><br><span class="line">        if (log.isDebugEnabled()) {</span><br><span class="line">            log.debug("Publishing event: " + e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void sessionDestroyed(HttpSessionEvent event) {</span><br><span class="line">        HttpSessionDestroyedEvent e = new HttpSessionDestroyedEvent(event.getSession());</span><br><span class="line">        Log log = LogFactory.getLog(LOGGER_NAME);</span><br><span class="line">        if (log.isDebugEnabled()) {</span><br><span class="line">            log.debug("Publishing event: " + e);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以发现这个<code>HttpSessionEventPublisher</code>类实现<code>HttpSessionListener</code>接口，且该类提供了session创建、销毁的方法，因此在该Bean中可以将session创建、销毁的事件及时感知到，并调用Spring中的事件机制将相关的创建和销毁事件发布出去，进而被SpringSecurity所感知到。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>现在我们通过阅读源码来分析SpringSecurity中是如何实现上述两个功能的。</p><p>通过前面《详解登录流程》一文的学习，我们知道用户在登录过程中会经过<code>UsernamePasswordAuthenticationFilter</code>这个过滤器，而这个过滤器中的<code>attemptAuthentication()</code>方法则是在在其父类<code>AbstractAuthenticationProcessingFilter</code>的<code>doFilter()</code>方法中被触发的，这里再次粘贴<code>AbstractAuthenticationProcessingFilter#doFilter()</code>方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)res;</span><br><span class="line">        if (!this.requiresAuthentication(request, response)) {</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        } else {</span><br><span class="line">            if (this.logger.isDebugEnabled()) {</span><br><span class="line">                this.logger.debug("Request is to process authentication");</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Authentication authResult;</span><br><span class="line">            try {</span><br><span class="line">                authResult = this.attemptAuthentication(request, response);</span><br><span class="line">                if (authResult == null) {</span><br><span class="line">                    return;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                this.sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">            } catch (InternalAuthenticationServiceException var8) {</span><br><span class="line">                this.logger.error("An internal error occurred while trying to authenticate the user.", var8);</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var8);</span><br><span class="line">                return;</span><br><span class="line">            } catch (AuthenticationException var9) {</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var9);</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            if (this.continueChainBeforeSuccessfulAuthentication) {</span><br><span class="line">                chain.doFilter(request, response);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            this.successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>从上述源码中可以知道调用<code>attemptAuthentication()</code>方法完成用户认证之后，接着调用<code>sessionStrategy.onAuthentication()</code>方法来处理session并发相关的内容，查看一下这个sessionStrategy，发现它是一个<code>SessionAuthenticationStrategy</code>对象，而这个<code>SessionAuthenticationStrategy</code>是一个接口，里面只有一个<code>onAuthentication()</code>方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SessionAuthenticationStrategy {</span><br><span class="line">    void onAuthentication(Authentication var1, HttpServletRequest var2, HttpServletResponse var3) throws SessionAuthenticationException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>因此我们需要找到<code>SessionAuthenticationStrategy</code>的实现类，且该类对<code>onAuthentication()</code>方法的逻辑进行了实现：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-3474fc9ac1aab815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-3474fc9ac1aab815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到上面有一个名为<code>ConcurrentSessionControlAuthenticationStrategy</code>的实现类，含义就是“并发会话控制身份验证策略”，这个类用来控制session的并发。查看一下该类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentSessionControlAuthenticationStrategy implements MessageSourceAware, SessionAuthenticationStrategy {</span><br><span class="line">    protected MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();</span><br><span class="line">    private final SessionRegistry sessionRegistry;</span><br><span class="line">    private boolean exceptionIfMaximumExceeded = false;</span><br><span class="line">    private int maximumSessions = 1;</span><br><span class="line"></span><br><span class="line">    public ConcurrentSessionControlAuthenticationStrategy(SessionRegistry sessionRegistry) {</span><br><span class="line">        Assert.notNull(sessionRegistry, "The sessionRegistry cannot be null");</span><br><span class="line">        this.sessionRegistry = sessionRegistry;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void onAuthentication(Authentication authentication, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        List&lt;SessionInformation&gt; sessions = this.sessionRegistry.getAllSessions(authentication.getPrincipal(), false);</span><br><span class="line">        int sessionCount = sessions.size();</span><br><span class="line">        int allowedSessions = this.getMaximumSessionsForThisUser(authentication);</span><br><span class="line">        if (sessionCount &gt;= allowedSessions) {</span><br><span class="line">            if (allowedSessions != -1) {</span><br><span class="line">                if (sessionCount == allowedSessions) {</span><br><span class="line">                    HttpSession session = request.getSession(false);</span><br><span class="line">                    if (session != null) {</span><br><span class="line">                        Iterator var8 = sessions.iterator();</span><br><span class="line"></span><br><span class="line">                        while(var8.hasNext()) {</span><br><span class="line">                            SessionInformation si = (SessionInformation)var8.next();</span><br><span class="line">                            if (si.getSessionId().equals(session.getId())) {</span><br><span class="line">                                return;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                this.allowableSessionsExceeded(sessions, allowedSessions, this.sessionRegistry);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected int getMaximumSessionsForThisUser(Authentication authentication) {</span><br><span class="line">        return this.maximumSessions;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected void allowableSessionsExceeded(List&lt;SessionInformation&gt; sessions, int allowableSessions, SessionRegistry registry) throws SessionAuthenticationException {</span><br><span class="line">        if (!this.exceptionIfMaximumExceeded &amp;&amp; sessions != null) {</span><br><span class="line">            sessions.sort(Comparator.comparing(SessionInformation::getLastRequest));</span><br><span class="line">            int maximumSessionsExceededBy = sessions.size() - allowableSessions + 1;</span><br><span class="line">            List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(0, maximumSessionsExceededBy);</span><br><span class="line">            Iterator var6 = sessionsToBeExpired.iterator();</span><br><span class="line"></span><br><span class="line">            while(var6.hasNext()) {</span><br><span class="line">                SessionInformation session = (SessionInformation)var6.next();</span><br><span class="line">                session.expireNow();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        } else {</span><br><span class="line">            throw new SessionAuthenticationException(this.messages.getMessage("ConcurrentSessionControlAuthenticationStrategy.exceededAllowed", new Object[]{allowableSessions}, "Maximum sessions of {0} for this principal exceeded"));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setExceptionIfMaximumExceeded(boolean exceptionIfMaximumExceeded) {</span><br><span class="line">        this.exceptionIfMaximumExceeded = exceptionIfMaximumExceeded;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setMaximumSessions(int maximumSessions) {</span><br><span class="line">        Assert.isTrue(maximumSessions != 0, "MaximumLogins must be either -1 to allow unlimited logins, or a positive integer to specify a maximum");</span><br><span class="line">        this.maximumSessions = maximumSessions;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setMessageSource(MessageSource messageSource) {</span><br><span class="line">        Assert.notNull(messageSource, "messageSource cannot be null");</span><br><span class="line">        this.messages = new MessageSourceAccessor(messageSource);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里面有很多方法，这里主要以分析其中的<code>onAuthentication()</code>方法为主：<br>（1）首先调用<code>sessionRegistry.getAllSessions(authentication.getPrincipal(), false)</code>方法来获取当前用户所有的session，里面传入两个参数，第一个为当前用户的身份，用户名或者用户本身；第二个参数false，表示不包含已经过期的session。因为用户在登录成功后，会将用户的sessionId进行保存，其中key是用户的身份，也就是principal，而value则是该身份所对应的一系列sessionId的集合。可以看到这个<code>sessionRegistry.getAllSessions(authentication.getPrincipal(), false)</code>方法返回的是<code>List&lt;SessionInformation&gt;</code>类型的sessions对象。<br>（2）计算（1）中得到session的个数，也就是当前用户所拥有的有效session个数（定义为<code>sessionCount</code>变量）。之后调用<code>getMaximumSessionsForThisUser()</code>方法来获取当前用户所拥有的最大session数（定义为<code>allowedSessions</code>变量），查看源码可以这个<code>maximumSessions</code>属性默认值为1。<br>（3）判断当前session数<code>sessionCount</code>与session允许并发数<code>allowedSessions</code>值的大小，如果<code>sessionCount</code>小于<code>allowedSessions</code>，则不作任何处理；如果<code>sessionCount</code>大于或等于<code>allowedSessions</code>，则首先判断<code>allowedSessions</code>的值是否为-1，如果为-1，则说明对session的数量不作任何限制；如果不为-1，则进行下一步判断。</p><p>接下来判断当前session数<code>sessionCount</code>与session允许并发数<code>allowedSessions</code>值是否相等，如果相等，则先判断当前session是否不为null，且已经存在于sessions中？如果已经存在，那么不作任何处理。如果当前session为null，则说明将有一个新的session被创建出来，此时当前session数<code>sessionCount</code>的值就会超出session允许并发数<code>allowedSessions</code>的值。</p><p>如果当前session数<code>sessionCount</code>大于session允许并发数<code>allowedSessions</code>的值，那么就调用<code>allowableSessionsExceeded()</code>方法来处理相应的逻辑，该方法名称就是“超过允许的会话”。<br>（4）接下来开始阅读<code>allowableSessionsExceeded()</code>方法的源码，可以看到首先判断<code>exceptionIfMaximumExceeded</code>属性，该属性含义为“如果最大超过，则异常”，其实这个值就是之前我们在<code>SecurityConfig#configure(HttpSecurity http)</code>方法中配置的<code>maxSessionsPreventsLogin()</code>项，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a6526bf989ca46e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a6526bf989ca46e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>这个<code>maxSessionsPreventsLogin</code>属性值默认为false，如果这个值为true，那么就会抛出<code>SessionAuthenticationException</code>异常，说明此次登录失败。如果为false，且sessions不为空，则继续往下执行。</p><p>接下来调用<code>sessions.sort()</code>方法来根据请求时间进行排序，之后再将超出session允许并发数<code>allowedSessions</code>的值的其余session都过期。举个例子，运动会记录选手比赛时间，它记录了十个，但是最后只取前三名，因此需要对成绩按照时间进行排序，取前三个，其余的都删除，这里说的就是这个意思。</p><p>通过上面的源码分析和实际例子，详细大家对SpringSecurity中session的并发管理有了一个较为清晰的认识，但是这里还有一个小坑，至于在哪，笔者将结合前后端分离模式来进行分析和填坑。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;经过前面的学习，我们已经对SpringSecurity用户登录内容有了较为</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>获取登录额外信息</title>
    <link href="http://envyzhan.asia/2020/12/20/springsecurity-14-get-additional-login-information/"/>
    <id>http://envyzhan.asia/2020/12/20/springsecurity-14-get-additional-login-information/</id>
    <published>2020-12-20T11:23:04.000Z</published>
    <updated>2021-03-01T08:10:24.625Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>通过前面《详解登录流程》一文的学习，我们已经对用户登录流程、认证过程和保存用户信息等内容有了一个较为清晰的认识。同时我们也对用户登录流程和认证过程分别用了更为详细的内容去进行学习，那么本篇就花点时间来学习关于保存用户信息等那些事。</p><h1 id="Authentication对象"><a href="#Authentication对象" class="headerlink" title="Authentication对象"></a>Authentication对象</h1><p>首先阅读《详解登录流程》一文，之后再来阅读本部分内容会容易很多。</p><p>前面我们曾多次提到过<code>Authentication</code>这个接口，它用来保存用户的登录信息，这里再次贴上该接口的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable {</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line"></span><br><span class="line">    Object getDetails();</span><br><span class="line"></span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line"></span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该接口继承了<code>Principal</code>接口，查看一下该接口的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Principal {</span><br><span class="line">    public boolean equals(Object another);</span><br><span class="line"></span><br><span class="line">    public String toString();</span><br><span class="line"></span><br><span class="line">    public int hashCode();</span><br><span class="line"></span><br><span class="line">    public String getName();</span><br><span class="line"></span><br><span class="line">    public default boolean implies(Subject subject) {</span><br><span class="line">        if (subject == null)</span><br><span class="line">            return false;</span><br><span class="line">        return subject.getPrincipals().contains(this);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个接口中定义的都是一些较为基本的方法，因此<code>Authentication</code>接口其实也是进一步对<code>Principal</code>接口进行了封装。</p><p>回到<code>Authentication</code>接口中来，可以发现它是一个接口，其中有6个方法：<br>（1）<code>getAuthorities()</code>方法用来获取用户的权限；<br>（2）<code>getCredentials()</code>方法用来获取用户的凭证，通常这里的凭证就是用户密码；<br>（3）<code>getDetails()</code>方法用来获取用户携带的详细信息；<br>（4）<code>getPrincipal()</code>方法用来获取当前用户，注意它可能是用户名，也可能是用户对象本身；<br>（5）<code>isAuthenticated()</code>方法用来判断当前用户是否认证成功；<br>（6）<code>setAuthenticated()</code>方法用来设置当前用户是否认证。</p><p>看到（3）中的<code>getDetails()</code>方法了么？它用来获取用户携带的详细信息，那么问题来了，用户到底携带了哪些详细信息呢？查看一下源码中对于该方法的解释：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stores additional details about the authentication request. These might be an IP address, certificate serial number etc.</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该方法主要用于存储一些与用户身份认证相关的额外信息，如IP地址、证书序列号等。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>通过前面的学习，我们知道用户登录必定经过<code>UsernamePasswordAuthenticationFilter</code>过滤器，且在该类的<code>attemptAuthentication</code>方法中会获取登录用户名和密码，查看该方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {</span><br><span class="line">        if (this.postOnly &amp;&amp; !request.getMethod().equals("POST")) {</span><br><span class="line">            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());</span><br><span class="line">        } else {</span><br><span class="line">            String username = this.obtainUsername(request);</span><br><span class="line">            String password = this.obtainPassword(request);</span><br><span class="line">            if (username == null) {</span><br><span class="line">                username = "";</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            if (password == null) {</span><br><span class="line">                password = "";</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            username = username.trim();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            this.setDetails(request, authRequest);</span><br><span class="line">            return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>前面就是获取请求中的用户名和密码，之后调用<code>setDetails</code>方法，将request和<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入进去，但是细心的你可能发现这个<code>UsernamePasswordAuthenticationToken</code>对象是没有details这个属性的，它没有这个属性，那就查看一下它的父类<code>AbstractAuthenticationToken</code>，可以发现它的父类是有的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Object details;</span><br><span class="line"></span><br><span class="line">public Object getDetails() {</span><br><span class="line">        return this.details;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void setDetails(Object details) {</span><br><span class="line">        this.details = details;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>现在问题来了，这个details对象中保存的是什么呢？查看一下<code>UsernamePasswordAuthenticationFilter</code>类中<code>setDetails</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以发现此处调用了<code>authenticationDetailsSource</code>的<code>buildDetails()</code>方法，查看一下源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationDetailsSource&lt;C, T&gt; {</span><br><span class="line">    T buildDetails(C var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以发现这是一个接口，查看一下该接口的实现类：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-31066934b79862cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-31066934b79862cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>里面有三个实现类，与登录相关的是<code>WebAuthenticationDetailsSource</code>类，查看一下该类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WebAuthenticationDetailsSource implements AuthenticationDetailsSource&lt;HttpServletRequest, WebAuthenticationDetails&gt; {</span><br><span class="line">    public WebAuthenticationDetailsSource() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public WebAuthenticationDetails buildDetails(HttpServletRequest context) {</span><br><span class="line">        return new WebAuthenticationDetails(context);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该类实现了上述接口，里面有两个方法，一个是无参的构造方法，另一个则是<code>buildDetails()</code>方法，该方法用于返回一个<code>WebAuthenticationDetails</code>对象，查看一下这个<code>WebAuthenticationDetails</code>类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class WebAuthenticationDetails implements Serializable {</span><br><span class="line">    private static final long serialVersionUID = 520L;</span><br><span class="line">    private final String remoteAddress;</span><br><span class="line">    private final String sessionId;</span><br><span class="line"></span><br><span class="line">    public WebAuthenticationDetails(HttpServletRequest request) {</span><br><span class="line">        this.remoteAddress = request.getRemoteAddr();</span><br><span class="line">        HttpSession session = request.getSession(false);</span><br><span class="line">        this.sessionId = session != null ? session.getId() : null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private WebAuthenticationDetails(String remoteAddress, String sessionId) {</span><br><span class="line">        this.remoteAddress = remoteAddress;</span><br><span class="line">        this.sessionId = sessionId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object obj) {</span><br><span class="line">        //省略逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getRemoteAddress() {</span><br><span class="line">        return this.remoteAddress;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getSessionId() {</span><br><span class="line">        return this.sessionId;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int hashCode() {</span><br><span class="line">        //省略逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String toString() {</span><br><span class="line">        //省略逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该类定义了三个属性，其中remoteAddress表示请求的IP地址，sessionId则是sessionId，serialVersionUID则是序列化id，其他的则是属性的getter方法、有参的构造方法以及重写的equals、hashCode和toString方法。</p><p>注意里面还有一个传入<code>HttpServletRequest</code>对象的构造方法，可以看到它其实是从传入的<code>HttpServletRequest</code>对象中获取请求IP和session信息。</p><p>通过上面的分析，我们知道当用户登录时，那么SpringSecurity默认通过<code>WebAuthenticationDetailsSource </code>的<code>buildDetails</code>方法来构建一个<code>WebAuthenticationDetails</code>对象，之后将其设置到<code>UsernamePasswordAuthenticationToken</code>对象的details属性中。</p><p>因此开发者可以在用户成功登录后，通过如下方式来获取用户IP、Session信息。这里依旧在上一篇的基础上进行操作。新建一个service包，并在里面新建一个<code>InformationService</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class InformationService {</span><br><span class="line">    public String info(){</span><br><span class="line">        Authentication authentication =SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        WebAuthenticationDetails details = (WebAuthenticationDetails)authentication.getDetails();</span><br><span class="line">        String remoteAddress = details.getRemoteAddress();</span><br><span class="line">        String sessionId = details.getSessionId();</span><br><span class="line">        return String.format("remoteAddress is:"+remoteAddress+",sessionId is:"+sessionId);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这段代码就是使用<code>SecurityContextHolder.getContext().getAuthentication()</code>方法来获取一个<code>Authentication</code>对象，之后调用<code>getDetails()</code>方法来获取<code>WebAuthenticationDetails</code>对象，最后通过这个<code>WebAuthenticationDetails</code>对象中的<code>etRemoteAddress()</code>和<code>getSessionId()</code>方法来获取用户IP、Session信息。</p><p>最后在controller包内新建一个<code>InformationController</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class InformationController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private InformationService informationService;</span><br><span class="line"></span><br><span class="line">    @GetMapping("/info")</span><br><span class="line">    public String info(){</span><br><span class="line">        return informationService.info();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后启动项目，用户登录成功后，访问<code>/info</code>接口即可看到页面输出所示信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-aa3eec5a49973daf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-aa3eec5a49973daf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>这里的用户IP为<code>0:0:0:0:0:0:0:1</code>，其实就是<code>127.0.0.1</code>。</p><h1 id="自定义WebAuthenticationDetails对象"><a href="#自定义WebAuthenticationDetails对象" class="headerlink" title="自定义WebAuthenticationDetails对象"></a>自定义WebAuthenticationDetails对象</h1><p>通过前面的学习，我们知道<code>WebAuthenticationDetails</code>类中仅仅只包含了请求IP和SessionId，假如我们想保存更多关于HTTP请求的信息，此时就可以通过自定义<code>WebAuthenticationDetails</code>类来实现。</p><p>请注意，开发者仅仅只定义<code>WebAuthenticationDetails</code>类是不够的，还记得那个<code>setDetails()</code>方法么，再次查看它的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它调用的是<code>authenticationDetailsSource.buildDetails()</code>方法，而<code>AuthenticationDetailsSource</code>是一个接口，它有3个实现类，系统默认调用的是<code>WebAuthenticationDetailsSource</code>这个类，因此还需要自定义<code>WebAuthenticationDetailsSource</code>类才行。</p><p>接下来结合之前《自定义认证逻辑》一文来学习如何自定义<code>WebAuthenticationDetails</code>对象。</p><p>在《自定义认证逻辑》一文中，我们是在<code>MyAuthenticationProvider</code>类进行验证码的逻辑判断，查看一下当时的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyAuthenticationProvider extends DaoAuthenticationProvider {</span><br><span class="line">    @Override</span><br><span class="line">    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        //获取当前请求</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        //获取当前响应</span><br><span class="line">        //HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line"></span><br><span class="line">        //获取用户通过表单输入的验证码字符串</span><br><span class="line">        String formCaptcha =request.getParameter("code");</span><br><span class="line">        //获取生成的验证码字符串（从session中获取)</span><br><span class="line">        String genCaptcha = (String) request.getSession().getAttribute("verify_code");</span><br><span class="line"></span><br><span class="line">        if(formCaptcha ==null || genCaptcha ==null || !formCaptcha.equals(genCaptcha)){</span><br><span class="line">            throw new AuthenticationServiceException("验证码错误!");</span><br><span class="line">        }</span><br><span class="line">        super.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其实这个验证码的逻辑也可以放在自定义的<code>WebAuthenticationDetails</code>类中进行，之后只需用户在进行登录认证时调用这个自定义的<code>WebAuthenticationDetailsSource</code>类，这样自定义的<code>WebAuthenticationDetails</code>类也会被调用。</p><p><strong>第一步</strong>，新建一个details包，并在里面新建一个<code>MyWebAuthenticationDetails</code>类，注意这个类需要继承<code>WebAuthenticationDetails</code>类，并实现其中有参的构造方法，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebAuthenticationDetails extends WebAuthenticationDetails {</span><br><span class="line">    //自定义一个属性，用于判断验证码是否通过</span><br><span class="line">    private boolean isPassed = false;</span><br><span class="line"></span><br><span class="line">    //自定义请求方法属性</span><br><span class="line">    private String method;</span><br><span class="line"></span><br><span class="line">    public MyWebAuthenticationDetails(HttpServletRequest request) {</span><br><span class="line">        super(request);</span><br><span class="line">        //获取用户通过表单输入的验证码字符串</span><br><span class="line">        String formCaptcha =request.getParameter("code");</span><br><span class="line">        //获取生成的验证码字符串（从session中获取)</span><br><span class="line">        String genCaptcha = (String) request.getSession().getAttribute("verify_code");</span><br><span class="line">        if(formCaptcha !=null &amp;&amp; genCaptcha !=null &amp;&amp; formCaptcha.equals(genCaptcha)){</span><br><span class="line">           isPassed =true;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //给此处的自定义请求方法属性赋值</span><br><span class="line">        this.method =request.getMethod();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isPassed(){</span><br><span class="line">        return this.isPassed;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getMethod(){</span><br><span class="line">        return this.method;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们自定义了一个<code>MyWebAuthenticationDetails</code>类，并继承了<code>WebAuthenticationDetails</code>类，且需要提供一个包含<code>HttpServletRequest</code>的参数，因此开发者可以直接利用该对象来进行验证码的判断，并将判断结果存入isPassed变量。</p><p><strong>如果开发者想扩展属性，那么只需在这个自定义的<code>MyWebAuthenticationDetails</code>类中定义更多的属性，之后再从<code>HttpServletRequest</code>对象中取出对应的属性，并将值赋值给它，这样在后续用户成功登陆后就可以获取这些属性。</strong></p><p>上面我们就自定义了一个<code>method</code>属性，那么后期就将其输出在页面上。</p><p><strong>第二步</strong>，在details包内新建一个<code>MyWebAuthenticationDetailsSource</code>类，注意这个类需要继承<code>WebAuthenticationDetailsSource</code>类，并实现其中的<code>buildDetails</code>方法，之后让这个方法返回之前我们自定义的<code>WebAuthenticationDetails</code>对象，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyWebAuthenticationDetailsSource extends WebAuthenticationDetailsSource {</span><br><span class="line">    public MyWebAuthenticationDetailsSource() {</span><br><span class="line">        super();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MyWebAuthenticationDetails buildDetails(HttpServletRequest context) {</span><br><span class="line">        return new MyWebAuthenticationDetails(context);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第三步</strong>，修改<code>MyAuthenticationProvider</code>类中的代码。前面我们已经将验证码的判断逻辑放在了自定义的<code>MyWebAuthenticationDetails</code>类中，因此此处<code>MyAuthenticationProvider</code>中的<code>additionalAuthenticationChecks()</code>方法只需根据它返回的isPassed值来判断验证码是否通过验证：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyAuthenticationProvider extends DaoAuthenticationProvider {</span><br><span class="line"></span><br><span class="line">    //获取登录额外信息</span><br><span class="line">    @Override</span><br><span class="line">    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        if(!((MyWebAuthenticationDetails)authentication.getDetails()).isPassed()){</span><br><span class="line">            throw new AuthenticationServiceException("验证码错误!");</span><br><span class="line">        }</span><br><span class="line">        super.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第四步</strong>，使用自定义的<code>MyWebAuthenticationDetailsSource</code>来代替系统默认的<code>WebAuthenticationDetailsSource</code>。其实非常简单，开发者只需在<code>SecurityConfig</code>类的<code>configure(HttpSecurity http)</code>方法中新增如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private MyWebAuthenticationDetailsSource myWebAuthenticationDetailsSource;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            ....</span><br><span class="line">            .formLogin()</span><br><span class="line">            .authenticationDetailsSource(myWebAuthenticationDetailsSource)</span><br><span class="line">            ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里将用户自定义的<code>MyWebAuthenticationDetailsSource</code>对象注入到<code>SecurityConfig</code>类中，之后在<code>formLogin</code>中配置<code>authenticationDetailsSource</code>，并将自定义的<code>MyWebAuthenticationDetailsSource</code>对象传入进去。</p><p><strong>第五步</strong>，修改<code>InformationService</code>类中的代码，在里面新增一个<code>customizeInfo</code>方法，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String customizeInfo(){</span><br><span class="line">        Authentication authentication =SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        MyWebAuthenticationDetails details = (MyWebAuthenticationDetails)authentication.getDetails();</span><br><span class="line">        String remoteAddress = details.getRemoteAddress();</span><br><span class="line">        String sessionId = details.getSessionId();</span><br><span class="line">        String method = details.getMethod();</span><br><span class="line">        return String.format("remoteAddress is:"+remoteAddress+",sessionId is:"+sessionId+",method is:"+method);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第六步</strong>，修改<code>InformationController</code>类中的代码，在里面新增一个<code>customizeInfo</code>方法，里面的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/customizeInfo")</span><br><span class="line">public String customizeInfo(){</span><br><span class="line">    return informationService.customizeInfo();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>第七步</strong>，启动项目，开始进行测试。启动项目，用户登录成功后，访问<code>/customizeInfo</code>接口即可看到页面输出所示信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-fa11f4f40e2ce43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-fa11f4f40e2ce43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>这样本篇关于获取登录额外信息的学习就到此为止，后续学习其他内容。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;通过前面《详解登录流程》一文的学习，我们已经对用户登录流程、认证过程和保存</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>自定义认证逻辑</title>
    <link href="http://envyzhan.asia/2020/12/19/springsecurity-13-custom-authentication-logic/"/>
    <id>http://envyzhan.asia/2020/12/19/springsecurity-13-custom-authentication-logic/</id>
    <published>2020-12-19T11:23:04.000Z</published>
    <updated>2021-03-01T08:08:51.140Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们对SpringSecurity中的登录流程进行了较为详细的分析，但是采用的都是系统默认的认证逻辑，这种方式在学习中尚能使用，但是在实际工作中一般都会自定义登录逻辑。笔者结合自己实际工作中的一些应用来介绍一种比较常用的自定义认证逻辑。</p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p>前面我们在《添加登录验证码》和《前后端分离JSON格式登录实现》两篇文章中，通过自定义过滤器，并在过滤器中实现了相应的逻辑，这些也是自定义认证逻辑的范畴，只不过是最为基础罢了，但是它们都存在一些问题，如下面的例子所述的那样。</p><p>假设现在有一个系统，我们给它添加了一个验证码，同时为了校验验证码，需要自定义一个过滤器，并将该过滤器放入SpringSecurity的过滤器链中，之后每次请求都会通过该过滤器。这样的逻辑看似没有问题，但是你仔细想就会发现，我们仅仅需要登录的请求经过该过滤器，其他请求是无需经过的，因此如果你对性能有较为严苛的要求，那么就有必要对上述逻辑进行修改。</p><h3 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h3><p>首先阅读《详解登录流程》一文，之后再来阅读本部分内容会容易很多。</p><p>通过查阅<code>ProviderManager#authenticate()</code>方法中的源码可以知道，<code>AuthenticationProvider</code>接口定义了SpringSecurity中的验证逻辑，查看一下该接口的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationProvider {</span><br><span class="line">    Authentication authenticate(Authentication var1) throws AuthenticationException;</span><br><span class="line"></span><br><span class="line">    boolean supports(Class&lt;?&gt; var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从中可以知道它提供了两个方法，其中authenticate方法用于验证用户身份，supports方法用于判断当前<code>AuthenticationProvider</code>对象是否支持对应的Authentication。Authentication非常重要，里面包含了当前登录用户的信息，查看一下它的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable {</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line"></span><br><span class="line">    Object getDetails();</span><br><span class="line"></span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line"></span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以发现它是一个接口，其中有6个方法：<br>（1）<code>getAuthorities()</code>方法用来获取用户的权限；<br>（2）<code>getCredentials()</code>方法用来获取用户的凭证，通常这里的凭证就是用户密码；<br>（3）<code>getDetails()</code>方法用来获取用户携带的详细信息；<br>（4）<code>getPrincipal()</code>方法用来获取当前用户，注意它可能是用户名，也可能是用户对象本身；<br>（5）<code>isAuthenticated()</code>方法用来判断当前用户是否认证成功；<br>（6）<code>setAuthenticated()</code>方法用来设置当前用户是否认证。</p><p>Authentication接口包含了一些获取用户信息的基本方法，它有很多实现类，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-cb43680808b900ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-cb43680808b900ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>在上述实现类中，我们用的较多的就是<code>UsernamePasswordAuthenticationToken</code>类，该类用于处理用户名和密码相关的认证逻辑。  请注意每一个<code>Authentication</code>都有与之匹配的<code>AuthenticationProvider</code>去处理校验逻辑，这也是<code>AuthenticationProvider </code>接口提供<code>supports()</code>方法的原因。</p><p>那么问题来了，我怎么知道哪个<code>Authentication</code>与哪个<code>AuthenticationProvider</code>相匹配呢？可以查看这个<code>AuthenticationProvider</code>接口的子类信息，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f2ac6fb962d9e147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f2ac6fb962d9e147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>根据它的子类名称就能猜出相应的匹配关系，如上面的<code>UsernamePasswordAuthenticationToken</code>类所对应的<code>AuthenticationProvider</code>就是<code>DaoAuthenticationProvider</code>类。</p><p>通过《详解登录流程》一文的学习，我们知道在一次完整的认证中，可能包含多个<code>AuthenticationProvider</code>，而这些<code>AuthenticationProvider</code>都由<code>ProviderManager</code>来进行统一管理。</p><p>接下来重点研究之前提到过的<code>DaoAuthenticationProvider</code>，当我们需要使用用户名+密码这一方式进行登录时就会使用到它。<code>DaoAuthenticationProvider</code>类的父类为<code>AbstractUserDetailsAuthenticationProvider</code>类，<code>AbstractUserDetailsAuthenticationProvider</code>类实现了前面所说的<code>AuthenticationProvider</code>接口，且对该接口中的<code>authenticate</code>和<code>supports</code>这两个方法提供了具体的实现，因此我们来看<code>AbstractUserDetailsAuthenticationProvider</code>类中那两个实现的方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; {</span><br><span class="line">            return this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports", "Only UsernamePasswordAuthenticationToken is supported");</span><br><span class="line">        });</span><br><span class="line">        String username = this.determineUsername(authentication);</span><br><span class="line">        boolean cacheWasUsed = true;</span><br><span class="line">        UserDetails user = this.userCache.getUserFromCache(username);</span><br><span class="line">        if (user == null) {</span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            } catch (UsernameNotFoundException var6) {</span><br><span class="line">                this.logger.debug("Failed to find user '" + username + "'");</span><br><span class="line">                if (!this.hideUserNotFoundExceptions) {</span><br><span class="line">                    throw var6;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        } catch (AuthenticationException var7) {</span><br><span class="line">            if (!cacheWasUsed) {</span><br><span class="line">                throw var7;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line">            user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.postAuthenticationChecks.check(user);</span><br><span class="line">        if (!cacheWasUsed) {</span><br><span class="line">            this.userCache.putUserInCache(user);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Object principalToReturn = user;</span><br><span class="line">        if (this.forcePrincipalAsString) {</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public boolean supports(Class&lt;?&gt; authentication) {</span><br><span class="line">        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><h5 id="authenticate方法分析"><a href="#authenticate方法分析" class="headerlink" title="authenticate方法分析"></a>authenticate方法分析</h5><p>前面多次提到authenticate方法用于用户认证相关的逻辑，接下来分析一下该方法的执行流程：<br><strong>（1）</strong>判断当前Authentication对象是否是<code>UsernamePasswordAuthenticationToken</code>类的实例，如果是，那么就能使用当前的<code>AbstractUserDetailsAuthenticationProvider</code>。<br><strong>（2）</strong>调用<code>determineUsername()</code>方法从登录信息中获取用户名。查看一下这个<code>determineUsername()</code>方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String determineUsername(Authentication authentication) {</span><br><span class="line">        return authentication.getPrincipal() == null ? "NONE_PROVIDED" : authentication.getName();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>这个方法的逻辑非常清晰，就是从Authentication中获取用户身份，这里就是用户名。<br><strong>（3）</strong>从缓存中通过用户名来获取用户信息，如果获取不到用户信息则说明缓存未启用；反之得到用户信息；<br><strong>（4）</strong>调用retrieveUser方法，将得到的用户名和之前的<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入，查看一下这个retrieveUser方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        this.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            if (loadedUser == null) {</span><br><span class="line">                throw new InternalAuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");</span><br><span class="line">            } else {</span><br><span class="line">                return loadedUser;</span><br><span class="line">            }</span><br><span class="line">        } catch (UsernameNotFoundException var4) {</span><br><span class="line">            this.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            throw var4;</span><br><span class="line">        } catch (InternalAuthenticationServiceException var5) {</span><br><span class="line">            throw var5;</span><br><span class="line">        } catch (Exception var6) {</span><br><span class="line">            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它首先调用<code>getUserDetailsService()</code>方法得到一个<code>UserDetailsService</code>对象，之后调用它的<code>loadUserByUsername()</code>方法来获取<code>UserDetails</code>对象，而这个就是之前我们自定义<code>UserDetailService</code>类时所定义的<code>loadUserByUsername()</code>方法。<br><strong>（5）</strong>调用<code>preAuthenticationChecks.check(user)</code>方法来检查User对象的各个属性是否正常。查看一下这个check方法，发现它存在于<code>UserDetailsChecker</code>接口中：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsChecker {</span><br><span class="line">    void check(UserDetails var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>为了弄清楚这个check方法的执行逻辑，这里需要查看<code>UserDetailsChecker</code>接口的实现类<code>AccountStatusUserDetailsChecker</code>，在这个实现类中就有check方法的具体实现逻辑：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void check(UserDetails user) {</span><br><span class="line">      if (!user.isAccountNonLocked()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is locked");</span><br><span class="line">          throw new LockedException(this.messages.getMessage("AccountStatusUserDetailsChecker.locked", "User account is locked"));</span><br><span class="line">      } else if (!user.isEnabled()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is disabled");</span><br><span class="line">          throw new DisabledException(this.messages.getMessage("AccountStatusUserDetailsChecker.disabled", "User is disabled"));</span><br><span class="line">      } else if (!user.isAccountNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is expired");</span><br><span class="line">          throw new AccountExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.expired", "User account has expired"));</span><br><span class="line">      } else if (!user.isCredentialsNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account credentials have expired");</span><br><span class="line">          throw new CredentialsExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.credentialsExpired", "User credentials have expired"));</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里主要对用户的账户是否未锁住、是否可用、是否未过期、密码是否过期等进行判断，满足其中任意一个都会抛出异常。<br><strong>（6）</strong>接着调用<code>additionalAuthenticationChecks()</code>方法来对用户密码进行判断，查看这个方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void additionalAuthenticationChecks(UserDetails var1, UsernamePasswordAuthenticationToken var2) throws AuthenticationException;</span><br></pre></td></tr></tbody></table></figure></div><p>这是一个抽象方法，它的具体实现是<code>AbstractUserDetailsAuthenticationProvider</code>类的子类。其实非常好理解，因为<code>AbstractUserDetailsAuthenticationProvider</code>是一个较为通用的父类，用于处理一些通用的逻辑。但是请注意，并不是任何时候的登录都需要输入用户密码，因此这里的<code>additionalAuthenticationChecks()</code>方法最好就是抽象方法，具体的实例逻辑交由<code>AbstractUserDetailsAuthenticationProvider</code>类的子类来实现。</p><p>对于此处而言就是<code>DaoAuthenticationProvider</code>这个类，可以发现这个类中的<code>additionalAuthenticationChecks</code>方法就提供了具体实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">       if (authentication.getCredentials() == null) {</span><br><span class="line">           this.logger.debug("Failed to authenticate since no credentials provided");</span><br><span class="line">           throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">       } else {</span><br><span class="line">           String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">           if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {</span><br><span class="line">               this.logger.debug("Failed to authenticate since password does not match stored value");</span><br><span class="line">               throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。以<code>BCryptPasswordEncoder</code>类中的matches方法为例，查看一下密码的匹配逻辑，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) {</span><br><span class="line">        if (rawPassword == null) {</span><br><span class="line">            throw new IllegalArgumentException("rawPassword cannot be null");</span><br><span class="line">        } else if (encodedPassword != null &amp;&amp; encodedPassword.length() != 0) {</span><br><span class="line">            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {</span><br><span class="line">                this.logger.warn("Encoded password does not look like BCrypt");</span><br><span class="line">                return false;</span><br><span class="line">            } else {</span><br><span class="line">                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">            }</span><br><span class="line">        } else {</span><br><span class="line">            this.logger.warn("Empty encoded password");</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>其中rawPassword是获取到的用户密码，而encodedPassword则是数据库中查询到的密码，密码匹配逻辑其实较为简单。<br><strong>（7）</strong>回到<code>AbstractUserDetailsAuthenticationProvider</code>类的<code>authenticate</code>方法中，密码验证通过后，接下来调用<code>postAuthenticationChecks.check(user)</code>方法来检查密码是否过期。<br><strong>（8）</strong>之后判断<code>forcePrincipalAsString</code>属性是否为true，该属性是强制将Principal(用户名)转换为String(字符串)对象。其实在<code>UsernamePasswordAuthenticationFilter</code>类中就已经将principal(用户名)设置为字符串，但是在默认情况下，当用户登录成功后，这个属性的值就成了当前用户，也就是UserDetails对象。需要说明的是，这个<code>forcePrincipalAsString</code>属性默认值为false，其实开发者不需要管这个参数，因为没转成字符串，反而更利于后续获取用户信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object principalToReturn = user;</span><br><span class="line">if (this.forcePrincipalAsString) {</span><br><span class="line">    principalToReturn = user.getUsername();</span><br><span class="line">}</span><br><span class="line">return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></tbody></table></figure></div><p><strong>（9）</strong>最后调用<code>createSuccessAuthentication()</code>方法来构造一个<code>Authentication</code>对象，准确来说是<code>UsernamePasswordAuthenticationToken</code>对象：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) {</span><br><span class="line">       UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">       result.setDetails(authentication.getDetails());</span><br><span class="line">       this.logger.debug("Authenticated user");</span><br><span class="line">       return result;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><h5 id="supports方法分析"><a href="#supports方法分析" class="headerlink" title="supports方法分析"></a>supports方法分析</h5><p>接下来再来看那个supports方法的作用，这里再次贴一下该方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean supports(Class&lt;?&gt; authentication) {</span><br><span class="line">        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到该方法的逻辑非常简单，就是判断当前<code>Authentication</code>对象是否是<code>UsernamePasswordAuthenticationToken</code>对象。</p><h5 id="additionalAuthenticationChecks方法分析"><a href="#additionalAuthenticationChecks方法分析" class="headerlink" title="additionalAuthenticationChecks方法分析"></a>additionalAuthenticationChecks方法分析</h5><p>由于<code>AbstractUserDetailsAuthenticationProvider</code>抽象类已经实现了authenticate和supports方法，因此在<code>AbstractUserDetailsAuthenticationProvider</code>的子类DaoAuthenticationProvider中，我们着重关注<code>additionalAuthenticationChecks</code>这个方法，而这个方法在前面我们就对它进行了分析，这里再次贴上它的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        if (authentication.getCredentials() == null) {</span><br><span class="line">            this.logger.debug("Failed to authenticate since no credentials provided");</span><br><span class="line">            throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">        } else {</span><br><span class="line">            String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">            if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {</span><br><span class="line">                this.logger.debug("Failed to authenticate since password does not match stored value");</span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。</p><p>从前面《详解登录流程》一文中可以知道，<code>AuthenticationProvider</code>都是通过<code>ProviderManager#authenticate()</code>方法来调用的，因此这里有必要再次粘贴该方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">       Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">       AuthenticationException lastException = null;</span><br><span class="line">       AuthenticationException parentException = null;</span><br><span class="line">       Authentication result = null;</span><br><span class="line">       Authentication parentResult = null;</span><br><span class="line">       int currentPosition = 0;</span><br><span class="line">       int size = this.providers.size();</span><br><span class="line">       Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">       while(var9.hasNext()) {</span><br><span class="line">           AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">           if (provider.supports(toTest)) {</span><br><span class="line">               if (logger.isTraceEnabled()) {</span><br><span class="line">                   Log var10000 = logger;</span><br><span class="line">                   String var10002 = provider.getClass().getSimpleName();</span><br><span class="line">                   ++currentPosition;</span><br><span class="line">                   var10000.trace(LogMessage.format("Authenticating request with %s (%d/%d)", var10002, currentPosition, size));</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               try {</span><br><span class="line">                   result = provider.authenticate(authentication);</span><br><span class="line">                   if (result != null) {</span><br><span class="line">                       this.copyDetails(authentication, result);</span><br><span class="line">                       break;</span><br><span class="line">                   }</span><br><span class="line">               } catch (InternalAuthenticationServiceException | AccountStatusException var14) {</span><br><span class="line">                   this.prepareException(var14, authentication);</span><br><span class="line">                   throw var14;</span><br><span class="line">               } catch (AuthenticationException var15) {</span><br><span class="line">                   lastException = var15;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       if (result == null &amp;&amp; this.parent != null) {</span><br><span class="line">           try {</span><br><span class="line">               parentResult = this.parent.authenticate(authentication);</span><br><span class="line">               result = parentResult;</span><br><span class="line">           } catch (ProviderNotFoundException var12) {</span><br><span class="line">               ;</span><br><span class="line">           } catch (AuthenticationException var13) {</span><br><span class="line">               parentException = var13;</span><br><span class="line">               lastException = var13;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       if (result != null) {</span><br><span class="line">           if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) {</span><br><span class="line">               ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           if (parentResult == null) {</span><br><span class="line">               this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       } else {</span><br><span class="line">           if (lastException == null) {</span><br><span class="line">               lastException = new ProviderNotFoundException(this.messages.getMessage("ProviderManager.providerNotFound", new Object[]{toTest.getName()}, "No AuthenticationProvider found for {0}"));</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           if (parentException == null) {</span><br><span class="line">               this.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           throw lastException;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div><p>几乎所有关于认证的逻辑都在这个方法中，详细的流程分析这里就不再赘述，可以知道这个方法里面会遍历所有的<code>AuthenticationProvider</code>对象，并调用它的<code>authenticate()</code>方法来进行用户认证。</p><h1 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h1><p>通过上面的知识回顾，我们已经知道之前通过自定义过滤器，然后将过滤器添加到SpringSecurity过滤器链中，进而实现添加验证码这一功能，这种方式其实是有问题的，它破坏了原有的过滤器链，使得一些非登录请求也需要经过上述配置的验证码过滤器，无形中降低了系统的性能。</p><p>因此我们需要对上述方式进行改进，改进的思路也很简单，不过在此之前需要捋一下登录请求的思路，将上面分析的几个方法给串起来。首先调用<code>attemptAuthentication</code>方法来进行尝试验证，之后调用<code>AbstractUserDetailsAuthenticationProvider#authenticate</code>方法来进行登录认证，在这个认证方法中又会调用<code>DaoAuthenticationProvider#additionalAuthenticationChecks</code>方法来校验用户登录密码。因此，我们的思路就是自定义一个<code>AuthenticationProvider</code>类并重写其中的<code>additionalAuthenticationChecks</code>方法，进而替换此处用于密码校验的<code>DaoAuthenticationProvider#additionalAuthenticationChecks</code>方法。</p><p>这样做的好处就是既能实现自定义功能，又能保持原有过滤器链的完整性。常见的手机号码动态登录也可以使用这种方式来认证，这一部分内容将在下一篇中介绍。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处同样是实现验证码登录，但是就不再自己定义生成验证码的逻辑了，而是直接使用网上现成的<a href="https://github.com/penggle/kaptcha">kaptcha</a>，这个项目是Google项目的复制品，可以直接使用，非常方便。</p><h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5><p>使用IDEA创建一个名为<code>customize-kaptcha</code>的SpringBoot工程：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-6a00e15cf104addb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-6a00e15cf104addb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>当然也可以在创建项目的时候不添加任何依赖，而是在后续pom.xml依赖文件中添加如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure></div><h5 id="提供一个验证码实例"><a href="#提供一个验证码实例" class="headerlink" title="提供一个验证码实例"></a>提供一个验证码实例</h5><p>新建config包，并在该包内新建一个<code>VerifyCodeConfig</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class VerifyCodeConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    DefaultKaptcha verifyCode(){</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //定义生成验证码图片的宽度</span><br><span class="line">        properties.setProperty("kaptcha.image.width","150");</span><br><span class="line">        //定义生成验证码图片的高度</span><br><span class="line">        properties.setProperty("kaptcha.image.height","50");</span><br><span class="line">        //定义生成验证码中字符的取值范围</span><br><span class="line">        properties.setProperty("kaptcha.textproducer.char.string", "0123456789");</span><br><span class="line">        //定义验证码中字符的个数,此处为4个</span><br><span class="line">        properties.setProperty("kaptcha.textproducer.char.length", "4");</span><br><span class="line"></span><br><span class="line">        Config config = new Config(properties);</span><br><span class="line">        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        return defaultKaptcha;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这个类中定义了一个<code>verifyCode()</code>方法，用于返回一个<code>DefaultKaptcha</code>对象，里面设置了验证码的宽度、高度、字符取值范围、字符个数等信息。</p><h5 id="提供一个返回验证码接口"><a href="#提供一个返回验证码接口" class="headerlink" title="提供一个返回验证码接口"></a>提供一个返回验证码接口</h5><p>新建controller包，并在该包内新建一个<code>VerifyCodeController</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class VerifyCodeController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = "/vercode.jpg")</span><br><span class="line">    public void getVerifyCode(HttpServletResponse response, HttpSession session){</span><br><span class="line">        response.setContentType("image/jpeg");</span><br><span class="line">        String text = defaultKaptcha.createText();</span><br><span class="line">        session.setAttribute("verify_code",text);</span><br><span class="line">        BufferedImage image = defaultKaptcha.createImage(text);</span><br><span class="line">        try {</span><br><span class="line">            ServletOutputStream out = response.getOutputStream();</span><br><span class="line">            ImageIO.write(image,"jpg",out);</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>请注意上面<code>setContentType()</code>方法中的<code>image/jpeg</code>为固定格式，不能将其修改为<code>image/jpg</code>。上面代码的含义非常简单，就是将生成的验证码中的字符串添加到session中，并将生成的验证码以图片形式展示在页面上。</p><h5 id="提供一个AuthenticationProvider类"><a href="#提供一个AuthenticationProvider类" class="headerlink" title="提供一个AuthenticationProvider类"></a>提供一个AuthenticationProvider类</h5><p>新建provider包，并在该包内新建一个<code>MyAuthenticationProvider</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyAuthenticationProvider extends DaoAuthenticationProvider {</span><br><span class="line">    @Override</span><br><span class="line">    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        //获取当前请求</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        //获取当前响应</span><br><span class="line">        //HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line"></span><br><span class="line">        //获取用户通过表单输入的验证码字符串</span><br><span class="line">        String formCaptcha =request.getParameter("code");</span><br><span class="line">        //获取生成的验证码字符串（从session中获取)</span><br><span class="line">        String genCaptcha = (String) request.getSession().getAttribute("verify_code");</span><br><span class="line"></span><br><span class="line">        if(formCaptcha ==null || genCaptcha ==null || !formCaptcha.equals(genCaptcha)){</span><br><span class="line">            throw new AuthenticationServiceException("验证码错误!");</span><br><span class="line">        }</span><br><span class="line">        super.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个自定义的<code>AuthenticationProvider</code>类需要继承<code>DaoAuthenticationProvider</code>类，并重写其中的<code>additionalAuthenticationChecks()</code>方法。该方法的逻辑分析如下：<br>（1）首先从上下文中获取当前请求Request对象，注意这种方式在Spring Web中很常见，下面也给出获取Response对象的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取当前请求</span><br><span class="line">HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">//获取当前响应</span><br><span class="line">HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br></pre></td></tr></tbody></table></figure></div><p>（2）接着获取用户通过表单输入的验证码字符串，使用的方法就是<code>request.getParameter()</code>方式；<br>（3）从session中获取生成的验证码字符串，之后判断（2）和（3）中的对象是否相等，如果不等则直接抛出异常；<br>（4）最后调用父类的<code>additionalAuthenticationChecks()</code>方法，其实就是<code>DaoAuthenticationProvider</code>类的方法，用于进行密码的校验逻辑。</p><p>前面多次提到，验证码的验证工作是在用户名+密码验证之前进行的，因此这里就是先进行验证码验证，后进行用户名+密码校验。</p><h5 id="提供一个响应类对象"><a href="#提供一个响应类对象" class="headerlink" title="提供一个响应类对象"></a>提供一个响应类对象</h5><p>新建bean包，并在该包内新建一个<code>ResponseBean</code>类，其中的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseBean {</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    private ResponseBean() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private ResponseBean(Integer status, String message, Object object) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static ResponseBean build(){</span><br><span class="line">        return new ResponseBean();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，只有信息</span><br><span class="line">    public static ResponseBean ok(String message){</span><br><span class="line">        return new ResponseBean(200,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，有信息和数据</span><br><span class="line">    public static ResponseBean ok(String message,Object object){</span><br><span class="line">        return new ResponseBean(200,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，只有信息</span><br><span class="line">    public static ResponseBean error(String message){</span><br><span class="line">        return new ResponseBean(500,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，有信息和数据</span><br><span class="line">    public static ResponseBean error(String message,Object object){</span><br><span class="line">        return new ResponseBean(500,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() {</span><br><span class="line">        return status;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setStatus(Integer status) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getMessage() {</span><br><span class="line">        return message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setMessage(String message) {</span><br><span class="line">        this.message = message;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getObject() {</span><br><span class="line">        return object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setObject(Object object) {</span><br><span class="line">        this.object = object;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个类中定义了3个属性，然后提供ok和error的方法，注意这两个方法都存在多个重写方法，以适应不同的需求。</p><h5 id="自定义SecurityConfig类"><a href="#自定义SecurityConfig类" class="headerlink" title="自定义SecurityConfig类"></a>自定义SecurityConfig类</h5><p>在前面我们自定义了<code>MyAuthenticationProvider</code>类，接下就是配置如何让自定义的<code>MyAuthenticationProvider</code>类来代替默认的<code>DaoAuthenticationProvider</code>类。</p><p>由于所有的<code>AuthenticationProvider</code>都是放在<code>ProviderManager</code>中进行管理，因此就需要开发者自己提供<code>ProviderManager</code>，然后将此处自定义的<code>MyAuthenticationProvider</code>注入其中。</p><p>在config包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() {</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    MyAuthenticationProvider myAuthenticationProvider() {</span><br><span class="line">        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider();</span><br><span class="line">        myAuthenticationProvider.setPasswordEncoder(passwordEncoder());</span><br><span class="line">        myAuthenticationProvider.setUserDetailsService(userDetailsService());</span><br><span class="line">        return myAuthenticationProvider;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    protected AuthenticationManager authenticationManager() throws Exception {</span><br><span class="line">        ProviderManager manager = new ProviderManager(Arrays.asList(myAuthenticationProvider()));</span><br><span class="line">        return manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    protected UserDetailsService userDetailsService() {</span><br><span class="line">        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername("envy").password("1234").roles("admin").build());</span><br><span class="line">        return manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers("/vercode.jpg").permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .successHandler((request, response, authentication) -&gt; {</span><br><span class="line">                    response.setContentType("application/json;charset=utf-8");</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(new ObjectMapper().writeValueAsString(ResponseBean.ok("success", authentication.getPrincipal())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                })</span><br><span class="line">                .failureHandler((request, response, exception) -&gt; {</span><br><span class="line">                    response.setContentType("application/json;charset=utf-8");</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(new ObjectMapper().writeValueAsString(ResponseBean.error(exception.getMessage())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                })</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>接下来分析一下上述代码的含义：<br>（1）定义一个<code>passwordEncoder</code>方法，该方法用于返回一个不对密码进行加密的<code>PasswordEncoder</code>对象；<br>（2）定义一个<code>myAuthenticationProvider</code>方法，该方法用于返回一个<code>MyAuthenticationProvider</code>对象，这个对象设置了密码编码属性和用户详细信息。<br>（3）定义一个<code>authenticationManager</code>方法，该方法用于返回一个<code>AuthenticationManager</code>对象，请注意这个方法里面先构建一个<code>ProviderManager</code>对象，然后将之前自定义的<code>MyAuthenticationProvider</code>注入其中。<br>（4）定义一个<code>userDetailsService</code>方法，该方法用于返回一个<code>UserDetailsService</code>对象。请注意这里为了简单起见，我直接将用户存在了内存中，当然如果开发者想将其存在数据库中，可以参考之前的《Spring Data JPA操作数据库》一文。<br>（5）<code>configure(HttpSecurity http)</code>方法就是对资源进行控制，注意这个<code>/vercode.jpg</code>接口需要放开，任何人都可以访问。之后定义登录成功处理器以及失败处理器并显示对应的信息。</p><p>通过以上内容的配置，我们就能在不修改原来过滤器链的的情况下，又将自己自定义的验证码逻辑添加进去。</p><h5 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h5><p>接下来启动项目，开始进行测试。打开Postman，开始进行登录，首先输入正确的用户名和密码，但是输入错误的验证码，之后点击登录，可以发现现实“验证码错误”：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-d6c8b3a2072668bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-d6c8b3a2072668bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接下来直接访问<code>/vercode.jpg</code>接口，可以看到验证码图片显示正常：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-8160f445cabafe88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-8160f445cabafe88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后回到登录接口，这次输入正确的用户名+密码+验证码，可以看到用户登录成功了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6362fca97333cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-f6362fca97333cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>如果用户输入正确的用户名和验证码，但是输入错误的密码时，页面会显示如下信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-aea8f83062bb48db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-aea8f83062bb48db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>ok，那么本篇关于自定义认证逻辑的学习就到此为止，后续学习其他内容。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们对SpringSecurity中的登录流程进行了较为详细的分析，</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>令牌持久化和二次验证</title>
    <link href="http://envyzhan.asia/2020/12/18/springsecurity-12-token-persistence-and-secondary-verfication/"/>
    <id>http://envyzhan.asia/2020/12/18/springsecurity-12-token-persistence-and-secondary-verfication/</id>
    <published>2020-12-18T11:23:04.000Z</published>
    <updated>2021-03-01T08:07:59.447Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前一篇学习了如何实现自动登录，但是随之而来的是以牺牲系统安全为代价，这一点在很多场景下都是不可取的，因此就必须对自动登录的核心—令牌进行一些安全提升，或者采用二次验证等方式来提升系统的安全性。</p><h3 id="令牌持久化"><a href="#令牌持久化" class="headerlink" title="令牌持久化"></a>令牌持久化</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>前面提到过一个<code>makeTokenSignature()</code>方法，该方法的逻辑是计算令牌过期时间、用户名、密码和盐Key参数所构成字符串的哈希值：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected String makeTokenSignature(long tokenExpiryTime, String username, String password) {</span><br><span class="line">        String data = username + ":" + tokenExpiryTime + ":" + password + ":" + this.getKey();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance("MD5");</span><br><span class="line">            return new String(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">        } catch (NoSuchAlgorithmException var7) {</span><br><span class="line">            throw new IllegalStateException("No MD5 algorithm available!");</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以将其理解为是tokenValue，前面说过这个tokenValue默认存储在cookie中，这是非常不安全的，因此可以将其持久化到数据库中，同时添加新的校验参数，这样极大的提升了系统的安全性，而且对用户体验没有任何影响。</p><p>也就是说所谓的令牌持久化，其实就是在基本的自动登录功能上添加了新的校验参数而已，这样可提高系统的安全性。</p><p>在持久化令牌中，我们新增了两个经过MD5散列函数计算的校验参数：series和token。其中series是仅当用户在使用用户名和密码登录时，才会生成或者更新；而token则是只要有新的会话，它就会重新生成，这样做的好处就是可以避免一个用户同时在多端登录。以手机QQ为例，当用户在A手机登录，之后在B手机登录就会踢掉之前在A上的登录，这样可以发现账号是否泄漏，这也是禁止多端登录的一个比较通用做法。</p><p>通过前一篇《实现自动登录》一文的学习，我们知道自动化登录的具体处理类为<code>TokenBasedRememberMeServices</code>，而我们持久化令牌使用到的处理类为<code>PersistentTokenBasedRememberMeServices</code>，这个类怎么找到的呢？</p><p>首先通过<code>TokenBasedRememberMeServices</code>类知道它继承自抽象类<code>AbstractRememberMeServices</code>，之后通过查看这个抽象类的具体实现类就发现了这个<code>PersistentTokenBasedRememberMeServices</code>类，三者的继承关系如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-ad3feb673faf9a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-ad3feb673faf9a24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接下来查看一下这个<code>PersistentTokenBasedRememberMeServices</code>类的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class PersistentTokenBasedRememberMeServices extends AbstractRememberMeServices {</span><br><span class="line">    private PersistentTokenRepository tokenRepository = new InMemoryTokenRepositoryImpl();</span><br><span class="line">    private SecureRandom random = new SecureRandom();</span><br><span class="line">    public static final int DEFAULT_SERIES_LENGTH = 16;</span><br><span class="line">    public static final int DEFAULT_TOKEN_LENGTH = 16;</span><br><span class="line">    private int seriesLength = 16;</span><br><span class="line">    private int tokenLength = 16;</span><br><span class="line"></span><br><span class="line">    public PersistentTokenBasedRememberMeServices(String key, UserDetailsService userDetailsService, PersistentTokenRepository tokenRepository) {</span><br><span class="line">        //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        if (cookieTokens.length != 2) {</span><br><span class="line">            throw new InvalidCookieException("Cookie token did not contain 2 tokens, but contained '" + Arrays.asList(cookieTokens) + "'");</span><br><span class="line">        } else {</span><br><span class="line">            String presentedSeries = cookieTokens[0];</span><br><span class="line">            String presentedToken = cookieTokens[1];</span><br><span class="line">            PersistentRememberMeToken token = this.tokenRepository.getTokenForSeries(presentedSeries);</span><br><span class="line">            if (token == null) {</span><br><span class="line">                throw new RememberMeAuthenticationException("No persistent token found for series id: " + presentedSeries);</span><br><span class="line">            } else if (!presentedToken.equals(token.getTokenValue())) {</span><br><span class="line">                this.tokenRepository.removeUserTokens(token.getUsername());</span><br><span class="line">                throw new CookieTheftException(this.messages.getMessage("PersistentTokenBasedRememberMeServices.cookieStolen", "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack."));</span><br><span class="line">            } else if (token.getDate().getTime() + (long)this.getTokenValiditySeconds() * 1000L &lt; System.currentTimeMillis()) {</span><br><span class="line">                throw new RememberMeAuthenticationException("Remember-me login has expired");</span><br><span class="line">            } else {</span><br><span class="line">                this.logger.debug(LogMessage.format("Refreshing persistent login token for user '%s', series '%s'", token.getUsername(), token.getSeries()));</span><br><span class="line">                PersistentRememberMeToken newToken = new PersistentRememberMeToken(token.getUsername(), token.getSeries(), this.generateTokenData(), new Date());</span><br><span class="line"></span><br><span class="line">                try {</span><br><span class="line">                    this.tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate());</span><br><span class="line">                    this.addCookie(newToken, request, response);</span><br><span class="line">                } catch (Exception var9) {</span><br><span class="line">                    this.logger.error("Failed to update token: ", var9);</span><br><span class="line">                    throw new RememberMeAuthenticationException("Autologin failed due to data access problem");</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                return this.getUserDetailsService().loadUserByUsername(token.getUsername());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) {</span><br><span class="line">       //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {</span><br><span class="line">         //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected String generateSeriesData() {</span><br><span class="line">         //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected String generateTokenData() {</span><br><span class="line">         //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">         //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setSeriesLength(int seriesLength) {</span><br><span class="line">         //逻辑</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setTokenLength(int tokenLength) {</span><br><span class="line">        //逻辑</span><br><span class="line">    }</span><br><span class="line">    public void setTokenValiditySeconds(int tokenValiditySeconds) {</span><br><span class="line">         //逻辑</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这里将除了<code>processAutoLoginCookie</code>方法外的其余方法的具体逻辑给抹除了，仔细看这个<code>processAutoLoginCookie</code>方法的源码，可以发现它有一个<code>PersistentRememberMeToken</code>对象，查看一下这个对象的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PersistentRememberMeToken {</span><br><span class="line">    private final String username;</span><br><span class="line">    private final String series;</span><br><span class="line">    private final String tokenValue;</span><br><span class="line">    private final Date date;</span><br><span class="line"></span><br><span class="line">    public PersistentRememberMeToken(String username, String series, String tokenValue, Date date) {</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.series = series;</span><br><span class="line">        this.tokenValue = tokenValue;</span><br><span class="line">        this.date = date;</span><br><span class="line">    }</span><br><span class="line">    //getter和setter方法</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以发现这个类中除了用户名，还有series、tokenValue和date(上一次使用自动登录的时间)等属性，这就是持久化令牌时的实体类，后续会使用到这个类。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>接下来通过代码来学习持久化令牌的相关内容。</p><p>我们需要将令牌持久化到数据库中，因此需要定义一张表来记录令牌信息，这个表中的字段可以使用系统默认的字段，这就是上面所说的<code>PersistentRememberMeToken</code>类中的属性，当然也可以自定义。那么如何自定义呢？在此之前我们需要先分析系统是如何使用JDBC来操作默认字段的。</p><p>还是回到之前的<code>PersistentTokenBasedRememberMeServices#processAutoLoginCookie()</code>方法中，可以看到在获取<code>PersistentRememberMeToken</code>对象时，使用的代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersistentRememberMeToken token = this.tokenRepository.getTokenForSeries(presentedSeries);</span><br></pre></td></tr></tbody></table></figure></div><p>如果你使用过JDBC或者JPA那么知道这里的tokenRepository就是数据库提供的操作对象，点进去查看它的源码，可以看到它跳到如下位置：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private PersistentTokenRepository tokenRepository = new InMemoryTokenRepositoryImpl();</span><br></pre></td></tr></tbody></table></figure></div><p>显然左侧的<code>PersistentTokenRepository</code>是一个接口，右侧的<code>InMemoryTokenRepositoryImpl</code>就是该接口的一个实现类，且是基于内存的Token操作，而这里我们学习的是数据库，因此猜测这个<code>PersistentTokenRepository</code>接口应该有一个用于数据库操作的实现类，查看一下，可以发现确实存在<code>JdbcTokenRepositoryImpl</code>这个实现类。源码看多了，这种其实很容易就能猜的出来。查看一下这个<code>JdbcTokenRepositoryImpl</code>的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTokenRepositoryImpl extends JdbcDaoSupport implements PersistentTokenRepository {</span><br><span class="line">    public static final String CREATE_TABLE_SQL = "create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)";</span><br><span class="line">    public static final String DEF_TOKEN_BY_SERIES_SQL = "select username,series,token,last_used from persistent_logins where series = ?";</span><br><span class="line">    public static final String DEF_INSERT_TOKEN_SQL = "insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)";</span><br><span class="line">    public static final String DEF_UPDATE_TOKEN_SQL = "update persistent_logins set token = ?, last_used = ? where series = ?";</span><br><span class="line">    public static final String DEF_REMOVE_USER_TOKENS_SQL = "delete from persistent_logins where username = ?";</span><br><span class="line">    private String tokensBySeriesSql = "select username,series,token,last_used from persistent_logins where series = ?";</span><br><span class="line">    private String insertTokenSql = "insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)";</span><br><span class="line">    private String updateTokenSql = "update persistent_logins set token = ?, last_used = ? where series = ?";</span><br><span class="line">    private String removeUserTokensSql = "delete from persistent_logins where username = ?";</span><br><span class="line">    private boolean createTableOnStartup;</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>是不是感觉这个页面非常熟悉？是的，在前面学习数据库认证的时候就是这样，可以看到这里面定义的都是一些SQL语句，而通过语句中的内容开发者就能分析出系统默认表的结构。</p><p>结合笔者分析出的信息及自定义SQL语句等，可以得到我们所需的数据表：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use envysecurity;</span><br><span class="line">drop table if exists persistent_logins;</span><br><span class="line">create table persistent_logins (</span><br><span class="line">username varchar(64) not null, </span><br><span class="line">series varchar(64) primary key, </span><br><span class="line">token varchar(64) not null, </span><br><span class="line">last_used timestamp not null</span><br><span class="line">)engine=INNODB default charset=utf8;</span><br></pre></td></tr></tbody></table></figure></div><p>由于需要将数据存到数据库中，因此需要在项目的pom.xml依赖文件中新增如下依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure></div><p>接着修改application.yml文件中的内容为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: "envythink"</span><br><span class="line">      password: "1234"</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:///envysecurity?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br></pre></td></tr></tbody></table></figure></div><p>然后修改MySecurityConfig类的信息为如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MySecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository(){</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .rememberMe()</span><br><span class="line">                .key("envy")</span><br><span class="line">                .tokenRepository(jdbcTokenRepository())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们往MySecurityConfig类中新增了如下代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">JdbcTokenRepositoryImpl jdbcTokenRepository(){</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    return jdbcTokenRepository;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key("envy")</span><br><span class="line">            .tokenRepository(jdbcTokenRepository())</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到我们首先注入一个DataSource对象，然后提供一个JdbcTokenRepositoryImpl实例，并将注入的DataSource对象作为数据源赋值给JdbcTokenRepositoryImpl实例，接着通过调用<code>.tokenRepository(jdbcTokenRepository())</code>方法传入PersistentTokenRepository对象，这样我们就完成了持久化的配置工作。</p><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>接下来启动项目，然后访问<code>http://localhost:8080/hello</code>接口，此时页面会自动跳转到登录页面，之后我们输入用户名和密码，并勾选“记住我”选框，登录成功后，系统就显示“Hello,World!”，这就说明我们上面配置的持久化令牌就已经生效了。</p><p>查看一下此时的令牌信息，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-be113d6358bc7989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-be113d6358bc7989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>也就是说此时令牌信息为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JTJGc1YlMkZoRjNGWjZDMWV1NGRkYXp2alElM0QlM0Q6UmUyQU9vQmg0c1Zqa1hwTzJXJTJGY05BJTNEJTNE</span><br></pre></td></tr></tbody></table></figure></div><p>将这个令牌使用MD5进行解密，发现解密后的信息如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%2FsV%2FhF3FZ6C1eu4ddazvjQ%3D%3D:Re2AOoBh4sVjkXpO2W%2FcNA%3D%3D</span><br></pre></td></tr></tbody></table></figure></div><p>请注意其中的<code>%2F</code>表示<code>/</code>，<code>%3D</code>表示<code>=</code>，因此上面的令牌其实就是如下的字符串：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sV/hF3FZ6C1eu4ddazvjQ==:Re2AOoBh4sVjkXpO2W/cNA==</span><br></pre></td></tr></tbody></table></figure></div><p>接着查看一下数据库，可以发现此时数据中已经生成了一条记录：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-67da58560fd7c3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-67da58560fd7c3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到此时数据库中的记录和之前我们通过解析得到的RememberMe令牌信息是一致的，也就说明我们令牌持久化的配置是成功的。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h5 id="令牌生成过程"><a href="#令牌生成过程" class="headerlink" title="令牌生成过程"></a>令牌生成过程</h5><p>接下来将对上述“令牌持久化”功能进行源码分析，主要涉及到两个过程：一个是remember-me令牌生成过程；另一个是remember-me令牌解析过程。可以发现这个和之前“自动登录”功能的流程基本上是一致的，只是实现类由<code>TokenBasedRememberMeServices</code>变为<code>PersistentTokenBasedRememberMeServices</code>。尽管<code>PersistentTokenBasedRememberMeServices</code>类的源码在前面已经贴出了，但是既然是源码分析，那么就有必要再次对该源码进行阅读。这里贴出几个需要分析的方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) {</span><br><span class="line">    String username = successfulAuthentication.getName();</span><br><span class="line">    this.logger.debug(LogMessage.format("Creating new persistent login for user %s", username));</span><br><span class="line">    PersistentRememberMeToken persistentToken = new PersistentRememberMeToken(username, this.generateSeriesData(), this.generateTokenData(), new Date());</span><br><span class="line"></span><br><span class="line">    try {</span><br><span class="line">        this.tokenRepository.createNewToken(persistentToken);</span><br><span class="line">        this.addCookie(persistentToken, request, response);</span><br><span class="line">    } catch (Exception var7) {</span><br><span class="line">        this.logger.error("Failed to save persistent token ", var7);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">protected String generateSeriesData() {</span><br><span class="line">    byte[] newSeries = new byte[this.seriesLength];</span><br><span class="line">    this.random.nextBytes(newSeries);</span><br><span class="line">    return new String(Base64.getEncoder().encode(newSeries));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">protected String generateTokenData() {</span><br><span class="line">    byte[] newToken = new byte[this.tokenLength];</span><br><span class="line">    this.random.nextBytes(newToken);</span><br><span class="line">    return new String(Base64.getEncoder().encode(newToken));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">    this.setCookie(new String[]{token.getSeries(), token.getTokenValue()}, this.getTokenValiditySeconds(), request, response);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>简单分析一下上述方法：<br>（1）由于令牌持久化的前提是用户已经登录成功，因此需要从登录的认证信息中获取用户名，也就是username。<br>（2）构造一个<code>PersistentRememberMeToken</code>对象，分别调用<code>generateSeriesData()</code>、<code>generateTokenData()</code>方法来获取series和token信息。查看一下<code>generateSeriesData()</code>方法的源码，可以发现它首先定义一个byte[]类型的数组，之后调用<code>random.nextBytes()</code>方法来生成随机数，请注意这里的random其实是SecureRandom对象，不同于以前使用的<code>Math.random</code>或者<code>java.util.Random</code>伪随机数，SecureRandom采用的是类似于密码学的随机数生成规则，因此输出的结果难以预测，安全性较高。之后在使用Base64对生成的随机数进行编码，最后进行返回。<br>（3）回到onLoginSuccess方法中，继续往下看，之后调用<code>tokenRepository.createNewToken(persistentToken)</code>方法将PersistentRememberMeToken对象存入数据库中。其实这里的<code>tokenRepository</code>对象就是前面创建的<code>JdbcTokenRepositoryImpl</code>对象。<br>（4）调用<code>addCookie()</code>方法将之前创建的<code>PersistentRememberMeToken</code>对象添加到cookie中，可以查看这个<code>addCookie()</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void addCookie(PersistentRememberMeToken token, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        this.setCookie(new String[]{token.getSeries(), token.getTokenValue()}, this.getTokenValiditySeconds(), request, response);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>从上述源码就能知道这个Cookie是一个字符串类型的数组，且数组中的元素分别为series、tokenValue、tokenValiditySeconds等信息。</p><h5 id="令牌解析过程"><a href="#令牌解析过程" class="headerlink" title="令牌解析过程"></a>令牌解析过程</h5><p>说完了令牌的生成过程，接下来开始学习令牌的解析过程，也就是如何从持久化的令牌中获取用户信息。此时就需要阅读<code>PersistentTokenBasedRememberMeServices</code>类中<code>processAutoLoginCookie()</code>方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        if (cookieTokens.length != 2) {</span><br><span class="line">            throw new InvalidCookieException("Cookie token did not contain 2 tokens, but contained '" + Arrays.asList(cookieTokens) + "'");</span><br><span class="line">        } else {</span><br><span class="line">            String presentedSeries = cookieTokens[0];</span><br><span class="line">            String presentedToken = cookieTokens[1];</span><br><span class="line">            PersistentRememberMeToken token = this.tokenRepository.getTokenForSeries(presentedSeries);</span><br><span class="line">            if (token == null) {</span><br><span class="line">                throw new RememberMeAuthenticationException("No persistent token found for series id: " + presentedSeries);</span><br><span class="line">            } else if (!presentedToken.equals(token.getTokenValue())) {</span><br><span class="line">                this.tokenRepository.removeUserTokens(token.getUsername());</span><br><span class="line">                throw new CookieTheftException(this.messages.getMessage("PersistentTokenBasedRememberMeServices.cookieStolen", "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack."));</span><br><span class="line">            } else if (token.getDate().getTime() + (long)this.getTokenValiditySeconds() * 1000L &lt; System.currentTimeMillis()) {</span><br><span class="line">                throw new RememberMeAuthenticationException("Remember-me login has expired");</span><br><span class="line">            } else {</span><br><span class="line">                this.logger.debug(LogMessage.format("Refreshing persistent login token for user '%s', series '%s'", token.getUsername(), token.getSeries()));</span><br><span class="line">                PersistentRememberMeToken newToken = new PersistentRememberMeToken(token.getUsername(), token.getSeries(), this.generateTokenData(), new Date());</span><br><span class="line"></span><br><span class="line">                try {</span><br><span class="line">                    this.tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate());</span><br><span class="line">                    this.addCookie(newToken, request, response);</span><br><span class="line">                } catch (Exception var9) {</span><br><span class="line">                    this.logger.error("Failed to update token: ", var9);</span><br><span class="line">                    throw new RememberMeAuthenticationException("Autologin failed due to data access problem");</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                return this.getUserDetailsService().loadUserByUsername(token.getUsername());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>分析一下上述方法的执行逻辑：<br>（1）前面我们通过调用<code>addCookie()</code>方法将之前创建的<code>PersistentRememberMeToken</code>对象添加到cookie中，因此首先判断这个从前端传来的cookie的长度，如果长度不为2，则说明至少缺失series或者tokenValue中的任何一个，因此必须抛出异常，无法进行后续的验证。<br>（2）从cookieTokens中取出series和tokenValue信息，请注意这里就需要使用到前面的元素序号了。<br>（3）根据（2）中获取的series信息来调用<code>tokenRepository.getTokenForSeries()</code>方法，进而获取一个<code>PersistentRememberMeToken</code>对象。<br>（4）判断（3）中得到的<code>PersistentRememberMeToken</code>对象是否为空，如果为空则抛出异常，否则判断<code>PersistentRememberMeToken</code>对象中的tokenValue与之前从前端中传来tokenValue是否相同，如果不相同，则说明账号可能被盗用了（因为只要有新的会话，token就会更新），因此就需要根据用户名来移除相应的token，此时用户就只能通过用户名+密码的方式来重新登录，进而获取新的自动登录权限。<br>（5）之后进行token是否过期判断，逻辑是通过token生成时间+过期期限的值是否大于当前时间，如果大于则说明此时token还能继续使用，否则说明token已经过期，无法使用。<br>（6）以上验证通过后，接下来构造一个PersistentRememberMeToken对象，并调用<code>tokenRepository.updateToken()</code>方法来更新数据库中的token，这样就能发现当有一个新的会话诞生时，就会生成一个与之对应的token。<br>（7）调用<code>addCookie()</code>方法将新生成的token放入其中。<br>（8）最后再通过用户名来查询用户信息，之后再进行登录操作。</p><p>通过以上的分析，相信大家对“令牌持久化”有了一个较为清晰的认识。通过“令牌持久化”，相比于之前的登录安全性，它提升了不止一个等级，但是“令牌持久化”依旧存在用户身份被盗用的问题，这个问题其实是非常难解决的，只能说是最大限度降低被盗发生的可能性。</p><h1 id="二次校验"><a href="#二次校验" class="headerlink" title="二次校验"></a>二次校验</h1><p>除了前面学习的“令牌持久化”方式，这里还提供另一种方式—二次校验。</p><p>我们知道此处引入自动登录的初心是为了提升用户体验，让用户在第一次访问某个页面时，通过输入用户名和密码完成登录后，此后在一定的时间期限内，再次访问该页面则无需登录。但是自动登录又引入了安全风险，这是我们不想看到的。我们希望如果用户使用了自动登录功能，那么只允许它做一些常规的不敏感操作，比如浏览普通页面，查看数据等，但是不允许用户对页面和数据进行修改、删除等操作。且如果用户非要对页面和数据进行修改、删除等操作时，我们可以让页面跳转到登录页面，让用户重新输入密码来验证身份，身份验证通过后再允许它执行一些敏感操作，这就是二次校验的逻辑。</p><p>“二次校验”比较经典的应用例子就是GitHub仓库，当开发者需要删除某个仓库时，页面就会跳转到输入用户密码的界面，之后用户输入密码并验证通过后才能删除该仓库。当然偶尔也是输入仓库名称来防止用户误删除仓库，这些都是比较常见的应用场景。</p><p>为了后续项目的演示效果，这里需要提供三个接口。在controller包内新建一个HelloController类，之后在该类中新增如下方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "Hello,World!";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("/book")</span><br><span class="line">    public String book(){</span><br><span class="line">        return "Hello,Book!";</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @GetMapping("/movie")</span><br><span class="line">    public String movie(){</span><br><span class="line">        return "Hello,Movie!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>对三个接口的描述如下：<br>（1）<code>/hello</code>接口，它是只要用户认证后就能访问（即用户成功登陆），注意无论是通过用户名+密码认证还是自动认证，只要通过认证，那么就能访问。<br>（2）<code>/book</code>接口，它必须是用户通过用户名+密码认证后才能访问，也就是说用户通过自动登录方式认证的，它是无法访问到该接口的。<br>（3）<code>/movie</code>接口，它必须是用户通过自动认证后才能访问，也就是说用户通过用户名+密码登录方式认证的，它是无法访问到该接口的。</p><p>在完成了上述三个接口的定义后，接下来就进行配置，让上述三个接口按照既定逻辑生效。修改MySecurityConfig类中<code>configure(HttpSecurity http)</code>方法的代码为如下所示信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers("/movie").rememberMe()</span><br><span class="line">            .antMatchers("/book").fullyAuthenticated()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key("envy")</span><br><span class="line">            .tokenRepository(jdbcTokenRepository())</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>简单介绍一下上述添加的配置：<br>（1）<code>.antMatchers("/movie").rememberMe()</code>配置表示<code>/movie</code>接口是<code>rememberMe</code>才能访问，即“自动登录”。查看一下这个rememberMe方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry rememberMe() {</span><br><span class="line">            return this.access("rememberMe");</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它其实是调用了access方法来表示只有”rememberMe”的方式才能认证。<br>（2）<code>.antMatchers("/book").fullyAuthenticated()</code>配置表示<code>/book</code>接口是<code>fullyAuthenticated</code>才能访问，即“全登录”，它不包括自动登录的方式。查看一下这个<code>fullyAuthenticated</code>方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry fullyAuthenticated() {</span><br><span class="line">            return this.access("fullyAuthenticated");</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure></div><p>其实<code>ExpressionUrlAuthorizationConfigurer</code>这个类中名为AuthorizedUrl的内部类中提供了很多认证方式，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry permitAll() {</span><br><span class="line">    return this.access("permitAll");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry anonymous() {</span><br><span class="line">    return this.access("anonymous");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry rememberMe() {</span><br><span class="line">    return this.access("rememberMe");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry denyAll() {</span><br><span class="line">    return this.access("denyAll");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry authenticated() {</span><br><span class="line">    return this.access("authenticated");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry fullyAuthenticated() {</span><br><span class="line">    return this.access("fullyAuthenticated");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面这些都是默认提供的，分别表示所有请求都允许访问（需登录）、匿名访问（无需登录）、记住我登录、禁止访问所有、需要认证（需登录）和全认证（不包括自动登录）。</p><p>（3）<code>.anyRequest().authenticated()</code>配置表示其余所有的接口都是需要认证后才能访问，即登录后才能访问。</p><p>之后开发者注释掉之前使用“令牌持久化”的相关代码，重启项目，之后访问<code>/hello</code>接口，页面就会跳转到登录页面，用户输入密码并勾选“记住我”，点击登录，之后页面会显示<code>/hello</code>接口的内容，同时可以发现也能访问<code>/book</code>接口，但是用户无法访问<code>/movie</code>接口。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前一篇学习了如何实现自动登录，但是随之而来的是以牺牲系统安全为代价，这一点</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
  <entry>
    <title>实现自动登录</title>
    <link href="http://envyzhan.asia/2020/12/17/springsecurity-11-automatic-login/"/>
    <id>http://envyzhan.asia/2020/12/17/springsecurity-11-automatic-login/</id>
    <published>2020-12-17T11:23:04.000Z</published>
    <updated>2021-03-01T08:06:13.588Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面对登录流程进行了较为细致的学习之后，接下来实现一个常用的功能—自动登录。请注意本篇新建了一个工程auto-login，不再使用之前的代码。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>以常用的QQ邮箱为例，如下所示界面就是支持自动登录：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a318bbe3f4e61f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a318bbe3f4e61f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>不仅仅是这里举例的QQ邮箱，很多网站都有这个功能。对于用户来说，每次登录都需要输出用户名和密码不仅增加了登录难度，降低用户体验，更重要的是账号被盗的风险也随之提升。</p><p>自动登录，说白了就是用户在登录成功后，那么在接下来的一段时间里，就算发生了诸如用户关闭浏览器、服务器宕机重启等行为时，此时用户依旧可以保持之前的登录状态，而不用重新登录。SpringSecurity对于自动登录提供了简易的配置方式，开发者通过简单的一些配置就能实现较为复杂的自动登录功能。</p><h3 id="工程初始化"><a href="#工程初始化" class="headerlink" title="工程初始化"></a>工程初始化</h3><p>第一步，使用IDEA创建一个名为<code>auto-login</code>的SpringBoot工程，之后选择添加Web和SpringSecurity依赖。</p><p>第二步，在<code>application.yml</code>配置文件中新增如下配置信息，用于自定义登录用户名和密码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: "envythink"</span><br><span class="line">      password: "1234"</span><br></pre></td></tr></tbody></table></figure></div><p>第三步，新建controller包，并在里面新建一个<code>HelloController</code>类，简单起见里面只提供一个<code>/hello</code>接口，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "Hello,World!";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第四步，新建config包，并在里面新建一个<code>MySecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，并实现其中的<code>configure(HttpSecurity http)</code>方法，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MySecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第五步，启动项目进行测试。访问<code>http://localhost:8080/hello</code>链接，可以看到首先会跳转到登录页面：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-fdb8aa713a5eb4ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-fdb8aa713a5eb4ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>之后输入第二步中配置的用户名和密码，点击登录，之后页面就跳转到<code>http://localhost:8080/hello</code>链接界面，进而显示<code>/hello</code>接口的信息：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-cb6a552a6f5cbb7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-cb6a552a6f5cbb7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>上面是一个非常简单的SpringSecurity使用的例子，接下来就在此基础上实现“自动登录”功能。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>“自动登录”在SpringSecurity中被称为“记住我”，想实现“记住我”这个功能，开发者只需在SpringSecurity Config配置类中的<code>configure(HttpSecurity http)</code>方法中添加<code>.rememberMe()</code>配置方法即可，注意添加的位置：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-b931908ae72022da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-b931908ae72022da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>只需添加一个方法就能实现“自动登录”，接下来进行验证。重启项目，之后继续访问<code>http://localhost:8080/hello</code>链接，可以看到此时登录页面就出现了“自动登录”这一提示框：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-7ba110aac267eb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-7ba110aac267eb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>输入之前配置的用户名和密码，并勾选“记住我”选框，点击登录可以发现出错了：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: UserDetailsService is required.</span><br></pre></td></tr></tbody></table></figure></div><p>原因在于用户未提供一个UserDetailsService实例，因此抛出异常。</p><h3 id="提供一个UserDetailsService实例"><a href="#提供一个UserDetailsService实例" class="headerlink" title="提供一个UserDetailsService实例"></a>提供一个UserDetailsService实例</h3><p>出于简单考虑，这里就不使用数据库，而是直接将查询用户信息的逻辑固定化。</p><p>第一步，新建一个entity包，并在里面新建一个User实体类，注意它需要实现<code>UserDetails</code>接口，并实现其中的抽象方法。简单起见里面只提供两个属性，除了返回用户名和密码，其余方法都设置为true，这样便于后续测试，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class User implements UserDetails {</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public User(String username, String password) {</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() {</span><br><span class="line">        return password;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() {</span><br><span class="line">        return username;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>第二步，新建一个service包，并在里面新建一个<code>MyUserDetailsService</code>类，注意它需要实现<code>UserDetailsService</code>接口，并实现其中的抽象方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyUserDetailsService implements UserDetailsService {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {</span><br><span class="line">        if(!"envythink".equals(username)){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        return new User("envythink","1234");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>第三步，新建一个config包，并在里面新建一个<code>MySecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，并实现其中的抽象方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MySecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder(){</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception {</span><br><span class="line">        auth.userDetailsService(myUserDetailsService);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .rememberMe()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="重启项目"><a href="#重启项目" class="headerlink" title="重启项目"></a>重启项目</h3><p>在完成上述步骤后，接下来就重新启动项目，继续访问<code>http://localhost:8080/hello</code>链接，可以看到此时登录页面依旧出现了“自动登录”这一提示框：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-7ba110aac267eb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-7ba110aac267eb32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>输入之前配置的用户名和密码，并勾选“记住我”选框，点击登录可以发现现在系统是登录成功了：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-d0b88aead491e403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-d0b88aead491e403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>可以看到此处的登录表单中有三个输入控件，且name属性分别为username、password和remember-me，也就是说当开发者需要自定义登录页面，那么此时控件的name属性必须与前述三者保持一致。</p><p>登录成功后，页面会自动跳转到<code>/hello</code>接口，同时我们发现此时系统在访问<code>/hello</code>接口的时候，是携带了Cookie信息，如下所示：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-facf34c52e280241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-facf34c52e280241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>放大一下，可以看到里面有一个以<code>remember-me</code>为Key的键值对，而这个键值对就保存了用户信息，这个后续会详解：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-bff70082991d6bed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-bff70082991d6bed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>接下来我们关闭浏览器，之后再次重新打开浏览器。正常来说，当用户关闭浏览器，再次访问<code>/hello</code>接口时，系统会要求用户重新登录的，但是如果使用了“记住我”这一功能，那么此时用户就可以访问<code>/hello</code>接口，而不用重新登录，这也就说明我们设置的RememberMe功能生效了，即用户下次就可以自动登录。</p><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p>接下来将对上述“自动登录”功能的流程进行梳理，首先来看之前提到的Cookie，里面有一个以<code>remember-me</code>为Key的键值对，信息如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remember-me=ZW52eXRoaW5rOjE2MTEyOTQ3OTgwMDI6NGFlZTYxYzMwNzFmMTg1NDJiOWQwY2Y4NzE1Yjk1ZjI</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这里的Value是一串使用Base64加密的字符串，开发者可以使用一些在线的解码工具来解码，当然了也可以自己提供一个方法来进行转码。在项目测试类中新建如下方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class AutoLoginApplicationTests {</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() {</span><br><span class="line">        String s = new String(Base64.getDecoder().decode("ZW52eXRoaW5rOjE2MTEyOTQ3OTgwMDI6NGFlZTYxYzMwNzFmMTg1NDJiOWQwY2Y4NzE1Yjk1ZjI"));</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>之后执行该方法，可以看到控制台输出以下信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">envythink:1611294798002:4aee61c3071f18542b9d0cf8715b95f2</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到这个Base64字符串被<code>:</code>号分隔为3部分，第一部分是用户名，这个就是之前输入的；第二部分非常像一个时间戳，通过时间戳转换工具可以知道，它的确是时间戳，且值为当前登录时间+2周的时间；第三部分是使用MD5哈希函数计算出来的值，也就是说它是一个加密值，它的明文格式如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username + ":" +tokenExpiryTime + ":" + password + ":" + key</span><br></pre></td></tr></tbody></table></figure></div><p>最后的key是盐值，用于防止令牌被修改，这些在前面学习Shiro框架的时候笔者都已经介绍过，因此这里就不再详细介绍。</p><p>因此上面“自动登录”的完整流程是：用户访问<code>/hello</code>接口，系统自动跳转到登录页面，用户输入用户名和密码，并勾选“记住我”之后，系统验证登录成功，页面将Remember-Me键值对添加到Cookie中，并携带Cookie自动跳转到<code>/hello</code>接口页面。之后用户关闭浏览器，并重新打开，再去访问<code>/hello</code>接口，此时会携带Cookie中的Remember-Me键值对到服务端，之后服务端会将其进行计算，进而得到用户名和过期时间，之后再根据用户名来查询用户密码，接着通过md5哈希函数来计算得到哈希值，然后再将计算出的哈希值和浏览器传递来的哈希值进行对比，进而确认此令牌是否有效。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>接下来将对上述“自动登录”功能进行源码分析，主要涉及到两个过程：一个是<code>remember-me</code>令牌生成过程；另一个是<code>remember-me</code>令牌解析过程。</p><h5 id="remember-me令牌生成过程"><a href="#remember-me令牌生成过程" class="headerlink" title="remember-me令牌生成过程"></a><code>remember-me</code>令牌生成过程</h5><p><code>remember-me</code>令牌的生成主要在<code>TokenBasedRememberMeServices#onLoginSuccess</code>方法内进行的，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void onLoginSuccess(HttpServletRequest request, HttpServletResponse response, Authentication successfulAuthentication) {</span><br><span class="line">        String username = this.retrieveUserName(successfulAuthentication);</span><br><span class="line">        String password = this.retrievePassword(successfulAuthentication);</span><br><span class="line">        if (!StringUtils.hasLength(username)) {</span><br><span class="line">            this.logger.debug("Unable to retrieve username");</span><br><span class="line">        } else {</span><br><span class="line">            if (!StringUtils.hasLength(password)) {</span><br><span class="line">                UserDetails user = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">                password = user.getPassword();</span><br><span class="line">                if (!StringUtils.hasLength(password)) {</span><br><span class="line">                    this.logger.debug("Unable to obtain password for user: " + username);</span><br><span class="line">                    return;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            int tokenLifetime = this.calculateLoginLifetime(request, successfulAuthentication);</span><br><span class="line">            long expiryTime = System.currentTimeMillis();</span><br><span class="line">            expiryTime += 1000L * (long)(tokenLifetime &lt; 0 ? 1209600 : tokenLifetime);</span><br><span class="line">            String signatureValue = this.makeTokenSignature(expiryTime, username, password);</span><br><span class="line">            this.setCookie(new String[]{username, Long.toString(expiryTime), signatureValue}, tokenLifetime, request, response);</span><br><span class="line">            if (this.logger.isDebugEnabled()) {</span><br><span class="line">                this.logger.debug("Added remember-me cookie for user '" + username + "', expiry: '" + new Date(expiryTime) + "'");</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>分析一下上述方法的执行逻辑：<br><strong>（1）</strong>通过<code>retrieveUserName()</code>和<code>retrievePassword()</code>方法从登录成功的<code>successfulAuthentication</code>对象中取出用户和密码。先查看一下<code>retrieveUserName()</code>方法的源码，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String retrieveUserName(Authentication authentication) {</span><br><span class="line">        return this.isInstanceOfUserDetails(authentication) ? ((UserDetails)authentication.getPrincipal()).getUsername() : authentication.getPrincipal().toString();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它需要传入一个<code>Authentication</code>对象，之后调用<code>isInstanceOfUserDetails()</code>方法来判断这个对象是否是<code>UserDetails</code>类的实例（这里肯定是的，因为我们自定义的User实体类就是继承于<code>UserDetails</code>类）。查看一下这个<code>isInstanceOfUserDetails()</code>方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private boolean isInstanceOfUserDetails(Authentication authentication) {</span><br><span class="line">        return authentication.getPrincipal() instanceof UserDetails;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>准确说是判断<code>Authentication#getPrincipal()</code>方法得到的对象是否是<code>UserDetails</code>类的实例，是就返回true，否则就是false。之后<code>retrieveUserName()</code>方法就根据<code>Authentication#getPrincipal()</code>方法的返回结果来进行取值。<br><strong>（2）</strong>之后判断用户名和密码是否存在，请注意，由于登录成功后，密码可能会被擦除，因此如果（1）中没有获取到用户密码，那么就需要再次从<code>UserDetailsService</code>对象中根据用户名来获取用户密码。<br><strong>（3）</strong>调用<code>calculateLoginLifetime()</code>方法来获取令牌的有效期，前面说过令牌默认有效期就是两周（这里的时间戳1209600就是两周）。<br><strong>（4）</strong>调用<code>System.currentTimeMillis()</code>方法来获取当前系统的时间戳，之后在此基础上加上（3）中得到的令牌有效期，其实就是在当前时间添加两周时间。<br><strong>（5）</strong>调用<code>makeTokenSignature()</code>方法来计算哈希值，查看一下该方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected String makeTokenSignature(long tokenExpiryTime, String username, String password) {</span><br><span class="line">        String data = username + ":" + tokenExpiryTime + ":" + password + ":" + this.getKey();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance("MD5");</span><br><span class="line">            return new String(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">        } catch (NoSuchAlgorithmException var7) {</span><br><span class="line">            throw new IllegalStateException("No MD5 algorithm available!");</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它通过构建一个包含用户名、令牌有效期、密码和盐的字符串，之后计算该字符串的哈希值。请注意，如果开发者没有设置这个盐Key，那么它默认使用的是<code>RememberMeConfigurer#getKey()</code>方法。我尝试在<code>TokenBasedRememberMeServices</code>类中查找<code>getKey()</code>方法，但是并没有发现，于是在该类的父类及其其他实现类中进行查询，依旧还是没有，最终通过查阅文档发现它调用的居然是<code>RememberMeConfigurer#getKey()</code>方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private String getKey() {</span><br><span class="line">        if (this.key == null) {</span><br><span class="line">            if (this.rememberMeServices instanceof AbstractRememberMeServices) {</span><br><span class="line">                this.key = ((AbstractRememberMeServices)this.rememberMeServices).getKey();</span><br><span class="line">            } else {</span><br><span class="line">                this.key = UUID.randomUUID().toString();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      return this.key;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以看到它其实是一串UUID字符串。请注意，由于这里使用的UUID字符串，而它是一个随机字符串，那么就会有一个问题，每次重启服务端这个Key就会变化，这样肯定会导致之前生成的所有<code>remember-me</code>自动登录令牌失效，因此开发者应当指定Key的值。</p><p>开发者只需在<code>MySecurityConfig#configure(HttpSecurity http)</code>中添加一个<code>.key()</code>方法，注意添加的位置：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-a41021bf3b86b1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" data-fancybox="group" data-caption="undefined" class="fancybox"><img class="mediumZoom lazyload" data-src="https://upload-images.jianshu.io/upload_images/8964398-a41021bf3b86b1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p>这样用户配置了Key，那么即使用户关闭浏览器和重启服务器，此时访问<code>/hello</code>接口也是不需要登录的。</p><p><strong>（6）</strong>回到<code>onLoginSuccess()</code>方法中，可以看到它调用<code>setCookie()</code>方法将用户名、令牌过期时间和<strong>（5）</strong>中得到的哈希值作为参数传入：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setCookie(new String[]{username, Long.toString(expiryTime), signatureValue}</span><br></pre></td></tr></tbody></table></figure></div><p>以上就是<code>remember-me</code>令牌生成的过程，接下来结合之前《详解登录流程》一文来梳理整个登录流程，这里简单列举该过程中涉及到的类，如下所示：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbstractAuthenticationProcessingFilter#doFilter -&gt;</span><br><span class="line">AbstractAuthenticationProcessingFilter#successfulAuthentication -&gt;</span><br><span class="line">AbstractRememberMeServices#loginSuccess -&gt;</span><br><span class="line">TokenBasedRememberMeServices#onLoginSuccess</span><br></pre></td></tr></tbody></table></figure></div><h5 id="remember-me令牌解析过程"><a href="#remember-me令牌解析过程" class="headerlink" title="remember-me令牌解析过程"></a><code>remember-me</code>令牌解析过程</h5><p>接下来分析当用户关闭浏览器，之后打开再次访问<code>/hello</code>接口，或者开发者重启服务器时，用户“自动登录”这一流程。</p><p>前面提到过SpringSecurity中的一系列功能都是通过一个过滤器链来实现的，此处的RememberMe功能亦是如此。那么问题来了，用的哪个过滤器链呢？前面登录使用的是<code>UsernamePasswordAuthenticationFilter</code>类，类比一下，RememberMe功能是不是使用了<code>RememberMeAuthenticationFilter</code>?找一下，可以发现确实存在这个类，而且就是这个类提供的过滤器链，因为里面也有doFilter方法，查看一下该doFilter方法的源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {</span><br><span class="line">        if (SecurityContextHolder.getContext().getAuthentication() != null) {</span><br><span class="line">            this.logger.debug(LogMessage.of(() -&gt; {</span><br><span class="line">                return "SecurityContextHolder not populated with remember-me token, as it already contained: '" + SecurityContextHolder.getContext().getAuthentication() + "'";</span><br><span class="line">            }));</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        } else {</span><br><span class="line">            Authentication rememberMeAuth = this.rememberMeServices.autoLogin(request, response);</span><br><span class="line">            if (rememberMeAuth != null) {</span><br><span class="line">                try {</span><br><span class="line">                    rememberMeAuth = this.authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);</span><br><span class="line">                    this.onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line">                    this.logger.debug(LogMessage.of(() -&gt; {</span><br><span class="line">                        return "SecurityContextHolder populated with remember-me token: '" + SecurityContextHolder.getContext().getAuthentication() + "'";</span><br><span class="line">                    }));</span><br><span class="line">                    if (this.eventPublisher != null) {</span><br><span class="line">                        this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(SecurityContextHolder.getContext().getAuthentication(), this.getClass()));</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    if (this.successHandler != null) {</span><br><span class="line">                        this.successHandler.onAuthenticationSuccess(request, response, rememberMeAuth);</span><br><span class="line">                        return;</span><br><span class="line">                    }</span><br><span class="line">                } catch (AuthenticationException var6) {</span><br><span class="line">                    this.logger.debug(LogMessage.format("SecurityContextHolder not populated with remember-me token, as AuthenticationManager rejected Authentication returned by RememberMeServices: '%s'; invalidating remember-me token", rememberMeAuth), var6);</span><br><span class="line">                    this.rememberMeServices.loginFail(request, response);</span><br><span class="line">                    this.onUnsuccessfulAuthentication(request, response, var6);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>分析一下上述方法的执行逻辑：<br><strong>（1）</strong>第一行代码非常熟悉，前面多次提到开发者可以从中获取用户的登录信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecurityContextHolder.getContext().getAuthentication()</span><br></pre></td></tr></tbody></table></figure></div><p>如果开发者无法从<code>SecurityContextHolder</code>中获取登录信息，那么就需要调用<code>rememberMeServices.autoLogin()</code>方法进行用户登录，查看一下该方法的源码，注意该方法实现类为<code>AbstractRememberMeServices</code>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public final Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        String rememberMeCookie = this.extractRememberMeCookie(request);</span><br><span class="line">        if (rememberMeCookie == null) {</span><br><span class="line">            return null;</span><br><span class="line">        } else {</span><br><span class="line">            this.logger.debug("Remember-me cookie detected");</span><br><span class="line">            if (rememberMeCookie.length() == 0) {</span><br><span class="line">                this.logger.debug("Cookie was empty");</span><br><span class="line">                this.cancelCookie(request, response);</span><br><span class="line">                return null;</span><br><span class="line">            } else {</span><br><span class="line">                try {</span><br><span class="line">                    String[] cookieTokens = this.decodeCookie(rememberMeCookie);</span><br><span class="line">                    UserDetails user = this.processAutoLoginCookie(cookieTokens, request, response);</span><br><span class="line">                    this.userDetailsChecker.check(user);</span><br><span class="line">                    this.logger.debug("Remember-me cookie accepted");</span><br><span class="line">                    return this.createSuccessfulAuthentication(request, user);</span><br><span class="line">                } catch (CookieTheftException var6) {</span><br><span class="line">                    this.cancelCookie(request, response);</span><br><span class="line">                    throw var6;</span><br><span class="line">                } catch (UsernameNotFoundException var7) {</span><br><span class="line">                    this.logger.debug("Remember-me login was valid but corresponding user not found.", var7);</span><br><span class="line">                } catch (InvalidCookieException var8) {</span><br><span class="line">                    this.logger.debug("Invalid remember-me cookie: " + var8.getMessage());</span><br><span class="line">                } catch (AccountStatusException var9) {</span><br><span class="line">                    this.logger.debug("Invalid UserDetails: " + var9.getMessage());</span><br><span class="line">                } catch (RememberMeAuthenticationException var10) {</span><br><span class="line">                    this.logger.debug(var10.getMessage());</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                this.cancelCookie(request, response);</span><br><span class="line">                return null;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>这个方法的逻辑比较简单，因此就不做细致分析。它主要是解析Cookie，并对Cookie信息进行解码，之后再调用<code>processAutoLoginCookie()</code>方法来进行校验，查看一下这个<code>processAutoLoginCookie()</code>方法的源码，注意该方法实现类为<code>TokenBasedRememberMeServices</code>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">plaintext</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected UserDetails processAutoLoginCookie(String[] cookieTokens, HttpServletRequest request, HttpServletResponse response) {</span><br><span class="line">        if (cookieTokens.length != 3) {</span><br><span class="line">            throw new InvalidCookieException("Cookie token did not contain 3 tokens, but contained '" + Arrays.asList(cookieTokens) + "'");</span><br><span class="line">        } else {</span><br><span class="line">            long tokenExpiryTime = this.getTokenExpiryTime(cookieTokens);</span><br><span class="line">            if (this.isTokenExpired(tokenExpiryTime)) {</span><br><span class="line">                throw new InvalidCookieException("Cookie token[1] has expired (expired on '" + new Date(tokenExpiryTime) + "'; current time is '" + new Date() + "')");</span><br><span class="line">            } else {</span><br><span class="line">                UserDetails userDetails = this.getUserDetailsService().loadUserByUsername(cookieTokens[0]);</span><br><span class="line">                Assert.notNull(userDetails, () -&gt; {</span><br><span class="line">                    return "UserDetailsService " + this.getUserDetailsService() + " returned null for username " + cookieTokens[0] + ". This is an interface contract violation";</span><br><span class="line">                });</span><br><span class="line">                String expectedTokenSignature = this.makeTokenSignature(tokenExpiryTime, userDetails.getUsername(), userDetails.getPassword());</span><br><span class="line">                if (!equals(expectedTokenSignature, cookieTokens[2])) {</span><br><span class="line">                    throw new InvalidCookieException("Cookie token[2] contained signature '" + cookieTokens[2] + "' but expected '" + expectedTokenSignature + "'");</span><br><span class="line">                } else {</span><br><span class="line">                    return userDetails;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>这个方法的逻辑也很简单，获取用户名和令牌过期时间，之后通过用户名来查询用户密码，接着通过调用<code>makeTokenSignature()</code>方法来计算此时的哈希值。</p><p>回到之前的<code>autoLogin()</code>方法中，此时会将<code>processAutoLoginCookie()</code>方法中返回的哈希值与浏览器中传递来的哈希值进行对比，来判断这个令牌是否有效，进而确认登录是否有效。</p><h3 id="文章小结"><a href="#文章小结" class="headerlink" title="文章小结"></a>文章小结</h3><p>通过上面的学习，我们对RememberMe的实现原理有了一个清晰的认识，可以发现该功能的核心就是将令牌（登录信息）存储在Cookie中。这样即使服务器重启、浏览器关闭后再次打开，只要令牌没有过期，那么用户就能访问到数据。</p><p>不过使用Cookie还是有一定的风险，因为它存储在本地客户端中，假设某个不法分子获取了用户令牌，那么就可能产生大的问题。</p><p>不过这样就自相矛盾了，为了提升用户体验，我们使用了“自我登录”功能，但是又引发了安全问题，不同情况有不同的取舍，是选择用户体验？还是安全性？这个需要结合实际情况，但是我们可以通过技术迭代，最大限度地将安全风险降低到最小。那么如何降低风险呢？这些都将在下一篇《持久化令牌》一文中进行学习。</p></body></html>]]></content>
    
    
      
      
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面对登录流程进行了较为细致的学习之后，接下来实现一个常用的功能—自动登</summary>
      
    
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/categories/springsecurity/"/>
    
    
    <category term="springsecurity" scheme="http://envyzhan.asia/tags/springsecurity/"/>
    
  </entry>
  
</feed>
