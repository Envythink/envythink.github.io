<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2023-03-14T07:00:50.285Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>功能开关在业务中的实践</title>
    <link href="http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/"/>
    <id>http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/</id>
    <published>2023-03-01T09:55:30.000Z</published>
    <updated>2023-03-14T07:00:50.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在搞一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但是后续发现这样有个弊端，即只能针对一个活动或者相同时间的多个活动生效，而实际上我们的活动有多个，权衡再三决定使用功能开关来实现。</p><h1 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h1><p>功能开关其实是一种代码可配置性的实践，说到底就是通过控制开关的状态来实现对功能的决定控制。</p><p>功能开关的实现有很多种方式，可以使用MySQL或者Redis等数据库，出于对后续数据扩展和对存储容量的考量，此处使用Bit数组来实现。</p><h3 id="Bit数组原理"><a href="#Bit数组原理" class="headerlink" title="Bit数组原理"></a>Bit数组原理</h3><p>既然是数组，那么下标必然从0开始，bit只有两种取值，要么为0，要么为1：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3049804d68aadfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>而0和1正好对应开关的关闭和启用，即ON和OFF状态。之后开发者只需定义好每个开关所在的Bit数组的索引号和状态即可，这样后续就可以通过判断开关的状态来实现对功能的控制：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-e89b847c9308657f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到使用这种方式所占用的内存空间非常少，理论上只需占用2n位的内存，n为开关的数量。</p><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>Java中对于Bit数组可以使用BitSet来实现 ，里面有很多方法，这里我们摘几个用到的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BitSet implements Cloneable, java.io.Serializable &#123;</span><br><span class="line">    //给指定位置设置值</span><br><span class="line">    public void set(int bitIndex, boolean value) &#123;&#125;</span><br><span class="line">    //给指定位置的值取反操作</span><br><span class="line">    public void clear(int bitIndex) &#123;&#125;</span><br><span class="line">    //获取指定位置的值</span><br><span class="line">    public boolean get(int bitIndex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，新建开关状态常量SwitchConst：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关常量</span><br><span class="line"> */</span><br><span class="line">public class SwitchConst &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用</span><br><span class="line">     */</span><br><span class="line">    public static final boolean ON = true;</span><br><span class="line">    /**</span><br><span class="line">     * 关停</span><br><span class="line">     */</span><br><span class="line">    public static final boolean OFF = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于开关只有开和闭这两种状态，因此可以不使用枚举类。</p><p>第二步，新建功能开关枚举类SwitchEnum，这个就是开发者所要定义的开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能开关枚举类</span><br><span class="line"> */</span><br><span class="line">public enum SwitchEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * HTTPS</span><br><span class="line">     */</span><br><span class="line">    HTTPS(0,SwitchConst.ON,&quot;HTTPS设置&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 充值会员</span><br><span class="line">     */</span><br><span class="line">    RECHARGE(1,SwitchConst.OFF,&quot;充值送油卡&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下标</span><br><span class="line">     */</span><br><span class="line">    private int index;</span><br><span class="line">    /**</span><br><span class="line">     * 默认状态</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    SwitchEnum(int index,boolean status,String desc)&#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getIndex()&#123;</span><br><span class="line">        return this.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean getStatus()&#123;</span><br><span class="line">        return this.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return this.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;name=%s,desc=%s&quot;,name(),desc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>第三步，新建开关状态切换接口Switch，里面定义切换开关状态和判断接口状态的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关转态切换</span><br><span class="line"> */</span><br><span class="line">public interface Switch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOn(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOff(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断开关状态</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    boolean judgeStatus(SwitchEnum switchEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个BitSetSwitch，表示基于BitSet实现的开关，因此需要实现Switch接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum BitSetSwitch implements Switch&#123;</span><br><span class="line">    MYBITSET;</span><br><span class="line"></span><br><span class="line">    BitSetSwitch()&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOn(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.set(switchEnum.getIndex(),SwitchConst.ON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOff(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.clear(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean judgeStatus(SwitchEnum switchEnum) &#123;</span><br><span class="line">        return bitSet.get(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        Stream.of(SwitchEnum.values()).forEach(item-&gt;bitSet.set(item.getIndex(),item.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将BitSetSwitch设置为了一个枚举类，目的就是通过单例生成一个BitSetSwitch对象。注意不能将其设置为普通的类，如果那样的话，在使用的时候就需要通过new关键字生成BitSetSwitch对象，而且每调用一次就得新创建一个对象，这肯定是不行的，功能开关肯定是全局唯一的。</p><p>第五步，新建测试类SwitchTest，测试一下功能开关的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSetSwitch bitSetSwitch = BitSetSwitch.MYBITSET;</span><br><span class="line">        bitSetSwitch.turnOn(SwitchEnum.HTTPS);</span><br><span class="line">        bitSetSwitch.turnOff(SwitchEnum.RECHARGE);</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.HTTPS,bitSetSwitch.judgeStatus(SwitchEnum.HTTPS)));</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.RECHARGE,bitSetSwitch.judgeStatus(SwitchEnum.RECHARGE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行该方法，可以发现控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开关【name=HTTPS,desc=HTTPS设置】，状态为：true</span><br><span class="line">开关【name=RECHARGE,desc=充值送油卡】，状态为：false</span><br></pre></td></tr></table></figure><p>这说明当前项目开启了HTTPS设置，但是关停了充值送油卡这一活动。后期要实现灵活控制，可配合配置中心在配置文件中进行控制。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>功能开关在实际开发过程中非常实用，因此有必要在理解的基础上进行灵活使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在搞一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins+Gitlab一键打包部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/</id>
    <published>2023-02-26T14:55:30.000Z</published>
    <updated>2023-03-14T06:52:35.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行。当我们的应用数量较多时，还可以使用Docker Compose的方式，但是毫无疑问上面的种种还都只是手动部署，本篇来学习如何使用Jenkins和Gitlab来实现一键打包部署SpringBoot应用。</p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><h3 id="GitLab简介"><a href="#GitLab简介" class="headerlink" title="GitLab简介"></a>GitLab简介</h3><p>GitLab是一款开源的基于Git的版本仓库管理工具，开发者可以使用它来搭建属于自己的Git仓库。</p><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><p><strong>第一步</strong>，下载GitLab的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/gitlab/config</span><br><span class="line">mkdir -p /mydata/gitlab/logs</span><br><span class="line">mkdir -p /mydata/gitlab/data</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动GitLab服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10443:443 -p 1080:80 -p 1022:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">-v /mydata/gitlab/config:/etc/gitlab \</span><br><span class="line">-v /mydata/gitlab/logs:/var/log/gitlab \</span><br><span class="line">-v /mydata/gitlab/data:/var/opt/gitlab \</span><br><span class="line">-d  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，开启防火墙：<br>由于Gitlab运行在1080端口，因此我们需要开放该端口，注意不能直接关闭防火墙，否则Gitlab会无法启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启1080端口</span><br><span class="line">firewall-cmd --zone=public --add-port=1080/tcp --permanent</span><br><span class="line"># 重启防火墙才能生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，打开浏览器，访问<code>http://宿主机IP:1080</code>链接，查看GitLab是否已经正常启动。请注意，由于GitLab启动比较慢，需要耐心等待10分钟左右，如果GitLab没有启动完成就访问，会出现502的错误。</p><p>开发者可以使用<code>docker logs gitlab -f</code>命令来动态查看容器启动日志，进而确定Gitlab是否已经启动完成。</p><p>之后访问<code>http://宿主机IP:1080</code>链接，可以看到GitLab已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebe4ce1f76be102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以使用如下命令来查看root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it gitlab grep &#x27;Password:&#x27; /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure><p>然后使用root用户加上上面得到的密码进行登录，注意root用户和kenbings用户的密码均为kenbings：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-298f808bd29ae8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="GitLab使用"><a href="#GitLab使用" class="headerlink" title="GitLab使用"></a>GitLab使用</h3><h5 id="创建组织"><a href="#创建组织" class="headerlink" title="创建组织"></a>创建组织</h5><p>首先创建一个组织，然后在这个组织下分别创建用户和项目，这样同组织的用户就可以使用该组织下的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-56b7f4bf0f6b38ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f18564bf73bb1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04c57d1455b307de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3de88e91015ce63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7126f255b6e95fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>点击 <a href="https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe">这里</a> 进行下载，然后一路Next进行安装。</p><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h5 id="下载代码到本地"><a href="#下载代码到本地" class="headerlink" title="下载代码到本地"></a>下载代码到本地</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http或者git地址</span><br></pre></td></tr></table></figure><h5 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h5><p>进入一个名为hello的项目目录，修改<code>README.md</code>并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入项目工程目录</span><br><span class="line">cd hello/</span><br><span class="line"># 将当前修改的文件添加到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 提交代码</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br></pre></td></tr></table></figure><h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h5 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="本地创建并提交分支"><a href="#本地创建并提交分支" class="headerlink" title="本地创建并提交分支"></a>本地创建并提交分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换并从当前分支创建一个dev分支</span><br><span class="line">git checkout -b dev</span><br><span class="line"># 将新创建的dev分支推送到远程仓库</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h5 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换到dev分支</span><br><span class="line">git checkout dev</span><br><span class="line"># 查看本地仓库文件状况</span><br><span class="line">git status</span><br><span class="line"># 查看本地所有分支</span><br><span class="line">git branch</span><br><span class="line"># 查看提交记录</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><p>Jenkins是开源CI&amp;CD软件的领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要，开发者可以用Jenkins来构建和部署自己的项目。举个例子，可以从自定义的代码仓库中获取代码，然后将代码打包成可执行的文件，之后通过远程的ssh工具执行脚本，最终实现运行项目这一目的。</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><strong>第一步</strong>，下载Jenkins的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/jenkins_home</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动Jenkins服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 50000:5000 --name jenkins \</span><br><span class="line">-u root \</span><br><span class="line">-v /mydata/jenkins_home:/var/jenkins_home \</span><br><span class="line">-d jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><h3 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h3><p>Jenkins服务启动后，然后访问<code>http://宿主机IP:8080</code>链接，页面出现如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-24988fcf53f76a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后使用如下命令从启动日志中获取到管理员密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs jenkins</span><br></pre></td></tr></table></figure><p>接着进行登录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d190ae88cf70c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择安装插件方式，这里我们直接安装推荐的插件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-74523a9030f27c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着就进入插件安装界面，联网等待插件安装：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f13bb799ee18f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>安装完成后，接下来我们创建一个管理员账号，账户和密码均为admin：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8785e2fbb1588637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后进行实例配置，配置Jenkins的访问URL：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dcfc0c2c2f0e81f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-703a4bbfdf686f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着点击“Manage Jenkins”–》“Manage Plugins”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-89737123c424524e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>确保以下插件被正确安装：<br>（1）根据角色管理权限的插件：Role-based Authorization Strategy；<br>（2）配置远程服务器：Publish Over SSH。</p><p>接下来新增maven的安装配置，点击“Manage Jenkins”–》“Global Tool Configuration”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8fbf0437fb8b534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-68ff4208251976f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后新增凭据，点击“Manage Jenkins”–》“Global Tool Configuration”，接着按照图片所示进行操作（注意里面配置的是通过ssh连接到宿主机的用户名和密码）：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-871bf5cc27c8425d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea8e8f2989b50dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着在点击“Manage Jenkins”–》“Configure System”，中添加全局ssh的配置，这样Jenkins使用ssh就可以执行远程linux的脚本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-914d9729c1e0f46c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Jenkins角色权限管理"><a href="#Jenkins角色权限管理" class="headerlink" title="Jenkins角色权限管理"></a>Jenkins角色权限管理</h3><p>开发者可以使用Jenkins的角色管理插件，来管理Jenkins的用户。举个例子，开发者可以给管理员赋予所有权限，给运维人员赋予执行任务的相关权限，而其他人员只赋予查看权限。</p><p>点击“Manage Jenkins”–》“Configure Global Security”，然后在里面启用基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9b38969b1d3d829f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们点击“Manage Jenkins”–》“Manage and Assign Roles”，然后在里面开始配置基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-00ae69b2af0f6f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fee924fad0462233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Manage Roles”，添加角色与权限关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-01c4781f8148613d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Assign Roles”，给用户分配角色：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64cdd0024c1e66f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="打包部署SpringBoot应用"><a href="#打包部署SpringBoot应用" class="headerlink" title="打包部署SpringBoot应用"></a>打包部署SpringBoot应用</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-jenkins</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-jenkins</code>这一Module中进行。</p><h3 id="将代码上传到GItlab中"><a href="#将代码上传到GItlab中" class="headerlink" title="将代码上传到GItlab中"></a>将代码上传到GItlab中</h3><p>修改POM文件中build标签中的内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>注意此处需要将dockerHost地址修改为开发者自己的Docker镜像仓库地址。同时项目在容器中运行的端口需要与后续启动脚本中的端口保持一致，这里为8088端口。</p><p>然后依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /shop-jenkins</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init project&quot;</span><br><span class="line">git remote add origin http://192.168.51.160:1080/myshop/shop-gitlab-jenkins.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -uf origin main</span><br></pre></td></tr></table></figure><p>注意如果在推送代码的过程中出现如下问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9af484a83d6a3321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>主要原因是因为向一个受保护的分支强制提交了代码，可以在仓库里面进行设置来解决这个问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c40f2c4217fef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e67581d3b3b7c47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="定义一个执行脚本"><a href="#定义一个执行脚本" class="headerlink" title="定义一个执行脚本"></a>定义一个执行脚本</h3><p>在<code>/mydata/sh</code>目录下定义一个名为<code>shop-jenkins.sh</code>的脚本，其中的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">app_name=&#x27;shop-jenkins&#x27;</span><br><span class="line">docker stop $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----stop container-----&#x27;</span><br><span class="line">docekr rm $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----rm container-----&#x27;</span><br><span class="line">docker run -p 8088:8088 --name $&#123;app_name&#125; \</span><br><span class="line">--link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/$&#123;app_name&#125;/logs:/var/logs \</span><br><span class="line">-d myshop-all/$&#123;app_name&#125;:0.0.1-SNAPSHOT</span><br><span class="line">echo &#x27;----start container----&#x27;</span><br></pre></td></tr></table></figure><p>注意里面的映射的端口信息，接着给该脚本赋予可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shop-jenkins.sh</span><br></pre></td></tr></table></figure><p>如果开发者是在Windows系统下创建的sh脚本，那么放到Linux系统上时需要修改文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用vim编辑器来修改</span><br><span class="line">vi shop-jenkins.sh</span><br><span class="line"># 查看文件格式，windows上传上来的默认为dos</span><br><span class="line">:set ff </span><br><span class="line">#修改文件格式为unix</span><br><span class="line">:set ff=unix </span><br><span class="line">#保存并退出</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>然后我们创建对应的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-jenkins</span><br></pre></td></tr></table></figure><h1 id="在Jenkins中创建执行任务"><a href="#在Jenkins中创建执行任务" class="headerlink" title="在Jenkins中创建执行任务"></a>在Jenkins中创建执行任务</h1><p><strong>第一步</strong>，新建一个任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69a4ee3649aedac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，设置任务名称后选择构建一个自由风格的软件项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-845861f3b8d6158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第三步</strong>，点击源码管理，然后在里面添加仓库地址：<code>http://192.168.51.160:1080/myshop/shop-gitlab-jenkins</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1f28a87cb227fe96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时显示连接不通，我们需要添加一个凭据，也就是Git仓库的账号和密码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-23b0f51cc134ba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>填写完该凭据后就选择它，此时就可以正常连接到Git仓库：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8afb66ed66c1d79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，添加一个构建用于调用顶层maven模板，该构建主要用于将源码打包为Docker镜像并上传至Docker镜像仓库中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96d012913b65027d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择maven版本并设置maven命令以及指定pom文件的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6c3b13b50a6744c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着设置需要执行的shell的命令，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mydata/sh/shop-jenkins.sh</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ca8e69c00cf15653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击保存操作，这样任务就创建完成了。</p><p><strong>第五步</strong>，在任务列表中可以点击运行来执行该任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9941d3d80b4fc277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可通过点击左侧的构建历史序号，然后选择控制台输出即可看到整个任务的执行过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-108a84f1c09d77a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d5f4a904325309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第六步</strong>，接着我们开放8088端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8088/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开浏览器，访问<code>http://宿主机IP:8088/swagger-ui.html</code>连接，查看<code>shop-jenkins</code>服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c382f1b4ee6fe432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Jenkins+Gitlab一键打包部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker Compose部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/</id>
    <published>2023-02-24T02:55:30.000Z</published>
    <updated>2023-03-14T06:50:53.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行，但是当我们的应用数量较多时，上述两种方式似乎变得很不友好。</p><p>此时可以使用Docker Compose来解决上述问题，Docker Compose是一个用于定义和运行多个docker容器应用的工具。使用Compose允许开发者使用YAML文件来配置应用服务，之后使用一个命令，就可以部署配置的所有服务。</p><h1 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h1><h3 id="下载Docker-Compose"><a href="#下载Docker-Compose" class="headerlink" title="下载Docker Compose"></a>下载Docker Compose</h3><p>使用如下命令来下载Docker Compose：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="修改下载文件的权限"><a href="#修改下载文件的权限" class="headerlink" title="修改下载文件的权限"></a>修改下载文件的权限</h3><p>将下载文件的权限设置为可执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="确认Docker-Compose安装成功"><a href="#确认Docker-Compose安装成功" class="headerlink" title="确认Docker Compose安装成功"></a>确认Docker Compose安装成功</h3><p>可使用如下命令来确认Docker Compose已经安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果输出Docker Compose的版本则说明它已经安装成功了。</p><h1 id="Docker-Compose使用步骤"><a href="#Docker-Compose使用步骤" class="headerlink" title="Docker Compose使用步骤"></a>Docker Compose使用步骤</h1><p>一般来说，Docker Compose的使用分为三个步骤：<br>（1）使用Dockerfile来定义应用的程序环境，注意此步只有在需要修改初始化镜像时，才执行；<br>（2）使用<code>docker-compose.yml</code>文件来定义需要部署的应用程序服务，以便后续可通过执行脚本来一次性部署服务；<br>（3）使用<code>docker-compose up</code>命令一次性将所有应用服务部署起来。</p><h1 id="docker-compose-yml配置文件常用命令"><a href="#docker-compose-yml配置文件常用命令" class="headerlink" title="docker-compose.yml配置文件常用命令"></a>docker-compose.yml配置文件常用命令</h1><p>Docker Compose将所管理的容器分为三层，即工程、服务及容器。<code>docker-compose.yml</code>中定义的所有服务组成了一个工程，services节点下即为服务，服务之下为容器。容器与容器之间可通过以服务名称为域名来进行访问。举个例子，在<code>shop-docker-compose</code>服务中可通过<code>jdbc:mysql://db:3306</code>这个地址来访问db这个mysql服务。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>version用于指定docker-compose的版本号，目前使用值都是3。</p><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>services是一系列服务的集合，该节点下定义具体的服务。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image用于指定服务所使用的镜像，举个例子如使用的是mysql5.7的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>container_name用于设置容器的名称，举个例子如指定容器名称为mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: mysql</span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>ports用于设置宿主机和容器的端口映射，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的3306端口映射到容器的3306端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - 3306:3306</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>volumes用于将宿主机的文件或者目录挂载到容器中，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的如下文件挂载到容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">  - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">  - /mydata/mysql/conf:/etc/mysql</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>environment用于设置环境变量，举个例子设置MySQL初始化时root账户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  - MYSQL_ROOT_PASSWORD=envy123</span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>links用于连接其他的容器服务，注意格式为<code>（SERVICE:ALIAS）</code>，举个例子以database为域名来访问服务名称为db的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  - db:database</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h1><h3 id="构建、创建、启动相关容器"><a href="#构建、创建、启动相关容器" class="headerlink" title="构建、创建、启动相关容器"></a>构建、创建、启动相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>其中的<code>-d</code>表示在后台运行。</p><h3 id="指定文件启动"><a href="#指定文件启动" class="headerlink" title="指定文件启动"></a>指定文件启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h3 id="停止所有相关容器"><a href="#停止所有相关容器" class="headerlink" title="停止所有相关容器"></a>停止所有相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h3 id="列出所有容器信息"><a href="#列出所有容器信息" class="headerlink" title="列出所有容器信息"></a>列出所有容器信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-compose</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-compose</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-compose-0.0.1-SNAPSHOT.jar /shop-docker-compose.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-compose.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-compose.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-compose.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ac5e57969321848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-compose\target\shop-docker-compose-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-compose ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.948 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T16:47:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-compose</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-compose</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-compose:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。</p><h1 id="使用Docker-Compose部署应用"><a href="#使用Docker-Compose部署应用" class="headerlink" title="使用Docker Compose部署应用"></a>使用Docker Compose部署应用</h1><h3 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为<code>docker-compose.yml</code>的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  db:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: mysql</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">    - 3306:3306</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">    - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">    - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">    - /mydata/mysql/conf:/etc/mysql</span><br><span class="line">    # 指定容器的环境变量</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=envy123</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  shop-docker-compose:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: myshop-all/shop-docker-compose:0.0.1-SNAPSHOT</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: shop-docker-compose</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">      - /mydata/app/shop-docker-compose/logs:/var/logs</span><br></pre></td></tr></table></figure><h3 id="运行Docker-Compose命令启动所有服务"><a href="#运行Docker-Compose命令启动所有服务" class="headerlink" title="运行Docker Compose命令启动所有服务"></a>运行Docker Compose命令启动所有服务</h3><p>将上面定义的<code>docker-compose.yml</code>文件上传至<code>/mydata/app/shop-docker-compose</code>目录中，然后在该目录中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看一下服务是否已经启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-compose]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                           COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">252d6d043a3d   myshop-all/shop-docker-compose:0.0.1-SNAPSHOT   &quot;java -jar /shop-doc…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              shop-docker-compose</span><br><span class="line">3c1f3944c4ca   registry:2                                      &quot;/entrypoint.sh /etc…&quot;   7 hours ago     Up 7 hours     0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp              registry2</span><br><span class="line">1f83ff04b145   mysql:5.7                                       &quot;docker-entrypoint.s…&quot;   25 hours ago    Up 2 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   mysql</span><br></pre></td></tr></table></figure><p>接着我们需要进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>然后创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p>接着打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到之前的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p>修改root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>接着我们开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>然后打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-compose服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Docker Compose部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-23T10:15:33.000Z</published>
    <updated>2023-03-14T06:49:25.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在部署第一篇中，我们学习了如何使用通过<code>docker-maven-plugin</code>来构建docker镜像，遗憾的是此方式需要依赖自建的Registry镜像仓库，这在实际开发过程中还是有困难的。</p><p>鉴于此，本篇来学习另一种方式，使用Dockerfile来构建docker镜像。注意此方式不需要依赖自建的镜像仓库，只需应用的jar包和一个Dockerfile文件。</p><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Dockerfile为SpringBoot应用构建Docker镜像。</p><h1 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM用于指定所需依赖的基础镜像，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像需要依赖java8的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br></pre></td></tr></table></figure><p>注意FROM命令必须放在Dockerfile文件的第一行。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER用于指定镜像维护者的名字，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像的维护者为kenbings：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER kenbings</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD用于复制文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如将当前目录下的<code>shop-docker-file.jar</code>包复制到docker容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD shop-docker-file.jar /shop-docker-file.jar</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT用于指定docker容器启动时执行的命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在启动容器时启动运行jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV用于设置环境变量，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>举个例子，在mysql运行时设置root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV MYSQL_ROOT_PASSWORD envy123</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE用于声明要暴露的端口（注意只会声明不会打开端口），格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port1&gt; &lt;port2&gt; ...</span><br></pre></td></tr></table></figure><p>举个例子，声明服务运行在8080端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN用于自定义容器在构建过程中需要执行的命令，如安装一些软件、创建一些文件等，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在容器构建过程中需要在/目录下创建一个名为<code>shop-docker-file.jar</code>的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-file</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-file</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-file.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c13081c65ae93a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-file\target\shop-docker-file-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-file ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.759 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T14:59:31+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-file</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-file</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。上述命令执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br><span class="line">Sending build context to Docker daemon   36.5MB</span><br><span class="line">Step 1/6 : FROM openjdk:8u102</span><br><span class="line"> ---&gt; ca5dd051db43</span><br><span class="line">Step 2/6 : MAINTAINER kenbings</span><br><span class="line"> ---&gt; Running in 89102f5205f6</span><br><span class="line">Removing intermediate container 89102f5205f6</span><br><span class="line"> ---&gt; 3a095a2cfe51</span><br><span class="line">Step 3/6 : ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"> ---&gt; 0429582ab23e</span><br><span class="line">Step 4/6 : RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"> ---&gt; Running in 3083441e10a6</span><br><span class="line">Removing intermediate container 3083441e10a6</span><br><span class="line"> ---&gt; 10be5dacfb00</span><br><span class="line">Step 5/6 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 505f2c42fbdf</span><br><span class="line">Removing intermediate container 505f2c42fbdf</span><br><span class="line"> ---&gt; fbab2deea31e</span><br><span class="line">Step 6/6 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br><span class="line"> ---&gt; Running in bde857feb023</span><br><span class="line">Removing intermediate container bde857feb023</span><br><span class="line"> ---&gt; 7c0df63d8996</span><br><span class="line">Successfully built 7c0df63d8996</span><br><span class="line">Successfully tagged myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>查看一下该镜像是否确实生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker images|grep &#x27;docker-file&#x27;</span><br><span class="line">myshop-all/shop-docker-file   0.0.1-SNAPSHOT   7c0df63d8996   About a minute ago   714MB</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker-file应用服务"><a href="#启动shop-docker-file应用服务" class="headerlink" title="启动shop-docker-file应用服务"></a>启动shop-docker-file应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker-file/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker-file/logs:/var/logs \</span><br><span class="line">--name shop-docker-file \</span><br><span class="line">-d myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-file服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Dockerfile为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在部署第一篇中，我们学习了如何使用通过&lt;code&gt;docker-maven-plugin&lt;/code&gt;来构建docker镜像</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven插件为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-20T03:51:30.000Z</published>
    <updated>2023-03-14T06:47:18.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Docker镜像，并上传至私有镜像仓库Docker Registry中。</p><h1 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h1><p>开发者可以使用Docker提供的registry这一镜像来搭建属于自己的私有仓库，这里选择版本为2的镜像即可，先将其下载到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry:2</span><br></pre></td></tr></table></figure><p>这里有它的快速使用方法，其实就是一条命令：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec61be9dc5bbcc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>执行下面的命令即可创建一个私有仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry2 registry:2</span><br></pre></td></tr></table></figure><h1 id="Docker开启远程API"><a href="#Docker开启远程API" class="headerlink" title="Docker开启远程API"></a>Docker开启远程API</h1><p>打开<code>docker.service</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>将其中的如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><br></pre></td></tr></table></figure><h1 id="让Docker支持http上传镜像"><a href="#让Docker支持http上传镜像" class="headerlink" title="让Docker支持http上传镜像"></a>让Docker支持http上传镜像</h1><p>使用如下命令来让Docker支持http上传镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&#123; &quot;insecure-registries&quot;:[&quot;192.168.51.160:5000&quot;] &#125;&#x27; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>修改完上述配置信息后，接下来需要使用如下命令来让配置生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>接着重启Docker服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>最后开启防火墙的Docker构建端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h1 id="使用Maven构建Docker镜像"><a href="#使用Maven构建Docker镜像" class="headerlink" title="使用Maven构建Docker镜像"></a>使用Maven构建Docker镜像</h1><p>再次强调，本篇代码是在第二篇《整合Swagger-UI实现在线API文档》的基础上进行修改的。</p><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker</code>这一Module中进行。</p><p><strong>第一步</strong>，在POM文件中新增<code>docker-maven-plugin</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>解释一下上述配置信息：<br>（1）<code>executions.execution.phase</code>表示配置在maven打包应用时构建docker镜像；<br>（2）<code>imageName</code>用于指定镜像名称，其中<code>myshop-all</code>是仓库名称，<code>$&#123;project.artifactId&#125;</code>是镜像名称，<code>$&#123;project.version&#125;</code>是仓库名称；<br>（3）<code>dockerHost</code>表示设置镜像打包后上传的docker服务器地址；<br>（4）<code>baseImage</code>表示该应用所依赖的基础镜像，此处为openjdk:8u102；<br>（5）<code>entryPoint</code>表示设置docker容器启动时执行的命令；<br>（6）<code>resources.resource.targetPath</code>表示将打包后的资源文件复制到该目录；<br>（7）<code>resources.resource.directory</code>表示待复制的文件所在的目录，注意Maven打包的应用jar包会保存在target目录下；<br>（8）<code>resources.resource.includ</code>表示需要复制的文件，即打包好的应用的jar包。</p><p><strong>第二步</strong>，修改<code>application.yml</code>配置文件，将其中的localhost修改为db：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://db:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p>实际上，我们可以将docker中的容器看做独立的虚拟机，这样<code>shop-docker</code>访问localhost时就不会访问到mysql，但是容器之间可通过指定服务名称来进行访问，如db，注意db这个名称需要在运行<code>shop-docker</code>容器时进行指定。</p><p><strong>第三步</strong>，使用IDEA打包项目并构建镜像，请注意依赖的基础镜像需要先下载到本地，否则会出现镜像构建超时的情况。接着执行maven的package命令来构建镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7fba034b80d2f8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c1f6abe0bac76a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时查看一下宿主机，可以看到宿主机上显示已经存在了该镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b76dce1634120500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="运行shop-docker服务"><a href="#运行shop-docker服务" class="headerlink" title="运行shop-docker服务"></a>运行shop-docker服务</h1><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker应用服务"><a href="#启动shop-docker应用服务" class="headerlink" title="启动shop-docker应用服务"></a>启动shop-docker应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker/logs:/var/logs \</span><br><span class="line">--name shop-docker \</span><br><span class="line">-d myshop-all/shop-docker:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Maven插件为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Dock</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合RabbitMQ实现延迟消息</title>
    <link href="http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/"/>
    <id>http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/</id>
    <published>2023-02-16T02:51:12.000Z</published>
    <updated>2023-03-14T06:45:40.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="AMQP简介"><a href="#AMQP简介" class="headerlink" title="AMQP简介"></a>AMQP简介</h3><p>AMQP (Advanced Message Queuing Protocol ，高级消息队列协议）是一个线路层的协议规范，而不是API 规范（例如JMS）。由于AMQP 是一个线路层协议规范，因此它天然就是跨平台的，就像SMTP、HTTP等协议一样，只要开发者按照规范的格式发送数据，任何平台都可以通过AMQP进行消息交互。像目前流行的StormMQ、RabbitMQ等都实现了AMQP协议。</p><h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ是一个实现了AMQP的开源消息中间件，使用高性能的Erlang编写。RabbitMQ具有可靠性、支持多种协议、高可用、支持消息集群以及多语言客户端等特点，在分布式系统中存储转发消息，具有不错的性能表现。</p><h3 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h3><p><strong>第一步</strong>，安装Erlang，可点击 <a href="http://erlang.org/download/otp_win64_23.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第二步</strong>，安装RabbitMQ，可点击 <a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.0/rabbitmq-server-3.8.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第三步</strong>，以管理员身份打开终端，并切换到RabbitMQ安装目录下的sbin目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3691d4f14d85cd00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后执行如下命令来开启管理功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://localhost:15672/</code>链接：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-962d2a01534f8f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第五步</strong>，输出账号和密码:guest和guest，然后登陆，点击右上角的Admin，创建用户名为kenbings和kenbings的用户，并设置角色为管理员：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-df8a5c4ccc8aecb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着创建一个名为<code>/shop</code>的虚拟host：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08ecd99c955f189d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后点击shop用户，进入到用户配置界面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-95d88b8d9ed02629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dc312644d1676024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样RabbitMQ的安装和配置就完成了，下面开始学习AMQP协议。</p><h1 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h1><p>AMQP协议作为RabbitMQ的规范，规定了RabbitMQ对外接口，同时学会了AMQP协议的使用，就基本掌握了RabbitMQ的使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae628aa7ee00312c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ就是Message Broker；<br><strong>Virtual Host</strong>：虚拟Broker，用于将多个单元隔离开；<br><strong>Connection</strong>：publisher/consumer和broker之间的TCP连接；<br><strong>Channel</strong>：connection内部建立的逻辑连接，通常每个线程创建单独的channel；<br><strong>Routing Key</strong>：路由键，用于指示消息的路由转发，相当于快递的地址；<br><strong>Exchange</strong>：交换机，相当于快递的分拨中心；<br><strong>Queue</strong>：消息队列，消息最终被送到这里等待consumer取走；<br><strong>Binding Key</strong>：exchange和queue之间的虚拟连接，用于message的分发依据。</p><h1 id="Exchange的作用"><a href="#Exchange的作用" class="headerlink" title="Exchange的作用"></a>Exchange的作用</h1><p>在AMQP协议或者是RabbitMQ实现中，最核心的组件是Exchange，Exchange承担RabbitMQ中的核心功能，即路由转发。Exchange有多个种类，配置多变，需要深度分析。</p><p>Exchange的功能是根据绑定关系和路由键为消息提供路由，将消息转发至相应的队列。</p><p>Exchange有4种类型，Direct、Topic、Fanout和Headers，其中Headers使用较少，以前三种为主。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2f35828e0212b741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h1><p>本篇要实现的延迟消息，是用户在下单之后，超过一定时间如30分钟，之后自动取消订单这一业务场景。可能的业务步骤如下：<br>（1）用户进行下单操作（会存在锁定商品库存、使用优惠券、积分、红包等操作）；<br>（2）生成订单信息，并获取订单id；<br>（3）根据订单id获取到设置的订单超时时间（假设设置30分钟内不支付取消订单）；<br>（4）按照订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；<br>（5）如果用户没有支付，那么就执行取消订单的操作（释放商品库存、优惠券、积分、红包等操作）。</p><h1 id="整合RabbitMQ实现延迟消息"><a href="#整合RabbitMQ实现延迟消息" class="headerlink" title="整合RabbitMQ实现延迟消息"></a>整合RabbitMQ实现延迟消息</h1><p><strong>第一步</strong>，复制一份<code>shop-mongodb</code>源码，将其名字修改为<code>shop-rabbitmq</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-rabbitmq</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-rabbitmq</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--消息队列相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在spring节点下添加RabbitMQ相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  # RabbitMQ相关    </span><br><span class="line">rabbitmq:</span><br><span class="line">  host: localhost # rabbitmq的连接地址</span><br><span class="line">  port: 5672 # rabbitmq的连接端口号</span><br><span class="line">  virtual-host: /shop # rabbitmq的虚拟host</span><br><span class="line">  username: kenbings # rabbitmq的用户名</span><br><span class="line">  password: kenbings # rabbitmq的密码</span><br><span class="line">  publisher-confirms: true #如果对异步消息需要回调必须设置为true</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shoprabbitmq</code>包内定义一个名为enums的包，接着在enums包内定义一个名为<code>QueueEnum</code>的枚举类，注意这是消息队列的枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列枚举类</span><br><span class="line"> */</span><br><span class="line">@Getter</span><br><span class="line">public enum QueueEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单取消通知队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_ORDER_CANCEL(&quot;shop.order.direct.exchange&quot;,&quot;shop.order.cancel.queue&quot;,&quot;shop.order.cancel.key&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息通知TTL队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(&quot;shop.order.direct.ttl.exchange&quot;,&quot;shop.order.cancel.ttl.queue&quot;,&quot;shop.order.cancel.ttl.key&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 交换机</span><br><span class="line">     */</span><br><span class="line">    private String exchange;</span><br><span class="line">    /**</span><br><span class="line">     * 队列名称</span><br><span class="line">     */</span><br><span class="line">    private String queue;</span><br><span class="line">    /**</span><br><span class="line">     * 路由键</span><br><span class="line">     */</span><br><span class="line">    private String routingKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String queue, String routingKey)&#123;</span><br><span class="line">        this.exchange = exchange;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在config包内定义一个名为<code>RabbitMQConfig</code>的配置类，注意这是消息队列的配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderTTLDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderQueue()&#123;</span><br><span class="line">        return new Queue(QueueEnum.QUEUE_ORDER_CANCEL.getQueue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟消息队列（死信队列）</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderTTLQueue()&#123;</span><br><span class="line">        return QueueBuilder.durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getQueue())</span><br><span class="line">                .withArgument(&quot;x-dead-letter-exchange&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getExchange()) //消息过期后转到的交换机</span><br><span class="line">        .withArgument(&quot;x-dead-letter-routing-key&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey()) //消息过期后转发的路由键</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将正常订单队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderBinding(DirectExchange orderDirectExchange,Queue orderQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderQueue).to(orderDirectExchange).with(QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将订单延迟队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderTTLBinding(DirectExchange orderTTLDirectExchange,Queue orderTTLQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderTTLQueue).to(orderTTLDirectExchange).with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们尝试启动一下项目入口类，然后查看一下RabbitMQ的浏览器控制台，然后查看Exchange：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8239e340336e0883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着再来查看一下队列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cadff6c72def3c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>shop.order.direct.exchange</code>（取消订单消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.queue</code>，这样如果有消息以<code>shop.order.cancel.key</code>为路由键发送过来，就会发送到此队列中。</p><p><code>shop.order.direct.ttl.exchange</code>（订单延迟消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.ttl.queue</code>，这样如果有消息以<code>shop.order.cancel.ttl.key</code>为路由键发送过来，就会发送到此队列中，并在此队列中保存一段时间，等到超时时间到，后自动将消息发送到<code>shop.order.cancel.queue</code>（取消订单消息队列）中。</p><p><strong>第六步</strong>，在component包内定义一个名为<code>CancelOrderSender</code>的类，该类用于往订单延迟队列(订单消息通知TTL队列，<code>shop.order.cancel.ttl.queue</code>)中发送消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往订单延迟队列(订单消息通知TTL队列，`shop.order.cancel.ttl.queue`)中发送消息</span><br><span class="line"> * 取消订单消息的发出者</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CancelOrderSender &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给延迟队列发送消息</span><br><span class="line">     * @param orderId 订单号</span><br><span class="line">     * @param delayTime 延迟时间（毫秒）</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(Long orderId,long delayTime)&#123;</span><br><span class="line">        String exchange = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange();</span><br><span class="line">        String routingKey = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey();</span><br><span class="line">        amqpTemplate.convertAndSend(exchange, routingKey, orderId, new MessagePostProcessor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">                        //给消息设置延迟时间，单位毫秒</span><br><span class="line">                        message.getMessageProperties().setExpiration(String.valueOf(delayTime));</span><br><span class="line">                        return message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        LOGGER.info(&quot;发送延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在component包内定义一个名为<code>CancelOrderReceiver</code>的类，该类用于从订单取消通知队列(<code>shop.order.cancel.queue</code>)中拉取消息并消费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理取消订单消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;shop.order.cancel.queue&quot;)</span><br><span class="line">public class CancelOrderReceiver &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderReceiver.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void handle(Long orderId)&#123;</span><br><span class="line">        LOGGER.info(&quot;收到延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在service包内定义一个名为<code>OmsPortalOrderService</code>的接口，用于定义与前台订单管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface OmsPortalOrderService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据提交信息生成订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    CommonResult generateOrder(OrderParam orderParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取消单个超时订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    void cancelOrder(Long orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在dto包内定义一个名为<code>OrderParam</code>的类，这是生成订单时需传入的参数对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成订单时需传入的参数</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class OrderParam &#123;</span><br><span class="line">    //收货地址id</span><br><span class="line">    private Long memberReceiveAddressId;</span><br><span class="line">    //优惠券id</span><br><span class="line">    private Long couponId;</span><br><span class="line">    //使用的积分数</span><br><span class="line">    private Integer useIntegration;</span><br><span class="line">    //支付方式</span><br><span class="line">    private Integer payType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在impl包内定义一个名为<code>OmsPortalOrderServiceImpl</code>的类，这个类需要实现<code>OmsPortalOrderService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class OmsPortalOrderServiceImpl implements OmsPortalOrderService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(OmsPortalOrderService.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CancelOrderSender cancelOrderSender;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateOrder(OrderParam orderParam) &#123;</span><br><span class="line">        //TODO 一系列下单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始生成订单&quot;);</span><br><span class="line">        //下单完成后发送一个延迟消息，用于实现当用户没有付款时取消订单这一功能，注意orderId应该在下单后生成</span><br><span class="line">        Long orderId = 516516161616L;</span><br><span class="line">        sendDelayMessageCancelOrder(orderId);</span><br><span class="line">        return CommonResult.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancelOrder(Long orderId) &#123;</span><br><span class="line">        //TODO 一系列取消订单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始取消订单，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendDelayMessageCancelOrder(Long orderId) &#123;</span><br><span class="line">        //获取订单超时时间，假设为30秒</span><br><span class="line">        long delayTimes = 30 * 1000;</span><br><span class="line">        //发送延迟消息</span><br><span class="line">        cancelOrderSender.sendMessage(orderId, delayTimes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在controller包内定义一个名为<code>OmsPortalOrderController</code>的类，这是前台订单管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理的Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;OmsPortalOrderController&quot;,description = &quot;订单管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OmsPortalOrderController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService omsPortalOrderService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;根据购物车信息生成订单&quot;)</span><br><span class="line">    @PostMapping(&quot;/generateOrder&quot;)</span><br><span class="line">    public Object generateOrder(@RequestBody OrderParam orderParam) &#123;</span><br><span class="line">        return omsPortalOrderService.generateOrder(orderParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa310e78ea1ddc34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，进行接口测试。首先后台用户进行登录，接着测试“下单接口”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8040f8eadc87c2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后回到IDEA控制台，可以看到输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:05:40.460  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.service.OmsPortalOrderService    : 开始生成订单</span><br><span class="line">2021-12-09 18:05:40.464  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.component.CancelOrderSender      : 发送延迟消息，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>之后等待30秒钟，IDEA控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:06:10.494  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.component.CancelOrderReceiver    : 收到延迟消息，订单号为：516516161616</span><br><span class="line">2021-12-09 18:06:10.495  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.service.OmsPortalOrderService    : 开始取消订单，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>可以看到时间间隔就是30秒，这也说明该订单下单30秒后未支付便被自动取消了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合MongoDB实现用户商品浏览记录</title>
    <link href="http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/"/>
    <id>http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/</id>
    <published>2023-02-13T11:15:10.000Z</published>
    <updated>2023-03-14T06:43:15.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><p>MongoDB是一个为快速开发互联网Web应用而构建的数据库系统，其数据模型和持久化策略就是为了构建高读/写吞吐量和高自动灾备伸缩性的系统。</p><h3 id="安装MongoDB服务"><a href="#安装MongoDB服务" class="headerlink" title="安装MongoDB服务"></a>安装MongoDB服务</h3><p>第一步，点击 <a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.2.21-signed.msi">这里</a> 下载MongoDB的安装包；</p><p>第二步，自定义MongoDB的安装路径：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ff90ac35c7ba41d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三步，在MongoDB安装路径下创建<code>data\db</code>和<code>data\log</code>这两个文件夹：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-357fca313358d035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第四步，在MongoDB安装路径下创建<code>mongod.cfg</code>配置文件，里面的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: E:\Application\MongoDB\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: E:\Application\MongoDB\data\db</span><br></pre></td></tr></table></figure><p>第五步，进入到MongoDB安装路径下的bin目录，里面有两个exe文件，分别是客户端和服务端运行程序：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-60c5c82bf617341e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后以管理员身份打开终端，并切换到bin目录下，执行如下命令来给系统安装MongoDB服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Application\MongoDB\bin\mongod.exe --config &quot;E:\Application\MongoDB\mongod.cfg&quot; --install</span><br></pre></td></tr></table></figure><p>第六步，一些与MongoDB服务管理相关的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动服务：net start MongoDB</span><br><span class="line">关闭服务：net stop MongoDB</span><br><span class="line">移除服务：E:\Application\MongoDB\bin\mongod.exe --remove</span><br></pre></td></tr></table></figure><p>使用上述命令来启动MongoDB服务。</p><h3 id="安装MongoDB客户端"><a href="#安装MongoDB客户端" class="headerlink" title="安装MongoDB客户端"></a>安装MongoDB客户端</h3><p>第一步，点击 <a href="https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip">这里</a> 下载MongoDB客户端的安装包；</p><p>第二步，将其解压到指定目录，并打开名为<code>robo3t.exe</code>的软件，然后连接到<code>localhost:27017</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-221869c039f544c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>Spring Data MongoDB是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-MongoDB常用注解"><a href="#Spring-Data-MongoDB常用注解" class="headerlink" title="Spring Data MongoDB常用注解"></a>Spring Data MongoDB常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到MongoDB文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    @AliasFor(&quot;collection&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String collection() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String language() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到MongoDB文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h3><p><code>@Indexed</code>注解添加到映射到MongoDB文档上的领域对象的某个字段上，用于标识该字段为MongoDB的索引字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Indexed &#123;</span><br><span class="line">    boolean unique() default false;</span><br><span class="line"></span><br><span class="line">    IndexDirection direction() default IndexDirection.ASCENDING;</span><br><span class="line"></span><br><span class="line">    boolean sparse() default false;</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean dropDups() default false;</span><br><span class="line"></span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useGeneratedName() default false;</span><br><span class="line"></span><br><span class="line">    boolean background() default false;</span><br><span class="line"></span><br><span class="line">    int expireAfterSeconds() default -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承MongoRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface MongoRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll(Sort var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; S insert(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; insert(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ff1fae57d08f8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，根据会员id按照时间倒序获取会员的浏览记录，直接在接口中定义如下方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-269ef8c63a11e00f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用MongoDB的JSON语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123; &#x27;memberId&#x27; : ?0 &#125;&quot;)</span><br><span class="line">List&lt;MemberReadHistory&gt; findByMemberId(Long memberId);</span><br></pre></td></tr></table></figure><h1 id="整合MongoDB实现用户商品浏览记录"><a href="#整合MongoDB实现用户商品浏览记录" class="headerlink" title="整合MongoDB实现用户商品浏览记录"></a>整合MongoDB实现用户商品浏览记录</h1><p><strong>第一步</strong>，复制一份<code>shop-elasticsearch</code>源码，将其名字修改为<code>shop-mongodb</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-mongodb</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-mongodb</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!---MongoDB相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在<code>spring.data</code>节点下添加MongoDB相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># MongoDB相关</span><br><span class="line">data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: localhost # mongodb的连接地址</span><br><span class="line">      port: 27017 # mongodb的连接端口号</span><br><span class="line">      database: shop-port # mongodb的连接的数据库</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在nosql包内定义一个名为mongodb的包，接着在mongodb包内定义一个名为document的包。然后在document包内定义一个名为<code>MemberReadHistory</code>的类，注意这是会员浏览记录文档对象。然后文档对象的ID域使用<code>@Id</code>注解，需要检索的字段添加<code>@Indexed</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户商品浏览历史记录文档对象</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document</span><br><span class="line">public class MemberReadHistory &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    /**</span><br><span class="line">     * 用户id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long memberId;</span><br><span class="line">    /**</span><br><span class="line">     * 用户昵称</span><br><span class="line">     */</span><br><span class="line">    private String memberNickname;</span><br><span class="line">    /**</span><br><span class="line">     * 用户头像</span><br><span class="line">     */</span><br><span class="line">    private String memberIcon;</span><br><span class="line">    /**</span><br><span class="line">     * 商品id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long productId;</span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    private String productName;</span><br><span class="line">    /**</span><br><span class="line">     * 商品图片</span><br><span class="line">     */</span><br><span class="line">    private String productPic;</span><br><span class="line">    /**</span><br><span class="line">     * 商品副标题</span><br><span class="line">     */</span><br><span class="line">    private String productSubTitle;</span><br><span class="line">    /**</span><br><span class="line">     * 商品价格</span><br><span class="line">     */</span><br><span class="line">    private String productPrice;</span><br><span class="line">    /**</span><br><span class="line">     * 浏览时间</span><br><span class="line">     */</span><br><span class="line">    private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，<br>在mongodb包内新建一个名为repository的包，并在该包内定义一个名为<code>MemberReadHistoryRepository</code>的接口，注意这个接口需要继承<code>MongoRepository</code>接口，这样就拥有了一些基本的操作MongoDB数据的方法，同时我们在里面定义了一个衍生的根据用户(会员)id按照时间倒序获取商品浏览历史记录的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在service包内定义一个名为<code>MemberReadHistoryService</code>的接口，用于定义与会员浏览商品历史记录管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 生成浏览历史记录</span><br><span class="line">     * @param memberReadHistory 浏览历史记录信息</span><br><span class="line">     */</span><br><span class="line">    int create(MemberReadHistory memberReadHistory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除浏览历史记录</span><br><span class="line">     * @param ids 浏览历史记录id</span><br><span class="line">     */</span><br><span class="line">    int delete(List&lt;String&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定会员的浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; list(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为<code>MemberReadHistoryServiceImpl</code>的类，这个类需要实现<code>MemberReadHistoryService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class MemberReadHistoryServiceImpl implements MemberReadHistoryService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryRepository memberReadHistoryRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int create(MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        memberReadHistory.setId(null);</span><br><span class="line">        memberReadHistory.setCreateTime(new Date());</span><br><span class="line">        memberReadHistoryRepository.save(memberReadHistory);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(List&lt;String&gt; ids) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; deleteMemberReadHistoryLists = new ArrayList&lt;&gt;();</span><br><span class="line">        for(String id:ids)&#123;</span><br><span class="line">            MemberReadHistory memberReadHistory = new MemberReadHistory();</span><br><span class="line">            memberReadHistory.setId(id);</span><br><span class="line">            deleteMemberReadHistoryLists.add(memberReadHistory);</span><br><span class="line">        &#125;</span><br><span class="line">        memberReadHistoryRepository.deleteAll(deleteMemberReadHistoryLists);</span><br><span class="line">        return deleteMemberReadHistoryLists.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MemberReadHistory&gt; list(Long memberId) &#123;</span><br><span class="line">        return memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为<code>MemberReadHistoryController</code>的类，这是会员商品浏览历史记录管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;MemberReadHistoryController&quot;,description = &quot;会员商品浏览历史记录管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/member/readHistory&quot;)</span><br><span class="line">public class MemberReadHistoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryService memberReadHistoryService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;创建浏览记录&quot;)</span><br><span class="line">    @PostMapping( &quot;/create&quot;)</span><br><span class="line">    public CommonResult create(@RequestBody MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        int count = memberReadHistoryService.create(memberReadHistory);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;删除浏览记录&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete&quot;)</span><br><span class="line">    public CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;String&gt; ids) &#123;</span><br><span class="line">        int count = memberReadHistoryService.delete(ids);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;展示浏览记录&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;MemberReadHistory&gt;&gt; list(@RequestParam(value = &quot;memberId&quot;)@ApiParam(&quot;会员id&quot;) Long memberId) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; memberReadHistoryList = memberReadHistoryService.list(memberId);</span><br><span class="line">        return CommonResult.success(memberReadHistoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dd8a052925639de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十步</strong>，进行接口测试。首先后台用户进行登录，接着测试“创建浏览记录”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e6f92e5435b42a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以更改memberId来创建两条测试数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ee8bb3da8a9c429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着测试一下查看某会员商品浏览历史记录接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cf379c721ab83d3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cfa677df390fa9b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合MongoDB实现用户商品浏览记录的学习就完成了，后续介绍如何整合RabbitMQ实现延迟消息这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-mongodb">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。&lt;</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用ElasticSearch实现商品复杂搜索</title>
    <link href="http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/"/>
    <id>http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/</id>
    <published>2023-02-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:41:37.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能。</p><h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><p>由于商品搜索涉及到中文搜索，因此ElasticSearch需要安装分词器才可以支持。前面我们安装的分词器是IKAnalyzer，接下来简单学习如何使用它。</p><h3 id="默认分词器"><a href="#默认分词器" class="headerlink" title="默认分词器"></a>默认分词器</h3><p>使用默认分词器，只是将中文逐字进行分割，并不符合我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae1a50cce244e752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="中文分词器-1"><a href="#中文分词器-1" class="headerlink" title="中文分词器"></a>中文分词器</h3><p>使用中文分词器后，可以将中文文本按照语境进行分隔，可以满足我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bdeab3b6591aa428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实在前一文中，我们就在EsProduct中，对于需要进行中文分词的字段，都使用了<code>@Field</code>注解且将analyzer属性设置为<code>ik_max_word</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品名称</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 副标题</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String subTitle;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关键字</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String keywords;</span><br></pre></td></tr></table></figure><h1 id="商品简单搜索"><a href="#商品简单搜索" class="headerlink" title="商品简单搜索"></a>商品简单搜索</h1><p>商品简单搜索即通过商品名称、副标题或者关键字来搜索包含指定关键字的商品。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现"><a href="#使用Query-DSL来调用ES的Restful-API来实现" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 5,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;小米&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92e8865c96648ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elasticsearch-Repository的衍生查询"><a href="#Elasticsearch-Repository的衍生查询" class="headerlink" title="Elasticsearch Repository的衍生查询"></a>Elasticsearch Repository的衍生查询</h1><p>Elasticsearch Repository的衍生查询原理其实很简单，就是将一定规则名称的方法转化为Elasticsearch的Query DSL语句，可以查看如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8cb04a107ff6d6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="复杂商品搜索"><a href="#复杂商品搜索" class="headerlink" title="复杂商品搜索"></a>复杂商品搜索</h1><p>复杂商品搜索会涉及到过滤、不同字段匹配权重以及排序等功能。</p><p>这里的需求是按照输入的关键字来搜索商品名称、副标题和关键字，可以按照品牌和分类进行筛选，可以有5种排序方式，默认按相关度进行排序。查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8984cbb5ee895f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里有一些比较特殊的需求，如商品名称匹配关键字的商品，我们认为与搜索条件更匹配，其次是副标题和关键字，此时就需要使用到<code>function_score</code>查询。</p><p>在ElasticSearch中，搜索到文档的相关性由<code>_score</code>字段来表示，文档的<code>_score</code>字段值越高，表示与搜索条件越匹配。而<code>function_score</code>查询可通过设置权重来影响<code>_score</code>字段值，因此使用<code>function_score</code>查询就可以很好的满足我们的需求。</p><p>这里我们设置商品名称权重为10，商品副标题权重为5，商品关键字权重为2。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-1"><a href="#使用Query-DSL来调用ES的Restful-API来实现-1" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;&quot;match_all&quot;: &#123;&#125;&#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must&quot; :[</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;brandId&quot;: 6</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;productCategoryId&quot;: 19</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 10</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_score&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-508e99c72af4b0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到EsProductService接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据关键字搜索名称、副标题或者关键字复合查询</span><br><span class="line"> * @param keyword 关键字</span><br><span class="line"> * @param brandId 品牌id</span><br><span class="line"> * @param productCategoryId 商品类别id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @param sort 排序字段</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; search(String keyword,Long brandId,Long productCategoryId,Integer pageNum, Integer pageSize,Integer sort);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个search方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; search(String keyword, Long brandId, Long productCategoryId, Integer pageNum, Integer pageSize, Integer sort) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    NativeSearchQueryBuilder nativeSearchQueryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //分页</span><br><span class="line">    nativeSearchQueryBuilder.withPageable(pageable);</span><br><span class="line">    //过滤</span><br><span class="line">    if(brandId != null || productCategoryId != null)&#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        if(brandId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;brandId&quot;,brandId));</span><br><span class="line">        &#125;</span><br><span class="line">        if(productCategoryId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;productCategoryId&quot;,productCategoryId));</span><br><span class="line">        &#125;</span><br><span class="line">        nativeSearchQueryBuilder.withFilter(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //搜索</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(10)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序</span><br><span class="line">    if(sort == 1)&#123;</span><br><span class="line">        //按新品从新到旧</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;id&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 2)&#123;</span><br><span class="line">        //按销量从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;sale&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 3)&#123;</span><br><span class="line">        //按价格从低到高</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.ASC));</span><br><span class="line">    &#125;else if(sort == 4)&#123;</span><br><span class="line">        //按价格从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //按相关度</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    &#125;</span><br><span class="line">    //不传则默认按照相关度由高到低排</span><br><span class="line">    nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    NativeSearchQuery searchQuery = nativeSearchQueryBuilder.build();</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">    return esProductRepository.search(searchQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为search的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;综合搜索、筛选、排序&quot;)</span><br><span class="line">@ApiImplicitParam(name = &quot;sort&quot;, value = &quot;排序字段:0-&gt;按相关度；1-&gt;按新品；2-&gt;按销量；3-&gt;价格从低到高；4-&gt;价格从高到低&quot;,</span><br><span class="line">        defaultValue = &quot;0&quot;, allowableValues = &quot;0,1,2,3,4&quot;, paramType = &quot;query&quot;, dataType = &quot;integer&quot;)</span><br><span class="line">@GetMapping(&quot;/search&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;品牌id&quot;) Long brandId,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;商品类别id&quot;) Long productCategoryId,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;) @ApiParam(&quot;排序字段&quot;)Integer sort) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword,brandId,productCategoryId,pageNum, pageSize,sort);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关商品推荐（猜你喜欢）"><a href="#相关商品推荐（猜你喜欢）" class="headerlink" title="相关商品推荐（猜你喜欢）"></a>相关商品推荐（猜你喜欢）</h1><p>当我们在查看某个商品的时候，底部一般会有一些商品推荐（猜你喜欢），这里我们选择使用ElasticSearch来简单实现。</p><p>这里的需求是，可以根据指定商品的id来查找相关商品，查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f2d3b4d8af714ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说我们这里的原理是这样的：首先根据商品id获取到指定商品的信息，然后以指定商品的名称、品牌、分类来搜索商品，并且过滤掉当前的商品（剔除此商品的id），调整搜索条件中的权重以获取最好的匹配度。</p><p>这里我们设置商品名称权重为8，商品副标题权重为2，商品关键字权重为2，商品品牌id权重为5，商品商品类别id权重为3。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-2"><a href="#使用Query-DSL来调用ES的Restful-API来实现-2" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must_not&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                  &quot;id&quot;: 28</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 8</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brandId&quot;: 6</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;productCategoryId&quot;: 19</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 3</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6427b03e1f96d556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据商品id推荐相关商品</span><br><span class="line"> * @param id 商品id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个recommend方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    List&lt;EsProduct&gt; esProductList = esProductDao.getAllEsProductList(id);</span><br><span class="line">    if(esProductList.size()&gt;0)&#123;</span><br><span class="line">        EsProduct esProduct = esProductList.get(0);</span><br><span class="line">        String keyword = esProduct.getName();</span><br><span class="line">        Long brandId = esProduct.getBrandId();</span><br><span class="line">        Long productCategoryId = esProduct.getProductCategoryId();</span><br><span class="line">        //根据商品标题、品牌、分类进行搜索</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(8)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;brandId&quot;,brandId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;productCategoryId&quot;,productCategoryId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(3)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        //过滤掉相同的商品</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();</span><br><span class="line">        boolQueryBuilder.mustNot(QueryBuilders.termQuery(&quot;id&quot;,id));</span><br><span class="line"></span><br><span class="line">        //构建查询条件</span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">        builder.withFilter(boolQueryBuilder);</span><br><span class="line">        builder.withPageable(pageable);</span><br><span class="line">        NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">        LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">        return esProductRepository.search(searchQuery);</span><br><span class="line">    &#125;</span><br><span class="line">    return new PageImpl&lt;&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为recommend的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;根据商品id推荐商品&quot;)</span><br><span class="line">@GetMapping( &quot;/recommend/&#123;id&#125;&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; recommend(@PathVariable @ApiParam(&quot;商品id&quot;) Long id,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.recommend(id, pageNum, pageSize);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聚合搜索商品相关信息"><a href="#聚合搜索商品相关信息" class="headerlink" title="聚合搜索商品相关信息"></a>聚合搜索商品相关信息</h1><p>在搜索商品时，通常会有一个筛选界面来帮助用户快速找到想要的商品，这里使用Elasticsearch来简单实现。</p><p>这里的需求是，可以根据搜索关键字获取到与关键字匹配商品相关的分类，品牌以及属性，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9305b0e633b7e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里可以使用ElasticSearch的聚合来实现，搜索出相关商品，聚合出商品的品牌、分类以及属性，取出现次数最多的前10个即可。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-3"><a href="#使用Query-DSL来调用ES的Restful-API来实现-3" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;华为&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,</span><br><span class="line">        &quot;subTitle&quot;,</span><br><span class="line">        &quot;keywords&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brandName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;productCategoryNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;productCategoryName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;allAttrValues&quot;: &#123;</span><br><span class="line">      &quot;nested&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;attrValueList&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;productAttrs&quot;: &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;attrValueList.type&quot;: 1</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;attrIds&quot;: &#123;</span><br><span class="line">              &quot;terms&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;attrValueList.productAttributeId&quot;,</span><br><span class="line">                &quot;size&quot;: 10</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;attrValues&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.value&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;attrNames&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.name&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，当我们搜索“华为”这个关键字时，聚合出了如下的分类和品牌信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08de9f19d304b551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>聚合出了“屏幕尺寸”、“网络”、“系统”等筛选属性信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6b22dccdf4ad08fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>在SpringBoot中实现聚合操作非常复杂，已经超出了Elasticsearch Repository的使用范围，需要直接使用更为底层的<code>ElasticsearchTemplate</code>来实现。</p><p><strong>第一步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内定义一个名为domain的包，并在domain包内定义一个名为<code>EsProductRelatedInfo</code>的类，这是搜索相关商品品牌名称，分类名称及属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索相关商品品牌名称，分类名称及属性</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductRelatedInfo &#123;</span><br><span class="line">    private List&lt;String&gt; brandNames;</span><br><span class="line">    private List&lt;String&gt; productCategoryNames;</span><br><span class="line">    private List&lt;ProductAttr&gt; productAttrs;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    public static class ProductAttr&#123;</span><br><span class="line">        private Long attrId;</span><br><span class="line">        private String attrName;</span><br><span class="line">        private List&lt;String&gt; attrValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取搜索词相关品牌、分类、属性</span><br><span class="line"> */</span><br><span class="line">EsProductRelatedInfo searchRelatedInfo(String keyword);</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>EsProductServiceImpl</code>类中实现这个<code>searchRelatedInfo</code>方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public EsProductRelatedInfo searchRelatedInfo(String keyword) &#123;</span><br><span class="line">    NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">    //搜索条件</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.multiMatchQuery(keyword,&quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //聚合搜索品牌名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;brandNames&quot;).field(&quot;brandName&quot;));</span><br><span class="line">    //集合搜索分类名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;productCategoryNames&quot;).field(&quot;productCategoryName&quot;));</span><br><span class="line">    //聚合搜索商品属性，去除type=1的属性</span><br><span class="line">    AbstractAggregationBuilder aggregationBuilder = AggregationBuilders.nested(&quot;allAttrValues&quot;,&quot;attrValueList&quot;)</span><br><span class="line">            .subAggregation(AggregationBuilders.filter(&quot;productAttrs&quot;,QueryBuilders.termQuery(&quot;attrValueList.type&quot;,1))</span><br><span class="line">                    .subAggregation(AggregationBuilders.terms(&quot;attrIds&quot;)</span><br><span class="line">                            .field(&quot;attrValueList.productAttributeId&quot;)</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrValues&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.value&quot;))</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrNames&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.name&quot;))));</span><br><span class="line">    builder.addAggregation(aggregationBuilder);</span><br><span class="line">    NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">    SearchResponse searchResponse = elasticsearchTemplate.query(searchQuery, response -&gt; response);</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;,searchQuery.getQuery().toString());</span><br><span class="line">    return convertProductRelatedInfo(searchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将返回结果转换为对象</span><br><span class="line"> */</span><br><span class="line">private EsProductRelatedInfo convertProductRelatedInfo(SearchResponse searchResponse) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = new EsProductRelatedInfo();</span><br><span class="line">    Map&lt;String, Aggregation&gt; aggregationMap = searchResponse.getAggregations().getAsMap();</span><br><span class="line">    //设置品牌</span><br><span class="line">    Aggregation brandNames = aggregationMap.get(&quot;brandNames&quot;);</span><br><span class="line">    List&lt;String&gt; brandNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i&lt;((Terms) brandNames).getBuckets().size(); i++)&#123;</span><br><span class="line">        brandNameList.add(((Terms) brandNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setBrandNames(brandNameList);</span><br><span class="line">    //设置分类</span><br><span class="line">    Aggregation productCategoryNames = aggregationMap.get(&quot;productCategoryNames&quot;);</span><br><span class="line">    List&lt;String&gt; productCategoryNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i=0;i&lt;((Terms) productCategoryNames).getBuckets().size();i++)&#123;</span><br><span class="line">        productCategoryNameList.add(((Terms) productCategoryNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductCategoryNames(productCategoryNameList);</span><br><span class="line">    //设置参数</span><br><span class="line">    Aggregation productAttrs = aggregationMap.get(&quot;allAttrValues&quot;);</span><br><span class="line">    List&lt;? extends Terms.Bucket&gt; attrIds = ((LongTerms) ((Filter) ((Nested) productAttrs).getAggregations().get(&quot;productAttrs&quot;)).getAggregations().get(&quot;attrIds&quot;)).getBuckets();</span><br><span class="line">    List&lt;EsProductRelatedInfo.ProductAttr&gt; attrList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Terms.Bucket attrId : attrIds) &#123;</span><br><span class="line">        EsProductRelatedInfo.ProductAttr attr = new EsProductRelatedInfo.ProductAttr();</span><br><span class="line">        attr.setAttrId((Long) attrId.getKey());</span><br><span class="line">        List&lt;String&gt; attrValueList = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrValues = ((StringTerms) attrId.getAggregations().get(&quot;attrValues&quot;)).getBuckets();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrNames = ((StringTerms) attrId.getAggregations().get(&quot;attrNames&quot;)).getBuckets();</span><br><span class="line">        for (Terms.Bucket attrValue : attrValues) &#123;</span><br><span class="line">            attrValueList.add(attrValue.getKeyAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        attr.setAttrValues(attrValueList);</span><br><span class="line">        if(!CollectionUtils.isEmpty(attrNames))&#123;</span><br><span class="line">            String attrName = attrNames.get(0).getKeyAsString();</span><br><span class="line">            attr.setAttrName(attrName);</span><br><span class="line">        &#125;</span><br><span class="line">        attrList.add(attr);</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductAttrs(attrList);</span><br><span class="line">    return productRelatedInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>EsProductController</code>类中定义一个名为<code>searchRelatedInfo</code>的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;获取搜索的相关品牌、分类及筛选属性&quot;)</span><br><span class="line">@GetMapping(value = &quot;/search/relate&quot;)</span><br><span class="line">public CommonResult&lt;EsProductRelatedInfo&gt; searchRelatedInfo(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = esProductService.searchRelatedInfo(keyword);</span><br><span class="line">    return CommonResult.success(productRelatedInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fef19695a18583e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后进行接口测试。首先后台用户进行登录，接着测试相关接口，可以看到接口都是正常的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a308b197290a377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1cd8c204dc3094e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于使用ElasticSearch实现商品复杂搜索的学习就完成了，后续介绍如何整合MongoDB实现用户商品浏览记录这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合ElasticSearch实现商品搜索</title>
    <link href="http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/"/>
    <id>http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/</id>
    <published>2023-01-20T06:55:30.000Z</published>
    <updated>2023-03-14T06:38:37.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索这一功能。</p><h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><p>ElasticSearch是一个分布式、可扩展、实时的搜索与数据分析引擎，它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，在日常工作和学习中扮演着非常重要的角色。关于ElasticSearch的学习，可以参考笔者的其他文章。注意本篇使用的ElasticSearch版本为6.8.6。</p><p>Kibana作为访问ElasticSearch的客户端，可以很方便的提供开发者可视化方式操作ES。</p><p>在整合前，请确保ElasticSearch和Kibana都已经正确安装并启动，且ElasticSearch的分词器也已经安装。</p><h1 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h1><p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-Elasticsearch常用注解"><a href="#Spring-Data-Elasticsearch常用注解" class="headerlink" title="Spring Data Elasticsearch常用注解"></a>Spring Data Elasticsearch常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到ElasticSearch文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    //索引名称，类似于数据库中的数据库</span><br><span class="line">    String indexName();</span><br><span class="line">    //类型，类似于数据库中的数据表</span><br><span class="line">    String type() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useServerConfiguration() default false;</span><br><span class="line">    //分片数，默认为5</span><br><span class="line">    short shards() default 5;</span><br><span class="line">    //副本数，默认为1</span><br><span class="line">    short replicas() default 1;</span><br><span class="line">    //每次刷新间隔，默认1秒</span><br><span class="line">    String refreshInterval() default &quot;1s&quot;;</span><br><span class="line"></span><br><span class="line">    String indexStoreType() default &quot;fs&quot;;</span><br><span class="line"></span><br><span class="line">    boolean createIndex() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到ElasticSearch文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="@Field"></a>@Field</h3><p><code>@Field</code>注解添加到映射到ElasticSearch文档上的领域对象字段上，注意它用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Field &#123;</span><br><span class="line">    //文档中字段的类型</span><br><span class="line">    FieldType type() default FieldType.Auto;</span><br><span class="line">    //是否建立倒排索引，默认是</span><br><span class="line">    boolean index() default true;</span><br><span class="line"></span><br><span class="line">    DateFormat format() default DateFormat.none;</span><br><span class="line"></span><br><span class="line">    String pattern() default &quot;&quot;;</span><br><span class="line">    //是否进行存储</span><br><span class="line">    boolean store() default false;</span><br><span class="line"></span><br><span class="line">    boolean fielddata() default false;</span><br><span class="line"></span><br><span class="line">    String searchAnalyzer() default &quot;&quot;;</span><br><span class="line">    //分词器名称</span><br><span class="line">    String analyzer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String normalizer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] ignoreFields() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    boolean includeInParent() default false;</span><br><span class="line"></span><br><span class="line">    String[] copyTo() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个FieldType是一个枚举类，用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum FieldType &#123;</span><br><span class="line">    Text,  //进行分词并建立索引的字符类型</span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,  //自动判断字段类型</span><br><span class="line">    Nested,  //嵌套对象类型</span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword;  //不进行分词并建立索引的类型</span><br><span class="line"></span><br><span class="line">    private FieldType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承ElasticsearchRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface ElasticsearchRepository&lt;T, ID extends Serializable&gt; extends ElasticsearchCrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; S index(S var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; search(QueryBuilder var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(QueryBuilder var1, Pageable var2);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(SearchQuery var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; searchSimilar(T var1, String[] var2, Pageable var3);</span><br><span class="line"></span><br><span class="line">    void refresh();</span><br><span class="line"></span><br><span class="line">    Class&lt;T&gt; getEntityClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d961153b53feaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，商品表中有商品名称、商品副标题和关键字，直接在接口中定义如下方法，即可对这三个字段进行全文搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索查询</span><br><span class="line"> * @param name 商品名称</span><br><span class="line"> * @param subTitle 商品副标题</span><br><span class="line"> * @param keywords 商品关键字</span><br><span class="line"> * @param page 分页信息</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fb03dc0544a57dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用ElasticSearch的DSL语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?0&quot;&#125;&#125;&#125;&#125;&quot;)</span><br><span class="line">Page&lt;EsProduct&gt; findByName(String name,Pageable pageable);</span><br></pre></td></tr></table></figure><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>（1）<code>pms_product</code>：商品信息表；<br>（2）<code>pms_product_attribute</code>：商品属性参数表；<br>（3）<code>pms_product_attribute_value</code>：存储产品参数值的表，即商品id与商品属性id之间的对应关系表。</p><h1 id="整合ElasticSearch实现商品搜索"><a href="#整合ElasticSearch实现商品搜索" class="headerlink" title="整合ElasticSearch实现商品搜索"></a>整合ElasticSearch实现商品搜索</h1><p><strong>第一步</strong>，复制一份<code>shop-springsecurity-jwt</code>源码，将其名字修改为<code>shop-elasticsearch</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-elasticsearch</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-elasticsearch</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Elasticsearch相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在spring节点下添加ElasticSearch相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ElasticSearch相关</span><br><span class="line">data:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    repositories:</span><br><span class="line">      enabled: true</span><br><span class="line">    cluster-nodes: localhost:9300 # es的连接地址及端口号</span><br><span class="line">    cluster-name: elasticsearch # es集群的名称</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述三张表的对应信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内新建一个名为nosql的包，并在nosql包内定义一个名为elasticsearch的包，接着在elasticsearch包内定义一个名为document的包。然后在document包内定义一个名为EsProduct的类，注意这是商品文档对象。</p><p>一般来说，不需要分词的字段可以设置类型为Keyword，也就是使用<code>@Field(type = FieldType.Keyword)</code>注解，如这里的货号、品牌名称和商品分类名称。而需要进行分词的字段可以设置为Text类型，即使用<code>@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</code>注解，如这里的商品名称、副标题和关键字，同时需要指定分词器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document(indexName = &quot;pms&quot;, type = &quot;product&quot;,shards = 1,replicas = 0)</span><br><span class="line">public class EsProduct implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -1L;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line">    private Long brandId;</span><br><span class="line">    private Long productCategoryId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 货号</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productSn;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 品牌名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String brandName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品分类名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productCategoryName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 副标题</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String subTitle;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关键字</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String keywords;</span><br><span class="line"></span><br><span class="line">    private String pic;</span><br><span class="line">    private BigDecimal price;</span><br><span class="line">    private Integer sale;</span><br><span class="line">    private Integer newStatus;</span><br><span class="line">    private Integer recommendStatus;</span><br><span class="line">    private Integer stock;</span><br><span class="line">    private Integer promotionType;</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 嵌套类型，商品属性列表</span><br><span class="line">     */</span><br><span class="line">    @Field(type =FieldType.Nested)</span><br><span class="line">    private List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在document包内定义一个名为<code>EsProductAttributeValue</code>的类，因为商品文档对象EsProduct中有一个名为attrValueList的属性，它是一个List类型，里面都是<code>EsProductAttributeValue</code>对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品属性信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductAttributeValue implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品属性值id</span><br><span class="line">     */</span><br><span class="line">    private Long productAttributeId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性值</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性参数：0-&gt;规格；1-&gt;参数</span><br><span class="line">     */</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type=FieldType.Keyword)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch</code>包内新建一个名为repository的包，并在该包内定义一个名为<code>EsProductRepository</code>的接口，注意这个接口需要继承<code>ElasticsearchRepository</code>接口，这样就拥有了一些基本的操作ElasticSearch数据的方法，同时我们在里面定义了一个衍生的根据条件搜索查询商品的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在dao包内定义一个名为<code>EsProductDao</code>的接口，这是搜索系统中商品管理自定义的Dao。我们在里面添加一个从数据库中查询所有商品文档对象EsProduct的方法，当然了这个方法也可以传入id变成查询指定id的商品文档对象。简单来说就是查询数据库的多张表，将商品信息组装为EsProduct对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索系统中商品管理自定义的Dao</span><br><span class="line"> */</span><br><span class="line">public interface EsProductDao &#123;</span><br><span class="line">    List&lt;EsProduct&gt; getAllEsProductList(@Param(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在<code>resources/mapper</code>包内定义一个名为<code>EsProductDao</code>的XML文件，这是第八步中对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopelasticsearch.dao.EsProductDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;esProductListMap&quot; type=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct&quot;</span><br><span class="line">               autoMapping=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">        &lt;collection property=&quot;attrValueList&quot; columnPrefix=&quot;attr_&quot; ofType=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue&quot;&gt;</span><br><span class="line">            &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;product_attribute_id&quot; property=&quot;productAttributeId&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;value&quot; property=&quot;value&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;type&quot; property=&quot;type&quot;/&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;select id=&quot;getAllEsProductList&quot; resultMap=&quot;esProductListMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">            p.id id,</span><br><span class="line">            p.product_sn productSn,</span><br><span class="line">            p.brand_id brandId,</span><br><span class="line">            p.brand_name brandName,</span><br><span class="line">            p.product_category_id productCategoryId,</span><br><span class="line">            p.product_category_name productCategoryName,</span><br><span class="line">            p.pic pic,</span><br><span class="line">            p.name name,</span><br><span class="line">            p.sub_title subTitle,</span><br><span class="line">            p.price price,</span><br><span class="line">            p.sale sale,</span><br><span class="line">            p.new_status newStatus,</span><br><span class="line">            p.recommend_status recommendStatus,</span><br><span class="line">            p.stock stock,</span><br><span class="line">            p.promotion_type promotionType,</span><br><span class="line">            p.keywords keywords,</span><br><span class="line">            p.sort sort,</span><br><span class="line">            pav.id attr_id,</span><br><span class="line">            pav.value attr_value,</span><br><span class="line">            pav.product_attribute_id attr_product_attribute_id,</span><br><span class="line">            pa.type attr_type,</span><br><span class="line">            pa.name attr_name</span><br><span class="line">        from pms_product p</span><br><span class="line">        left join pms_product_attribute_value pav on p.id = pav.product_id</span><br><span class="line">        left join pms_product_attribute pa on pav.product_attribute_id= pa.id</span><br><span class="line">        where delete_status = 0 and publish_status = 1</span><br><span class="line">        &lt;if test=&quot;id!=null&quot;&gt;</span><br><span class="line">            and p.id=#&#123;id&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下上述配置信息的含义：<br>（1）mapper标签中的namespace属性用于指定此Mapper文件所对应的接口文件是第八步中定义的接口文件，即该文件的项目路径；<br>（2）由于<code>getAllEsProductList(@Param(&quot;id&quot;) Long id)</code>方法返回的是一个<code>List&lt;EsProduct&gt;</code>对象，因此该select标签返回的是一个resultMap对象，而这个对象返回的应该是<code>List&lt;EsProduct&gt;</code>中的EsProduct对象；<br>（3）在该mapper文件中定义一个id为<code>esProductListMap</code>的resultMap，然后指定type属性为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct</code>，也就是ES中存的对象类型。同时这里需要设置autoMapping属性的值为true，表示自动根据sql语句查询的字段名称与EsProduct类中设置的属性名称进行映射绑定；<br>（4）在resultMap标签内使用一个collection标签，指定property属性为attrValueList，这个值必须与开发者在EsProduct中指定的属性名称完全一致。接着设置columnPrefix，表示我们从数据库使用sql语句查询得到的字段名称都是<code>attr_</code>开头的，ofType指定类型为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue</code>。接着我们就使用result标签来手动将其进行绑定；<br>（5）通过上面的分析，我们知道在select标签中，<code>pms_product</code>表里查询得到的字段必须指定别名为与EsProduct属性相同的名称，而<code>pms_product_attribute_value</code>表中查询得到的字段别名必须以<code>attr_</code>开头，且符合上述自定义的映射关系。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>EsProductService</code>的接口，用于定义EsProduct搜索相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索的Service</span><br><span class="line"> */</span><br><span class="line">public interface EsProductService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 从数据中导入所有商品到ES</span><br><span class="line">     * @return 导入的文档数</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除ES中的商品</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在ES中创建指定id的商品文档信息</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    EsProduct create(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id批量删除ES中的商品</span><br><span class="line">     * @param ids 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(List&lt;Long&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据关键字搜索商品信息</span><br><span class="line">     * @param keyword 关键字</span><br><span class="line">     * @param pageNum 页码</span><br><span class="line">     * @param pageSize 每页数量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; search(String keyword,Integer pageNum, Integer pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>EsProductServiceImpl</code>的类，这个类需要实现<code>EsProductService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(EsProductServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProductIterable = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; esProductIterator = esProductIterable.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (esProductIterator.hasNext())&#123;</span><br><span class="line">            result++;</span><br><span class="line">            esProductIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(Long id) &#123;</span><br><span class="line">        esProductRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public EsProduct create(Long id) &#123;</span><br><span class="line">        EsProduct result = null;</span><br><span class="line">        List&lt;EsProduct&gt; esProductLists = esProductDao.getAllEsProductList(id);</span><br><span class="line">        if(esProductLists.size()&gt;0)&#123;</span><br><span class="line">            EsProduct esProduct = esProductLists.get(0);</span><br><span class="line">            result = esProductRepository.save(esProduct);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(List&lt;Long&gt; ids) &#123;</span><br><span class="line">        if(!CollectionUtils.isEmpty(ids))&#123;</span><br><span class="line">            List&lt;EsProduct&gt; esProductList = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Long id:ids) &#123;</span><br><span class="line">                EsProduct esProduct = new EsProduct();</span><br><span class="line">                esProduct.setId(id);</span><br><span class="line">                esProductList.add(esProduct);</span><br><span class="line">            &#125;</span><br><span class="line">            esProductRepository.deleteAll(esProductList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，在controller包内定义一个名为<code>EsProductController</code>的类，这是商品搜索功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品搜索管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;EsProductController&quot;,description = &quot;商品搜索管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/esProduct&quot;)</span><br><span class="line">public class EsProductController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductService esProductService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;导入所有数据库中商品到ES&quot;)</span><br><span class="line">    @PostMapping(&quot;/importAll&quot;)</span><br><span class="line">    public CommonResult&lt;Integer&gt; importAllList() &#123;</span><br><span class="line">        int count = esProductService.importAll();</span><br><span class="line">        return CommonResult.success(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id删除Es中指定的商品信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@PathVariable Long id) &#123;</span><br><span class="line">        esProductService.delete(id);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id批量删除Es中的商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/delete/batch&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;</span><br><span class="line">        esProductService.delete(ids);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id在ES中创建商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/create/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;EsProduct&gt; create(@PathVariable Long id) &#123;</span><br><span class="line">        EsProduct esProduct = esProductService.create(id);</span><br><span class="line">        if (esProduct != null) &#123;</span><br><span class="line">            return CommonResult.success(esProduct);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;简单搜索&quot;)</span><br><span class="line">    @GetMapping(&quot;/search/simple&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">        Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword, pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，修改<code>com.kenbings.shop.shopelasticsearch.common.api.CommonPage</code>类，在里面新增加一个将SpringData 分页后的list转为分页信息的restPage方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将 SpringData 分页后的list转为分页信息</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; CommonPage&lt;T&gt; restPage(Page&lt;T&gt; pageInfo)&#123;</span><br><span class="line">    CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">    commonPage.setPageNum(pageInfo.getNumber());</span><br><span class="line">    commonPage.setPageSize(pageInfo.getSize());</span><br><span class="line">    commonPage.setTotalPage(pageInfo.getTotalPages());</span><br><span class="line">    commonPage.setTotal(pageInfo.getTotalElements());</span><br><span class="line">    commonPage.setList(pageInfo.getContent());</span><br><span class="line">    return commonPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-759bd6bcb461605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十五步</strong>，进行接口测试。首先后台用户进行登录，接着测试“导入所有数据库中商品到ES”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96277397495717d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“简单搜索”这一接口，可以看到测试成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b838446b00c212b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合ElasticSearch实现商品搜索的学习就完成了，后续介绍如何使用ElasticSearch实现复杂搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合SpringSecurity和JWT实现认证与授权</title>
    <link href="http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/"/>
    <id>http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/</id>
    <published>2023-01-14T10:55:30.000Z</published>
    <updated>2023-03-14T06:36:44.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>SpringSecurity是一个强大的可高度定制的认证与授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。关于SpringSecurity的学习，可以参考笔者的其他文章。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JWT是JSON WEB TOKEN的缩写，它是基于RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p><h5 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h5><p>JWT由三部分组成：header、playload和signature，JWT token的格式为<code>header.payload.signature</code>。</p><p>其中header中用于存放签名的生成算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;: &quot;HS512&quot;&#125;</span><br></pre></td></tr></table></figure><p>payload中用于存放用户名、token的生成时间和过期时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;sub&quot;:&quot;admin&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br></pre></td></tr></table></figure><p>signature为以header和payload生成的签名，一旦header和payload被篡改，那么验证将失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//secret为加密算法的密钥</span><br><span class="line">String signature = HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure><h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><p>如下是一个JWT的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw</span><br></pre></td></tr></table></figure><p>开发者可以点击 <a href="https://jwt.io/">这里</a> 获取到解析结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b52c581daa8e3375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="JWT实现认证和授权的原理"><a href="#JWT实现认证和授权的原理" class="headerlink" title="JWT实现认证和授权的原理"></a>JWT实现认证和授权的原理</h5><p>第一步，用户调用登录接口，登录成功后获取到JWT的token；</p><p>第二步，用户后续每次调用接口时，都会在http的header中添加一个名为Authorization的头，值为JWT的token；</p><p>第三步，后台程序通过对Authorization头中信息的解码及数字签名，校验来获取其中的用户信息，进而实现认证和授权。</p><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p>Hutool是一个丰富的Java开源工具包，可以帮助我们简化每一行代码，减少每一个方法。</p><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>由于此处采用的是RBAC（基于角色的权限控制）模型，一般会涉及到五张表，同时外加针对某个用户的特定角色，因此会涉及到六张表，分别如下所示：<br>（1）<code>ums_admin</code>：后台用户表；<br>（2）<code>ums_role</code>：后台用户角色表；<br>（3）<code>ums_permission</code>：后台用户权限表；<br>（4）<code>ums_admin_role_relation</code>：后台用户和角色关系表，用户与角色是多对多关系；<br>（5） <code>ums_role_permission_relation</code>：后台用户角色和权限关系表，角色与权限是多对多关系；<br>（6）<code>ums_admin_permission_relation</code>：后台用户和权限关系表(除角色中定义的权限以外的加减权限)，加权限是指用户比角色多出的权限，减权限是指用户比角色少的权限。</p><h1 id="整合SpringSecurity及JWT"><a href="#整合SpringSecurity及JWT" class="headerlink" title="整合SpringSecurity及JWT"></a>整合SpringSecurity及JWT</h1><p><strong>第一步</strong>，复制一份<code>shop-redis</code>源码，将其名字修改为<code>shop-springsecurity-jwt</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-springsecurity-jwt</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-springsecurity-jwt</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringSecurity依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Hutool Java工具包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--JWT(Json Web Token)登录支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在根节点下添加jwt自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自定义jwt的key</span><br><span class="line">jwt:</span><br><span class="line">  tokenHeader: Authorization #JWT存储的请求头</span><br><span class="line">  secret: mySecret #JWT加解密使用的密钥</span><br><span class="line">  expiration: 604800 #JWT的超期限时间(60*60*24)</span><br><span class="line">  tokenHead: Bearer  #JWT负载中拿到开头</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt.common</code>包内新建一个名为utils的包，并在utils包内定义一个名为JwtTokenUtil的工具类，该类用于生成和解析JWT token以获取对应信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JwtToken生成的工具类</span><br><span class="line"> * JWT token的格式：header.payload.signature</span><br><span class="line"> * header的格式（算法、token的类型）：</span><br><span class="line"> * &#123;&quot;alg&quot;: &quot;HS512&quot;,&quot;typ&quot;: &quot;JWT&quot;&#125;</span><br><span class="line"> * payload的格式（用户名、创建时间、生成时间）：</span><br><span class="line"> * &#123;&quot;sub&quot;:&quot;kenbings&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br><span class="line"> * signature的生成算法：</span><br><span class="line"> * HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);</span><br><span class="line">    private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;</span><br><span class="line">    private static final String CLAIM_KEY_CREATED = &quot;created&quot;;</span><br><span class="line">    @Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">    private String secret;</span><br><span class="line">    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span><br><span class="line">    private Long expiration;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT的token</span><br><span class="line">     */</span><br><span class="line">    private String generateToken(Map&lt;String, Object&gt; claims) &#123;</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取JWT中的负载</span><br><span class="line">     */</span><br><span class="line">    private Claims getClaimsFromToken(String token) &#123;</span><br><span class="line">        Claims claims = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.info(&quot;JWT格式验证失败:&#123;&#125;&quot;,token);</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成token的过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date generateExpirationDate() &#123;</span><br><span class="line">        return new Date(System.currentTimeMillis() + expiration * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取登录用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUserNameFromToken(String token) &#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username =  claims.getSubject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证token是否还有效</span><br><span class="line">     *</span><br><span class="line">     * @param token       客户端传入的token</span><br><span class="line">     * @param userDetails 从数据库中查询出来的用户信息</span><br><span class="line">     */</span><br><span class="line">    public boolean validateToken(String token, UserDetails userDetails) &#123;</span><br><span class="line">        String username = getUserNameFromToken(token);</span><br><span class="line">        return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否已经失效</span><br><span class="line">     */</span><br><span class="line">    private boolean isTokenExpired(String token) &#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        return expiredDate.before(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date getExpiredDateFromToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        return claims.getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户信息生成token</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否可以被刷新</span><br><span class="line">     */</span><br><span class="line">    public boolean canRefresh(String token) &#123;</span><br><span class="line">        return !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新token</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下其中比较重要的三个方法的作用：<br>（1）<code>generateToken(UserDetails userDetails)</code>方法，传入的是一个UserDetails对象，这是SpringSecurity提供的对象，其实就是用户登录成功后信息的一个封装对象；<br>（2）<code>getUserNameFromToken(String token)</code>方法，从token中获取用户姓名，诸如此类的方法还有很多，这里就不再说明；<br>（3）<code>validateToken(String token, UserDetails userDetails)</code>方法，用于判断token是否有效，其中token是客户端传入的，而userDetails则是从数据库中查询出来的用户信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为component的包，并在component包内定义一个名为<code>RestfulAccessDeniedHandler</code>的类，该类定义当访问接口没有权限时，应当返回的结果，注意它需要实现<code>AccessDeniedHandler</code>接口，并重写其中的handle方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当访问接口没有权限时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestfulAccessDeniedHandler implements AccessDeniedHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在component包内定义一个名为<code>RestAuthenticationEntryPoint</code>的类，该类定义当未登录或者token失效访问接口时，应当返回的结果，注意它需要实现<code>AuthenticationEntryPoint</code>接口，并重写其中的commence方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当未登录或者token失效访问接口时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述六张表的对应信息。</p><p><strong>第八步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dto的包，并在dto包内定义一个名为<code>AdminUserDetails</code>的类，该类定义SpringSecurity登录时需要使用到的UserDetails，注意它需要实现<code>UserDetails</code>接口，并重写其中对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity登录时需要使用到的UserDetails</span><br><span class="line"> */</span><br><span class="line">public class AdminUserDetails implements UserDetails &#123;</span><br><span class="line">    private UmsAdmin umsAdmin;</span><br><span class="line">    private List&lt;UmsPermission&gt; permissionList;</span><br><span class="line"></span><br><span class="line">    public AdminUserDetails(UmsAdmin umsAdmin,List&lt;UmsPermission&gt; permissionList)&#123;</span><br><span class="line">        this.umsAdmin = umsAdmin;</span><br><span class="line">        this.permissionList = permissionList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回当前用户的权限</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        return permissionList.stream().filter(permission -&gt; permission.getValue()!=null)</span><br><span class="line">                .map(permission -&gt; new SimpleGrantedAuthority(permission.getValue()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return umsAdmin.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return umsAdmin.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return umsAdmin.getStatus().equals(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，正常来说这里面方法的逻辑都需要在数据库中定义对应的字段信息，然后根据业务逻辑来进行判断，而不是像这里直接固定化。这个类不需要交由Spring去管理，因此不需要添加<code>@Component</code>注解。</p><p><strong>第九步</strong>，在component包内定义一个名为<code>JwtAuthenticationTokenFilter</code>的类，这是JWT登录授权过滤器，注意它需要继承<code>OncePerRequestFilter</code>类，并重写其中的doFilterInternal方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JWT登录授权过滤器</span><br><span class="line"> */</span><br><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationTokenFilter.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        String authHeader = request.getHeader(this.tokenHeader);</span><br><span class="line">        if (authHeader != null &amp;&amp; authHeader.startsWith(this.tokenHead)) &#123;</span><br><span class="line">            //获取&quot;Bearer &quot;之后的部分</span><br><span class="line">            String authToken = authHeader.substring(this.tokenHead.length());</span><br><span class="line">            String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">            LOGGER.info(&quot;检查用户:&#123;&#125;&quot;, username);</span><br><span class="line">            if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123;</span><br><span class="line">                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);</span><br><span class="line">                if (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    LOGGER.info(&quot;当前认证用户:&#123;&#125;&quot;, username);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在校验用户名和密码之前添加的过滤器，如果请求中包含jwt且token有效，那么会从中用户名，然后调用SpringSecurity的相关API来进行登录操作。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>UmsAdminService</code>的接口，用于定义后台管理员相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名查询后台管理员</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin getAdminByUsername(String username);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员注册</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin register(UmsAdmin umsAdminParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员登录</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param password 密码</span><br><span class="line">     * @return 生成的JWT的token</span><br><span class="line">     */</span><br><span class="line">    String login(String username, String password);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定后台管理员的所有权限（包括角色权限和+-权限）</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>UmsAdminServiceImpl</code>的类，这个类需要实现<code>UmsAdminService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsAdminServiceImpl implements UmsAdminService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(UmsAdminServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminMapper adminMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminRoleRelationDao adminRoleRelationDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin getAdminByUsername(String username) &#123;</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(username);</span><br><span class="line">        List&lt;UmsAdmin&gt; adminLists = adminMapper.selectByExample(example);</span><br><span class="line">        if(adminLists !=null &amp;&amp; !adminLists.isEmpty())&#123;</span><br><span class="line">            return adminLists.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin register(UmsAdmin umsAdminParam) &#123;</span><br><span class="line">        //查询是否有相同用户名的用户</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(umsAdminParam.getUsername());</span><br><span class="line">        List&lt;UmsAdmin&gt; umsAdminList = adminMapper.selectByExample(example);</span><br><span class="line">        if (!umsAdminList.isEmpty()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = new UmsAdmin();</span><br><span class="line">        BeanUtils.copyProperties(umsAdminParam, umsAdmin);</span><br><span class="line">        umsAdmin.setCreateTime(new Date());</span><br><span class="line">        umsAdmin.setStatus(1);</span><br><span class="line">        //将密码进行加密操作</span><br><span class="line">        String encodePassword = passwordEncoder.encode(umsAdmin.getPassword());</span><br><span class="line">        umsAdmin.setPassword(encodePassword);</span><br><span class="line">        adminMapper.insert(umsAdmin);</span><br><span class="line">        return umsAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String login(String username, String password) &#123;</span><br><span class="line">        String token = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">            if(userDetails == null)&#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;不存在对应的用户信息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!passwordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;密码不正确&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            LOGGER.warn(&quot;登录异常:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;UmsPermission&gt; getPermissionList(Long adminId) &#123;</span><br><span class="line">        return adminRoleRelationDao.getPermissionList(adminId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在后面我们定义了<code>getPermissionList(Long adminId)</code>方法，该方法用于根据adminId从数据库中查询用户所有的权限，包括角色权限以及个人独有的权限。</p><p><strong>第十二步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dao的包，并在dao包内定义一个名为<code>UmsAdminRoleRelationDao</code>的接口，这是一个自定义的dao，用于查询后台用户与角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于查询后台用户与角色的自定义DAO</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminRoleRelationDao &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取用户所有权限(包括+-权限)</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(@Param(&quot;adminId&quot;) Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，在resources目录下新建一个名为mapper的目录，并在mapper目录下定义一个名为<code>UmsAdminRoleRelationDao.xml</code>的XML文件，这个其实就是之前UmsAdminRoleRelationDao接口对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopspringsecurityjwt.dao.UmsAdminRoleRelationDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getPermissionList&quot; resultMap=&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper.UmsPermissionMapper.BaseResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_role_relation ar</span><br><span class="line">                LEFT JOIN ums_role r ON ar.role_id = r.id</span><br><span class="line">                LEFT JOIN ums_role_permission_relation rp ON r.id = rp.role_id</span><br><span class="line">                LEFT JOIN ums_permission p ON rp.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            ar.admin_id = #&#123;adminId&#125;</span><br><span class="line">          AND p.id IS NOT NULL</span><br><span class="line">          AND p.id NOT IN (</span><br><span class="line">            SELECT</span><br><span class="line">                p.id</span><br><span class="line">            FROM</span><br><span class="line">                ums_admin_permission_relation pr</span><br><span class="line">                    LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">            WHERE</span><br><span class="line">                pr.type = - 1</span><br><span class="line">              AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">        )</span><br><span class="line">        UNION</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_permission_relation pr</span><br><span class="line">                LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            pr.type = 1</span><br><span class="line">          AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，在config包内定义一个名为SecurityConfig的类，这是SpringSecurity的配置类，它需要继承<code>WebSecurityConfigurerAdapter</code>类，并实现其中的一些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled=true)</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器</span><br><span class="line">     * @param httpSecurity</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        httpSecurity.csrf()// 由于使用的是JWT，我们这里不需要csrf</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement()// 基于token，所以不需要session</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问</span><br><span class="line">                        &quot;/&quot;,</span><br><span class="line">                        &quot;/*.html&quot;,</span><br><span class="line">                        &quot;/favicon.ico&quot;,</span><br><span class="line">                        &quot;/**/*.html&quot;,</span><br><span class="line">                        &quot;/**/*.css&quot;,</span><br><span class="line">                        &quot;/**/*.js&quot;,</span><br><span class="line">                        &quot;/swagger-resources/**&quot;,</span><br><span class="line">                        &quot;/v2/api-docs/**&quot;</span><br><span class="line">                )</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(&quot;/admin/login&quot;, &quot;/admin/register&quot;)// 对登录注册要允许匿名访问</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求</span><br><span class="line">                .permitAll()</span><br><span class="line">//                .antMatchers(&quot;/**&quot;)//测试时全部运行访问</span><br><span class="line">//                .permitAll()</span><br><span class="line">                .anyRequest()// 除上面外的所有请求全部需要鉴权认证</span><br><span class="line">                .authenticated();</span><br><span class="line">        // 禁用缓存</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line">        // 添加JWT filter</span><br><span class="line">        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        //添加自定义未授权和未登录结果返回</span><br><span class="line">        httpSecurity.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(restAuthenticationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置UserDetailsService及PasswordEncoder</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService())</span><br><span class="line">                .passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">        //获取登录用户信息</span><br><span class="line">        return username -&gt; &#123;</span><br><span class="line">            UmsAdmin admin = adminService.getAdminByUsername(username);</span><br><span class="line">            if (admin != null) &#123;</span><br><span class="line">                List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(admin.getId());</span><br><span class="line">                return new AdminUserDetails(admin,permissionList);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()&#123;</span><br><span class="line">        return new JwtAuthenticationTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述一些方法：<br>（1）<code>configure(HttpSecurity httpSecurity)</code>方法，用于配置需要拦截的url路径、jwt过滤器及出现异常后的处理器；<br>（2）<code>configure(AuthenticationManagerBuilder auth)</code>方法，用于配置UserDetailsService及PasswordEncoder；<br>（3）<code>passwordEncoder()</code>方法，这是SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder；<br>（4）<code>userDetailsService()</code>方法，这是SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要开发者自行实现；<br>（5）<code>jwtAuthenticationTokenFilter()</code>方法，这是在校验用户名和密码前添加的过滤器，如果有jwt且token有效，那么会自行根据token信息进行登录；<br>（6）<code>RestfulAccessDeniedHandler</code>，这是当访问接口没有权限时，返回自定义的JSON格式结果；<br>（7）<code>RestAuthenticationEntryPoint</code>，这是当未登录或者token失效访问接口时，返回自定义的JSON格式结果。</p><p><strong>第十五步</strong>，在dto包内定义一个名为<code>UmsAdminLoginParam</code>的类，这是后台管理员登录参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录参数</span><br><span class="line"> */</span><br><span class="line">public class UmsAdminLoginParam &#123;</span><br><span class="line">    @ApiModelProperty(value = &quot;用户名&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;用户名不能为空&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @ApiModelProperty(value = &quot;密码&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;密码不能为空&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，在controller包内定义一个名为<code>UmsAdminController</code>的类，这是后台管理员登录注册功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录注册功能Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags = &quot;UmsAdminController&quot;, description = &quot;后台用户管理&quot;)</span><br><span class="line">@RequestMapping(&quot;/admin&quot;)</span><br><span class="line">public class UmsAdminController &#123;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;用户注册&quot;)</span><br><span class="line">    @PostMapping(&quot;/register&quot;)</span><br><span class="line">    public CommonResult&lt;UmsAdmin&gt; register(@RequestBody UmsAdmin umsAdminParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = adminService.register(umsAdminParam);</span><br><span class="line">        if (umsAdmin == null) &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">        return CommonResult.success(umsAdmin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;登录后返回token&quot;)</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public CommonResult login(@Validated @RequestBody UmsAdminLoginParam umsAdminLoginParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());</span><br><span class="line">        if (token == null) &#123;</span><br><span class="line">            return CommonResult.validateFailed(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;();</span><br><span class="line">        tokenMap.put(&quot;token&quot;, token);</span><br><span class="line">        tokenMap.put(&quot;tokenHead&quot;, tokenHead);</span><br><span class="line">        return CommonResult.success(tokenMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取用户所有权限（包括+-权限）&quot;)</span><br><span class="line">    @GetMapping(&quot;/permission/&#123;adminId&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public CommonResult&lt;List&lt;UmsPermission&gt;&gt; getPermissionList(@PathVariable @ApiParam(&quot;后台用户id&quot;)Long adminId) &#123;</span><br><span class="line">        List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(adminId);</span><br><span class="line">        return CommonResult.success(permissionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们只提供了三个接口，分别是后台用户登录、注册以及获取对应权限的接口。</p><p><strong>第十七步</strong>，修改config包中Swagger2Config类的代码为如下所示，这里其实就是实现接口调用时自带Authorization头，后续就可以访问需要登录的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopspringsecurityjwt.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                //添加登录认证</span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;ApiKey&gt; securitySchemes() &#123;</span><br><span class="line">        //设置请求头信息</span><br><span class="line">        List&lt;ApiKey&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        ApiKey apiKey = new ApiKey(&quot;Authorization&quot;, &quot;Authorization&quot;, &quot;header&quot;);</span><br><span class="line">        result.add(apiKey);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        //设置需要登录认证的路径</span><br><span class="line">        List&lt;SecurityContext&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        result.add(getContextByPath(&quot;/brand/.*&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SecurityContext getContextByPath(String pathRegex)&#123;</span><br><span class="line">        return SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(pathRegex))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityReference&gt; defaultAuth() &#123;</span><br><span class="line">        List&lt;SecurityReference&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];</span><br><span class="line">        authorizationScopes[0] = authorizationScope;</span><br><span class="line">        result.add(new SecurityReference(&quot;Authorization&quot;, authorizationScopes));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在<code>securityContexts()</code>方法中设置了需要登录认证的路径，即品牌相关的接口访问都需要登录之后才能访问。</p><p><strong>第十八步</strong>，修改之前PmsBrandController类中的方法，我们给它们添加如下访问权限：<br>（1）给添加接口添加<code>pms:brand:create</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:create&#x27;)&quot;)</span><br><span class="line">public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)</span><br></pre></td></tr></table></figure><p>（2）给删除接口添加<code>pms:brand:delete</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:delete&#x27;)&quot;)</span><br><span class="line">public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)</span><br></pre></td></tr></table></figure><p>（3）给修改接口添加<code>pms:brand:update</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:update&#x27;)&quot;)</span><br><span class="line">public CommonResult updateBrand(</span><br><span class="line">    @PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">    @RequestBody PmsBrand pmsBrandDTO, </span><br><span class="line">    BindingResult result</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（4）给查询接口添加<code>pms:brand:read</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)</span><br></pre></td></tr></table></figure><p>注意这里面的权限就是<code>ums_permission</code>数据表中value字段的值，因此值必须按照要求进行书写：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6fcc1f9d38bfc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第十九步</strong>，修改项目启动类<code>ShopSpringSecurityJwtApplication</code>，在其上面使用<code>@MapperScan</code>注解来指定扫描的mapper接口路径，注意我们的mapper接口路径有两个，因此需要使用字符串数组来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&#123;&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper&quot;,&quot;com.kenbings.shop.shopspringsecurityjwt.dao&quot;&#125;)</span><br><span class="line">public class ShopSpringSecurityJwtApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ShopSpringSecurityJwtApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二十步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8f52c710416dae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先是未登录，访问<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到返回之前定义的JSON信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f2c2db75536ff30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ac173bb1a1feff3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们尝试进行登录，登录账号为kenbings，密码为kenbings，访问<code>/admin/login</code>接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc4d2180603d3d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-12b5fc8e6fb6bcbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们已经登录成功了，接下来点击右侧的Authorize按钮，在弹框中输入登录接口中获取到的token信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2d6b3eb1c1600269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后我们再来访问之前的<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到该接口已经可以正常访问了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa6f5902c79f4d44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们再来访问一些需要权限的接口，如获取商品品牌管理中获取所有品牌信息的接口<code>/brand/listAll</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-129799d3530a2051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这是正常结果，因为当前用户没有任何权限，我们给这个用户可以访问该接口的权限，接着再去访问一下该接口，可以看到数据能正常返回了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ca370de9d75a069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合SpringSecurity和JWT实现认证与授权的学习就完成了，后续介绍如何整合ElasticSearch实现商品搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-springsecurity-jwt">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。&lt;/p</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Redis实现数据缓存</title>
    <link href="http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/"/>
    <id>http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/</id>
    <published>2023-01-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:32:47.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。</p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个使用C语言开发的高性能键值对数据库，可用于数据缓存，以实现大量数据的高并发负载访问。</p><p>点击 <a href="https://github.com/MicrosoftArchive/redis/releases">这里</a> 下载Redis，选择3.2.100的版本进行下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-26cb65d7746bafdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>下载之后解压到指定目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4369236c61892f6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着打开终端，切换到上述解压目录，执行redis启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p>可以看到此时redis就已经启动成功了。</p><h1 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h1><p><strong>第一步</strong>，复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-redis</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-redis</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-redis</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis依赖配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在指定位置处新增如下配置信息。首先在spring节点下新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost # Redis服务器地址</span><br><span class="line">    database: 2 # Redis数据库索引（默认为0）</span><br><span class="line">    port: 6379 # Redis服务器连接端口</span><br><span class="line">    password: envy123 # Redis服务器连接密码（默认为空）</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">        max-idle: 8 # 连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 # 连接池中的最小空闲连接</span><br><span class="line">    timeout: 3000ms # 连接超时时间（毫秒）</span><br></pre></td></tr></table></figure><p>然后在根节点下添加Redis自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 自定义redis的key</span><br><span class="line">redis:</span><br><span class="line">  key:</span><br><span class="line">    prefix:</span><br><span class="line">      authCode: &quot;portal:authCode:&quot;</span><br><span class="line">    expire:</span><br><span class="line">      authCode: 120 # 验证码超期时间，单位秒</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在service包内定义一个名为RedisService的接口，用于定义一些常用的Redis操作，此处我们让对象和数组都以JSON形式进行存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Redis操作</span><br><span class="line"> * 对象和数组都以JSON形式进行存储</span><br><span class="line"> */</span><br><span class="line">public interface RedisService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存储数据</span><br><span class="line">     */</span><br><span class="line">    void set(String key,String value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据</span><br><span class="line">     */</span><br><span class="line">    String get(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置超期时间</span><br><span class="line">     */</span><br><span class="line">    boolean expire(String key,long expire);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    void remove(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自增操作</span><br><span class="line">     * @param delta 自增步长</span><br><span class="line">     */</span><br><span class="line">    Long increment(String key,long delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在impl包内定义一个名为RedisServiceImpl的类，这个类需要实现RedisService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisServiceImpl implements RedisService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String get(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean expire(String key, long expire) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key,expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long increment(String key, long delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key,delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，这里我们以会员发送验证码为例来介绍如何使用Redis。在service包内定义一个名为UmsMemberService的接口，用于定义会员管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsMemberService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号生成验证码</span><br><span class="line">     */</span><br><span class="line">    CommonResult generateAuthCode(String telephone);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断验证码和手机号是否匹配</span><br><span class="line">     */</span><br><span class="line">    CommonResult verifyAuthCode(String telephone,String authCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为UmsMemberServiceImpl的类，这个类需要实现UmsMemberService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsMemberServiceImpl implements UmsMemberService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.prefix.authCode&#125;&quot;)</span><br><span class="line">    private String REDIS_KEY_PREFIX_AUTH_CODE;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.expire.authCode&#125;&quot;)</span><br><span class="line">    private Long AUTH_CODE_EXPIRE_SECONDS;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateAuthCode(String telephone) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            stringBuilder.append(random.nextInt(10));</span><br><span class="line">        &#125;</span><br><span class="line">        String authCode = stringBuilder.toString();</span><br><span class="line">        //验证码+手机号作为Key存储到Redis中</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        redisService.set(redisKey,authCode);</span><br><span class="line">        redisService.expire(redisKey,AUTH_CODE_EXPIRE_SECONDS);</span><br><span class="line">        return CommonResult.success(authCode,&quot;验证码获取成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult verifyAuthCode(String telephone, String authCode) &#123;</span><br><span class="line">        if(StringUtils.isEmpty(authCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;请输入验证码&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        String redisAuthCode = redisService.get(redisKey);</span><br><span class="line">        if(StringUtils.isEmpty(redisAuthCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result = authCode.equals(redisAuthCode);</span><br><span class="line">        if(result)&#123;</span><br><span class="line">            return CommonResult.success(null,&quot;验证码校验成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为UmsMemberController的类，这是会员登录注册管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;UmsMemberController&quot;,description = &quot;会员登录注册管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/sso&quot;)</span><br><span class="line">public class UmsMemberController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsMemberService umsMemberService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取验证码&quot;)</span><br><span class="line">    @GetMapping(&quot;/getAuthCode&quot;)</span><br><span class="line">    public CommonResult getAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone)&#123;</span><br><span class="line">        return umsMemberService.generateAuthCode(telephone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;校验验证码是否正确&quot;)</span><br><span class="line">    @PostMapping(&quot;/verifyAuthCode&quot;)</span><br><span class="line">    public CommonResult verifyAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone,@ApiParam(&quot;验证码&quot;)@RequestParam String authCode)&#123;</span><br><span class="line">        return umsMemberService.verifyAuthCode(telephone,authCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-88a3bea3216897d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后测试获取验证码的接口，可以发现测试是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3abff9e3628d2059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下校验验证码是否正确的接口，发现测试也是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ed658578a9933b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Redis实现数据缓存的学习就完成了，后续介绍如何整合SpringSecurity和JWT实现认证与授权这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-redis">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Swagger-UI实现在线API文档</title>
    <link href="http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/"/>
    <id>http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/</id>
    <published>2023-01-10T02:55:30.000Z</published>
    <updated>2023-03-14T06:29:52.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。</p><h1 id="Swagger-UI简介"><a href="#Swagger-UI简介" class="headerlink" title="Swagger-UI简介"></a>Swagger-UI简介</h1><p>Swagger-UI是HTML、CSS和Javascript的一个集合，可以动态地根据注解生成在线API文档，本篇将要整合的Swagger-UI版本为2系列。</p><p>Swagger-UI常用的一些注解如下所示：<br>（1）<code>@Api</code>：用于修饰Controller类，可生成Controller相关的文档信息；<br>（2）<code>@ApiOperation</code>：用于修饰Controller类中的方法，可生成接口方法相关的文档信息；<br>（3）<code>@ApiParam</code>：用于修饰接口中方法的参数，可生成接口参数相关的文档信息；<br>（4）<code>@ApiModelProperty</code>：用于修饰实体类的属性，当实体类是请求参数或返回结果时，会直接生成相关的文档信息。</p><p>关于Swagger-UI的详细介绍，可以参阅笔者其他的文章，此处不做过多介绍。</p><h1 id="整合Swagger-UI"><a href="#整合Swagger-UI" class="headerlink" title="整合Swagger-UI"></a>整合Swagger-UI</h1><p><strong>第一步</strong>，复制一份<code>shop-basic</code>源码，将其名字修改为<code>shop-swagger-ui</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-swagger-ui</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-swagger-ui</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.3.7&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;!--Swagger-UI API文档--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意，<code>mybatis-generator-core</code>的版本必须从1.3.3修改为1.3.7，否则后续在生成API文档的时候会出现异常问题，以及新生成的mapper文件无法覆盖旧文件的情况。</p><p><strong>第三步</strong>，在config包内新建一个名为Swagger2Config的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br><span class="line">                //为有@Api注解的Controller生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br><span class="line">                //为有@ApiOperation注解的方法生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，Swagger UI对生成API文档的范围有三种选择，分别如下所示：<br>（1）生成指定包下类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br></pre></td></tr></table></figure><p>（2）生成有指定注解的类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br></pre></td></tr></table></figure><p>（3）生成有指定注解的方法的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，给需要生成的Controller类添加Swagger注解，此处选择之前使用的品牌管理PmsBrandController类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;PmsBrandController&quot;,description = &quot;商品品牌管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取所有的品牌信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;添加品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;更新指定id的品牌信息&quot;)</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;删除指定id的品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;分页查询品牌列表&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取指定id的品牌详情&quot;)</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们充分使用了<code>@Api</code>、<code>@ApiOperation</code>和<code>@ApiParam</code>注解，没有使用到<code>@ApiModelProperty</code>注解，那是因为<code>@ApiModelProperty</code>注解用于修饰实体类的属性，我们如果要使用它，就要修改MyBatis Generator注释的生成规则。</p><p><strong>第五步</strong>，修改MyBatis Generator注释的生成规则。在前面我们说过，<code>CommentGenerator</code>类是自定义注释生成器，我们可以修改<code>addFieldComment</code>方法，使其可以生成Swagger的<code>@ApiModelProperty</code>注解来取代原来的方法注释。同时还需要添加<code>addJavaFileComment</code>方法，使其能在import中导入<code>@ApiModelProperty</code>，否则需要手动导入该类，这在需要生成大量实体类时，是一件非常痛苦的事情。</p><p><code>CommentGenerator</code>类中的代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line">    private static final String EXAMPLE_SUFFIX=&quot;Example&quot;;</span><br><span class="line">    private static final String API_MODEL_PROPERTY_FULL_CLASS_NAME=&quot;io.swagger.annotations.ApiModelProperty&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            //数据库中特殊字符需要转义</span><br><span class="line">            if(remarks.contains(&quot;\&quot;&quot;))&#123;</span><br><span class="line">                remarks = remarks.replace(&quot;\&quot;&quot;,&quot;&#x27;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //给model的字段添加swagger注解</span><br><span class="line">            field.addJavaDocLine(&quot;@ApiModelProperty(value = \&quot;&quot;+remarks+&quot;\&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addJavaFileComment(CompilationUnit compilationUnit) &#123;</span><br><span class="line">        super.addJavaFileComment(compilationUnit);</span><br><span class="line">        //只在model中添加swagger注解类的导入</span><br><span class="line">        if(!compilationUnit.isJavaInterface()&amp;&amp;!compilationUnit.getType().getFullyQualifiedName().contains(EXAMPLE_SUFFIX))&#123;</span><br><span class="line">            compilationUnit.addImportedType(new FullyQualifiedJavaType(API_MODEL_PROPERTY_FULL_CLASS_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在<code>generatorConfig.xml</code>文件中新增一行配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--生成mapper.xml时覆盖原文件--&gt;</span><br><span class="line">&lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;</span><br></pre></td></tr></table></figure><p>注意配置项的放置位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e333f0646a2cb799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第七步</strong>，执行Generator类中的main方法，可以看到此时会重新生成mbg中的代码。</p><p>可以看到新生成的PmsBrand类里面，已经根据数据库注释自动添加了<code>@ApiModelProperty</code>注解：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7b29773035cf8a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第八步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，效果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b7ab59b14cb1cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击添加品牌按钮，可以看到里面已经显示从<code>@ApiModelProperty</code>文件中生成的说明信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-76a53338333057a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击分页查询品牌列表，可以看到返回结果也已经进行了说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ba083acf7836a3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时开发者可以直接在文档上进行接口测试，这里以查询id为1的品牌详情信息为例进行说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-899fc1f73cb9b6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa9c286cf227f08f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Swagger-UI实现在线API文档的学习就完成了，后续介绍如何整合单机版Redis实现缓存这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-swagger-ui">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>项目骨架搭建</title>
    <link href="http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/"/>
    <id>http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/</id>
    <published>2023-01-08T09:55:30.000Z</published>
    <updated>2023-03-14T06:27:04.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操作，以及通过PageHelper实现分页查询。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>一个基于Spring的快速搭建Java企业级应用的开发框架。</p><h3 id="Mybatis-generator"><a href="#Mybatis-generator" class="headerlink" title="Mybatis generator"></a>Mybatis generator</h3><p>Mybatis代码生成器，可根据数据库生成对应的model、mapper.xml、mapper接口以及Example，这样一般的单表查询不用再手写mapper。</p><h3 id="PagerHelper"><a href="#PagerHelper" class="headerlink" title="PagerHelper"></a>PagerHelper</h3><p>MyBatis分页插件，只需几行简单事务代码就能实现分页功能。如果你使用的是SpringBoot，那么只要整合了PagerHelper就自动整合了MyBatis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">//之后进行查询操作将自动进行分页</span><br><span class="line">List&lt;PmsBrand&gt; brandList = brandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">//通过构造PageInfo对象获取分页信息，如当前页码，总页数，总条数</span><br><span class="line">PageInfo&lt;PmsBrand&gt; pageInfo = new PageInfo&lt;PmsBrand&gt;(list);</span><br></pre></td></tr></table></figure><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>阿里巴巴开源的数据库连接池，性能极佳，提供了多种特性和功能。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p><strong>第一步</strong>，使用Maven新建一个名为myshop-all的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-87cd54660844c03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，删除其中的src目录，并修改其中的pom文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;myshop-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;shop-basic&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在myshop-all目录下，使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为shop-basic的Module：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-14744df2535d4ea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，修改<code>shop-basic</code>这一web项目的pom文件内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-basic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;shop-basic&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;项目骨架搭建&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--集成druid连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Mysql数据库驱动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，修改<code>shop-basic</code>这一web项目的application.yml配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，新建<code>com.kenbings.shop.shopbasic.common.api</code>这两级目录，然后在api目录中新建IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 封装API的错误码</span><br><span class="line"> */</span><br><span class="line">public interface IErrorCode &#123;</span><br><span class="line">    long getCode();</span><br><span class="line"></span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建ResultCode枚举类，需要实现之前的IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一些常用API操作码枚举类</span><br><span class="line"> */</span><br><span class="line">public enum ResultCode implements IErrorCode&#123;</span><br><span class="line">    SUCCESS(200, &quot;操作成功&quot;),</span><br><span class="line">    FAILED(500, &quot;操作失败&quot;),</span><br><span class="line">    VALIDATE_FAILED(404, &quot;参数检验失败&quot;),</span><br><span class="line">    UNAUTHORIZED(401, &quot;暂未登录或token已经过期&quot;),</span><br><span class="line">    FORBIDDEN(403, &quot;没有相关权限&quot;);</span><br><span class="line"></span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    private ResultCode(long code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonResult类，用于构建一个通用的返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通用返回对象</span><br><span class="line"> */</span><br><span class="line">public class CommonResult&lt;T&gt; &#123;</span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public CommonResult()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public CommonResult(long code,String message,T data)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMessage(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data,String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), message,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param errorCode 返回的错误码</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(IErrorCode errorCode)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(errorCode.getCode(),errorCode.getMessage(),null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param message 返回的提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.FAILED.getCode(), message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed() &#123;</span><br><span class="line">        return failed(ResultCode.FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed() &#123;</span><br><span class="line">        return failed(ResultCode.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     * @param message 提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed(String message) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.VALIDATE_FAILED.getCode(), message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未登录返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; unauthorized(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.UNAUTHORIZED.getCode(), ResultCode.UNAUTHORIZED.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未授权返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; forbidden(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.FORBIDDEN.getCode(), ResultCode.FORBIDDEN.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(long code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonPage类，这是一个用于封装分页数据的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页数据封装类</span><br><span class="line"> */</span><br><span class="line">public class CommonPage&lt;T&gt; &#123;</span><br><span class="line">    private Integer pageNum;</span><br><span class="line">    private Integer pageSize;</span><br><span class="line">    private Integer totalPage;</span><br><span class="line">    private Long total;</span><br><span class="line">    private List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将 PageHelper 分页后的list转换为分页信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonPage&lt;T&gt; restPage(List&lt;T&gt; list)&#123;</span><br><span class="line">        CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">        PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(list);</span><br><span class="line">        commonPage.setPageNum(pageInfo.getPageNum());</span><br><span class="line">        commonPage.setPageSize(pageInfo.getPageSize());</span><br><span class="line">        commonPage.setTotalPage(pageInfo.getPages());</span><br><span class="line">        commonPage.setTotal(pageInfo.getTotal());</span><br><span class="line">        commonPage.setList(pageInfo.getList());</span><br><span class="line">        return commonPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageNum() &#123;</span><br><span class="line">        return pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageNum(Integer pageNum) &#123;</span><br><span class="line">        this.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageSize() &#123;</span><br><span class="line">        return pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageSize(Integer pageSize) &#123;</span><br><span class="line">        this.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getTotalPage() &#123;</span><br><span class="line">        return totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotalPage(Integer totalPage) &#123;</span><br><span class="line">        this.totalPage = totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getTotal() &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotal(Long total) &#123;</span><br><span class="line">        this.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，新建<code>com.kenbings.shop.shopbasic.config</code>目录，在里面定义一个名为MyBatisConfig的类，用于设置动态生成的mapper接口的路径信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;)</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，新建<code>com.kenbings.shop.shopbasic.mbg</code>目录，在里面定义一个名为CommentGenerator的类，它需要继承DefaultCommentGenerator类，用于自定义注释生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            addFieldJavaDoc(field, remarks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给model的字段添加注释</span><br><span class="line">     */</span><br><span class="line">    private void addFieldJavaDoc(Field field, String remarks) &#123;</span><br><span class="line">        //文档注释开始</span><br><span class="line">        field.addJavaDocLine(&quot;/**&quot;);</span><br><span class="line">        //获取数据库字段的备注信息</span><br><span class="line">        String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));</span><br><span class="line">        for (String remarkLine : remarkLines) &#123;</span><br><span class="line">            field.addJavaDocLine(&quot; * &quot; + remarkLine);</span><br><span class="line">        &#125;</span><br><span class="line">        addJavadocTag(field, false);</span><br><span class="line">        //文档注释结束</span><br><span class="line">        field.addJavaDocLine(&quot; */&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在mbg目录下新建一个名为Generator的类，用于执行MBG的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于执行MBG的代码</span><br><span class="line"> */</span><br><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream inputStream = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser configurationParser = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = configurationParser.parseConfiguration(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        //创建 MBG</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在resources目录下新建一个名为<code>generatorConfig.xml</code>的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!--可以自定义生成model的代码注释--&gt;</span><br><span class="line">        &lt;commentGenerator type=&quot;com.kenbings.shop.shopbasic.mbg.CommentGenerator&quot;&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--配置数据库连接--&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot;</span><br><span class="line">                        connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot;</span><br><span class="line">                        userId=&quot;$&#123;jdbc.userId&#125;&quot;</span><br><span class="line">                        password=&quot;$&#123;jdbc.password&#125;&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!--指定生成model的路径--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.model&quot; targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper.xml的路径--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot; targetProject=&quot;shop-basic\src\main\resources&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper接口的的路径--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;pms_brand&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在resources目录下新建一个名为<code>generator.properties</code>的数据配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.connectionURL=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">jdbc.userId=root</span><br><span class="line">jdbc.password=envy123</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，打开数据库，执行如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS shop;</span><br><span class="line">CREATE DATABASE shop;</span><br><span class="line">USE shop;</span><br><span class="line">DROP TABLE IF EXISTS pms_brand;</span><br><span class="line">CREATE TABLE `pms_brand` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,</span><br><span class="line">  `first_letter` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;首字母&#x27;,</span><br><span class="line">  `sort` int DEFAULT NULL,</span><br><span class="line">  `factory_status` int DEFAULT NULL COMMENT &#x27;是否为品牌制造商：0-&gt;不是；1-&gt;是&#x27;,</span><br><span class="line">  `show_status` int DEFAULT NULL,</span><br><span class="line">  `product_count` int DEFAULT NULL COMMENT &#x27;产品数量&#x27;,</span><br><span class="line">  `product_comment_count` int DEFAULT NULL COMMENT &#x27;产品评论数量&#x27;,</span><br><span class="line">  `logo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;品牌logo&#x27;,</span><br><span class="line">  `big_pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;专区大图&#x27;,</span><br><span class="line">  `brand_story` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT &#x27;品牌故事&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb3 COMMENT=&#x27;品牌表&#x27;;</span><br></pre></td></tr></table></figure><p>此时我们项目的基本骨架如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a2e09010d13779a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，执行Generator类中的main方法，可以看到此时生成后的目录结构如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3bf6f596d7e6e682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十四步</strong>，新建<code>com.kenbings.shop.shopbasic.service</code>目录，并在里面新建一个名为PmsBrandService的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface PmsBrandService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listAllBrand();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    int createBrand(PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    int updateBrand(Long id,PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    int deleteBrand(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    PmsBrand getBrand(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十五步</strong>，在之前的service目录中新建一个名为impl的目录，然后在impl目录中新建一个名为PmsBrandServiceImpl的类，注意这个类需要实现PmsBrandService接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PmsBrandServiceImpl implements PmsBrandService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandMapper pmsBrandMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listAllBrand() &#123;</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createBrand(PmsBrand pmsBrand) &#123;</span><br><span class="line">        return pmsBrandMapper.insertSelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int updateBrand(Long id, PmsBrand pmsBrand) &#123;</span><br><span class="line">        pmsBrand.setId(id);</span><br><span class="line">        return pmsBrandMapper.updateByPrimaryKeySelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int deleteBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PmsBrand getBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，新建<code>com.kenbings.shop.shopbasic.controller</code>目录，并在里面新建一个名为PmsBrandController的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第十七步</strong>，启动项目入口类ShopBasicApplication，打开浏览器进行测试，这里以访问id为1的品牌为例进行说明。</p><p>在浏览器地址栏中输入<code>http://localhost:8080/brand/1</code>，可以看到浏览器显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a87453b8a871d2a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样关于项目的骨架搭建就完成了，后续学习如何接入Swagger-UI实现API文档的在线使用。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-basic">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的记录你的日志</title>
    <link href="http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/"/>
    <id>http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/</id>
    <published>2022-08-10T09:55:30.000Z</published>
    <updated>2022-09-12T09:07:53.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。</p><h1 id="操作日志使用场景"><a href="#操作日志使用场景" class="headerlink" title="操作日志使用场景"></a>操作日志使用场景</h1><h3 id="操作日志与系统日志区别"><a href="#操作日志与系统日志区别" class="headerlink" title="操作日志与系统日志区别"></a>操作日志与系统日志区别</h3><p>当对某个对象进行新增、修改和查询操作后，通常需要记录对象的新旧状态，这其实就是操作日志，一般而已操作日志都是给用户查阅的，因此可读性要求较高。最常见的就是物流信息的更新，这其实是针对该快递对象的更新记录，里面会告诉用户包裹转到何时何地。</p><p>而系统日志通常是作为开发人员排查和解决问题的依据，一般记录在指定的日志文件中，由于是给开发人员使用的，所以可读性要求不高，里面只记录一些重点信息，如代码当前输出的信息。</p><h3 id="操作日志分类"><a href="#操作日志分类" class="headerlink" title="操作日志分类"></a>操作日志分类</h3><p>一般来说，操作日志分类分为三类，下面依次进行简要学习：<br>（1）单纯的文本记录。举个例子，2021-12-01 10:00:00 用户登录。时间是动态但与其他内容关，其他信息都是固定值。<br>（2）简单的动态文本记录。举个例子，2021-12-01 10:00:00 用户：张三，创建订单，订单号为1000。用户名和订单号则与需要传入或者生成。<br>（3）记录对象的前后状态。举个例子，2021-12-01 10:00:00 用户：张三，修改了订单备注信息，由“微辣”修改为“中辣”。可以看到此处需要同时记录对象的前后状态。</p><p>当然实际可能修改的字段不止以上几种，可能涉及到的内容较多，但基本上和上述三类差异不大。</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h3 id="使用Canal监听数据库"><a href="#使用Canal监听数据库" class="headerlink" title="使用Canal监听数据库"></a>使用Canal监听数据库</h3><p>Canal是一款基于MySQL数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库Binglog的方式来知道具体是哪些数据发生了修改，然后根据修改的数据来记录用户操作日志。</p><p>这种方式完全不侵入原来的业务代码，但是缺点也很明显，就是只能针对数据库的更改做记录，如果涉及到其他团队的RPC调用，这无法监听数据库因此只能手动记录操作日志。举个简单的例子，用户下单后调用短信通知服务，告诉用户下单成功，毫无疑问短信通知服务肯定是公共服务，只能下单方法调用了这个RPC，那么只能在下单方法中记录给用户发送通知的操作记录。关于一部分的内容，可以参考后续文章。</p><h3 id="通过日志文件记录"><a href="#通过日志文件记录" class="headerlink" title="通过日志文件记录"></a>通过日志文件记录</h3><p>通过日志文件方式，这是最常用的方式，直接在调用的时候输出一些调用信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;用户登录&quot;);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，创建订单，订单号为&#123;&#125;&quot;,userId,orderId);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，修改了订单备注信息，由“&#123;&#125;”修改为“&#123;&#125;”&quot;,userId,oldInfo,newInfo);</span><br></pre></td></tr></table></figure><p>可以看到这里存在三个问题：（1）如何获取到用户信息；（2）操作日志如何与系统日志分开；（3）如何生成可读性高的日志信息。</p><h5 id="如何获取到用户信息"><a href="#如何获取到用户信息" class="headerlink" title="如何获取到用户信息"></a>如何获取到用户信息</h5><p>如何获取用户信息，这里有很多种方式，可以通过拦截器或者AOP方式，传入请求然后从请求中获取，并将用户信息存入MDC（Mapped Diagnostic Context，映射调试上下文）中，那么相应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserInterceptor extends HandlerInterceptor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    //获取到用户ID</span><br><span class="line">    String userId = getUserInfo(request);</span><br><span class="line">    //把用户ID放入MDC上下文中</span><br><span class="line">    MDC.put(&quot;userId&quot;, userId );</span><br><span class="line">    return super.preHandle(request, response, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getUserInfo(HttpServletRequest request) &#123;</span><br><span class="line">    // 通过SSO、Cookie或者Auth信息获取当前登陆的用户信息</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将用户ID格式化到日志文件中，可使用<code>%X&#123;userId&#125;</code>变量来获取MDC中的用户ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br></pre></td></tr></table></figure><h5 id="操作日志如何与系统日志分开"><a href="#操作日志如何与系统日志分开" class="headerlink" title="操作日志如何与系统日志分开"></a>操作日志如何与系统日志分开</h5><p>针对这种情况，通俗做法就是通过Log的配置文件来将操作日志放到单独的日志文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=&quot;businessLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;File&gt;logs/business.log&lt;/File&gt;</span><br><span class="line">    &lt;append&gt;true&lt;/append&gt;</span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">        &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">        &lt;fileNamePattern&gt;logs/业务A.%d.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">        &lt;maxHistory&gt;90&lt;/maxHistory&gt;</span><br><span class="line">        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br><span class="line">        &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">        </span><br><span class="line">&lt;logger name=&quot;userlogInLog&quot; additivity=&quot;false&quot; level=&quot;INFO&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;userlogInLogAppender&quot;/&gt;</span><br><span class="line">&lt;/logger&gt;</span><br></pre></td></tr></table></figure><p>之后只需在使用的时候记录一下这个日志即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//记录特定的日志类</span><br><span class="line">private final Logger userlogInLog= LoggerFactory.getLogger(&quot;userlogInLog&quot;);</span><br><span class="line"> </span><br><span class="line">//日志存储</span><br><span class="line">userlogInLog.info(&quot;用户登录&quot;);</span><br></pre></td></tr></table></figure><h5 id="如何生成可读性高的日志信息"><a href="#如何生成可读性高的日志信息" class="headerlink" title="如何生成可读性高的日志信息"></a>如何生成可读性高的日志信息</h5><p>这种一般可以使用AOP或者LogUtil方式，之后将生成的日志单独保存在一个文件中，后续通过ELK系统将其收集、过滤、存储和展示。</p><h3 id="通过LogUtil方式记录"><a href="#通过LogUtil方式记录" class="headerlink" title="通过LogUtil方式记录"></a>通过LogUtil方式记录</h3><p>可以在业务逻辑代码中调用封装好的日志记录工具类来随时记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogUtil.log(&quot;用户登录，登录人：%s&quot;,userId)</span><br><span class="line">LogUtil.log(&quot;用户：%s，创建订单，订单号为%d&quot;,userId,orderId);</span><br><span class="line">String template = &quot;用户：%s，修改了订单号%d的备注信息，由“%s”修改为“%s”&quot;;</span><br><span class="line">LogUtil.log(String.format(tempalte, &quot;张三&quot;, &quot;10001, &quot;微辣&quot;,&quot;中辣&quot;));</span><br></pre></td></tr></table></figure><p>这只是记录用户的简单操作，在实际开发过程中可能比这要复杂的多，可能针对不同的业务逻辑，记录的格式和值完全不同，更重要的是将日志这种与实际业务逻辑不相关的内容深度融合在了业务代码中。</p><h3 id="通过AOP方式记录"><a href="#通过AOP方式记录" class="headerlink" title="通过AOP方式记录"></a>通过AOP方式记录</h3><p>为了让日志与业务逻辑解耦，更多的是使用AOP配合注解方式来记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以做到完全不侵入业务代码，但是记录的日志格式不符合预期，格式是固定的，其实这个可以使用动态模板来实现。</p><h1 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h1><p>动态模板其实就是通过解析变量占位符来解析模板，进而实现通过注解记录操作日志这一目的。模板解析的方式有很多种，这里使用SpEL（Spring Expression Language）来实现，我们希望的日志记录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看上面的日志输出格式只提到了oldRemark和newRemark这两个参数，其实隐含了两个更重要的信息，即操作人和订单id，那么这两个参数如何获取呢？同时这个方法传入的是修改值，而旧值如果用户不传入，此时还需要在业务中查询，而这个仅仅是因为操作日志记录需要，实际业务却不需要，所以使得方式不够优雅。</p><p>为了解决操作人和订单id的显示问题，我们需要将操作日志修改为如下所示格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  operator=&quot;#request.userId&quot;,bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在日志记录格式中添加了操作人和订单号，其实这种获取操作人的方式可能不太正确，一般在Web项目中，用户信息都是保存在一个线程上下文的静态方法中，所以操作人的信息一般是通过如下方式，假设获取当前登录用户信息的方法为<code>UserContext.getCurrentUserInfo()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator=&quot;#&#123;T(com.bamboo.user.UserContext).getCurrentUserInfo()&#125;&quot;</span><br></pre></td></tr></table></figure><p>但是这样获取用户信息的方式也太长了，而且并不是所有的地方都需要获取登录用户的信息，因此可以将这个operator参数的值设置为可选项，这样用户可以填写操作人，如果没填那么就可以从UserContext山下文中获取当前登录用户的信息。此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还有一个问题，就是需要添加一个旧的值oldRemark，这个值的获取非常尴尬，因为用户不传入这个参数，因此我们必须自行将这个oldRemark查询出来，然后将其放到操作日志的线程上下文中，这样后续模板在解析的时候就可以使用了。那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    //查询出原来的备注信息</span><br><span class="line">    Stirng oldRemark = orderService.query(reuest);</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemark&quot;,oldRemark);</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用<code>LogRecordContext</code>这个日志记录线程上下文来记录方法参数之外的变量，更重要的是它不破坏原有方法传递的参数信息。不过这种方式还是有问题的，因为它在业务代码中插入了一些实际业务逻辑不需要的代码，这一点其实可通过自定义函数来解决，后面会介绍。</p><p>经过上面的修改，此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;。</span><br></pre></td></tr></table></figure><p>如果这个oldRemark和newRemark是人可读的字符串，这肯定没问题，但是如果是某种业务代码，如口味代码，那么就可能变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;101&quot;，修改为&quot;102&quot;。</span><br></pre></td></tr></table></figure><p>用户不知道这个101和102具体是指什么，用户关心的是可读的信息，所以此时还需要通过<code>LogRecordContext</code>来查询并进行替换展示。</p><p>前面说过如果开发者不想将业务逻辑和日志记录糅杂在一起，可以使用自定义函数来进行实现。可以自定义函数将oldRemark和newRemark转换成人可读的数据，那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderInfo&#123;#oldRemarkInfo&#125;&#125;&quot;，修改为&quot;&#123;OrderInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemarkInfo&quot;,orderService.query(reuest));</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>OrderInfo</code>是自定义函数，我们使用大括号将Spring的SpEL表达式包裹起来，这样不仅可以将SpEL表达式和自定义函数区分开，便于解析；还可以在模板中不需要SpEL表达式的时候容易识别出来，减少不必要的SpEL解析，以提升性能。</p><p>看到这里，开发者完全可以将<code>LogRecordContext</code>线程上下文去掉，直接将<code>oldRemark</code>信息也通过自定义新的函数来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderOldInfo&#123;#request.orderId&#125;&#125;&quot;，修改为&quot;&#123;OrderNewInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些操作，开发者就能通过自定义新函数传入订单id就能获取到之前的订单信息，当然这要求该方法的执行必须在updateOrder方法之前，这样就可以获取到对应信息，如此一来所有的目标都实现了，同时代码几乎没有任何的侵入性。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>新建项目并添加web和aop依赖，接着自定义一个注解，后续所有添加该注解的方法都会被拦截并记录对应的操作记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value = RetentionPolicy.RUNTIME )</span><br><span class="line">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface OperationRecord &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作类型</span><br><span class="line">     */</span><br><span class="line">    OperationEnum type();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作内容</span><br><span class="line">     */</span><br><span class="line">    String operation();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 备注</span><br><span class="line">     */</span><br><span class="line">    String remark() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于备注这个信息不是所有场景下都具有的，因此这里就给了一个默认值。同时这里的操作类型定义了一个枚举类型，所以接下来就定义这个枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作类型</span><br><span class="line"> */</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public enum OperationEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 首页</span><br><span class="line">     */</span><br><span class="line">    INDEX(0),</span><br><span class="line">    /**</span><br><span class="line">     * 用户</span><br><span class="line">     */</span><br><span class="line">    USER(1),</span><br><span class="line">    /**</span><br><span class="line">     * 红包</span><br><span class="line">     */</span><br><span class="line">    REDPACKET(2),</span><br><span class="line">    /**</span><br><span class="line">     * 版本</span><br><span class="line">     */</span><br><span class="line">    APPVERSION(3),</span><br><span class="line">    /**</span><br><span class="line">     * 登录</span><br><span class="line">     */</span><br><span class="line">    LOGIN(4)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    private Integer typeId;</span><br><span class="line"></span><br><span class="line">    public Integer getTypeId() &#123;</span><br><span class="line">        return typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTypeId(Integer typeId) &#123;</span><br><span class="line">        this.typeId = typeId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志记录类"><a href="#自定义日志记录类" class="headerlink" title="自定义日志记录类"></a>自定义日志记录类</h3><p>由于用户的操作日志记录需要保存到数据库中，因此接下来定义数据表和对应的实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_operation_record` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `job_number` varchar(255) NOT NULL COMMENT &#x27;工号&#x27;,</span><br><span class="line">  `login_ip` varchar(255) NOT NULL COMMENT &#x27;登录IP&#x27;,</span><br><span class="line">  `type` int(11) NOT NULL COMMENT &#x27;操作类型&#x27;,</span><br><span class="line">  `operation` varchar(1000) DEFAULT NULL COMMENT &#x27;操作内容&#x27;,</span><br><span class="line">  `operate_time` datetime DEFAULT NULL COMMENT &#x27;操作时间&#x27;,</span><br><span class="line">  `remark` varchar(1000) DEFAULT NULL COMMENT &#x27;备注&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>实体类信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class TbOperationRecord &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String jobNumber;</span><br><span class="line">    private String loginIp;</span><br><span class="line">    private Integer type;</span><br><span class="line">    private String operation;</span><br><span class="line">    private Date operateTime;</span><br><span class="line">    private String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志Dao层"><a href="#自定义日志Dao层" class="headerlink" title="自定义日志Dao层"></a>自定义日志Dao层</h3><p>这里我们直接通过<code>mybatis-generate</code>工具来生成对应的Dao代码。</p><h3 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h3><p>接下来我们需要自定义切面类<code>AdminOperationRecordAop</code>，然后通过AOP来拦截请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">public class AdminOperationRecordAop &#123;</span><br><span class="line">    private final SpelExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">    private final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();</span><br><span class="line">    @Autowired</span><br><span class="line">    private TbOperationRecordDao tbOperationRecordDao;</span><br><span class="line"></span><br><span class="line">    public static final String TYPE = &quot;type&quot;;</span><br><span class="line">    public static final String OPERATION = &quot;operation&quot;;</span><br><span class="line">    public static final String REMARK = &quot;remark&quot;;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.poly.myinterface.OperationRecord)&quot;)</span><br><span class="line">    public void myPointCut()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @After(&quot;myPointCut()&quot;)</span><br><span class="line">    public void operationRecord(JoinPoint joinPoint)&#123;</span><br><span class="line">        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //IP地址</span><br><span class="line">        String userIp = IpUtils.getIpAddr(request);</span><br><span class="line">        //工号</span><br><span class="line">        Object jobNumber = request.getSession().getAttribute(&quot;adminId&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String, String&gt; operationRecordInfo = getOperationRecordInfo(joinPoint);</span><br><span class="line">            int type = Integer.parseInt(operationRecordInfo.get(TYPE));</span><br><span class="line">            String remark = operationRecordInfo.get(REMARK);</span><br><span class="line">            String operation = operationRecordInfo.get(OPERATION);</span><br><span class="line">            fillOperationRecord(type,remark,operation,userIp,jobNumber.toString());</span><br><span class="line">            log.info(&quot;【日志操作花费时间=&#123;&#125;秒】&quot;,(System.currentTimeMillis()-start)/1000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">        String str = null;</span><br><span class="line">        if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">            Expression expression = parser.parseExpression(speLString);</span><br><span class="line">            //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">            EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">            //获取被注解的方法</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            //获取被注解的方法的形参</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            //获取运行时参数的名称</span><br><span class="line">            String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">            for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">                context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str = String.valueOf(expression.getValue(context));</span><br><span class="line">            log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Map&lt;String,String&gt; getOperationRecordInfo(JoinPoint joinPoint) throws ClassNotFoundException &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        OperationRecord annotation = method.getAnnotation(OperationRecord.class);</span><br><span class="line">        map.put(TYPE,annotation.type().getTypeId().toString());</span><br><span class="line">        map.put(REMARK,annotation.remark());</span><br><span class="line">        String operation = annotation.operation();</span><br><span class="line">        if(!operation.contains(&quot;;&quot;))&#123;</span><br><span class="line">            map.put(OPERATION,operation);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String[] strings = operation.split(&quot;;&quot;);</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            for(int i=0;i&lt;strings.length;i++)&#123;</span><br><span class="line">                String[] split = strings[i].split(&quot;#&quot;);</span><br><span class="line">                String spel =&quot;#&quot;+split[1];</span><br><span class="line">                String spelValue = getSPELValue(spel, joinPoint);</span><br><span class="line">                if(i!=strings.length-1)&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue).append(&quot;,&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(OPERATION,stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fillOperationRecord(Integer type,String remark,String operation,String loginIp,String jobNumber)&#123;</span><br><span class="line">        TbOperationRecord tbOperationRecord = new TbOperationRecord();</span><br><span class="line">        tbOperationRecord.setType(type);</span><br><span class="line">        tbOperationRecord.setRemark(remark);</span><br><span class="line">        tbOperationRecord.setOperation(operation);</span><br><span class="line">        tbOperationRecord.setLoginIp(loginIp);</span><br><span class="line">        tbOperationRecord.setJobNumber(jobNumber);</span><br><span class="line">        tbOperationRecord.setOperateTime(new Date());</span><br><span class="line">        tbOperationRecordDao.insert(tbOperationRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myPointCut()</code>是一个切点，里面设置的是之前定义的<code>OperationRecord</code>注解。接着我们定义了一个<code>operationRecord</code>方法，添加后置通知，表示在被拦截的方法执行之后这个<code>operationRecord</code>方法才会执行。我们通过下面的代码获取到用户请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br></pre></td></tr></table></figure><p>之后就通过<code>IpUtils.getIpAddr(request)</code>方法来获取请求来源的IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line">String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从请求携带的session中获取用户工号，之后就是获取被拦截的方法信息，从JoinPoint对象中可以得到方法签名，从方法签名中可以得到方法这个对象，然后通过字节码信息得到<code>OperationRecord</code>这个注解对象，然后就是将取出的信息放到map中进行存储。注意在获取<code>OperationRecord</code>这个注解对象的信息时，需要对传入的参数进行解析，这里使用SpEL进行解析，具体逻辑都在<code>getSPELValue</code>这个方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">        Expression expression = parser.parseExpression(speLString);</span><br><span class="line">        //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">        EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">        //获取被注解的方法</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        //获取被注解的方法的形参</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        //获取运行时参数的名称</span><br><span class="line">        String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">        for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">            context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        str = String.valueOf(expression.getValue(context));</span><br><span class="line">        log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过对传入的字符串进行解析，得到里面的Spring表达式对象，之后新建Spring表达式上下文对象，这个上下文对象中包含占位符信息以及每种占位符的值。接着我们获取到被注解的方法，并从方法中得到方法的形参，然后获取到运行时参数的名词，这种方式其实得到的只是方法中传递的参数值，对于方法中值没有传递的参数，目前还没获取，这一块等有空完善一下相关逻辑。</p><p>最后在使用的时候，只需在被使用的方法上添加类似如下的注解信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecord(type = OperationEnum.REDPACKET,operation = &quot;给用户id#userId;变更红包余额，相应的订单id#orderId;变动金额#changeBalance;变动类型#type;备注#remark&quot;,remark = &quot;变更红包金额&quot;)</span><br><span class="line">public ResultVO changeRedPacketBalance(int userId, String orderId, double changeBalance, int type, String remark) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在调用这个<code>changeRedPacketBalance</code>方法的时候就会在数据表<code>tb_operation_record</code>中新增一条对应的记录。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/JC51S_bI02npm4CE5NEEow">如何优雅地记录操作日志?</a>、<a href="https://mp.weixin.qq.com/s/JamcyrQdocnb0d0D0tSXNg">使用Aop记录带参数的复杂接口日志</a>、<a href="https://mp.weixin.qq.com/s/szhCq0tLCb_870uqAyIwPg">搞定 SpringBoot 操作日志</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。&lt;/p&gt;</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Canal实现数据增量同步</title>
    <link href="http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/"/>
    <id>http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/</id>
    <published>2022-08-02T09:55:30.000Z</published>
    <updated>2022-09-12T08:50:27.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随着业务系统的迭代、数据量的增多以及多种复杂场景下的分库分表实现，使得数据同步变得越来越具挑战性。针对这种情况，笔者决定使用阿里开源的Canal这一中间件来解决数据同步问题。</p><h1 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h1><h3 id="Canal简说"><a href="#Canal简说" class="headerlink" title="Canal简说"></a>Canal简说</h3><p>Canal是阿里巴巴开源的一款基于MySQL数据库的增量日志解析中间件，提供增量数据的订阅和消费功能。由于它是基于MySQL的日志进行的增量解析，因此对原有的业务代码完全不侵入。</p><p>Canal的工作原理是解析MySQL的binlog日志，提供增量数据的订阅和消费功能，具体包括：数据库镜像、数据库实时备份、业务缓存刷新、带业务逻辑的增量数据处理以及索引构建和实时维护（拆分异构索引和倒排索引）。</p><p>Canal官方文档，点击 <a href="https://github.com/alibaba/canal">这里</a> 进行查阅。</p><h3 id="Canal如何传输数据"><a href="#Canal如何传输数据" class="headerlink" title="Canal如何传输数据"></a>Canal如何传输数据</h3><p>下图是Canal官方展示的Canal传输数据架构图，可以看到Canal支持RabbitMQ、RocketMQ或者ES等常用的消息中间件：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-13f6424488da68e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从上图中可以知道Canal分为服务端和客户端，一般阿里开源的程序都是这个规范。其中服务端负责解析MySQL的binlog日志，并传输增量数据给客户端或者消息中间件；而客户端负责解析服务端传递过来的数据，并处理自己的业务逻辑。</p><p>当然，数据同步除了本篇学习的Canal外，还有其他一些优秀的开源工具，它们均支持MySQL，但是也存在一些区别。下面笔者将从支持实时同步、增量同步、需要编写保存变更数据的业务代码以及社区活跃度这4个方面进行对比，如下表所示：</p><table><thead><tr><th align="center"></th><th align="center">Canal</th><th align="center">Debezium</th><th align="center">DataX</th><th align="center">Databus</th><th align="center">Flinkx</th><th align="center">Bifrost</th></tr></thead><tbody><tr><td align="center">实时同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">增量同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">是否需要自己编写保存变更数据的代码</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">社区活跃度</td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">不高</td><td align="center">一般</td><td align="center">一般</td></tr></tbody></table><p>接下来将以Canal为例，来学习如何进行数据的同步。</p><h1 id="搭建服务端"><a href="#搭建服务端" class="headerlink" title="搭建服务端"></a>搭建服务端</h1><h3 id="安装Canal服务端"><a href="#安装Canal服务端" class="headerlink" title="安装Canal服务端"></a>安装Canal服务端</h3><p>点击 <a href="https://github.com/alibaba/canal/releases">这里</a> 下载Canal的服务端，即名称为<code>canal.developer</code>前缀的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-788d8d5206d6533d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>解压后的目录如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-7ae80252d4789fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中bin里面存放的是启动和停止脚本；conf目录存放的是配置文件；lib目录存放的是项目所依赖的包；logs目录存放的是项目运行的日志文件；plugin目录存放的是插件。其实这个canal服务端是一个SpringBoot项目，可以从其启动脚本中看出：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3fbb162356f8fa3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="修改MySQL配置信息"><a href="#修改MySQL配置信息" class="headerlink" title="修改MySQL配置信息"></a>修改MySQL配置信息</h3><p>第一步，找到MySQL安装目录下的<code>my.ini</code>文件，在里面新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">#使用ROW模式</span><br><span class="line">binlog-format=ROW</span><br><span class="line"># 设置MySQL replication，注意不要和canal的slaveId重复就行</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure><p>第二步，设置Canal服务端中关于MySQL的相关配置信息，即告诉Canal应该去监听哪个数据库的哪个表的日志文件。</p><p>注意一个Canal服务端中可以监听多个MySQL实例，Canal默认自带了一个example实例（在其<code>conf/example</code>目录下有一个名为<code>instance.properties</code>的文件），本篇笔记就以example为例来进行学习。如果开发者需要增加实例，那么需要复制example文件夹中的内容到同级目录中，并在同级目录下的<code>canal.properties</code>文件中指定所添加的实例名称。这里我们就使用默认的实例即可。</p><p>修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># position info</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># listener database name</span><br><span class="line">canal.instance.defaultDatabaseName=delaytask</span><br><span class="line"># table regex</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure><p>最后一行表示设置监听的数据库表信息，可以监听多个表，多个之间使用逗号进行分割，此处设置的是监听所有的表。</p><h3 id="修改RabbitMQ配置信息"><a href="#修改RabbitMQ配置信息" class="headerlink" title="修改RabbitMQ配置信息"></a>修改RabbitMQ配置信息</h3><p>由于Canal服务端默认的传输方式为tcp，因此我们需要在canal的配置文件中设置RabbitMQ相关的信息。</p><p>第一步，修改<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">#########     RabbitMQ     #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host = /</span><br><span class="line">rabbitmq.exchange = canal.exchange</span><br><span class="line">rabbitmq.username = guest</span><br><span class="line">rabbitmq.password = guest</span><br><span class="line"># 是否持久化，2表示是</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure><p>第二步，修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mq config</span><br><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure><p>其实就是设置RabbitMQ路由的key，这样才能将信息准确路由到指定的队列里面。</p><p>第三步，在RabbitMQ中创建交换机和队列。接着我们需要在RabbitMQ中新建一个名为<code>canal.exchange</code>的交换机，注意这个名字必须与<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中设置的<code>rabbitmq.exchange</code>选项值保持一致。</p><p>第四步，新建一个名为<code>canal.queue</code>的队列，这个队列的名称随意，不过为了区分实际业务，建议此队列还是命名为<code>canal.queue</code>。</p><p>第五步，定义交换机和队列之间的绑定键，名称为<code>canal.routing.key</code>，注意这个名字必须与<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中设置的<code>canal.mq.topic</code>选项值保持一致：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-6bb6ed9d27412ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="启动各个服务"><a href="#启动各个服务" class="headerlink" title="启动各个服务"></a>启动各个服务</h3><p>在完成上述准备工作后，接下来我们尝试启动MySQL，之后启动Canal服务端，只需直接双击bin目录下的<code>startup.bat</code>文件。或者在Canal的bin目录下打开终端，然后输入<code>start /min startup.bat</code>命令来启动Canal服务端：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-f17fef8ee5eeba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，这里有一个小坑，就是如果你的Java版本大于1.7，那么程序就会报错，因为此时永久代已经取消了，应该使用元空间。打开<code>startup.bat</code>文件，将其中的如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:PermSize=128m</span><br></pre></td></tr></table></figure><p>修改为如下后的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:MetaspaceSize=128m</span><br></pre></td></tr></table></figure><p>之后再重新执行<code>startup.bat</code>文件，进而启动Canal服务端。</p><h3 id="测试一下数据"><a href="#测试一下数据" class="headerlink" title="测试一下数据"></a>测试一下数据</h3><p>接下来使用如下命令往delaytask数据库中的<code>order_master</code>数据表里面新增一条信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (1, &#x27;2001&#x27;);</span><br></pre></td></tr></table></figure><p>然后查看一下RabbitMQ中的<code>canal.queue</code>队列里面的数据，可以看到里面已经有对应数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-db628944ef9fd5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这其实就是一个JSON字符串，格式化一下信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2001&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654495807000,</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654495807981,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个JOSN字符串中将用户执行的插入操作记录的非常清楚，如表名称、方法、参数、参数类型、参数值等。</p><p>既然服务端已经通过解析MySQL的binlog日志，并传输增量数据给消息中间件，那么接下来就是客户端监听MQ来获取JSON信息，并将其解析出来为后续业务逻辑服务。</p><h1 id="搭建客户端"><a href="#搭建客户端" class="headerlink" title="搭建客户端"></a>搭建客户端</h1><p>客户端就比较简单，就是消费Canal服务端传递过来的信息，而它传递的消息都存在了MQ中，因此客户端就只需监听<code>canal.queue</code>队列。</p><h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>由于MQ传递来的是JSON信息，因此接下来需要创建一个实体类来完成与JSON信息的数据绑定工作。新建一个名为CanalMessage的类，由于JSON中的data可能存在多种形式，因此可以将CanalMessage类定义为一个泛型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;String&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private String es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private String ts;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听MQ消息"><a href="#监听MQ消息" class="headerlink" title="监听MQ消息"></a>监听MQ消息</h3><p>接下来就是监听RabbitMQ中的<code>canal.queue</code>队列了，这样只要Canal服务端有数据推送过来就可以及时的消费掉。</p><p>简单起见，这里笔者就通过<code>@RabbitListener</code>来完成RabbitMQ中交换机、队列的声明和绑定工作。新建一个名为<code>CanalRabbitMQListener</code>的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 监听RabbitMQ中信息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings=&#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;,durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handlerCanalData(String message)&#123;</span><br><span class="line">        //message则是MQ中canal.queue中的消息</span><br><span class="line">        //将message消息转换为之前定义的CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class, true);</span><br><span class="line">        String databaseName = canalMessage.getDatabase();</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal监听，&#123;&#125;数据库的&#123;&#125;数据表发生变化，变化信息为&#123;&#125;&quot;,databaseName,tableName,message);</span><br><span class="line">        //其他后续的业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你还需要配置RabbitMQ的相关信息，可以在<code>application.properties</code>配置文件中新增如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=127.0.0.1</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>接下来我们启动项目，首先往<code>order_master</code>数据表中新增一条记录，命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (2, &#x27;2002&#x27;);</span><br></pre></td></tr></table></figure><p>可以看到此时项目控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Canal监听，delaytask数据库的order_master数据表发生变化，变化信息为：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2002&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654507483000,</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654507483543,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Canal客户端已经成功消费了MQ中的消息并接收到，后续开发者可根据实际业务进行后续逻辑开发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>在完整Kubernetes集群上部署微服务</title>
    <link href="http://envyzhan.asia/2022/07/08/2022-k8s-5-deploy-microservices-on-a-complete-cluster/"/>
    <id>http://envyzhan.asia/2022/07/08/2022-k8s-5-deploy-microservices-on-a-complete-cluster/</id>
    <published>2022-07-08T09:55:30.000Z</published>
    <updated>2022-09-12T08:47:31.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>接下来我们尝试在完整集群上部署微服务，首先来复习之前的一些命令以及学习一个新的命令，了解这些对于学习和熟悉Kubernetes有非常大的帮助。</p><h1 id="新的命令"><a href="#新的命令" class="headerlink" title="新的命令"></a>新的命令</h1><p>首先查看一下当前其他节点的运行状态信息，可以看到它们都是Ready状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get node</span><br><span class="line">NAME             STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.51.121   Ready     &lt;none&gt;    4h        v1.9.0</span><br><span class="line">192.168.51.123   Ready     &lt;none&gt;    4h        v1.9.0</span><br></pre></td></tr></table></figure><p>再来查看一下services，可以看到这里有一个Kubernetes默认的services：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.68.0.1    &lt;none&gt;        443/TCP   1d</span><br></pre></td></tr></table></figure><p>再来查看一下pods，正常应该就是没有的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>接下来我们尝试通过<code>kubectl run</code>命令在k8s集群中部署一个命名为<code>kubernetes-bootcamp</code>的应用，Docker镜像通过<code>--image</code>指定，<code>--port</code>设置应用对外服务的端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl run kubernetes-bootcamp --image=jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; created</span><br></pre></td></tr></table></figure><p>然后我们查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           41s</span><br></pre></td></tr></table></figure><p>才是再来查看一下pods，可以发现这里就创建了一个pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ssf78   1/1       Running   0          1m</span><br></pre></td></tr></table></figure><p>然后我们尝试查看一下某个pods中的运行日志信息，可使用<code>kubectl logs +pods名称</code>命令来进行查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl logs kubernetes-bootcamp-6b7849c495-ssf78</span><br><span class="line">Kubernetes Bootcamp App Started At: 2021-09-04T13:12:56.352Z | Running On:  kubernetes-bootcamp-6b7849c495-ssf78</span><br></pre></td></tr></table></figure><p>也可以借鉴docker logs命令，在上述kubectl logs命令后面添加<code>-f</code>参数来跟踪日志，这样一旦有刷新日志就会实时的刷新出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl logs kubernetes-bootcamp-6b7849c495-ssf78 -f</span><br></pre></td></tr></table></figure><p>我们再来查看一下这个pods的详细信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe pods kubernetes-bootcamp-6b7849c495-ssf78</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4d4ad6b504184977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到它多了一个Mounts的配置信息，值为<code>/var/run/secrets/kubernetes.io/serviceaccount</code>，然后我们可以使用类似于docker中的exec命令来以终端方式进入到该pods中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl exec -it kubernetes-bootcamp-6b7849c495-ssf78 bash</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/# ls -l /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 13 Sep  4 13:12 ca.crt -&gt; ..data/ca.crt</span><br><span class="line">lrwxrwxrwx 1 root root 16 Sep  4 13:12 namespace -&gt; ..data/namespace</span><br><span class="line">lrwxrwxrwx 1 root root 12 Sep  4 13:12 token -&gt; ..data/token</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/# cd /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/var/run/secrets/kubernetes.io/serviceaccount# ls</span><br><span class="line">ca.crtnamespace  token</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/var/run/secrets/kubernetes.io/serviceaccount# </span><br></pre></td></tr></table></figure><p>可以看到这个<code>/var/run/secrets/kubernetes.io/serviceaccount</code>其实是一个目录，里面有三个文件，ca.crt是根证书文件，namespace的值为default，以及一个token文件。这些值是怎么来的呢？通过前面的学习可以知道它是与serviceaccount相关联的值。接下来我们看看当前是否存在serviceaccount，使用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get serviceaccount</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         1d</span><br></pre></td></tr></table></figure><p>也可以使用简写命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get sa</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         1d</span><br></pre></td></tr></table></figure><p>可以看到这里有一个默认的名为default的namespace，可以使用如下命令来查看它的详细信息，其中<code>-o</code>指令用于指定输出的格式，这里我们让信息以yaml格式进行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get sa -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: ServiceAccount</span><br><span class="line">  metadata:</span><br><span class="line">    creationTimestamp: 2022-09-03T10:56:39Z</span><br><span class="line">    name: default</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;142&quot;</span><br><span class="line">    selfLink: /api/v1/namespaces/default/serviceaccounts/default</span><br><span class="line">    uid: 16487d73-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">  secrets:</span><br><span class="line">  - name: default-token-tq5m2</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure><p>你要是以json格式进行输出，这也是可以的。可以看到上面有一个名为<code>secrets.name</code>的配置项，它的值为default-token-tq5m2。开发者也可以使用如下命令查看一下当前所有的secrets：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">default-token-tq5m2   kubernetes.io/service-account-token   3         1d</span><br></pre></td></tr></table></figure><p>然后我们查看一下这个secrets的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get secrets -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  data:</span><br><span class="line">    ca.crt: ca.crt文件的内容</span><br><span class="line">    namespace: ZGVmYXVsdA==</span><br><span class="line">    token: token的值</span><br><span class="line">  kind: Secret</span><br><span class="line">  metadata:</span><br><span class="line">    annotations:</span><br><span class="line">      kubernetes.io/service-account.name: default</span><br><span class="line">      kubernetes.io/service-account.uid: 16487d73-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">    creationTimestamp: 2021-09-03T10:56:39Z</span><br><span class="line">    name: default-token-tq5m2</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;139&quot;</span><br><span class="line">    selfLink: /api/v1/namespaces/default/secrets/default-token-tq5m2</span><br><span class="line">    uid: 164a148f-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">  type: kubernetes.io/service-account-token</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure><p>这其实就和我们之前在<code>/var/run/secrets/kubernetes.io/serviceaccount</code>目录中所看到的三个文件是一一对应的，相当于将这个secret赋给了每一个pod。这就说明如果APIServer的<code>kube-apiserver.service</code>文件中的<code>admission-control</code>配置项，如果配置了ServiceAccount，那么它就会在default这个namespace下创建一个默认的serviceaccount，然后每个pod在启动的时候会将这个service中的secret以文件的形式挂载到pod中。有了这些挂载的文件之后，我们的pod就可以通过https的方式去访问APIServer，也就是说让pod可以通过APIServer的认证。</p><p>接下来继续学习Kubernetes，回到<code>/home/envy/services</code>目录，可以看到里面有三个文件，这是之前我们创建的三个用于配置对应信息的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# ls -l /home/envy/services/</span><br><span class="line">-rw-r--r-- 1 root root 274 8月  31 21:51 nginx-deployment.yaml</span><br><span class="line">-rw-r--r-- 1 root root 151 8月  31 21:24 nginx-pod.yaml</span><br><span class="line">-rw-r--r-- 1 root root 174 9月   2 21:47 nginx-service.yaml</span><br></pre></td></tr></table></figure><p>之前我们创建对应的deployment、pod和service时，使用了<code>kubectl create</code>命令，接下来我们尝试使用新的命令<code>kubectl apply</code>。我们利用<code>kubectl apply</code>来创建一个pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure><p>再来看一下当前所有的pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ssf78   1/1       Running   0          1h</span><br><span class="line">nginx                                  1/1       Running   0          4m</span><br></pre></td></tr></table></figure><p>然后查看一下名为nginx的pod的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl describe pods nginx</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2b90a2488a3badb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到相比于kubectl create命令，它多了一个Annotations，里面记录的是最近一次的修改，会将修改的内容添加到里面，你会发现这个命令并没有将完整的修改内容都显示全，如果你想显示完全，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods nginx -o json</span><br><span class="line">&quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.7.9\&quot;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;ports\&quot;:[&#123;\&quot;containerPort\&quot;:80&#125;]&#125;]&#125;&#125;\n&quot;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到这里面是我们上一次应用的完整配置，它起到了一个记录的功能，会将最近一次文件的配置内容放到annotations中进行存储，这样当应用出现问题的时候，它作为应用回滚的依据。还有一个区别，就是在使用<code>kubectl create</code>命令的时候，如果应用已经存在，那么必须将该应用删除，才能重新创建。而<code>kubectl apply</code>命令并不会重新去创建应用，而是会在之前应用的基础上进行修改。</p><p>举个例子，我们想创建一个基于nginx1.13版本的nginx-pod，此时该如何操作呢？可以使用<code>kubectl apply</code>命令，首先将<code>nginx-pod.yaml</code>文件中的nginx镜像版本由1.7.9修改为1.13：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: nginx</span><br><span class="line">      image: nginx:1.13</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br></pre></td></tr></table></figure><p>接着执行如下命令来创建nginx-pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; configured</span><br></pre></td></tr></table></figure><p>然后使用如下命令来查看一下是否真的更新成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods nginx -o json</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;annotations&quot;: &#123;</span><br><span class="line">        &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.13\&quot;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;ports\&quot;:[&#123;\&quot;containerPort\&quot;:80&#125;]&#125;]&#125;&#125;\n&quot;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>当然了，更新镜像还有之前使用的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl set image pods nginx nginx=nginx:1.7.9</span><br><span class="line">pod &quot;nginx&quot; image updated</span><br></pre></td></tr></table></figure><p>再来看一下容器中的镜像，可以看到此时容器中的镜像已经变成1.7.9，但是Annotations中显示的镜像版本还是1.13，这是因为这个Annotations中始终保持的是配置文件中最新的配置，而无论开发者使用命令做任何修改，Annotations中始终都不会进行显示，这里只会显示配置文件中的修改。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cc966d8f1931319b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们使用<code>kubectl apply</code>来创建nginx-deployment和nginx-service这两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-deployment.yaml </span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br><span class="line">[root@server02 services]# kubectl apply -f nginx-service.yaml </span><br><span class="line">service &quot;nginx-service&quot; created</span><br></pre></td></tr></table></figure><p>接下来我们尝试使用NodeIP+NodePort方式来访问其他的Node节点，这是可以访问的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes      ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          2d</span><br><span class="line">nginx-service   NodePort    10.68.199.24   &lt;none&gt;        8080:20000/TCP   4m</span><br></pre></td></tr></table></figure><p>然后我们使用另一种方式，就是通过进入到容器中使用CLUSTER_IP+ServicePort这一方式来访问。由于这里需要进入到一个容器中，如果现在没有容器，可以使用<code>kubectl run busybox --rm=true --image=busybox --restart=Never --tty -i</code>来启动一个busybox镜像，这个镜像是专门用于测试，它启动完之后提供一些命令，就相当于运行在这个集群中的一个沙盒。<code> --rm=true</code>参数表示在结束的时候会自动删除，<code>--image=busybox</code>用于指定镜像为busybox，<code>--restart=Never</code>表示重启方案，此处设置从来不重启，即退出后就不重启。<code>--tty</code>表示开启一个伪终端，<code> -i</code>表示获取到标准输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl run busybox --rm=true --image=busybox --restart=Never --tty -i</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ # ls</span><br><span class="line">bin   dev   etc   home  proc  root  sys   tmp   usr   var</span><br></pre></td></tr></table></figure><p>这样我们就进入了这个容器，我们可以使用wget命令，将wget输出定位到标准输出中，然后我们使用CLUSTER_IP+ServicePort这一方式来访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -qO - 10.68.199.24:8080</span><br></pre></td></tr></table></figure><p>如果出现nginx相关的页面信息，这就说明kube-proxy是正常的，然后我们将上面的IP修改为services的命令看看是否也能成功访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -qO - nginx-service:8080</span><br></pre></td></tr></table></figure><p>如果也出现nginx相关的页面信息，这就说明kube-dns也是正常的。</p><h1 id="微服务项目部署"><a href="#微服务项目部署" class="headerlink" title="微服务项目部署"></a>微服务项目部署</h1><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul><li>消息服务：message-service</li><li>课程dubbo服务：course-dubbo-service</li><li>课程web服务：course-edge-service</li><li>用户thrift服务：user-thrift-service</li><li>用户web服务：user-edge-service</li><li>API网关：api-gateway</li></ul><p>如果将它们放到kunernetes集群中运行，我们需要考虑哪些问题呢？<br><strong>（1）哪些服务适合单独成一个pod？哪些服务适合在一个pod中？</strong><br>在Kubernetes中，最小的单元是pod，一个pod中可以包含一个或者多个容器，因此我们需要考虑我们有哪些服务是适合放在同一个pod中，还有哪些是适合单独成一个pod。如果将多个服务放在一个pod中，会有什么特征呢？毫无疑问两者之间的访问效率肯定是很高的，它们之间通过本机localhost就可以访问到处于同一个pod中的服务。</p><p>消息服务与其他的服务关联程度不大，而且所有的服务都可能去调用消息服务，因此它和谁放在一起都不太合适，可以将其单独做成一个pod。然后课程的dubbo服务和web服务这两个是紧密相关的，因为课程的dubbo服务大部分都是由web服务去调用的，两者的交换频率肯定会很高。因此课程的dubbo服务和web服务这两个可以放在同一个pod中。同理用户的thrift服务和web服务也应该放在同一个pod中。api网关可能会调用很多的服务，因此它并不适合和其他的服务放在一起，所以将其放在一个单独的pod中。</p><p><strong>（2）在一个pod里面的服务如何彼此访问？它们的服务如何对外提供服务？</strong><br>举个例子，如课程的dubbo服务和web服务，它们都在同一个pod中，两者是如何进行彼此通信的呢？可以通过本机的端口直接去访问，这是没问题的。在前面我们学习过service，知道我们的服务可以通过CLUSTER_IP或者通过kube-dns根据名字来进行解析，让我们的服务可以在集群内部进行访问，并且在一个service中可以同时定义多个端口，其实就是允许我们同时对外提供多个服务。这一点从技术上来说也是没有任何问题的。</p><p><strong>（3）单独的pod如何对外提供服务？</strong><br>单独的pod其实就更简单了，直接通过CLUSTER_IP或者通过kube-dns根据名字来进行解析，就可以直接提供集群内的服务了。</p><p><strong>（4）哪个服务作为整个服务的入口，入口服务如何对外提供服务？</strong><br>最后比较特殊的就是API网关，它作为整个服务的入口，为了对外提供服务，它需要提供一个NodePort，这样就让我们在集群外，也可以访问到这个服务，这就是api-gateway需要对外提供服务的方式，即它需要使用到NodePort。</p><h3 id="搞定配置"><a href="#搞定配置" class="headerlink" title="搞定配置"></a>搞定配置</h3><p>配置的模板已经设置好了，就是按照前面所说的服务划分，但是开发者还需要做一些配置，将这些配置文件中的变量进行配置。进入到主节点中，我们先进入到如下目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/service-config/</span><br></pre></td></tr></table></figure><p>然后查看一下当前的目录文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">api-gateway.yaml     message-service.yaml</span><br><span class="line">course-service.yaml  user-service.yaml</span><br><span class="line">#替换变量 - (hub.envyzhan.com:9080是我的环境的镜像仓库地址，大家修改为各自的仓库)</span><br><span class="line">$ sed -i &#x27;s/&#123;&#123;HUB&#125;&#125;/hub.envyzhan.com:9080/g&#x27; *</span><br></pre></td></tr></table></figure><p>接下来查看各个文件的信息，<code>api-gateway.yaml</code>配置文件内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: api-gateway</span><br><span class="line">  name: api-gateway</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    nodePort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: api-gateway</span><br><span class="line">  type: NodePort</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: api-gateway-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: api-gateway</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api-gateway</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/api-gateway-zuul:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>接着我们再来看一下<code>message-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: message-service</span><br><span class="line">  name: message-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 9090</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9090</span><br><span class="line">  selector:</span><br><span class="line">    app: message-service</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: message-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: message-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: message-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/message-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br></pre></td></tr></table></figure><p>可以看到这个Service的类型是ClusterIP，因为它不需要对外提供服务，只需在集群内提供服务。</p><p>再来看一下<code>course-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: course-service</span><br><span class="line">  name: course-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8081</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8081</span><br><span class="line">  selector:</span><br><span class="line">    app: course-service</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: course-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: course-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: course-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/course-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 20880</span><br><span class="line">      - name: course-edge-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/course-edge-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8081</span><br></pre></td></tr></table></figure><p>可以看到里面有两个容器，一个是course-service，容器端口为20880，另一个则是course-edge-service，容器端口为8081，这个与名为course-service的service所指定的service端口是一致的。这是因为这个8081是在集群内提供给其他服务所使用的，而这个20880它只需要给这个course-edge-service使用就可以，因为别的服务并没有使用到它，也没有依赖它，因此上面我们只需指定一个端口。</p><p>最后再来看一下这个<code>user-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: user-service</span><br><span class="line">  name: user-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: user-edge-service-port</span><br><span class="line">    port: 8082</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8082</span><br><span class="line">  - name: user-service-port</span><br><span class="line">    port: 7911</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 7911</span><br><span class="line">  selector:</span><br><span class="line">    app: user-service</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: user-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: user-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: user-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/user-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 7911</span><br><span class="line">      - name: user-edge-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/user-edge-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8082</span><br></pre></td></tr></table></figure><p>可以看到这个名为user-service的service里面提供了两个port，一个是user-edge-service-port，端口号为8082；另一个则是user-service-port，端口号为7911，注意定义多个port时就需要开发者指定名称。一个是方便我们记忆，另一个则是方便后来维护的人，这些port分别用于做什么事情。这就表明这两个port在集群中，都是提供给集群内其他port来使用的。后面的user-service-deployment中也是有两个容器，一个是user-service，另一个则是user-edge-service。</p><p>可以看到user-service和course-service这两个service的唯一区别在于，course-service只定义了一个端口用于对外提供服务，而user-service却需要提供两个端口，且这两个端口都需要对外提供服务。</p><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>（1）启动Harbor。由于在前面我们已经将harbor设置为开机自启动，因此这里会自己启动。<br>（2）启动MySQL。进入到<code>/opt/mysql</code>目录，在里面执行其中的<code>start.sh</code>脚本文件即可启动MySQL。<br>（3）启动Redis。进入到<code>/opt/redis</code>目录，在里面执行其中的<code>start.sh</code>脚本文件即可启动Redis。<br>（4）启动Zookeeper。由于在前面我们已经将Zookeeper设置为开机自启动，因此这里会自己启动。</p><h1 id="梳理代码"><a href="#梳理代码" class="headerlink" title="梳理代码"></a>梳理代码</h1><p><strong>（1）api-gateway-zuul微服务配置信息改造。</strong>api-gateway-zuul微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: gateway-zuul-service</span><br><span class="line">  port: 8080</span><br><span class="line"># zuul相关配置信息</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    course:</span><br><span class="line">      path: /course/**</span><br><span class="line">      url: http://course-edge-service:8023/course/</span><br><span class="line">    user:</span><br><span class="line">      path: /user/**</span><br><span class="line">      url: http://user-edge-service:8022/user/</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64bbb1922dbb23e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b8aba803fb800f22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: gateway-zuul-service</span><br><span class="line">  port: 8080</span><br><span class="line"># zuul相关配置信息</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    course:</span><br><span class="line">      path: /course/**</span><br><span class="line">      url: http://course-service:8081/course/</span><br><span class="line">    user:</span><br><span class="line">      path: /user/**</span><br><span class="line">      url: http://user-service:8082/user/</span><br></pre></td></tr></table></figure><p><strong>（2）course-dubbo-service微服务配置信息改造。</strong>course-dubbo-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.51.100:3306/db_course</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://192.168.51.100:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">#    host: 192.168.51.6</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br></pre></td></tr></table></figure><p>通过对比发现这个服务的配置信息无需进行修改。<br><strong>（3）course-edge-service微服务配置信息改造。</strong>course-edge-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: course-edge-service</span><br><span class="line">  port: 8023</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://$&#123;zookeeper.url&#125;:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">#    host: 192.168.51.6</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: course-edge-service</span><br><span class="line">  port: 8023</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://192.168.51.100:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br><span class="line">user:</span><br><span class="line">  edge:</span><br><span class="line">    service:</span><br><span class="line">      addr: user-service:8082</span><br></pre></td></tr></table></figure><p><strong>（4）user-edge-service微服务配置信息改造。</strong>user-edge-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-edge-service</span><br><span class="line">  port: 8022</span><br><span class="line"></span><br><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 短信服务的IP和端口号</span><br><span class="line">  message:</span><br><span class="line">    ip: message-service</span><br><span class="line">    port: 9090</span><br><span class="line"></span><br><span class="line"># Redis配置信息</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: $&#123;redis.url&#125;</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 30000</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-edge-service</span><br><span class="line">  port: 8022</span><br><span class="line"></span><br><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 短信服务的IP和端口号</span><br><span class="line">  message:</span><br><span class="line">    ip: message-service</span><br><span class="line">    port: 9090</span><br><span class="line"></span><br><span class="line"># Redis配置信息</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.51.100</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 30000</span><br></pre></td></tr></table></figure><p><strong>（5）user-thrift-service微服务配置信息改造。</strong>user-thrift-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-thrift-service</span><br><span class="line">  port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://$&#123;mysql.url&#125;:3306/db_user</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-thrift-service</span><br><span class="line">  port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.51.100:3306/db_user</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br></pre></td></tr></table></figure><h3 id="重新打包镜像"><a href="#重新打包镜像" class="headerlink" title="重新打包镜像"></a>重新打包镜像</h3><p>将下来我们需要将之前我们修改过配置文件的服务，都重新打包成镜像，这个过程在前面都已经进行了介绍，这里就不过多介绍了。</p><h3 id="删除现有的服务"><a href="#删除现有的服务" class="headerlink" title="删除现有的服务"></a>删除现有的服务</h3><p>首先进入到主节点，查看一下当前所有的服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes      ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          3d</span><br><span class="line">nginx-service   NodePort    10.68.199.24   &lt;none&gt;        8080:20000/TCP   1d</span><br></pre></td></tr></table></figure><p>考虑到后面这个nginx-service可能会影响到现有的服务，这里我们将这个服务给删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete svc nginx-service</span><br><span class="line">service &quot;nginx-service&quot; deleted</span><br></pre></td></tr></table></figure><p>同理查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           2d</span><br><span class="line">nginx-deployment      2         2         2            2           1d</span><br></pre></td></tr></table></figure><p>删除上述两个deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete deploy nginx-deployment</span><br><span class="line">deployment &quot;nginx-deployment&quot; deleted</span><br><span class="line">[root@server02 service-config]# kubectl delete deploy kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; deleted</span><br></pre></td></tr></table></figure><p>再来查看一下当前所有的pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get pods</span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx     1/1       Running   0          1d</span><br></pre></td></tr></table></figure><p>删除这个名为nginx的pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete pod nginx</span><br><span class="line">pod &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure><p>接着进入到主节点所在机器，我们需要在它的<code>/etc/hosts</code>文件中新增一条映射信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.100 hub.envyzhan.com</span><br></pre></td></tr></table></figure><p>然后我们进入到<code>/home/envy/kubernetes-starter/service-config</code>目录，开始根据对应的配置文件创建对应的Service、Deployment。注意它们是有依赖关系的，因此创建顺序不能搞错，必须是【message-service.yaml】–&gt;【user-service.yaml】–&gt;【course-service.yaml】–&gt;【api-gateway.yaml】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl apply -f message-service.yaml </span><br><span class="line">service &quot;message-service&quot; created</span><br><span class="line">deployment &quot;message-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f user-service.yaml </span><br><span class="line">service &quot;user-service&quot; created</span><br><span class="line">deployment &quot;user-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f course-service.yaml </span><br><span class="line">service &quot;course-service&quot; created</span><br><span class="line">deployment &quot;course-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f api-gateway.yaml </span><br><span class="line">deployment &quot;api-gateway-deployment&quot; created</span><br><span class="line">The Service &quot;api-gateway&quot; is invalid: spec.ports[0].nodePort: Invalid value: 80: provided port is not in the valid range. The range of valid ports is 20000-40000</span><br></pre></td></tr></table></figure><p>可以看到我们在创建api-gateway这一NodePort时出现问题，原因是我们在APIServer中规定了节点端口必须在2万-4万之间，而此处的80端口是不在里面，所以就抛出异常。此时我们可以修改APIServer的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# vi /lib/systemd/system/kube-apiserver.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-51e96c44aa35c6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们可以将其中的2万-4万修改为80-4万，这样就好了，当然你可以让api-gateway它的NodePort修改为2万-4万之间的值，只是此时用起来就不太方便了。之后依次执行如下命令来重启APIServer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# systemctl daemon-reload</span><br><span class="line">[root@server02 service-config]# systemctl restart kube-apiserver</span><br></pre></td></tr></table></figure><p>之后我们再次重新执行上述<code>kubectl apply -f api-gateway.yaml</code>命令，可以看到此时就不抛出异常了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl apply -f api-gateway.yaml </span><br><span class="line">service &quot;api-gateway&quot; created</span><br><span class="line">deployment &quot;api-gateway-deployment&quot; unchanged</span><br></pre></td></tr></table></figure><p>接着我们查看一下当前所有的service信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get svc</span><br><span class="line">NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">api-gateway       NodePort    10.68.180.221   &lt;none&gt;        80:80/TCP           22s</span><br><span class="line">course-service    ClusterIP   10.68.54.94     &lt;none&gt;        8081/TCP            7m</span><br><span class="line">kubernetes        ClusterIP   10.68.0.1       &lt;none&gt;        443/TCP             3d</span><br><span class="line">message-service   ClusterIP   10.68.24.72     &lt;none&gt;        9090/TCP            7m</span><br><span class="line">user-service      ClusterIP   10.68.77.158    &lt;none&gt;        8082/TCP,7911/TCP   7m</span><br></pre></td></tr></table></figure><p>再来查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get deploy</span><br><span class="line">NAME                         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">api-gateway-deployment       1         1         1            0           8m</span><br><span class="line">course-service-deployment    1         1         1            0           9m</span><br><span class="line">message-service-deployment   1         1         1            0           9m</span><br><span class="line">user-service-deployment      1         1         1            0           9m</span><br></pre></td></tr></table></figure><p>可以看到现在AVAILABLE的个数为0，表示一个都无法使用。那我们查看当前所有的pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get pods -o wide</span><br><span class="line">NAME                                          READY     STATUS             RESTARTS   AGE       IP              NODE</span><br><span class="line">api-gateway-deployment-68f4694877-2s8nv       0/1       ImagePullBackOff   0          14m       172.20.188.9    192.168.51.121</span><br><span class="line">course-service-deployment-ff6f7d4b8-snm7l     0/2       ImagePullBackOff   0          14m       172.20.40.198   192.168.51.123</span><br><span class="line">message-service-deployment-64c49f8ff8-48r8g   0/1       ImagePullBackOff   0          14m       172.20.188.7    192.168.51.121</span><br><span class="line">user-service-deployment-8674c798b7-8bbck      0/2       ImagePullBackOff   0          14m       172.20.188.8    192.168.51.12</span><br></pre></td></tr></table></figure><p>可以看到原来它们都在拉取镜像，这个速度有点慢。为了保险起见，接下来我们查看一下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl logs -f api-gateway-deployment-68f4694877-2s8nv</span><br><span class="line">Error from server (BadRequest): container &quot;api-gateway&quot; in pod &quot;api-gateway-deployment-68f4694877-2s8nv&quot; is waiting to start: trying and failing to pull image</span><br></pre></td></tr></table></figure><p>可以看到镜像拉取失败，我们尝试登陆到harbor镜像仓库上<code>docker login http://hub.envyzhan.com:9080</code>，可以看到错误信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get &quot;https://hub.envyzhan.com:9080/v2/&quot;: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>在主节点上的<code>/etc/docker/daemon.json</code>文件中新增一个不安全镜像仓库的配置信息，注意值必须是数组形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;],</span><br><span class="line"> &quot;insecure-registries&quot;: [&quot;hub.envyzhan.com:9080&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们依次执行如下命令来重新启动docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 docker]# systemctl daemon-reload</span><br><span class="line">[root@server02 docker]# systemctl restart docker</span><br></pre></td></tr></table></figure><p>之后我们再重新执行上述<code>kubectl apply -f</code>命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;接下来我们尝试在完整集群上部署微服务，首先来复习之前的一些命令以及学习一个新的命令，了解这些对于学习和熟悉Kubernete</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes完整集群搭建</title>
    <link href="http://envyzhan.asia/2022/07/06/2022-k8s-4-complete-cluster-construction/"/>
    <id>http://envyzhan.asia/2022/07/06/2022-k8s-4-complete-cluster-construction/</id>
    <published>2022-07-06T09:55:30.000Z</published>
    <updated>2022-09-12T08:45:54.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整集群部署"><a href="#完整集群部署" class="headerlink" title="完整集群部署"></a>完整集群部署</h1><p>本篇尝试对之前使用的基础集群进行改造和升级，使其成为一个比较完整的Kubernetes集群。</p><h1 id="理解认证授权"><a href="#理解认证授权" class="headerlink" title="理解认证授权"></a>理解认证授权</h1><h3 id="为什么要认证"><a href="#为什么要认证" class="headerlink" title="为什么要认证"></a>为什么要认证</h3><p>想理解认证，我们得从认证用于解决什么问题、防止什么问题的发生入手？<br>防止什么问题呢？是防止有人入侵你的集群，root你的机器后我们集群依然安全吗？不是吧，root都到手了，那就为所欲为，防不胜防了。</p><p>其实网络安全本身就是为了解决在某些假设成立的条件下如何防范的问题。比如一个非常重要的假设就是两个节点或者ip之间的通讯网络是不可信任的，可能会被第三方窃取，也可能会被第三方篡改。就像我们上学时候给心仪的女孩传纸条，传送的过程可能会被别的同学偷看，甚至内容可能会从我喜欢你修改成我不喜欢你了。当然这种假设不是随便想出来的，而是从网络技术现状和实际发生的问题中发现、总结出来的。kubernetes的认证也是从这个问题出发来实现的。</p><h3 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h3><p>为了解决上面说的问题，kubernetes并不需要自己想办法，毕竟是网络安全层面的问题，是每个服务都会遇到的问题，业内也有成熟的方案来解决。这里我们一起了解一下业内方案和相关的概念。<br>（1）对称加密/非对称加密。（2）SSL/TLS。</p><h3 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h3><p>授权的概念就简单多了，就是什么人具有什么样的权限，一般通过角色作为纽带把他们组合在一起。也就是一个角色一边拥有多种权限，一边拥有多个人。这样就把人和权限建立了一个关系。</p><h1 id="kubernetes的认证授权"><a href="#kubernetes的认证授权" class="headerlink" title="kubernetes的认证授权"></a>kubernetes的认证授权</h1><p>Kubernetes集群的所有操作基本上都是通过kube-apiserver这个组件进行的，它提供HTTP RESTful形式的API供集群内外客户端调用。需要注意的是，认证授权过程只存在HTTPS形式的API中。也就是说，如果客户端使用HTTP连接到kube-apiserver，此时是不会进行认证授权的。因此开发者可以这样设置，在集群内部组件间通信使用HTTP，集群外部则使用HTTPS，这样既增加了安全性，也不至于太复杂。</p><p>对APIServer的访问要经过的三个步骤，前面两个是认证和授权，第三个是 Admission Control，它也能在一定程度上提高安全性，不过更多是资源管理方面的作用。</p><h3 id="kubernetes的认证"><a href="#kubernetes的认证" class="headerlink" title="kubernetes的认证"></a>kubernetes的认证</h3><p>kubernetes提供了多种认证方式，比如客户端证书、静态token、静态密码文件、ServiceAccountTokens等等。开发者可以同时使用一种或多种认证方式，只要通过任何一种都被认为是认证通过。下面我们就来认识几个常见的认证方式。<br>（1）客户端证书认证。客户端证书认证（TLS双向认证），也就是服务器客户端互相验证证书的正确性，只有在双方都正确的情况下协调通信加密方案。 为了使用这个方案，api-server需要用<code>--client-ca-file</code>选项来开启。</p><p>（2）引导Token。当我们有非常多的node节点时，手动为每个node节点配置TLS认证比较麻烦，这时就可以用到引导token的认证方式，前提是需要在api-server开启<code>experimental-bootstrap-token-auth</code>特性，客户端的token信息与预先定义的token匹配认证通过后，自动为node颁发证书。当然引导token是一种机制，可以用到各种场景中。</p><p>（3）Service Account Tokens认证。有些情况下，我们希望在pod内部访问api-server，获取集群的信息，甚至对集群进行改动。针对这种情况，kubernetes提供了一种特殊的认证方式：<code>Service Account</code>。 Service Account 和 pod、service、deployment 一样，也是 kubernetes 集群中的一种资源，用户也可以创建自己的 Service Account。 ServiceAccount主要包含了三个内容：namespace、Token 和 CA。namespace 指定了pod 所在的 namespace，CA 用于验证apiserver 的证书，token 用作身份验证。它们都通过mount的方式保存在 pod 的文件系统中。</p><h3 id="kubernetes的授权"><a href="#kubernetes的授权" class="headerlink" title="kubernetes的授权"></a>kubernetes的授权</h3><p>Kubernetes1.6版本中新增角色访问控制机制（Role-Based Access，RBAC），目的是让集群管理员可以针对特定使用者或服务账号的角色，进行更精确的资源访问控制。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。 目前 Kubernetes 中有一系列的鉴权机制，因为Kubernetes社区的投入和偏好，相对于其它鉴权机制而言，RBAC是更好的选择。具体RBAC是如何体现在kubernetes系统中的我们会在后面的部署中逐步的深入了解。</p><h3 id="kubernetes的AdmissionControl"><a href="#kubernetes的AdmissionControl" class="headerlink" title="kubernetes的AdmissionControl"></a>kubernetes的AdmissionControl</h3><p>AdmissionControl （准入控制）本质上为一段准入代码，在对kubernetes api的请求过程中，顺序如下：先经过认证和授权，然后执行准入操作，最后对目标对象进行操作。这个准入代码在api-server中，而且必须被编译到二进制文件中才能被执行。 在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的error信息。</p><p> 常用组件（控制代码）如下：<br>（1）AlwaysAdmit：允许所有请求。<br>（2）AlwaysDeny：禁止所有请求，多用于测试环境。<br>（3）ServiceAccount：它将serviceAccounts实现了自动化，它会辅助serviceAccount做一些事情，比如如果pod没有serviceAccount属性，它会自动添加一个default，并确保pod的serviceAccount始终存在。<br>（4）LimitRanger：它会观察所有的请求，以确保没有违反已经定义好的约束条件，这些条件定义在namespace中LimitRange对象中。如果在kubernetes中使用LimitRange对象，则必须使用这个插件。<br>（5）NamespaceExists：它会观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h3 id="停止原有kubernetes相关服务"><a href="#停止原有kubernetes相关服务" class="headerlink" title="停止原有kubernetes相关服务"></a>停止原有kubernetes相关服务</h3><p>在开始之前，我们需要先将基础版本的集群停掉，包括service，deployments，pods以及运行的所有kubernetes组件，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#删除master节点上自己创建的各种组件</span><br><span class="line">#删除services</span><br><span class="line">$ kubectl delete services kubernetes-bootcamp</span><br><span class="line">$ kubectl delete services nginx-service</span><br><span class="line">#删除deployments</span><br><span class="line">$ kubectl delete deploy kubernetes-bootcamp</span><br><span class="line">$ kubectl delete deploy nginx-deployment</span><br><span class="line">#删除pods</span><br><span class="line">$ kubectl delete pod nginx</span><br><span class="line"></span><br><span class="line">#停掉worker节点的服务</span><br><span class="line">$ service kubelet stop &amp;&amp; rm -fr /var/lib/kubelet/*</span><br><span class="line">$ service kube-proxy stop &amp;&amp; rm -fr /var/lib/kube-proxy/*</span><br><span class="line">$ service kube-calico stop</span><br><span class="line"></span><br><span class="line">#停掉master节点的服务</span><br><span class="line">$ service kube-calico stop</span><br><span class="line">$ service kube-scheduler stop</span><br><span class="line">$ service kube-controller-manager stop</span><br><span class="line">$ service kube-apiserver stop</span><br><span class="line">$ service etcd stop &amp;&amp; rm -fr /var/lib/etcd/*</span><br></pre></td></tr></table></figure><h3 id="生成配置（所有节点）"><a href="#生成配置（所有节点）" class="headerlink" title="生成配置（所有节点）"></a>生成配置（所有节点）</h3><p>和基础环境搭建一样，我们需要生成<code>kubernetes-with-ca</code>的所有相关配置文件。进入到<code>/home/envy/kubernetes-starter</code>目录，修改其中的config.properties配置文件为如下所示，其实也就是将ETCD_ENDPOINTS配置项中的http修改为了https，其他都没有变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#kubernetes二进制文件目录,eg: /home/envy/bin</span><br><span class="line">BIN_PATH=/home/envy/bin</span><br><span class="line"></span><br><span class="line">#当前节点ip, eg: 192.168.1.102</span><br><span class="line">NODE_IP=192.168.51.122</span><br><span class="line"></span><br><span class="line">#etcd服务集群列表, eg: http://192.168.1.102:2379</span><br><span class="line">#如果已有etcd集群可以填写现有的。没有的话填写：http://$&#123;MASTER_IP&#125;:2379 （MASTER_IP自行替换成自己的主节点ip）</span><br><span class="line">##如果用了证书，就要填写https://$&#123;MASTER_IP&#125;:2379 （MASTER_IP自行替换成自己的主节点ip）</span><br><span class="line">ETCD_ENDPOINTS=https://192.168.51.122:2379</span><br><span class="line"></span><br><span class="line">#kubernetes主节点ip地址, eg: 192.168.1.102</span><br><span class="line">MASTER_IP=192.168.51.122</span><br></pre></td></tr></table></figure><p>之后在该文件目录下执行如下命令来生成对应的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gen-config.sh with-ca</span><br></pre></td></tr></table></figure><p>生成的文件依旧是在target目录中，它会覆盖之前target目录中的文件。</p><h3 id="安装cfssl（所有节点）"><a href="#安装cfssl（所有节点）" class="headerlink" title="安装cfssl（所有节点）"></a>安装cfssl（所有节点）</h3><p>cfssl是非常好用的CA工具，我们用它来生成证书和秘钥文件。它安装过程比较简单，使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装wget工具</span><br><span class="line">$ yum install -y wget</span><br><span class="line">#下载</span><br><span class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">#修改为可执行权限</span><br><span class="line">$ chmod +x cfssl_linux-amd64 cfssljson_linux-amd64</span><br><span class="line">#移动到bin目录</span><br><span class="line">$ mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line">$ mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line">#验证</span><br><span class="line">$ cfssl version</span><br></pre></td></tr></table></figure><h3 id="生成根证书（主节点）"><a href="#生成根证书（主节点）" class="headerlink" title="生成根证书（主节点）"></a>生成根证书（主节点）</h3><p>根证书是证书信任链的根，各个组件通讯的前提是有一份大家都信任的证书（根证书），每个人使用的证书都是由这个根证书签发的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#所有证书相关的东西都放在这</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca</span><br><span class="line">#准备生成证书的配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/ca-config.json /etc/kubernetes/ca</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/ca-csr.json /etc/kubernetes/ca</span><br><span class="line">#生成证书和秘钥</span><br><span class="line">$ cd /etc/kubernetes/ca</span><br><span class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">#生成完成后会有以下文件（我们最终想要的就是ca-key.pem和ca.pem，一个秘钥，一个证书）</span><br><span class="line">$ ls</span><br><span class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><h1 id="改造etcd（主节点执行）"><a href="#改造etcd（主节点执行）" class="headerlink" title="改造etcd（主节点执行）"></a>改造etcd（主节点执行）</h1><h3 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h3><p>etcd节点需要提供给其他服务访问，就要验证其他服务的身份，所以需要一个标识自己监听服务的server证书，当有多个etcd节点时，也需要client证书与etcd集群的其他节点交互，当然client和server也可以使用同一个证书，因为它们本质上没有区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#etcd证书放在这</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/etcd</span><br><span class="line">#准备etcd证书配置</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/etcd/etcd-csr.json /etc/kubernetes/ca/etcd/</span><br><span class="line">$ cd /etc/kubernetes/ca/etcd/</span><br><span class="line">#使用根证书(ca.pem)签发etcd证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line"></span><br><span class="line">#跟之前类似生成三个文件etcd.csr是个中间证书请求文件，我们最终要的是etcd-key.pem和etcd.pem</span><br><span class="line">$ ls</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem</span><br></pre></td></tr></table></figure><h3 id="改造etcd服务"><a href="#改造etcd服务" class="headerlink" title="改造etcd服务"></a>改造etcd服务</h3><p>先比较一下增加认证的etcd配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装vim</span><br><span class="line">$ yum install -y vim</span><br><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/etcd.service kubernetes-with-ca/master-node/etcd.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-316a716346cb66ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到之前的<code>listen-client-urls</code>和<code>advertise-client-urls</code>现在都变成了https，同时新增了如下新的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--listen-peer-urls=https://&#123;&#123;NODE_IP&#125;&#125;:2380</span><br><span class="line">--initial-advertise-peer-urls=https://&#123;&#123;NODE_IP&#125;&#125;:2380</span><br><span class="line">--cert-file=/etc/kubernetes/ca/etcd/etcd.pem</span><br><span class="line">--key-file=/etc/kubernetes/ca/etcd/etcd-key.pem</span><br><span class="line">--peer-cert-file=/etc/kubernetes/ca/etcd/etcd.pem</span><br><span class="line">--peer-key-file=/etc/kubernetes/ca/etcd/etcd-key.pem</span><br><span class="line">--trusted-ca-file=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--peer-trusted-ca-file=/etc/kubernetes/ca/ca.pem</span><br></pre></td></tr></table></figure><h3 id="更新etcd服务"><a href="#更新etcd服务" class="headerlink" title="更新etcd服务"></a>更新etcd服务</h3><p>更新etcd服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/etcd.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service etcd start</span><br><span class="line">#验证etcd服务（endpoints自行替换）</span><br><span class="line">$ ETCDCTL_API=3 etcdctl \</span><br><span class="line">  --endpoints=https://192.168.51.122:2379  \</span><br><span class="line">  --cacert=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">  --cert=/etc/kubernetes/ca/etcd/etcd.pem \</span><br><span class="line">  --key=/etc/kubernetes/ca/etcd/etcd-key.pem \</span><br><span class="line">  endpoint health</span><br></pre></td></tr></table></figure><p>这样etcd我们就成功的改造完了，接下来我们继续改造其他的组件。</p><h1 id="改造api-server（主节点执行）"><a href="#改造api-server（主节点执行）" class="headerlink" title="改造api-server（主节点执行）"></a>改造api-server（主节点执行）</h1><h3 id="准备证书-1"><a href="#准备证书-1" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#定义api-server证书存放位置，由于api-server是核心，因此这里文件夹名为kubernetes，也可以叫apiserver，只是对应地方需要修改</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/kubernetes</span><br><span class="line">#准备apiserver证书配置</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/kubernetes/kubernetes-csr.json /etc/kubernetes/ca/kubernetes/</span><br><span class="line">$ cd /etc/kubernetes/ca/kubernetes/</span><br><span class="line">#使用根证书(ca.pem)签发kubernetes证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br><span class="line"></span><br><span class="line">#和之前类似，生成了三个文件，其中kubernetes.csr是个中间证书请求文件，我们最终要的是kubernetes-key.pem和kubernetes.pem</span><br><span class="line">$ ls</span><br><span class="line">kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem</span><br></pre></td></tr></table></figure><h3 id="改造api-server服务"><a href="#改造api-server服务" class="headerlink" title="改造api-server服务"></a>改造api-server服务</h3><p>先比较一下增加认证的api-server配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-apiserver.service kubernetes-with-ca/master-node/kube-apiserver.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ed5901de06be4363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这个<code>admission-control</code>选项多了一个ServiceAccount值（认证授权会使用到），同时<code>insecure-bind-address</code>参数值由0.0.0.0变成了127.0.0.1（不安全地址之前是所有IP都可以访问，现在只有本机才可以访问）以及<code>kubelet-https</code>参数值为true。同时新增了如下新的配置项，这些都是与认证和授权相关的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--bind-address=&#123;&#123;NODE_IP&#125;&#125;</span><br><span class="line">--authorization-mode=Node,RBAC  # 授权模式RBAC</span><br><span class="line">--runtime-config=rbac.authorization.k8s.io/v1</span><br><span class="line">--enable-bootstrap-token-auth</span><br><span class="line">--token-auth-file=/etc/kubernetes/ca/kubernetes/token.csv # 指定token-auth-file的地址，我们需要生成这个文件</span><br><span class="line">--tls-cert-file=/etc/kubernetes/ca/kubernetes/kubernetes.pem</span><br><span class="line">--tls-private-key-file=/etc/kubernetes/ca/kubernetes/kubernetes-key.pem</span><br><span class="line">--client-ca-file=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--service-account-key-file=/etc/kubernetes/ca/ca-key.pem</span><br><span class="line">--etcd-cafile=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--etcd-certfile=/etc/kubernetes/ca/kubernetes/kubernetes.pem</span><br><span class="line">--etcd-keyfile=/etc/kubernetes/ca/kubernetes/kubernetes-key.pem</span><br><span class="line">--service-cluster-ip-range=10.68.0.0/16</span><br><span class="line">--service-cluster-ip-range=10.68.0.0/16</span><br><span class="line">--service-node-port-range=20000-40000</span><br><span class="line">--service-node-port-range=20000-40000</span><br><span class="line">--etcd-servers=&#123;&#123;ETCD_ENDPOINTS&#125;&#125;</span><br><span class="line">--etcd-servers=&#123;&#123;ETCD_ENDPOINTS&#125;&#125;</span><br><span class="line">--enable-swagger-ui=true</span><br><span class="line">--enable-swagger-ui=true</span><br><span class="line">--allow-privileged=true</span><br><span class="line">--allow-privileged=true</span><br><span class="line">--audit-log-maxage=30</span><br><span class="line">--audit-log-maxage=30</span><br></pre></td></tr></table></figure><p>注意，这里面有一个<code>bootstrap-token-auth</code>验证，而我们指定了<code>token-auth-file</code>的存储位置，因此将下来就是生成这个名为token.csv的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#生成随机token</span><br><span class="line">$ head -c 16 /dev/urandom | od -An -t x | tr -d &#x27; &#x27;</span><br><span class="line">49dd2bb99bc687e21dfa34e78fe098b1</span><br><span class="line"></span><br><span class="line">#按照固定格式写入token.csv，注意替换token内容</span><br><span class="line">$ echo &quot;49dd2bb99bc687e21dfa34e78fe098b1,kubelet-bootstrap,10001,\&quot;system:kubelet-bootstrap\&quot;&quot; &gt; /etc/kubernetes/ca/kubernetes/token.csv</span><br></pre></td></tr></table></figure><h3 id="更新api-server服务"><a href="#更新api-server服务" class="headerlink" title="更新api-server服务"></a>更新api-server服务</h3><p>更新api-server服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/kube-apiserver.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-apiserver start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-apiserver</span><br></pre></td></tr></table></figure><h1 id="改造controller-manager（主节点执行）"><a href="#改造controller-manager（主节点执行）" class="headerlink" title="改造controller-manager（主节点执行）"></a>改造controller-manager（主节点执行）</h1><p>由于controller-manager一般与api-server在同一台机器上，因此可使用非安全端口与api-server进行通讯，故不需要生成证书和私钥。</p><h3 id="查看diff内容"><a href="#查看diff内容" class="headerlink" title="查看diff内容"></a>查看diff内容</h3><p>先比较一下增加认证的controller-manager配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-controller-manager.service kubernetes-with-ca/master-node/kube-controller-manager.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5a1d4caa696aa664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这个<code>cluster-signing-cert-file</code>和<code>cluster-signing-key-file</code>这两个配置项的值都从空字符串变成了我们设置的ca证书的文件和私钥。这里你可能会有疑问，它里面设置的master参数就是127.0.0.10:8080这不就是本地么，这里为什么还需要ca证书呢？原因在于这些证书并不是在访问api-server时才使用的，而是当签名为tls/bootstrap时的证书和私钥。同时新增了如下新的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--service-account-private-key-file=/etc/kubernetes/ca/ca-key.pem</span><br><span class="line">--root-ca-file=/etc/kubernetes/ca/ca.pem</span><br></pre></td></tr></table></figure><h3 id="更新controller-manager服务"><a href="#更新controller-manager服务" class="headerlink" title="更新controller-manager服务"></a>更新controller-manager服务</h3><p>更新controller-manager服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/kube-controller-manager.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-controller-manager start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-controller-manager</span><br></pre></td></tr></table></figure><h1 id="改造scheduler（主节点执行）"><a href="#改造scheduler（主节点执行）" class="headerlink" title="改造scheduler（主节点执行）"></a>改造scheduler（主节点执行）</h1><p>由于scheduler一般与api-server在同一台机器上，因此可使用非安全端口与api-server进行通讯，故不需要生成证书和私钥。</p><h3 id="查看diff内容-1"><a href="#查看diff内容-1" class="headerlink" title="查看diff内容"></a>查看diff内容</h3><p>先比较一下增加认证的scheduler配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-scheduler.service kubernetes-with-ca/master-node/kube-scheduler.service</span><br></pre></td></tr></table></figure><p>可以发现这个文件前后没有任何变化，因此不需要进行改造。</p><h3 id="启动scheduler服务"><a href="#启动scheduler服务" class="headerlink" title="启动scheduler服务"></a>启动scheduler服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ service kube-scheduler start</span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-scheduler</span><br></pre></td></tr></table></figure><h1 id="改造kubectl（任意节点）"><a href="#改造kubectl（任意节点）" class="headerlink" title="改造kubectl（任意节点）"></a>改造kubectl（任意节点）</h1><p>由于前面我们将kubectl安装在了主节点上，其实我们是不需要对kubectl进行改造的。但是如果你的kubectl不是安装在了主节点，那么就需要进行改造。当然了就算kubectl安装在了主节点，我们还是可以对kubectl进行改造。</p><h3 id="准备证书-2"><a href="#准备证书-2" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#kubectl证书放在这，由于kubectl相当于系统管理员，因此这里使用admin命名</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/admin</span><br><span class="line">#准备admin证书配置，由于kubectl只需客户端证书，因此证书请求中的 hosts 字段可以为空</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/admin/admin-csr.json /etc/kubernetes/ca/admin/</span><br><span class="line">$ cd /etc/kubernetes/ca/admin/</span><br><span class="line">#使用根证书(ca.pem)签发admin证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class="line"></span><br><span class="line">#最终需要的是admin-key.pem和admin.pem</span><br><span class="line">$ ls</span><br><span class="line">admin.csr  admin-csr.json  admin-key.pem  admin.pem</span><br></pre></td></tr></table></figure><h3 id="配置kubectl"><a href="#配置kubectl" class="headerlink" title="配置kubectl"></a>配置kubectl</h3><p>接下来使用如下命令来对kubectl进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#指定apiserver的地址和证书位置（ip自行修改）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443</span><br><span class="line">#设置客户端认证参数，指定admin证书和秘钥</span><br><span class="line">$ kubectl config set-credentials admin \</span><br><span class="line">        --client-certificate=/etc/kubernetes/ca/admin/admin.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --client-key=/etc/kubernetes/ca/admin/admin-key.pem</span><br><span class="line">#关联用户和集群</span><br><span class="line">$ kubectl config set-context kubernetes \</span><br><span class="line">        --cluster=kubernetes --user=admin</span><br><span class="line">#设置当前上下文</span><br><span class="line">$ kubectl config use-context kubernetes</span><br><span class="line"></span><br><span class="line">#设置结果就是一个配置文件，可以看看内容，此处的~其实就是/root</span><br><span class="line">$ cat ~/.kube/config</span><br></pre></td></tr></table></figure><p><code>~/.kube/config</code>文件里面多了很多配置信息，这里面就是上面配置的各种项。然后运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 admin]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>出现上述结构，则说明kubectl可通过https来访问apiserver了。</p><h3 id="验证主节点"><a href="#验证主节点" class="headerlink" title="验证主节点"></a>验证主节点</h3><p>回到主节点，我们使用刚刚配置好的kubectl来查看一下组件的状态，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 admin]# kubectl get componentstatus</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok                   </span><br><span class="line">scheduler            Healthy   ok                   </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125; </span><br></pre></td></tr></table></figure><h1 id="改造calico-node（所有节点执行）"><a href="#改造calico-node（所有节点执行）" class="headerlink" title="改造calico-node（所有节点执行）"></a>改造calico-node（所有节点执行）</h1><h3 id="准备证书（只在主节点上执行）"><a href="#准备证书（只在主节点上执行）" class="headerlink" title="准备证书（只在主节点上执行）"></a>准备证书（只在主节点上执行）</h3><p>后面你就会知道，calico证书会用在如下四个地方：<br>（1）calico/node，docker容器运行时访问etcd时，使用证书；<br>（2）cni 配置文件中，cni 插件需要访问etcd时，使用证书；<br>（3）calicoctl 操作集群网络访问etcd时， 使用证书；<br>（4）calico/kube-controllers 同步集群网络策略访问etcd时，使用证书。</p><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#定义calico证书存放目录</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/calico</span><br><span class="line">#准备calico证书配置，由于calico只需客户端证书，因此证书请求中 hosts 字段可以为空</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/calico/calico-csr.json /etc/kubernetes/ca/calico/</span><br><span class="line">$ cd /etc/kubernetes/ca/calico/</span><br><span class="line">#使用根证书(ca.pem)签发calico证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes calico-csr.json | cfssljson -bare calico</span><br><span class="line">#最终需要的是calico-key.pem和calico.pem</span><br><span class="line">$ ls</span><br><span class="line">calico.csr  calico-csr.json  calico-key.pem  calico.pem</span><br></pre></td></tr></table></figure><h3 id="改造calico服务（所有节点执行）"><a href="#改造calico服务（所有节点执行）" class="headerlink" title="改造calico服务（所有节点执行）"></a>改造calico服务（所有节点执行）</h3><h5 id="查看diff内容-2"><a href="#查看diff内容-2" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><p>先比较一下增加认证的calico配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/all-node/kube-calico.service kubernetes-with-ca/all-node/kube-calico.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-262d1d5f09ccc9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，calico服务相比于之前多了一些与认证相关的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e ETCD_CA_CERT_FILE=/etc/kubernetes/ca/ca.pem</span><br><span class="line">-e ETCD_CERT_FILE=/etc/kubernetes/ca/calico/calico.pem</span><br><span class="line">-e ETCD_KEY_FILE=/etc/kubernetes/ca/calico/calico-key.pem</span><br></pre></td></tr></table></figure><p>由于calico服务是所有节点都需要安装的，因此需要将上述三个对应目录下的证书文件拷贝到每个节点的<code>/etc/kubernetes/</code>目录下，可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /etc/kubernetes/ca root@其他节点ip:/etc/kubernetes/</span><br></pre></td></tr></table></figure><h5 id="更新calico服务"><a href="#更新calico服务" class="headerlink" title="更新calico服务"></a>更新calico服务</h5><p>接着我们依次执行如下命令来更新calico服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/all-node/kube-calico.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-calico start</span><br></pre></td></tr></table></figure><p>之后使用如下命令来验证calico，如果能看到其他节点的列表，这就说明calico更新是成功的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">|  PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.51.123 | node-to-node mesh | up    | 01:32:56 | Established |</span><br><span class="line">| 192.168.51.121 | node-to-node mesh | up    | 01:42:58 | Established |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+```</span><br></pre></td></tr></table></figure><h1 id="改造kubelet（所有节点执行）"><a href="#改造kubelet（所有节点执行）" class="headerlink" title="改造kubelet（所有节点执行）"></a>改造kubelet（所有节点执行）</h1><p>这里我们让kubelet采用引导token的方式认证，所以认证方式跟之前的组件不同，它的证书不是手动生成，而是由工作节点TLS BootStrap 向api-server请求，由主节点的controller-manager 自动签发。<strong>首先需要使用<code>service kubelet stop</code>命令来停止各个节点上kubelet的运行。</strong></p><h3 id="创建角色绑定（只在主节点上执行）"><a href="#创建角色绑定（只在主节点上执行）" class="headerlink" title="创建角色绑定（只在主节点上执行）"></a>创建角色绑定（只在主节点上执行）</h3><p>引导token的方式要求客户端向api-server发起请求时，告诉它你的用户名和token，并且这个用户是具有一个特定的角色<code>system:node-bootstrapper</code>，因此需要先将 bootstrap token 文件中的<code>kubelet-bootstrap</code>用户赋予这个特定角色，然后 kubelet 才有权限发起创建认证请求。</p><p>开发者需要在主节点执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#可以通过下面命令查询clusterrole列表</span><br><span class="line">$ kubectl -n kube-system get clusterrole</span><br><span class="line"></span><br><span class="line">#查看一下token文件的内容</span><br><span class="line">$ cat /etc/kubernetes/ca/kubernetes/token.csv</span><br><span class="line">49dd2bb99bc687e21dfa34e78fe098b1,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;</span><br><span class="line"></span><br><span class="line">#创建角色绑定（即将用户kubelet-bootstrap与角色system:node-bootstrapper进行绑定）</span><br><span class="line">$ kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">         --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</span><br></pre></td></tr></table></figure><h3 id="创建bootstrap-kubeconfig（所有工作节点执行）"><a href="#创建bootstrap-kubeconfig（所有工作节点执行）" class="headerlink" title="创建bootstrap.kubeconfig（所有工作节点执行）"></a>创建<code>bootstrap.kubeconfig</code>（所有工作节点执行）</h3><p>此配置用于完成bootstrap token认证，里面保存了用户、token等重要认证信息，注意这个文件可以借助kubectl命令生成，也可以由开发者自己通过书写配置文件生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数(注意替换ip)</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443 \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#设置客户端认证参数(注意替换token)</span><br><span class="line">$ kubectl config set-credentials kubelet-bootstrap \</span><br><span class="line">        --token=49dd2bb99bc687e21dfa34e78fe098b1 \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#设置上下文</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster=kubernetes \</span><br><span class="line">        --user=kubelet-bootstrap \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#将刚生成的文件移动到合适的位置</span><br><span class="line">$ mv bootstrap.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><h3 id="准备cni配置（所有工作节点执行）"><a href="#准备cni配置（所有工作节点执行）" class="headerlink" title="准备cni配置（所有工作节点执行）"></a>准备cni配置（所有工作节点执行）</h3><h5 id="查看diff内容-3"><a href="#查看diff内容-3" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install vim -y</span><br><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/10-calico.conf kubernetes-with-ca/worker-node/10-calico.conf</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c7fb6692753a1f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，相比于之前多了一些与认证相关的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;etcd_key_file&quot;: &quot;/etc/kubernetes/ca/calico/calico-key.pem&quot;</span><br><span class="line">&quot;etcd_cert_file&quot;: &quot;/etc/kubernetes/ca/calico/calico.pem&quot;,                                            </span><br><span class="line">&quot;etcd_ca_cert_file&quot;: &quot;/etc/kubernetes/ca/ca.pem&quot;, </span><br></pre></td></tr></table></figure><p>同时<code>k8s_api_root</code>这一选项变成了kubeconfig这一选项的值，配置文件就是<code>/etc/kubernetes/kubelet.kubeconfig</code>。</p><h3 id="覆盖之前配置信息"><a href="#覆盖之前配置信息" class="headerlink" title="覆盖之前配置信息"></a>覆盖之前配置信息</h3><p>接下来我们使用如下命令来覆盖之前的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/10-calico.conf /etc/cni/net.d/</span><br></pre></td></tr></table></figure><h3 id="改造kubelet服务（所有工作节点执行）"><a href="#改造kubelet服务（所有工作节点执行）" class="headerlink" title="改造kubelet服务（所有工作节点执行）"></a>改造kubelet服务（所有工作节点执行）</h3><h5 id="查看diff内容-4"><a href="#查看diff内容-4" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/kubelet.service kubernetes-with-ca/worker-node/kubelet.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-72af2a188de270cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，相比于之前多了一些配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \                             </span><br><span class="line">--cert-dir=/etc/kubernetes/ca \                                                                        </span><br><span class="line">--hairpin-mode hairpin-veth \</span><br></pre></td></tr></table></figure><h5 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h5><p>在所有工作节点上执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kubelet.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kubelet start</span><br></pre></td></tr></table></figure><p>之后使用<code>journalctl -f -u kubelet</code>命令来检查日志，以确保kubelet已经成功启动，接着回到主节点，执行如下命令看一下前一个工作节点是否向主节点发送了添加集群的请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr</span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE   33s       kubelet-bootstrap   Pending</span><br></pre></td></tr></table></figure><p>然后执行如下命令来允许worker加入(批准worker的tls证书请求)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr|grep &#x27;Pending&#x27; | awk &#x27;&#123;print $1&#125;&#x27;| xargs kubectl certificate approve</span><br><span class="line">certificatesigningrequest &quot;node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE&quot; approved</span><br></pre></td></tr></table></figure><p>最后再在主节点上确认其他两个节点都已经加入到集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr</span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr-52ZQYhjSU70AqZJahaD52YDdeSKFDRjJ2eGOSVIkMlw   1m        kubelet-bootstrap   Approved,Issued</span><br><span class="line">node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE   1h        kubelet-bootstrap   Approved,Issued</span><br></pre></td></tr></table></figure><h1 id="改造kube-proxy（工作节点执行）"><a href="#改造kube-proxy（工作节点执行）" class="headerlink" title="改造kube-proxy（工作节点执行）"></a>改造kube-proxy（工作节点执行）</h1><h3 id="准备证书-3"><a href="#准备证书-3" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#定义proxy证书的存放位置</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/kube-proxy</span><br><span class="line"></span><br><span class="line">#准备proxy证书配置，由于proxy只需客户端证书，因此证书请求中 hosts 字段可以为空。</span><br><span class="line">#CN 指定该证书的 User 为 system:kube-proxy，预定义的 ClusterRoleBinding为system:node-proxy，即将User用户system:kube-proxy 与 Role角色system:node-proxier进行绑定，授予了调用 kube-api-server proxy的相关 API 的权限</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/kube-proxy/kube-proxy-csr.json /etc/kubernetes/ca/kube-proxy/</span><br><span class="line">$ cd /etc/kubernetes/ca/kube-proxy/</span><br><span class="line"></span><br><span class="line">#使用根证书(ca.pem)签发kube-proxy证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">#最终需要的是kube-proxy-key.pem和kube-proxy.pem</span><br><span class="line">$ ls</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure><h3 id="创建kube-proxy-kubeconfig配置"><a href="#创建kube-proxy-kubeconfig配置" class="headerlink" title="创建kube-proxy.kubeconfig配置"></a>创建<code>kube-proxy.kubeconfig</code>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数（注意替换ip）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443 \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#置客户端认证参数</span><br><span class="line">$ kubectl config set-credentials kube-proxy \</span><br><span class="line">        --client-certificate=/etc/kubernetes/ca/kube-proxy/kube-proxy.pem \</span><br><span class="line">        --client-key=/etc/kubernetes/ca/kube-proxy/kube-proxy-key.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#设置上下文参数</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster=kubernetes \</span><br><span class="line">        --user=kube-proxy \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#将刚生成的文件移动到合适的位置</span><br><span class="line">$ mv kube-proxy.kubeconfig /etc/kubernetes/kube-proxy.kubeconfig</span><br></pre></td></tr></table></figure><h3 id="改造kube-proxy服务"><a href="#改造kube-proxy服务" class="headerlink" title="改造kube-proxy服务"></a>改造kube-proxy服务</h3><h5 id="查看diff内容-5"><a href="#查看diff内容-5" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/kube-proxy.service kubernetes-with-ca/worker-node/kube-proxy.service</span><br></pre></td></tr></table></figure><p>从diff结果中可以看出，<code>kube-proxy.service</code>文件前后没有发生任何变化。</p><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#复制配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">#安装依赖软件</span><br><span class="line">$ yum install conntrack -y</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">$ service kube-proxy start</span><br><span class="line">#查看日志</span><br><span class="line">$ journalctl -f -u kube-proxy</span><br></pre></td></tr></table></figure><h1 id="改造kube-dns（app）"><a href="#改造kube-dns（app）" class="headerlink" title="改造kube-dns（app）"></a>改造kube-dns（app）</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>kube-dns有些特别，因为它是以kubernetes应用的形式，运行在kubernetes集群中，因此它的认证授权方式和之前的组件都不一样，需要用到service account认证和RBAC授权。<br>（1）<strong>service account认证</strong>：每个service account都会自动生成自己的secret，用于包含一个ca，token和secret，用于跟api-server认证。<br>（2）<strong>RBAC授权</strong>：权限、角色和角色绑定都是kubernetes自动创建好的，开发者只需要创建一个名为kube-dns的ServiceAccount即可，官方现有的配置已经将它包含进去了。</p><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>我们只需在官方的基础上，通过更改或者添加变量，然后就能生成适合我们集群的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple/services/kube-dns.yaml kubernetes-with-ca/services/kube-dns.yaml</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7149d1e38a3d870a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以知道，新的配置文件中去掉了<code>kube-master-url=http://&#123;&#123;MASTER_IP&#125;&#125;:8080</code>这一项，这是用于访问kube-apiserver的地址。你可能有一个疑问，不设置api-server的地址，那它是怎么知道每个服务的CLUSTER_IP和pod的ENDPOINTS的呢？这是因为Kubernetes在启动每个服务Service时，会以环境变量的方式将所有服务的ip、端口等信息注入进来。</p><h3 id="创建kube-dns"><a href="#创建kube-dns" class="headerlink" title="创建kube-dns"></a>创建kube-dns</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br><span class="line">#看看启动是否成功</span><br><span class="line">$ kubectl -n kube-system get pods</span><br></pre></td></tr></table></figure><p>如果出现如下所示的信息，则说明kube-dns已经改造成功了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE</span><br><span class="line">kube-dns-795f5f6f9c-fn5kp   3/3       Running   3          2m</span><br></pre></td></tr></table></figure><p>那么这样安全版的Kubernetes集群我们就部署完成了，接下来我们就是学习如何使用它，以及如何在里面部署我们的微服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完整集群部署&quot;&gt;&lt;a href=&quot;#完整集群部署&quot; class=&quot;headerlink&quot; title=&quot;完整集群部署&quot;&gt;&lt;/a&gt;完整集群部署&lt;/h1&gt;&lt;p&gt;本篇尝试对之前使用的基础集群进行改造和升级，使其成为一个比较完整的Kubernetes集群。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes简易环境使用</title>
    <link href="http://envyzhan.asia/2022/07/04/2022-k8s-3-simple-environemnt-use/"/>
    <id>http://envyzhan.asia/2022/07/04/2022-k8s-3-simple-environemnt-use/</id>
    <published>2022-07-04T09:55:30.000Z</published>
    <updated>2022-09-12T08:44:34.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>接下来我们开始在Kubernetes简易环境中，来练习和使用一些常用的kubectl的命令，了解这些对于后续熟练和使用kubernetes有非常大的帮助。笔者将kubectl命令安装在了主节点上，因此接下来就在主节点上执行对应的kubectl命令。</p><p>（1）使用<code>kubectl version</code>命令查看k8s的版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# ·</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.0&quot;, GitCommit:&quot;925c127ec6b946659ad0fd596fa959be43f0cc05&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-12-15T21:07:38Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.0&quot;, GitCommit:&quot;925c127ec6b946659ad0fd596fa959be43f0cc05&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-12-15T20:55:30Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure><p>（2）使用<code>kubectl get nodes</code>命令查看k8s集群中所有的节点信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get nodes</span><br><span class="line">NAME             STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.51.121   Ready     &lt;none&gt;    24m       v1.9.0</span><br><span class="line">192.168.51.123   Ready     &lt;none&gt;    24m       v1.9.0</span><br></pre></td></tr></table></figure><p>（3）使用<code>kubectl get pods</code>命令查看k8s集群中所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>（4）使用<code>kubectl --help</code>来查看所有kubectl所支持的命令及帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create         Create a resource from a file or from stdin.</span><br><span class="line">  expose         使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的Kubernetes Service</span><br><span class="line">  run            在集群中运行一个指定的镜像</span><br><span class="line">  set            为 objects 设置一个指定的特征</span><br><span class="line">  run-container  在集群中运行一个指定的镜像. This command is deprecated, use &quot;run&quot; instead</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  get            显示一个或更多 resources</span><br><span class="line">  explain        查看资源的文档</span><br><span class="line">  edit           在服务器上编辑一个资源</span><br><span class="line">  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout        Manage the rollout of a resource</span><br><span class="line">  rolling-update 完成指定的 ReplicationController 的滚动升级</span><br><span class="line">  scale          为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本数量</span><br><span class="line">  autoscale      自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate    修改 certificate 资源.</span><br><span class="line">  cluster-info   显示集群信息</span><br><span class="line">  top            Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon         标记 node 为 unschedulable</span><br><span class="line">  uncordon       标记 node 为 schedulable</span><br><span class="line">  drain          Drain node in preparation for maintenance</span><br><span class="line">  taint          更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe       显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs           输出容器在 pod 中的日志</span><br><span class="line">  attach         Attach 到一个运行中的 container</span><br><span class="line">  exec           在一个 container 中执行一个命令</span><br><span class="line">  port-forward   Forward one or more local ports to a pod</span><br><span class="line">  proxy          运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp             复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth           Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  apply          通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch          使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace        通过 filename 或者 stdin替换一个资源</span><br><span class="line">  convert        在不同的 API versions 转换配置文件</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label          更新在这个资源上的 labels</span><br><span class="line">  annotate       更新一个资源的注解</span><br><span class="line">  completion     Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  api-versions   Print the supported API versions on the server, in the form of &quot;group/version&quot;</span><br><span class="line">  config         修改 kubeconfig 文件</span><br><span class="line">  help           Help about any command</span><br><span class="line">  plugin         Runs a command-line plugin</span><br><span class="line">  version        输出 client 和 server 的版本信息</span><br></pre></td></tr></table></figure><p>接下来我们尝试通过<code>kubectl run</code>命令在k8s集群中部署一个命名为kubernetes-bootcamp的应用，Docker镜像通过<code>--image</code>指定，<code>--port</code>设置应用对外服务的端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run kubernetes-bootcamp --image=jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br></pre></td></tr></table></figure><p>然后我们查看一下所有应用的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            0           4m</span><br></pre></td></tr></table></figure><p>再来查看一下所有Pod的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-5d7f968ccb-z59rw   0/1       ContainerCreating   0          5m</span><br></pre></td></tr></table></figure><p>也可以使用如下命令查看所有pod的更多信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE       IP        NODE</span><br><span class="line">kubernetes-bootcamp-5d7f968ccb-z59rw   0/1       ContainerCreating   0          6m        &lt;none&gt;    192.168.51.123</span><br></pre></td></tr></table></figure><p>如果开发者希望删除某个deployment，此时可以使用如下命令，后面的<code>kubernetes-bootcamp</code>则是应用的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl delete deployments kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; deleted</span><br></pre></td></tr></table></figure><p>其实kubernetes对一些命令也提供了一些别名，举个例子，假设当前使用的是<code>kubectl get</code>命令，它可以显示一个或更多的resources，此时就可以使用<code>kubectl get --help</code>查看后面所跟一些命令的别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Valid resource types include: </span><br><span class="line"></span><br><span class="line">  * all  </span><br><span class="line">  * certificatesigningrequests (aka &#x27;csr&#x27;)  </span><br><span class="line">  * clusterrolebindings  </span><br><span class="line">  * clusterroles  </span><br><span class="line">  * componentstatuses (aka &#x27;cs&#x27;)  </span><br><span class="line">  * configmaps (aka &#x27;cm&#x27;)  </span><br><span class="line">  * controllerrevisions  </span><br><span class="line">  * cronjobs  </span><br><span class="line">  * customresourcedefinition (aka &#x27;crd&#x27;)  </span><br><span class="line">  * daemonsets (aka &#x27;ds&#x27;)  </span><br><span class="line">  * deployments (aka &#x27;deploy&#x27;)  </span><br><span class="line">  * endpoints (aka &#x27;ep&#x27;)  </span><br><span class="line">  * events (aka &#x27;ev&#x27;)  </span><br><span class="line">  * horizontalpodautoscalers (aka &#x27;hpa&#x27;)  </span><br><span class="line">  * ingresses (aka &#x27;ing&#x27;)  </span><br><span class="line">  * jobs  </span><br><span class="line">  * limitranges (aka &#x27;limits&#x27;)  </span><br><span class="line">  * namespaces (aka &#x27;ns&#x27;)  </span><br><span class="line">  * networkpolicies (aka &#x27;netpol&#x27;)  </span><br><span class="line">  * nodes (aka &#x27;no&#x27;)  </span><br><span class="line">  * persistentvolumeclaims (aka &#x27;pvc&#x27;)  </span><br><span class="line">  * persistentvolumes (aka &#x27;pv&#x27;)  </span><br><span class="line">  * poddisruptionbudgets (aka &#x27;pdb&#x27;)  </span><br><span class="line">  * podpreset  </span><br><span class="line">  * pods (aka &#x27;po&#x27;)  </span><br><span class="line">  * podsecuritypolicies (aka &#x27;psp&#x27;)  </span><br><span class="line">  * podtemplates  </span><br><span class="line">  * replicasets (aka &#x27;rs&#x27;)  </span><br><span class="line">  * replicationcontrollers (aka &#x27;rc&#x27;)  </span><br><span class="line">  * resourcequotas (aka &#x27;quota&#x27;)  </span><br><span class="line">  * rolebindings  </span><br><span class="line">  * roles  </span><br><span class="line">  * secrets  </span><br><span class="line">  * serviceaccounts (aka &#x27;sa&#x27;)  </span><br><span class="line">  * services (aka &#x27;svc&#x27;)  </span><br><span class="line">  * statefulsets (aka &#x27;sts&#x27;)  </span><br><span class="line">  * storageclasses (aka &#x27;sc&#x27;)</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  # List all pods in ps output format.</span><br><span class="line">  kubectl get pods</span><br><span class="line">  </span><br><span class="line">  # List all pods in ps output format with more information (such as node name).</span><br><span class="line">  kubectl get pods -o wide</span><br><span class="line">  </span><br><span class="line">  # List a single replication controller with specified NAME in ps output format.</span><br><span class="line">  kubectl get replicationcontroller web</span><br><span class="line">  </span><br><span class="line">  # List a single pod in JSON output format.</span><br><span class="line">  kubectl get -o json pod web-pod-13je7</span><br><span class="line">  </span><br><span class="line">  # List a pod identified by type and name specified in &quot;pod.yaml&quot; in JSON output format.</span><br><span class="line">  kubectl get -f pod.yaml -o json</span><br><span class="line">  </span><br><span class="line">  # Return only the phase value of the specified pod.</span><br><span class="line">  kubectl get -o template pod/web-pod-13je7 --template=&#123;&#123;.status.phase&#125;&#125;</span><br><span class="line">  </span><br><span class="line">  # List all replication controllers and services together in ps output format.</span><br><span class="line">  kubectl get rc,services</span><br><span class="line">  </span><br><span class="line">  # List one or more resources by their type and names.</span><br><span class="line">  kubectl get rc/web service/frontend pods/web-pod-13je7</span><br><span class="line">  </span><br><span class="line">  # List all resources with different types.</span><br><span class="line">  kubectl get all</span><br></pre></td></tr></table></figure><p>例如，查看所有应用的信息所使用的命令，可由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployments</span><br></pre></td></tr></table></figure><p>简化为如下的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br></pre></td></tr></table></figure><p>我们再来看一下查看所有pod的更多信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   0          22h       172.20.40.194   192.168.51.123</span><br></pre></td></tr></table></figure><p>如果想要查看k8s的日志运行信息，可以使用<code>journalctl -f</code>命令。可以使用<code>kubectl describe deploy +应用名称</code>命令来查看某个应用的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe deploy kubernetes-bootcamp</span><br><span class="line">Name:                   kubernetes-bootcamp</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 29 Aug 2022 22:30:58 +0800</span><br><span class="line">Labels:                 run=kubernetes-bootcamp</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision=1</span><br><span class="line">Selector:               run=kubernetes-bootcamp</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=kubernetes-bootcamp</span><br><span class="line">  Containers:</span><br><span class="line">   kubernetes-bootcamp:</span><br><span class="line">    Image:        jocatalin/kubernetes-bootcamp:v1</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   kubernetes-bootcamp-6b7849c495 (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  22h   deployment-controller  Scaled up replica set kubernetes-bootcamp-6b7849c495 to 1</span><br></pre></td></tr></table></figure><p>我们再来看一下查看所有pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   0          22h       172.20.40.194   192.168.51.123</span><br></pre></td></tr></table></figure><p>再来看一下这个Pod的信息，可使用<code>kubectl describe pods +pod名称</code>命令：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9b62866055a8c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>基础命令的学习就到此结束了，接下来我们继续学习其他的知识。deployment已经创建起来了，我们该如何去访问它呢？第一种方式是使用<code>kubectl proxy</code>命令 ，它会在本地监听8001端口，这个主要用于测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl proxy</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure><p>然后我们就可以通过这个REST API来访问这个集群中运行的每一个服务。可以新开一个终端，在里面先查看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d</span><br></pre></td></tr></table></figure><p>然后我们再来通过REST API访问这个pod，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/kubernetes-bootcamp-6b7849c495-mgzpp/</span><br><span class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-6b7849c495-mgzpp | v=1</span><br></pre></td></tr></table></figure><p>这样我们就成功的访问了这个服务。接着我们停掉这个<code>kubectl proxy</code>，开始学习扩缩容相关内容。首先我们查看一下当前所有的deployments信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           1d</span><br></pre></td></tr></table></figure><p>接着我们来对这个deployments进行扩缩容，设置4个副本数，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl scale deploy kubernetes-bootcamp --replicas=4</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; scaled</span><br></pre></td></tr></table></figure><p>然后我们来看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-85bvf   1/1       Running   0          3m        172.20.188.1    192.168.51.121</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ddcnq   1/1       Running   0          3m        172.20.188.2    192.168.51.121</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d        172.20.40.195   192.168.51.123</span><br><span class="line">kubernetes-bootcamp-6b7849c495-nqwdv   1/1       Running   0          3m        172.20.40.196   192.168.51.123</span><br></pre></td></tr></table></figure><p>现在4个实例都已经启动了，可以看到在121上运行了2个实例，在123上也运行了2个实例，也就是说Kubernetes会尽可能的分散资源，不会在一台机器上运行很多，而在另一台机器上运行很少。接下来我们使用同样的命令，将其缩容为2个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl scale deploy kubernetes-bootcamp --replicas=2</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; scaled</span><br></pre></td></tr></table></figure><p>之后再来查看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d        172.20.40.195   192.168.51.123</span><br><span class="line">kubernetes-bootcamp-6b7849c495-nqwdv   1/1       Running   0          10m       172.20.40.196   192.168.51.123</span><br></pre></td></tr></table></figure><p>接下来学习如何更新镜像，首先查看一下当前列表中所有的deployments信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe deployments</span><br><span class="line">Name:                   kubernetes-bootcamp</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 29 Aug 2022 22:30:58 +0800</span><br><span class="line">Labels:                 run=kubernetes-bootcamp</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision=1</span><br><span class="line">Selector:               run=kubernetes-bootcamp</span><br><span class="line">Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=kubernetes-bootcamp</span><br><span class="line">  Containers:</span><br><span class="line">   kubernetes-bootcamp:</span><br><span class="line">    Image:        jocatalin/kubernetes-bootcamp:v1</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   kubernetes-bootcamp-6b7849c495 (2/2 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  12m   deployment-controller  Scaled up replica set kubernetes-bootcamp-6b7849c495 to 4</span><br><span class="line">  Normal  ScalingReplicaSet  4m    deployment-controller  Scaled down replica set kubernetes-bootcamp-6b7849c495 to 2</span><br></pre></td></tr></table></figure><p>可以看到这个名为kubernetes-bootcamp的deployments所使用的的镜像为<code>jocatalin/kubernetes-bootcamp:v1</code>，接下来我们尝试更新这个镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl set image deploy kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; image updated</span><br></pre></td></tr></table></figure><p>注意使用这个命令的时候，默认deployment的名称和容器的名称是一样的。然后使用如下命令来查看命令的更新结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl rollout status deploy kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; successfully rolled out</span><br></pre></td></tr></table></figure><p>从执行结果中可以看出它更新成功了，然后我们继续使用<code>kubectl describe deployments</code>命令来确认已经更新成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-467c41bd5c96a94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者对某一deployment执行了错误的命令，现在想回滚到上一步的操作状态，说白了就是撤销当前的操作，可以使用<code>kubectl rollout undo deploy +deployment的名称</code>这一命令。之后可以使用<code>kubectl rollout status deploy +deployment的名称</code>这一命令来查看当前执行状态。</p><p>上面学习的都是使用命令来管理服务，但是当服务较多时，还使用命令就显得捉襟见肘了，此时就可以通过配置文件来进行管理。</p><p>回到主节点所在机器上，在<code>/home/envy</code>目录下新建一个名为services的目录，然后在这个services目录中新建一个名为<code>nginx-pod.yaml</code>文件。一般来说，我们都会使用yaml格式的文件来创建k8s服务的配置文件。<code>nginx-pod.yaml</code>文件里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers: </span><br><span class="line">    - name: nginx  </span><br><span class="line">      image: nginx:1.7.9  </span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 版本号</span><br><span class="line">apiVersion: v1</span><br><span class="line"># 类型</span><br><span class="line">kind: Pod</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  containers: # 容器</span><br><span class="line">    - name: nginx  # 容器名称</span><br><span class="line">      image: nginx:1.7.9  # 容器所使用的镜像版本信息</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80  # 容器端口</span><br></pre></td></tr></table></figure><p>然后我们尝试使用<code>kubectl create</code>命令从指定文件或者输入中创建一个资源，当然这里就是从<code>nginx-pod.yaml</code>配置文件中来创建一个名为nginx的Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure><p>然后我们来看一下这个Pod的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  0/1       ImagePullBackOff   0          1m</span><br></pre></td></tr></table></figure><p>我们再来看一下deployment，可以发现不存在新的deployment，这是因为我们创建的是一个Pod，一个Pod就是一个Pod，这个和deployment没有任何关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           1d</span><br></pre></td></tr></table></figure><p>但是当我们使用<code>kubectl run</code>命令时，它会创建一个deployment，而不只是仅仅创建一个Pod而已。</p><p>再来看一下当前所有的Pods，可以看到我们前面创建的Pods已经创建完成并启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  1/1       Running            0          1m</span><br></pre></td></tr></table></figure><p>现在问题来了，我们该如何去访问这个nginx呢？还是采用之前的方式，在当前窗口执行<code>kubectl proxy</code>命令，然后新开一个终端执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/nginx/</span><br></pre></td></tr></table></figure><p>接下来我们尝试创建一个nginx的deployment，在<code>/home/envy/services</code>目录中新建一个名为<code>nginx-deployment.yaml</code>的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 版本号，注意固定格式</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line"># 类型</span><br><span class="line">kind: Deployment</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2  # 两个副本</span><br><span class="line">  template:  # 模板信息</span><br><span class="line">    metadata:  #模板元数据</span><br><span class="line">      labels: # 标签</span><br><span class="line">        app: nginx</span><br><span class="line">    spec: # 比较特别的配置</span><br><span class="line">      containers: # 容器</span><br><span class="line">      - name: nginx  # 容器名称</span><br><span class="line">        image: nginx:1.7.9  # 容器所使用的镜像版本信息</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80  # 容器端口</span><br></pre></td></tr></table></figure><p>之后我们继续使用之前的命令来创建一个deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-deployment.yaml </span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br></pre></td></tr></table></figure><p>然后我们查看一下当前所有的deployments，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           1d</span><br><span class="line">nginx-deployment      2         2         2            1           1m</span><br></pre></td></tr></table></figure><p>可以看到这个<code>nginx-deployment</code>目前只有一个，因为它正在去另一个服务器上下载，目前只有一个节点下载了这个镜像。然后我们还可以查看一下所有的pods:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  1/1       Running            0          31m</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c      0/1       ImagePullBackOff   0          3m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh      1/1       Running            0          3m</span><br></pre></td></tr></table></figure><p>这里主要关心以<code>nginx-deployment</code>开头的两个deployment，可以看到一个正在运行，另一个正在拉取镜像。我们还可以使用如下命令来查看指定标签的Pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods -l app=nginx</span><br><span class="line">NAME                                READY     STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c   0/1       ImagePullBackOff   0          5m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh   1/1       Running            0          5m</span><br></pre></td></tr></table></figure><p>可以看到这里就只是查看以app=nginx为标签的pods的信息，service的原理其实也是根据这个label（标签）来筛选出它所想要服务的Pod，然后实现一个负载均衡。</p><p>最后可以看到这两个以app=nginx为标签的pods已经成功启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods -l app=nginx</span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c   1/1       Running   0          10m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh   1/1       Running   0          10m</span><br></pre></td></tr></table></figure><p>接下来我们尝试在这基础的集群之上，再给它添加两个功能，也就是kube-proxy和kube-dns。当开发者需要给集群增加service功能，此时就需要增加kube-proxy组件；当需要dns，通过名称解析服务这样的功能，此时就可以增加kube-dns组件。k8s会把一些不必要的功能做成一个组件，这样有效的降低了各个组件之间的耦合程度。</p><h1 id="给集群增加service功能–kube-proxy（工作节点执行）"><a href="#给集群增加service功能–kube-proxy（工作节点执行）" class="headerlink" title="给集群增加service功能–kube-proxy（工作节点执行）"></a>给集群增加service功能–kube-proxy（工作节点执行）</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每台工作节点上都应该运行一个kube-proxy服务，它负责监听APIServer中service和endpoint的变化，并通过iptables等来为服务配置负载均衡，是让服务在集群外可以被访问到的重要方式。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>kube-proxy的部署方式也是通过系统服务，部署流程跟etcd完全一样，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 确保工作目录存在</span><br><span class="line">$ mkdir -p /var/lib/kube-proxy</span><br><span class="line">#复制kube-proxy服务配置文件到系统服务目录</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.service /lib/systemd/system/</span><br><span class="line">#复制kube-proxy依赖的配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.kubeconfig /etc/kubernetes/</span><br><span class="line">#enable服务</span><br><span class="line">$ systemctl enable kube-proxy.service</span><br><span class="line"># 启动服务</span><br><span class="line">$ service kube-proxy start</span><br><span class="line"># 查看服务日志，看是否有错误信息，确保服务正常</span><br><span class="line">$ journalctl -f -u kube-proxy.service</span><br></pre></td></tr></table></figure><p>然后我们查看一下监听的端口号，看到10249和10256端口都是正常启动的，说明配置是成功的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br></pre></td></tr></table></figure><p>接下来我们看一下这个<code>kube-proxy.service</code>文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kube-Proxy Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kube-proxy</span><br><span class="line">ExecStart=/home/envy/bin/kube-proxy \</span><br><span class="line">  --bind-address=192.168.51.121 \</span><br><span class="line">  --hostname-override=192.168.51.121 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \</span><br><span class="line">  --logtostderr=true \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>这里主要关注Service部分，其中WorkingDirectory是kube-proxy的工作目录，ExecStart是启动的命令，<code>/home/envy/bin/kube-proxy</code>则是需要启动的程序名称，通过<code>--bind-address</code>参数来设置监听的地址，<code>kubeconfig</code>则是它所依赖的配置文件，描述了kube-proxy如何访问api-server。</p><p>下面是<code>kube-proxy.kubeconfig</code>配置文件的内容，它配置了kube-proxy如何访问api-server，内容与kubelet雷同，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    server: http://192.168.51.122:8080</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">  name: default</span><br><span class="line">current-context: default</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users: []</span><br></pre></td></tr></table></figure><p>这样我们就给集群添加了kube-proxy，那么问题来了，我们该如何使用它呢？往下看，回到主节点，首先使用如下命令来查看所有的服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get services</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.68.0.1    &lt;none&gt;        443/TCP   3d</span><br></pre></td></tr></table></figure><p>注意这个服务是APIServer在启动的时候就默认创建的服务，它的作用是什么呢？我们先看一下它有什么东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl describe service kubernetes</span><br><span class="line">Name:              kubernetes</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            component=apiserver</span><br><span class="line">                   provider=kubernetes</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          &lt;none&gt;</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.68.0.1</span><br><span class="line">Port:              https  443/TCP</span><br><span class="line">TargetPort:        6443/TCP</span><br><span class="line">Endpoints:         192.168.51.122:6443</span><br><span class="line">Session Affinity:  ClientIP</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><p>可以看到它的Type是ClusterIP，而且IP地址为10.68.0.1，相当于给APIServer做成了一个服务，它有什么作用呢？第一，集群内其他的组件可通过这个IP来访问到APIServer，这样它就不需要依赖于具体的IP地址；第二，负载均衡，它可以用来负责APIServer这一组件的高可用，当然前提是我们有多个APIServer实例的时候，然后他就可以通过这个Server IP来实现负载均衡，并且会自动过滤掉不可用的节点，进而实现APIServer的高可用。</p><p>其实我们自己也可以创建service，首先查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           2d</span><br><span class="line">nginx-deployment      2         2         2            2           23h</span><br></pre></td></tr></table></figure><p>可以看到这里有两个deployments，之前我们访问这两个deployments的时候，使用的都是代理的方式，即<code>kubectl proxy</code>，开一个HTTP的EndPoint，然后通过这个EndPoint的地址去访问这个Pod。接下来我们看看kube-proxy如何给我们带来方便，让我们如何访问这个Pod。可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl expose deploy kubernetes-bootcamp --type=&quot;NodePort&quot; --target-port=8080 --port=80</span><br><span class="line">service &quot;kubernetes-bootcamp&quot; exposed</span><br></pre></td></tr></table></figure><p>该命令说明为<code>kubectl expose deploy deployment名称 --type=&quot;NodePort&quot; --target-port=容器端口 --port=Service端口</code>，接着我们再次使用之前的命令来获取当前所有的service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get services</span><br><span class="line">NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes            ClusterIP   10.68.0.1     &lt;none&gt;        443/TCP        3d</span><br><span class="line">kubernetes-bootcamp   NodePort    10.68.37.19   &lt;none&gt;        80:30735/TCP   1m</span><br></pre></td></tr></table></figure><p>可以看到这里多了一个service，它的类型为NodePort，所分配的IP地址为10.68.37.19，注意这里的端口映射，将80端口映射到30735，这个30735是随机的端口号，查看一下这个30735端口是否为监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# netstat -ntlp|grep 30735</span><br><span class="line">[root@server02 ~]#</span><br></pre></td></tr></table></figure><p>可以看到这个30735不是监听端口，但是这个端口应该是监听端口才是，为什么这里没有监听呢？是因为当前节点是master节点，而不是工作节点，它并没有kube-proxy。我们去另一台机器，如123机器，反正只要是工作节点就可以，之后查看 一下这台机器上的30735端口是否为监听端口，可以看到它确实是监听者。</p><p>这个30735是随机的端口号，也就是kube-proxy实际在节点上启动的一个端口，可以通过这个端口来访问我们的服务。上述命令中的<code>target-port</code>则是当前容器，也就是Pod它真正提供服务的端口，也就是说这个容器实际上监听的端口是8080。port则是我们在这个CLUSTER-IP虚拟IP上去访问这个服务的时候需要提供的端口，这里提供的则是80端口。也就是说此时我们可以通过Service的CLUSTER-IP加上80服务端口，或者是通过NodeIP+NodePort去访问这个服务，这是两种方式。</p><p>接下来我们看一下当前所有的Pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-x7bft   1/1       Running   0          55m       172.20.188.12   192.168.51.121</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running   2          2d        172.20.188.10   192.168.51.121</span><br><span class="line">nginx                                  1/1       Running   2          1d        172.20.188.9    192.168.51.121</span><br><span class="line">nginx-deployment-6c54bd5869-chjwn      1/1       Running   0          55m       172.20.188.13   192.168.51.121</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh      1/1       Running   2          1d        172.20.188.11   192.168.51.121</span><br></pre></td></tr></table></figure><p>从原理上来说，上述pod列表中的任意一个pod所包含的容器，都是可以访问到CLUSTER-IP，并且它们之间也都是可以互相连通的，这是Kubernetes在设计上所做的要求，前提是我们的环境是正常的。此处以192.168.51.121节点上容器为例，我们查看其中包含bootcamp的容器，可以看到它有多个，选择一个id为0b4380c9fb67的容器，并进入到该容器，直接访问CLUSTER-IP加上80端口，可以看到它是可以访问这个服务的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server01 ~]# docker exec -it 0b4380c9fb67 bash</span><br><span class="line">root@kubernetes-bootcamp-7689dc585d-x7bft:/# curl 10.68.37.19:80</span><br></pre></td></tr></table></figure><p>同样的我们可以在这个容器中尝试看一下是否可以连通其他的Pod，可以选择之前的nginx，它的IP地址为172.20.188.9，可以看到访问结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9893a47bc2d0287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>回到主节点，在前面我们创建的服务，它的NodePort是随机的，也就是前面多次提到的30735，我们希望将这个端口给固定下来，即我们给它指定一个NodePort，这也是可以的，但是需要我们通过配置文件的方式来进行设置。</p><p>截止到目前，<code>/home/envy/services</code>目录下已经有两个配置文件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# ls</span><br><span class="line">nginx-deployment.yaml  nginx-pod.yaml</span><br></pre></td></tr></table></figure><p>接下来我们创建一个新的配置文件，名为<code>nginx-service.yaml</code>，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 20000</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 版本号，注意固定格式</span><br><span class="line">apiVersion: v1</span><br><span class="line"># 类型</span><br><span class="line">kind: Service</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  ports: # 端口</span><br><span class="line">  - port: 8080  # Service端口（即CLUSTRER_IP所对应的端口）</span><br><span class="line">    targetPort: 80  # 容器端口（即具体的Nginx服务所对应的端口）</span><br><span class="line">    nodePort: 20000 # 节点端口（即能对节点外部提供服务的端口）</span><br><span class="line">  selector: # 给谁提供这样的服务，需要指定具体的Pod</span><br><span class="line">    app: nginx # 通过app=nginx进行指定</span><br><span class="line">  type: NodePort # 类型，默认的类型是CLUSTRER_IP，此处使用NodePort</span><br></pre></td></tr></table></figure><p>之后我们继续使用之前的命令来创建一个service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-service.yaml </span><br><span class="line">service &quot;nginx-service&quot; created</span><br></pre></td></tr></table></figure><p>然后我们再来查看当前所有的service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get services</span><br><span class="line">NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes            ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          5d</span><br><span class="line">kubernetes-bootcamp   NodePort    10.68.37.19    &lt;none&gt;        80:30735/TCP     1d</span><br><span class="line">nginx-service         NodePort    10.68.235.19   &lt;none&gt;        8080:20000/TCP   1m</span><br></pre></td></tr></table></figure><p>可以看到这里多了一个名为nginx-service的service，而且类型为NodePort，它也有一个CLUSTER-IP，重要的是它的端口映射为8080:20000，即8080为服务的端口，而20000则是节点的端口。然后我们尝试在主节点，使用<code>192.168.51.121:2000</code>来访问121工作节点的nginx服务，可以看到可以访问成功了。同理也可以使用<code>192.168.51.123:2000</code>来访问123工作节点的nginx服务，这也是可以的。通过命令和配置文件方式创建出来的service都是一样的，没有任何区别，只是Kubernetes给我们提供了不同的操作方式而已。</p><h1 id="给集群增加dns功能–kube-dns（以app方式启动）"><a href="#给集群增加dns功能–kube-dns（以app方式启动）" class="headerlink" title="给集群增加dns功能–kube-dns（以app方式启动）"></a>给集群增加dns功能–kube-dns（以app方式启动）</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>kube-dns为Kubernetes集群提供命名服务，主要用于解析集群服务名和Pod的hostname，目的是让pod可以通过名字访问到集群内的服务。它通过添加A记录的方式实现名字和service的解析，其中普通的service会解析到service-ip，而headless的service则会解析到pod列表，并且实现负载均衡。</p><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>kube-dns则是通过Kubernetes应用的方式进行部署，其中我们之前生成的target文件里面<code>kube-dns.yaml</code>的配置文件与官方基本上一致，除了镜像名称不同而已。</p><p>kube-dns这个服务比较特殊的一点在于它的namespace为kube-system，而不是main这个空间中。这个服务所涉及到的东西比较多，如果我们手动创建它的配置文件，这其实是很难的，一般做法是直接使用官方提供的文件，然后在里面根据实际情况进行配置，多个组件之间使用<code>---</code>进行区分。</p><p>查看一下这个<code>/home/envy/kubernetes-starter/target/services/kube-dns.yaml</code>配置文件中的信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">#ConfigMap是我们见到的一个新类型，顾名思义是做配置管理的，这里用作kube-dns配置存储</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: EnsureExists</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#认证授权使用，这里未用到</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#dns服务</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">    kubernetes.io/name: &quot;KubeDNS&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    #选择器，一个服务包含了哪些pods</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">  #服务的clusterip，需要跟kubelet保持一致</span><br><span class="line">  clusterIP: 10.68.0.2</span><br><span class="line">  ports:</span><br><span class="line">  - name: dns</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: UDP</span><br><span class="line">  - name: dns-tcp</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#具体的pod定义，包含了三个容器</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">spec:</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 10%</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kube-dns</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kube-dns</span><br><span class="line">      annotations:</span><br><span class="line">        scheduler.alpha.kubernetes.io/critical-pod: &#x27;&#x27;</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;CriticalAddonsOnly&quot;</span><br><span class="line">        operator: &quot;Exists&quot;</span><br><span class="line">      volumes:</span><br><span class="line">      - name: kube-dns-config</span><br><span class="line">        configMap:</span><br><span class="line">          name: kube-dns</span><br><span class="line">          optional: true</span><br><span class="line">      containers:</span><br><span class="line">      #实现dns解析功能</span><br><span class="line">      - name: kubedns</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-kube-dns-amd64:1.14.5</span><br><span class="line">        resources:</span><br><span class="line">          # TODO: Set memory limits when we&#x27;ve profiled the container for large</span><br><span class="line">          # clusters, then set request = limit to keep this container in</span><br><span class="line">          # guaranteed class. Currently, this container falls into the</span><br><span class="line">          # &quot;burstable&quot; category so the kubelet doesn&#x27;t backoff from restarting it.</span><br><span class="line">          limits:</span><br><span class="line">            memory: 170Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 70Mi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/kubedns</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /readiness</span><br><span class="line">            port: 8081</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          # we poll on pod startup for the Kubernetes master service and</span><br><span class="line">          # only setup the /readiness HTTP server once that&#x27;s available.</span><br><span class="line">          initialDelaySeconds: 3</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        args:</span><br><span class="line">        - --domain=cluster.local.</span><br><span class="line">        - --dns-port=10053</span><br><span class="line">        - --config-dir=/kube-dns-config</span><br><span class="line">        #访问kube-apiserver的地址</span><br><span class="line">        - --kube-master-url=http://192.168.51.122:8080</span><br><span class="line">        - --v=2</span><br><span class="line">        env:</span><br><span class="line">        - name: PROMETHEUS_PORT</span><br><span class="line">          value: &quot;10055&quot;</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-local</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-tcp-local</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 10055</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kube-dns-config</span><br><span class="line">          mountPath: /kube-dns-config</span><br><span class="line">      #dnsmasq类似一个dns缓存，用于提高访问效率</span><br><span class="line">      - name: dnsmasq</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-dnsmasq-nanny-amd64:1.14.5</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/dnsmasq</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        args:</span><br><span class="line">        - -v=2</span><br><span class="line">        - -logtostderr</span><br><span class="line">        - -configDir=/etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">        - -restartDnsmasq=true</span><br><span class="line">        - --</span><br><span class="line">        - -k</span><br><span class="line">        - --cache-size=1000</span><br><span class="line">        - --log-facility=-</span><br><span class="line">        - --server=/cluster.local./127.0.0.1#10053</span><br><span class="line">        - --server=/in-addr.arpa/127.0.0.1#10053</span><br><span class="line">        - --server=/ip6.arpa/127.0.0.1#10053</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns-tcp</span><br><span class="line">          protocol: TCP</span><br><span class="line">        # see: https://github.com/kubernetes/kubernetes/issues/29055 for details</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 150m</span><br><span class="line">            memory: 20Mi</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kube-dns-config</span><br><span class="line">          mountPath: /etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">      #sidecar是一个监控功能，负责监控另外两个容器的运行</span><br><span class="line">      - name: sidecar</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-sidecar-amd64:1.14.5</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /metrics</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        args:</span><br><span class="line">        - --v=2</span><br><span class="line">        - --logtostderr</span><br><span class="line">        - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local.,5,A</span><br><span class="line">        - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local.,5,A</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10054</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            memory: 20Mi</span><br><span class="line">            cpu: 10m</span><br><span class="line">      dnsPolicy: Default  # Don&#x27;t use cluster DNS.</span><br><span class="line">      serviceAccountName: kube-dns</span><br></pre></td></tr></table></figure><p>之后执行如下命令即可启动kube-dns服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br></pre></td></tr></table></figure><p>可以看到输出信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br><span class="line">configmap &quot;kube-dns&quot; created</span><br><span class="line">serviceaccount &quot;kube-dns&quot; created</span><br><span class="line">service &quot;kube-dns&quot; created</span><br><span class="line">deployment &quot;kube-dns&quot; created</span><br></pre></td></tr></table></figure><p>configMap用于配置管理，serviceaccount也是一种类型，主要用于Kubernetes的认证与授权，这里未使用到。</p><p>然后我们就可以使用如下命令来查看这个名为kube-system的namespace中的服务信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl -n kube-system get svc</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns   ClusterIP   10.68.0.2    &lt;none&gt;        53/UDP,53/TCP   3m</span><br></pre></td></tr></table></figure><p>可以看到这里面有一个CLUSTER-IP，这个就是之前我们在创建kubelet的时候所配置的地址，这样在使用kube-dns的时候它就会自动生效。注意我们在kube-dns的yaml配置文件中也需要配置一个与它完全一样的地址。</p><p>再来看一下这个名为kube-system的namespace中的deployment信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get deploy </span><br><span class="line">NAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kube-dns   1         1         1            1           9h</span><br></pre></td></tr></table></figure><p>然后看一下这个名为kube-system的namespace中的pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE</span><br><span class="line">kube-dns-7d7b4f767d-6xnnm   3/3       Running   3          9h</span><br></pre></td></tr></table></figure><p>可以看到这个Pod中运行了三个容器，它们都是Running状态，接下来我们看一下这些容器运行在哪些机器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods -o wide</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kube-dns-7d7b4f767d-6xnnm   3/3       Running   3          9h        172.20.40.202   192.168.51.123</span><br></pre></td></tr></table></figure><p>可以看到它们都运行在192.168.51.123这台机器上，接下来我们我们先查看这个192.168.51.123机器上运行的容器，然后进入到某一容器中，使用<code>curl nginx-service:8080</code>来访问之前创建的名为nginx-service的service。可以看到它是可以访问的，这就说明dns确实给我们提供了解析的功能，通过名字解析到了对应的CLUSTER-IP。也就是说其实它最终访问的还是<code>CLUSTER-IP:SERVICED_PORT</code>。然后我们还可以查看当前容器的dns配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kubernetes-bootcamp-7689dc585d-x7bft:/# cat /etc/resolv.conf </span><br><span class="line">nameserver 10.68.0.2</span><br><span class="line">search default.svc.cluster.local. svc.cluster.local. cluster.local.</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure><p>可以看到它第一个nameserver的值就是10.68.0.2，实际上就是通过这个值来解析的，这也可以证实为什么我们通过名字就可以映射到CLUSTER-IP。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;接下来我们开始在Kubernetes简易环境中，来练习和使用一些常用的kubectl的命令，了解这些对于后续熟练和使用kub</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes基础知识</title>
    <link href="http://envyzhan.asia/2022/06/28/2022-k8s-1-basic-knowledge/"/>
    <id>http://envyzhan.asia/2022/06/28/2022-k8s-1-basic-knowledge/</id>
    <published>2022-06-28T09:55:30.000Z</published>
    <updated>2022-09-12T08:40:06.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><p>Kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理，用于管理云平台中多个主机上的容器化的应用。Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h1 id="Kubernetes集群"><a href="#Kubernetes集群" class="headerlink" title="Kubernetes集群"></a>Kubernetes集群</h1><p><a href="https://kubernetes.io/zh-cn/">Kubernetes</a> 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。一个Kubernetes集群包含两种类型的资源：Master（调度整个集群）和Nodes（负责运行应用）。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8332cf68b444bf54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Master调度整个集群"><a href="#Master调度整个集群" class="headerlink" title="Master调度整个集群"></a>Master调度整个集群</h3><p>Master协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><h3 id="Nodes负责运行应用"><a href="#Nodes负责运行应用" class="headerlink" title="Nodes负责运行应用"></a>Nodes负责运行应用</h3><p>Node是一个虚拟机或者物理机，它在Kubernetes集群中充当工作机器的角色。每个Node都有Kubelet，它管理Node，而且是Node与Master通信的代理。 Node还具有用于处理容器操作的工具，如Docker或rkt。</p><p>请注意生产级别的Kubernetes集群至少包含三个Node，因为如果一个Node出现故障，那么其对应的etcd成员和控制平面节点都会丢失，并且冗余会受到影响。当然了，开发者可以通过添加更多控制平面节点方式来降低这种风险 。</p><p>在Kubernetes上部署应用时，需要告诉Master来启动应用容器，之后Master就会编排容器在集群的Node上运行。 Node使用Master暴露的Kubernetes API与Master通信。当然了，终端用户也可以使用Kubernetes API与集群进行交互。</p><p>Kubernetes既可以部署在物理机上，也可以部署在虚拟机上。开发者可以使用Minikube开始部署Kubernetes集群。 Minikube是一种轻量级的Kubernetes实现，可在本地计算机上创建VM并部署仅包含一个节点的简单集群。Minikube可用于Linux，macOS和Windows系统。Minikube CLI提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Kubernetes应用部署"><a href="#Kubernetes应用部署" class="headerlink" title="Kubernetes应用部署"></a>Kubernetes应用部署</h1><p>一旦运行了Kubernetes集群，就可以在其上部署容器化应用程序。 为此，你需要创建Kubernetes Deployment配置。Deployment指挥Kubernetes如何创建和更新应用程序的实例。创建Deployment后，Kubernetes master将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则Deployment控制器会将该实例替换为集群中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。</p><p>在没有Kubernetes这种编排系统之前，启动应用程序通常会采取安装脚本这一方式，但它们不允许从机器故障中恢复。Kubernetes Deployments提供了一种与众不同的应用程序管理方法，通过创建应用程序实例并使它们在节点之间运行。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-86d72371396d79dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>你可以使用Kubernetes命令行界面 <strong>Kubectl</strong> 创建和管理Deployment。Kubectl使用Kubernetes API 与集群进行交互。创建Deployment 时，你需要指定应用程序的容器镜像以及要运行的副本数。你可以稍后通过更新Deployment来更改该信息。</p><h1 id="Kubernetes中的概念"><a href="#Kubernetes中的概念" class="headerlink" title="Kubernetes中的概念"></a>Kubernetes中的概念</h1><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes处理的最基本单元，容器本身不会直接分配到主机上，而是会封装到名为Pod的对象中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a020c6f11413799f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图中Pod1里面有一个应用容器，且该Pod有一个独立的IP地址。Pod2里面有一个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。</p><p>Pod3里面有两个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。也就是说这个Pod中的两个应用容器是可以共享IP与磁盘。</p><p>Pod4里面有多个应用容器和磁盘，该Pod也有一个独立的IP地址。也就是说同一个Pod中可以有任意多个应用容器（多个容器间网络共享）和磁盘（多个共享目录）。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Pod是运行在Node上的，kubelet负责调度Pod的运行。只要资源足够，一个Node上可以有任意多个Pod。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3b6cc5f1a8669401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>粗蓝线框的节点是Master节点，其他的都是Node节点。看一下左下角的Node节点，里面运行了一个Pod，然后这个Pod的外面有一层黄色的虚线，这层虚线就是Service。这个Pod有一个IP，地址是10.10.10.1，这个Service也有一个IP，地址是10.10.9.1，可以看到Service和Pod的IP是不一样的。现在有个问题，为什么Pod有了IP，而外面还包一层Service，同时它也有独立的IP呢？</p><p>原因在于Pod是运行在具体的一个Node上，可能在某些场景下这个Pod出了问题（不稳定挂掉了或者服务容器异常退出，甚至整个Node挂掉了），这样的话这个Node就挂掉了，服务就无法访问了。那可能会去其他的位置重新启动一个Node，运行Pod，此时Pod的IP地址肯定变化了，因此就需要一个Service。当我们的Pod出了问题，它的IP地址发生了变化，此时我们还可以通过Service的IP来找到这个Pod。注意Service的IP与其生命周期是对应的，只要这个Service没有被删除，那么Service的IP就会一直存在，并且永远不会发生变化。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看上面两个Node，左侧Node中只有一个Pod，而右侧Node中有两个Pod，一共三个Pod。在多个Pod的情况下，一般都是同一个应用的多个副本，也就是对同一个应用进行扩容，由1个实例变成3个实例，然后它们对外会提供相同的服务。此时这个Service的IP除了可以向上面那样，定位到Pod的地址之外，还有另外一个作用，即对多个Pod的地址进行负载均衡。举个例子，如轮询访问每个Pod。当然了这个Pod不一定是一模一样的，也可以是同一应用的不同版本。比如我在进行灰度发布的时候，一个可能是旧版本，一个可能是新版本，这都是可以的。所以说Kubernetes并没有对Pod本身做任何限制，那怕是完全不同的应用，你也可以将其作为一个Service去管理。只是一般情况下，我们都不会这么做。</p><p>Service的概念我们已经知道了，那么Kubernetes是如何确定哪些Pod属于同一个Service呢？Kubernetes使用Label Selector来进行确定。当我们定义一个Service的时候，可以给它指定一个标签，如<code>s:app=B</code>，有这样一对标签的时候，就可以认为它属于ServiceB。之后它会去搜索所有的Pod，发现上面三个Pod都携带有<code>app=B</code>标签，那么这三个Pod就会自动归属于这个ServiceB。这就让Service和Pod之间的耦合变得很松，非常灵活。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a426db0b2191d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来梳理几个概念，首先是Pod，Pod里面可以运行多个容器，Service里面可以包含多个Pod，然后Development就比较宽泛，可以是部署Pod，也可以是部署Service。</p><p>接下来看一下通过Development来完成应用的扩容过程：首先从Master节点发起了一个Development，向给这个Service里面的Pod扩容成4个实例，而目前就只有一个实例。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1261d3c9878ba39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>扩容的目标对象是Pod，Pod才是一个真实存在的东西，才有扩容和缩容的概念，而Service是没有的，Service只是一个逻辑上存在的东西。它只是通过Label Selector将一组Pod划分为一个逻辑组，从而实现它们的负载均衡而已。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a2783b07670d2b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后就扩容完成了，在其他的两个节点上，也有了运行的Pod，一共是4个实例。然后这个Service就自动将新的Pod包含进来，那么问题来了，它是如何知道这些新的Pod呢？肯定是通过标签，既然是扩容，那么新Pod的标签和原来的Pod的标签是一样的，然后它通过标签选择，将新的Pod都选择上，接着Service就可以对外进行负载均衡，将流量转发给每个Pod。当某个Pod出问题的时候，Service会通过某种机制，不会将流量转发给出现问题的Pod上。</p><p>接下来看一下滚动更新的过程：首先停掉了一个旧的Pod，然后又新启动了一个Pod，此时这个Service中就同时有旧的版本和新的版本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7d06f1f15b9f0fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着又停掉了最下面那个Pod，又启动了一个新的Pod：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a7c59cbcfcb569e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如此进行，直到所有旧的Pod都更新完成，滚动更新就结束了。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-29af65060a479877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在所有的更新和扩容的过程，这个Service的IP都是始终保持不变的，以上就是Kubernetes中的核心概念。</p><h1 id="Kubernetes整体架构"><a href="#Kubernetes整体架构" class="headerlink" title="Kubernetes整体架构"></a>Kubernetes整体架构</h1><p>接下来我们看一下Kubernetes的整体架构，下面这张图初看可能觉得非常乱：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ad6ac17a412e734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先上面这一块是Master节点，然后下面两块分别都是Node节点。Master节点中部署的都是Kubernetes的核心模块，中间的虚线框表示APIServer，它提供了资源操作的唯一入口，并且提供认证、授权和Kubernetes的访问控制。开发者可以通过kuberctl或者自己开发的客户端通过HTTP请求以RESTful API的形式来访问这个APIServer，进而实现对整个集群的控制。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cbcd7e364e6f1a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>ControllerManager负责维护集群的状态，如故障检测、扩缩容、滚动更新等。Scheduler负责资源的调度，它会按照预定的调度策略，将Pod调度给相应的Node节点。前面学习的Mesos和Docker Swarm也都有调度模块，也有非常多的调度策略可以选择，而Kubernetes则有更加丰富的调度策略，关于这一块后面会详细进行介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec9354017f73b5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>右上角还有一个ETCD，主要用作于一致性存储，保存了Pod，Service，还有集群的一些状态等信息，其实就相当于所有的这些Kubernetes集群需要持久化的数据都会存储到这个ETCD中。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-101e46cba059c589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在这个Master节点中还运行了一个kube-dns组件，它负责整个集群的DNS服务，注意这个组件不是必须的。不过一般我们都选择安装它，因为通过名字访问是一个非常重要的功能。右侧还有一个名为dashboard的组件，它提供了集群数据管理的可视化界面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-999fad975491287c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下Node节点。从上图中可以看到，每个Node节点中都有一个Kubelet，Kubelet负责维护当前节点上的容器的生命周期，也负责维护当前节点的网络等。在每个Node节点上都运行一个kube-proxy，kube-proxy负责Service，负责提供内部的服务发现和负载均衡，相当于为Service这个概念提供了一个落地的方法。</p><p>接下来看一下一个Pod Developed全过程：首先用户执行kubectl，向APIServer发起一个命令，然后请求经过认证之后，再由Schedluer的各种策略来评分计算，得到一个目标的Node，然后告诉APIServer。</p><p>APIServer就会请求相关Node的kubelet，然后通过这个kubelet将这个Pod运行起来，同时APIServer会将这个Pod的信息存储到ETCD中。当Pod运行起来之后，这个ControllerManager就会负责管理这个Pod的状态。举个例子，假设这个Pod不小心挂了，那么ControllerManager就会重新创建一个一样的Pod，Pod的扩缩容也是由这个ControllerManager来管理的。此时这个Pod有一个独立的IP地址，我们可以在整个集群内使用这个IP来访问它。但是这个Pod的IP是容易发生变化，比如异常重启、服务升级时IP就变化了。再有一个就是当存在多个实例的时候，我们也不可能实时的去关注这些Pod的IP，并访问它们，于是就有了Service。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9e6b98c295d73335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>图中绿色虚线内有三个Pod，它们同属一一个Service，不再此绿色虚线内的Pod则是单独存在的，并没有提供Service的入口。而具体完成Service工作的则是kube-proxy模块，可以看到在每个Node上都有一个kube-proxy。在任何一个节点上访问这个Service的虚拟IP（即给Service分配的IP）都可以访问到这三个Pod，因此这两个节点对这一个Service都会有一个IP的指向，负载均衡的访问它们。Service的IP虽然在集群内部是可以访问得到，但是在这个集群之外呢？我们是想要在集群外的服务，访问集群内的一个服务，此时应该怎么办？这一点kube-proxy也考虑到了，它可以将服务端口直接暴露在当前的Node上，然后外面的请求直接访问Node上的一个IP就可以关联到这个Service了。</p><p>我们在学习Docker Swarm的时候，知道在容器中可以通过名字来访问其他的容器，Kubernetes也是可以的，这就是kube-dns所做的工作，它提供了整个集群的dns服务，让每个Pod都可以通过名字来访问对方。也就是说，任何一个Pod都可以通过名字来访问另一个Pod。</p><h1 id="Kubernetes-Scheduler调度策略"><a href="#Kubernetes-Scheduler调度策略" class="headerlink" title="Kubernetes Scheduler调度策略"></a>Kubernetes Scheduler调度策略</h1><p>Scheduler用于决定每个Pod应该调度到哪个节点上，Kubernetes的分配方式有两种：预选规则（preselect）和优选规则（optimize-select）。</p><p>【预选规则】预选规则（preselect）这里介绍五个比较重要的规则：NodiskConflict、CheckNodeMemoryPressure、NodeSelector、FitResource和Affinity。<br>（1）NodiskConflict，即看看有没有挂载的冲突。如果一个Pod需要一个挂载，然后在这台机器上，这个挂载已经被其他Pod占用的话，这就是挂载冲突，它不会让挂载冲突这件事情发生。<br>（2）CheckNodeMemoryPressure，即检查当前节点的内存压力，所有内存压力为0的节点可以调度，当然了还存在对磁盘的检查等等。<br>（3）NodeSelector，即选择指定hostname或者具有某些标签的节点，这是非常基础的，所有的服务编排框架都有这样的功能。<br>（4）FitResource，这也是非常基础的，Node需要满足Pod的CPU、内存、GPU等资源的要求。<br>（5）Affinity，亲和性，这个逻辑比较复杂，它可以满足很多需求，如一个Pod必须与另一个Pod运行在一起，一个Pod最好与另一个Pod运行在一起，这是两种描述，它都可以实现。既然有亲和性，那么就有反亲和性，即一个Pod不能与另一个Pod运行在一起，一个Pod最好不要与另一个Pod运行在一起。</p><p>【优选规则】优选规则（optimize-select）是指通过预选规则选出来一系列的Node之后，对这些Node进行打分。Kubernetes会使用一组优先级函数去处理每一个待选的Node，每一个优先级函数会返回一个0-10的分数，分数越高表示这台机器越好，越适合，同时每个函数也会对应一个权重，最终选择一个分值最高的机器来部署Pod。</p><p>这里介绍三个比较重要的规则：SelectorSpreadPriority、LeastRequestedPriority和AffinityPriority。</p><p>（1）SelectorSpreadPriority。对于同一个Service或者Controller的Pod，尽量会分布在不同的机器上，如果指定了区域，则会尽量将Pod分散在不同区域的不同主机上。<br>（2）LeastRequestedPriority。如果一个新的Pod需要分配节点，那么这个节点的优先级就由节点空闲的那部分容量的比值来决定。其实就是使用节点上Pod的总容量减去新的Pod的容量得到的值再除以总容量。也就是说当这个Pod运行在这个节点上之后，当前节点还存在多少空闲，如果空闲越高则分数越大。<br>（3）AffinityPriority，调度综合亲和性机制。Node Selector在调度的时候将Pod限定在某些节点上的时候，它是支持多种操作符的，如in、not in、exists、gt/lt等，它不会去限定对Label的精确匹配，然后会根据这些匹配条件和匹配结果进行一个算法级别的打分。</p><h1 id="Kubernetes-Pod通讯"><a href="#Kubernetes-Pod通讯" class="headerlink" title="Kubernetes Pod通讯"></a>Kubernetes Pod通讯</h1><p>接下来学习Kubernetes Pod与Pod之间的通讯方式有三种，下面分别进行介绍。</p><p>第一种，Pod的内部通讯，同一个Pod中的容器之间的相互通信。这就是近的两个Pod之间的通讯，同一个Pod肯定是运行在同一个主机上，然后它有共享的网络，同一个IP，所以它们之间的访问可以使用localhost加上端口号就能进行访问，这是最简单的一种通信方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-144babbc777e7e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二种，同一个Node上，不同Pod间的通讯。同一个Node上的Pod，它的默认路由都是docker0，由于它们都关联在同一个网桥docker0上，地址网段是相通的，所以它们之间可以直接通过该网桥来进行通讯。然后访问的方式就是可通过Pod的IP来直接访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c647c864ed5f872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三种，不同Node上，不同Pod间的通讯。它们要想实现访问，需要满足几个条件，一个是Pod的IP不能冲突（不能有相同的IP），其次就是Pod的IP要和Node所在IP关联起来，通过这个关联让Pod之间可以相互访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-287c7cdb834a0c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Kubernetes服务发现"><a href="#Kubernetes服务发现" class="headerlink" title="Kubernetes服务发现"></a>Kubernetes服务发现</h1><p>Kubernetes服务发现主要有两个组件，一个是kube-proxy，另一个则是kube-dns。</p><p>kube-proxy其实分为两种类型，一种是ClusterIP，这种对于每个服务都按照一个IPtable规则，会给相关的Pod做一个虚拟IP，会将虚拟IP的流量直接重定向到后端服务的一个集合。这个虚拟IP只能在集群内访问，并且是固定的，前提是Service不删除。另一种则是NodePort，NodePort就是在每一个Node上都起一个监听端口，相当于将服务暴露在节点上，这样就可以让集群外部的服务，通过NodeIP和NodePort去访问到我们集群内部的服务。</p><p>kube-dns是Kubernetes的一个插件，负责集群内部的DNS解析，目的是在集群内部可以让Pod之间通过名字来进行访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes简介&quot;&gt;&lt;a href=&quot;#Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes简介&quot;&gt;&lt;/a&gt;Kubernetes简介&lt;/h1&gt;&lt;p&gt;Kubernetes，简称K8s，是用8代替名字中间的8个字</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes基础知识</title>
    <link href="http://envyzhan.asia/2022/06/28/2022-k8s-2-simple-environment-construction/"/>
    <id>http://envyzhan.asia/2022/06/28/2022-k8s-2-simple-environment-construction/</id>
    <published>2022-06-28T09:55:30.000Z</published>
    <updated>2022-09-12T08:40:06.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><p>Kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理，用于管理云平台中多个主机上的容器化的应用。Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h1 id="Kubernetes集群"><a href="#Kubernetes集群" class="headerlink" title="Kubernetes集群"></a>Kubernetes集群</h1><p><a href="https://kubernetes.io/zh-cn/">Kubernetes</a> 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。一个Kubernetes集群包含两种类型的资源：Master（调度整个集群）和Nodes（负责运行应用）。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8332cf68b444bf54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Master调度整个集群"><a href="#Master调度整个集群" class="headerlink" title="Master调度整个集群"></a>Master调度整个集群</h3><p>Master协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><h3 id="Nodes负责运行应用"><a href="#Nodes负责运行应用" class="headerlink" title="Nodes负责运行应用"></a>Nodes负责运行应用</h3><p>Node是一个虚拟机或者物理机，它在Kubernetes集群中充当工作机器的角色。每个Node都有Kubelet，它管理Node，而且是Node与Master通信的代理。 Node还具有用于处理容器操作的工具，如Docker或rkt。</p><p>请注意生产级别的Kubernetes集群至少包含三个Node，因为如果一个Node出现故障，那么其对应的etcd成员和控制平面节点都会丢失，并且冗余会受到影响。当然了，开发者可以通过添加更多控制平面节点方式来降低这种风险 。</p><p>在Kubernetes上部署应用时，需要告诉Master来启动应用容器，之后Master就会编排容器在集群的Node上运行。 Node使用Master暴露的Kubernetes API与Master通信。当然了，终端用户也可以使用Kubernetes API与集群进行交互。</p><p>Kubernetes既可以部署在物理机上，也可以部署在虚拟机上。开发者可以使用Minikube开始部署Kubernetes集群。 Minikube是一种轻量级的Kubernetes实现，可在本地计算机上创建VM并部署仅包含一个节点的简单集群。Minikube可用于Linux，macOS和Windows系统。Minikube CLI提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Kubernetes应用部署"><a href="#Kubernetes应用部署" class="headerlink" title="Kubernetes应用部署"></a>Kubernetes应用部署</h1><p>一旦运行了Kubernetes集群，就可以在其上部署容器化应用程序。 为此，你需要创建Kubernetes Deployment配置。Deployment指挥Kubernetes如何创建和更新应用程序的实例。创建Deployment后，Kubernetes master将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则Deployment控制器会将该实例替换为集群中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。</p><p>在没有Kubernetes这种编排系统之前，启动应用程序通常会采取安装脚本这一方式，但它们不允许从机器故障中恢复。Kubernetes Deployments提供了一种与众不同的应用程序管理方法，通过创建应用程序实例并使它们在节点之间运行。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-86d72371396d79dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>你可以使用Kubernetes命令行界面 <strong>Kubectl</strong> 创建和管理Deployment。Kubectl使用Kubernetes API 与集群进行交互。创建Deployment 时，你需要指定应用程序的容器镜像以及要运行的副本数。你可以稍后通过更新Deployment来更改该信息。</p><h1 id="Kubernetes中的概念"><a href="#Kubernetes中的概念" class="headerlink" title="Kubernetes中的概念"></a>Kubernetes中的概念</h1><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes处理的最基本单元，容器本身不会直接分配到主机上，而是会封装到名为Pod的对象中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a020c6f11413799f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图中Pod1里面有一个应用容器，且该Pod有一个独立的IP地址。Pod2里面有一个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。</p><p>Pod3里面有两个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。也就是说这个Pod中的两个应用容器是可以共享IP与磁盘。</p><p>Pod4里面有多个应用容器和磁盘，该Pod也有一个独立的IP地址。也就是说同一个Pod中可以有任意多个应用容器（多个容器间网络共享）和磁盘（多个共享目录）。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Pod是运行在Node上的，kubelet负责调度Pod的运行。只要资源足够，一个Node上可以有任意多个Pod。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3b6cc5f1a8669401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>粗蓝线框的节点是Master节点，其他的都是Node节点。看一下左下角的Node节点，里面运行了一个Pod，然后这个Pod的外面有一层黄色的虚线，这层虚线就是Service。这个Pod有一个IP，地址是10.10.10.1，这个Service也有一个IP，地址是10.10.9.1，可以看到Service和Pod的IP是不一样的。现在有个问题，为什么Pod有了IP，而外面还包一层Service，同时它也有独立的IP呢？</p><p>原因在于Pod是运行在具体的一个Node上，可能在某些场景下这个Pod出了问题（不稳定挂掉了或者服务容器异常退出，甚至整个Node挂掉了），这样的话这个Node就挂掉了，服务就无法访问了。那可能会去其他的位置重新启动一个Node，运行Pod，此时Pod的IP地址肯定变化了，因此就需要一个Service。当我们的Pod出了问题，它的IP地址发生了变化，此时我们还可以通过Service的IP来找到这个Pod。注意Service的IP与其生命周期是对应的，只要这个Service没有被删除，那么Service的IP就会一直存在，并且永远不会发生变化。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看上面两个Node，左侧Node中只有一个Pod，而右侧Node中有两个Pod，一共三个Pod。在多个Pod的情况下，一般都是同一个应用的多个副本，也就是对同一个应用进行扩容，由1个实例变成3个实例，然后它们对外会提供相同的服务。此时这个Service的IP除了可以向上面那样，定位到Pod的地址之外，还有另外一个作用，即对多个Pod的地址进行负载均衡。举个例子，如轮询访问每个Pod。当然了这个Pod不一定是一模一样的，也可以是同一应用的不同版本。比如我在进行灰度发布的时候，一个可能是旧版本，一个可能是新版本，这都是可以的。所以说Kubernetes并没有对Pod本身做任何限制，那怕是完全不同的应用，你也可以将其作为一个Service去管理。只是一般情况下，我们都不会这么做。</p><p>Service的概念我们已经知道了，那么Kubernetes是如何确定哪些Pod属于同一个Service呢？Kubernetes使用Label Selector来进行确定。当我们定义一个Service的时候，可以给它指定一个标签，如<code>s:app=B</code>，有这样一对标签的时候，就可以认为它属于ServiceB。之后它会去搜索所有的Pod，发现上面三个Pod都携带有<code>app=B</code>标签，那么这三个Pod就会自动归属于这个ServiceB。这就让Service和Pod之间的耦合变得很松，非常灵活。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a426db0b2191d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来梳理几个概念，首先是Pod，Pod里面可以运行多个容器，Service里面可以包含多个Pod，然后Development就比较宽泛，可以是部署Pod，也可以是部署Service。</p><p>接下来看一下通过Development来完成应用的扩容过程：首先从Master节点发起了一个Development，向给这个Service里面的Pod扩容成4个实例，而目前就只有一个实例。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1261d3c9878ba39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>扩容的目标对象是Pod，Pod才是一个真实存在的东西，才有扩容和缩容的概念，而Service是没有的，Service只是一个逻辑上存在的东西。它只是通过Label Selector将一组Pod划分为一个逻辑组，从而实现它们的负载均衡而已。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a2783b07670d2b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后就扩容完成了，在其他的两个节点上，也有了运行的Pod，一共是4个实例。然后这个Service就自动将新的Pod包含进来，那么问题来了，它是如何知道这些新的Pod呢？肯定是通过标签，既然是扩容，那么新Pod的标签和原来的Pod的标签是一样的，然后它通过标签选择，将新的Pod都选择上，接着Service就可以对外进行负载均衡，将流量转发给每个Pod。当某个Pod出问题的时候，Service会通过某种机制，不会将流量转发给出现问题的Pod上。</p><p>接下来看一下滚动更新的过程：首先停掉了一个旧的Pod，然后又新启动了一个Pod，此时这个Service中就同时有旧的版本和新的版本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7d06f1f15b9f0fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着又停掉了最下面那个Pod，又启动了一个新的Pod：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a7c59cbcfcb569e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如此进行，直到所有旧的Pod都更新完成，滚动更新就结束了。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-29af65060a479877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在所有的更新和扩容的过程，这个Service的IP都是始终保持不变的，以上就是Kubernetes中的核心概念。</p><h1 id="Kubernetes整体架构"><a href="#Kubernetes整体架构" class="headerlink" title="Kubernetes整体架构"></a>Kubernetes整体架构</h1><p>接下来我们看一下Kubernetes的整体架构，下面这张图初看可能觉得非常乱：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ad6ac17a412e734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先上面这一块是Master节点，然后下面两块分别都是Node节点。Master节点中部署的都是Kubernetes的核心模块，中间的虚线框表示APIServer，它提供了资源操作的唯一入口，并且提供认证、授权和Kubernetes的访问控制。开发者可以通过kuberctl或者自己开发的客户端通过HTTP请求以RESTful API的形式来访问这个APIServer，进而实现对整个集群的控制。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cbcd7e364e6f1a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>ControllerManager负责维护集群的状态，如故障检测、扩缩容、滚动更新等。Scheduler负责资源的调度，它会按照预定的调度策略，将Pod调度给相应的Node节点。前面学习的Mesos和Docker Swarm也都有调度模块，也有非常多的调度策略可以选择，而Kubernetes则有更加丰富的调度策略，关于这一块后面会详细进行介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec9354017f73b5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>右上角还有一个ETCD，主要用作于一致性存储，保存了Pod，Service，还有集群的一些状态等信息，其实就相当于所有的这些Kubernetes集群需要持久化的数据都会存储到这个ETCD中。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-101e46cba059c589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在这个Master节点中还运行了一个kube-dns组件，它负责整个集群的DNS服务，注意这个组件不是必须的。不过一般我们都选择安装它，因为通过名字访问是一个非常重要的功能。右侧还有一个名为dashboard的组件，它提供了集群数据管理的可视化界面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-999fad975491287c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下Node节点。从上图中可以看到，每个Node节点中都有一个Kubelet，Kubelet负责维护当前节点上的容器的生命周期，也负责维护当前节点的网络等。在每个Node节点上都运行一个kube-proxy，kube-proxy负责Service，负责提供内部的服务发现和负载均衡，相当于为Service这个概念提供了一个落地的方法。</p><p>接下来看一下一个Pod Developed全过程：首先用户执行kubectl，向APIServer发起一个命令，然后请求经过认证之后，再由Schedluer的各种策略来评分计算，得到一个目标的Node，然后告诉APIServer。</p><p>APIServer就会请求相关Node的kubelet，然后通过这个kubelet将这个Pod运行起来，同时APIServer会将这个Pod的信息存储到ETCD中。当Pod运行起来之后，这个ControllerManager就会负责管理这个Pod的状态。举个例子，假设这个Pod不小心挂了，那么ControllerManager就会重新创建一个一样的Pod，Pod的扩缩容也是由这个ControllerManager来管理的。此时这个Pod有一个独立的IP地址，我们可以在整个集群内使用这个IP来访问它。但是这个Pod的IP是容易发生变化，比如异常重启、服务升级时IP就变化了。再有一个就是当存在多个实例的时候，我们也不可能实时的去关注这些Pod的IP，并访问它们，于是就有了Service。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9e6b98c295d73335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>图中绿色虚线内有三个Pod，它们同属一一个Service，不再此绿色虚线内的Pod则是单独存在的，并没有提供Service的入口。而具体完成Service工作的则是kube-proxy模块，可以看到在每个Node上都有一个kube-proxy。在任何一个节点上访问这个Service的虚拟IP（即给Service分配的IP）都可以访问到这三个Pod，因此这两个节点对这一个Service都会有一个IP的指向，负载均衡的访问它们。Service的IP虽然在集群内部是可以访问得到，但是在这个集群之外呢？我们是想要在集群外的服务，访问集群内的一个服务，此时应该怎么办？这一点kube-proxy也考虑到了，它可以将服务端口直接暴露在当前的Node上，然后外面的请求直接访问Node上的一个IP就可以关联到这个Service了。</p><p>我们在学习Docker Swarm的时候，知道在容器中可以通过名字来访问其他的容器，Kubernetes也是可以的，这就是kube-dns所做的工作，它提供了整个集群的dns服务，让每个Pod都可以通过名字来访问对方。也就是说，任何一个Pod都可以通过名字来访问另一个Pod。</p><h1 id="Kubernetes-Scheduler调度策略"><a href="#Kubernetes-Scheduler调度策略" class="headerlink" title="Kubernetes Scheduler调度策略"></a>Kubernetes Scheduler调度策略</h1><p>Scheduler用于决定每个Pod应该调度到哪个节点上，Kubernetes的分配方式有两种：预选规则（preselect）和优选规则（optimize-select）。</p><p>【预选规则】预选规则（preselect）这里介绍五个比较重要的规则：NodiskConflict、CheckNodeMemoryPressure、NodeSelector、FitResource和Affinity。<br>（1）NodiskConflict，即看看有没有挂载的冲突。如果一个Pod需要一个挂载，然后在这台机器上，这个挂载已经被其他Pod占用的话，这就是挂载冲突，它不会让挂载冲突这件事情发生。<br>（2）CheckNodeMemoryPressure，即检查当前节点的内存压力，所有内存压力为0的节点可以调度，当然了还存在对磁盘的检查等等。<br>（3）NodeSelector，即选择指定hostname或者具有某些标签的节点，这是非常基础的，所有的服务编排框架都有这样的功能。<br>（4）FitResource，这也是非常基础的，Node需要满足Pod的CPU、内存、GPU等资源的要求。<br>（5）Affinity，亲和性，这个逻辑比较复杂，它可以满足很多需求，如一个Pod必须与另一个Pod运行在一起，一个Pod最好与另一个Pod运行在一起，这是两种描述，它都可以实现。既然有亲和性，那么就有反亲和性，即一个Pod不能与另一个Pod运行在一起，一个Pod最好不要与另一个Pod运行在一起。</p><p>【优选规则】优选规则（optimize-select）是指通过预选规则选出来一系列的Node之后，对这些Node进行打分。Kubernetes会使用一组优先级函数去处理每一个待选的Node，每一个优先级函数会返回一个0-10的分数，分数越高表示这台机器越好，越适合，同时每个函数也会对应一个权重，最终选择一个分值最高的机器来部署Pod。</p><p>这里介绍三个比较重要的规则：SelectorSpreadPriority、LeastRequestedPriority和AffinityPriority。</p><p>（1）SelectorSpreadPriority。对于同一个Service或者Controller的Pod，尽量会分布在不同的机器上，如果指定了区域，则会尽量将Pod分散在不同区域的不同主机上。<br>（2）LeastRequestedPriority。如果一个新的Pod需要分配节点，那么这个节点的优先级就由节点空闲的那部分容量的比值来决定。其实就是使用节点上Pod的总容量减去新的Pod的容量得到的值再除以总容量。也就是说当这个Pod运行在这个节点上之后，当前节点还存在多少空闲，如果空闲越高则分数越大。<br>（3）AffinityPriority，调度综合亲和性机制。Node Selector在调度的时候将Pod限定在某些节点上的时候，它是支持多种操作符的，如in、not in、exists、gt/lt等，它不会去限定对Label的精确匹配，然后会根据这些匹配条件和匹配结果进行一个算法级别的打分。</p><h1 id="Kubernetes-Pod通讯"><a href="#Kubernetes-Pod通讯" class="headerlink" title="Kubernetes Pod通讯"></a>Kubernetes Pod通讯</h1><p>接下来学习Kubernetes Pod与Pod之间的通讯方式有三种，下面分别进行介绍。</p><p>第一种，Pod的内部通讯，同一个Pod中的容器之间的相互通信。这就是近的两个Pod之间的通讯，同一个Pod肯定是运行在同一个主机上，然后它有共享的网络，同一个IP，所以它们之间的访问可以使用localhost加上端口号就能进行访问，这是最简单的一种通信方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-144babbc777e7e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二种，同一个Node上，不同Pod间的通讯。同一个Node上的Pod，它的默认路由都是docker0，由于它们都关联在同一个网桥docker0上，地址网段是相通的，所以它们之间可以直接通过该网桥来进行通讯。然后访问的方式就是可通过Pod的IP来直接访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c647c864ed5f872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三种，不同Node上，不同Pod间的通讯。它们要想实现访问，需要满足几个条件，一个是Pod的IP不能冲突（不能有相同的IP），其次就是Pod的IP要和Node所在IP关联起来，通过这个关联让Pod之间可以相互访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-287c7cdb834a0c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Kubernetes服务发现"><a href="#Kubernetes服务发现" class="headerlink" title="Kubernetes服务发现"></a>Kubernetes服务发现</h1><p>Kubernetes服务发现主要有两个组件，一个是kube-proxy，另一个则是kube-dns。</p><p>kube-proxy其实分为两种类型，一种是ClusterIP，这种对于每个服务都按照一个IPtable规则，会给相关的Pod做一个虚拟IP，会将虚拟IP的流量直接重定向到后端服务的一个集合。这个虚拟IP只能在集群内访问，并且是固定的，前提是Service不删除。另一种则是NodePort，NodePort就是在每一个Node上都起一个监听端口，相当于将服务暴露在节点上，这样就可以让集群外部的服务，通过NodeIP和NodePort去访问到我们集群内部的服务。</p><p>kube-dns是Kubernetes的一个插件，负责集群内部的DNS解析，目的是在集群内部可以让Pod之间通过名字来进行访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes简介&quot;&gt;&lt;a href=&quot;#Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes简介&quot;&gt;&lt;/a&gt;Kubernetes简介&lt;/h1&gt;&lt;p&gt;Kubernetes，简称K8s，是用8代替名字中间的8个字</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
</feed>
