<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2022-09-12T09:10:45.242Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>功能开关在业务中的实践</title>
    <link href="http://envyzhan.asia/2022/08/18/17-practice-of-function-switch-in-business/"/>
    <id>http://envyzhan.asia/2022/08/18/17-practice-of-function-switch-in-business/</id>
    <published>2022-08-18T09:55:30.000Z</published>
    <updated>2022-09-12T09:10:45.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在搞一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但是后续发现这样有个弊端，即只能针对一个活动或者相同时间的多个活动生效，而实际上我们的活动有多个，权衡再三决定使用功能开关来实现。</p><h1 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h1><p>功能开关其实是一种代码可配置性的实践，说到底就是通过控制开关的状态来实现对功能的决定控制。</p><p>功能开关的实现有很多种方式，可以使用MySQL或者Redis等数据库，出于对后续数据扩展和对存储容量的考量，此处使用Bit数组来实现。</p><h3 id="Bit数组原理"><a href="#Bit数组原理" class="headerlink" title="Bit数组原理"></a>Bit数组原理</h3><p>既然是数组，那么下标必然从0开始，bit只有两种取值，要么为0，要么为1：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3049804d68aadfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>而0和1正好对应开关的关闭和启用，即ON和OFF状态。之后开发者只需定义好每个开关所在的Bit数组的索引号和状态即可，这样后续就可以通过判断开关的状态来实现对功能的控制：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-e89b847c9308657f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到使用这种方式所占用的内存空间非常少，理论上只需占用2n位的内存，n为开关的数量。</p><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>Java中对于Bit数组可以使用BitSet来实现 ，里面有很多方法，这里我们摘几个用到的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BitSet implements Cloneable, java.io.Serializable &#123;</span><br><span class="line">    //给指定位置设置值</span><br><span class="line">    public void set(int bitIndex, boolean value) &#123;&#125;</span><br><span class="line">    //给指定位置的值取反操作</span><br><span class="line">    public void clear(int bitIndex) &#123;&#125;</span><br><span class="line">    //获取指定位置的值</span><br><span class="line">    public boolean get(int bitIndex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，新建开关状态常量SwitchConst：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关常量</span><br><span class="line"> */</span><br><span class="line">public class SwitchConst &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用</span><br><span class="line">     */</span><br><span class="line">    public static final boolean ON = true;</span><br><span class="line">    /**</span><br><span class="line">     * 关停</span><br><span class="line">     */</span><br><span class="line">    public static final boolean OFF = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于开关只有开和闭这两种状态，因此可以不使用枚举类。</p><p>第二步，新建功能开关枚举类SwitchEnum，这个就是开发者所要定义的开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能开关枚举类</span><br><span class="line"> */</span><br><span class="line">public enum SwitchEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * HTTPS</span><br><span class="line">     */</span><br><span class="line">    HTTPS(0,SwitchConst.ON,&quot;HTTPS设置&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 充值会员</span><br><span class="line">     */</span><br><span class="line">    RECHARGE(1,SwitchConst.OFF,&quot;充值送油卡&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下标</span><br><span class="line">     */</span><br><span class="line">    private int index;</span><br><span class="line">    /**</span><br><span class="line">     * 默认状态</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    SwitchEnum(int index,boolean status,String desc)&#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getIndex()&#123;</span><br><span class="line">        return this.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean getStatus()&#123;</span><br><span class="line">        return this.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return this.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;name=%s,desc=%s&quot;,name(),desc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>第三步，新建开关状态切换接口Switch，里面定义切换开关状态和判断接口状态的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关转态切换</span><br><span class="line"> */</span><br><span class="line">public interface Switch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOn(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOff(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断开关状态</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    boolean judgeStatus(SwitchEnum switchEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个BitSetSwitch，表示基于BitSet实现的开关，因此需要实现Switch接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum BitSetSwitch implements Switch&#123;</span><br><span class="line">    MYBITSET;</span><br><span class="line"></span><br><span class="line">    BitSetSwitch()&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOn(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.set(switchEnum.getIndex(),SwitchConst.ON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOff(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.clear(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean judgeStatus(SwitchEnum switchEnum) &#123;</span><br><span class="line">        return bitSet.get(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        Stream.of(SwitchEnum.values()).forEach(item-&gt;bitSet.set(item.getIndex(),item.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将BitSetSwitch设置为了一个枚举类，目的就是通过单例生成一个BitSetSwitch对象。注意不能将其设置为普通的类，如果那样的话，在使用的时候就需要通过new关键字生成BitSetSwitch对象，而且每调用一次就得新创建一个对象，这肯定是不行的，功能开关肯定是全局唯一的。</p><p>第五步，新建测试类SwitchTest，测试一下功能开关的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSetSwitch bitSetSwitch = BitSetSwitch.MYBITSET;</span><br><span class="line">        bitSetSwitch.turnOn(SwitchEnum.HTTPS);</span><br><span class="line">        bitSetSwitch.turnOff(SwitchEnum.RECHARGE);</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.HTTPS,bitSetSwitch.judgeStatus(SwitchEnum.HTTPS)));</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.RECHARGE,bitSetSwitch.judgeStatus(SwitchEnum.RECHARGE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行该方法，可以发现控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开关【name=HTTPS,desc=HTTPS设置】，状态为：true</span><br><span class="line">开关【name=RECHARGE,desc=充值送油卡】，状态为：false</span><br></pre></td></tr></table></figure><p>这说明当前项目开启了HTTPS设置，但是关停了充值送油卡这一活动。后期要实现灵活控制，可配合配置中心在配置文件中进行控制。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>功能开关在实际开发过程中非常实用，因此有必要在理解的基础上进行灵活使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在搞一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的记录你的日志</title>
    <link href="http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/"/>
    <id>http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/</id>
    <published>2022-08-10T09:55:30.000Z</published>
    <updated>2022-09-12T09:07:53.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。</p><h1 id="操作日志使用场景"><a href="#操作日志使用场景" class="headerlink" title="操作日志使用场景"></a>操作日志使用场景</h1><h3 id="操作日志与系统日志区别"><a href="#操作日志与系统日志区别" class="headerlink" title="操作日志与系统日志区别"></a>操作日志与系统日志区别</h3><p>当对某个对象进行新增、修改和查询操作后，通常需要记录对象的新旧状态，这其实就是操作日志，一般而已操作日志都是给用户查阅的，因此可读性要求较高。最常见的就是物流信息的更新，这其实是针对该快递对象的更新记录，里面会告诉用户包裹转到何时何地。</p><p>而系统日志通常是作为开发人员排查和解决问题的依据，一般记录在指定的日志文件中，由于是给开发人员使用的，所以可读性要求不高，里面只记录一些重点信息，如代码当前输出的信息。</p><h3 id="操作日志分类"><a href="#操作日志分类" class="headerlink" title="操作日志分类"></a>操作日志分类</h3><p>一般来说，操作日志分类分为三类，下面依次进行简要学习：<br>（1）单纯的文本记录。举个例子，2021-12-01 10:00:00 用户登录。时间是动态但与其他内容关，其他信息都是固定值。<br>（2）简单的动态文本记录。举个例子，2021-12-01 10:00:00 用户：张三，创建订单，订单号为1000。用户名和订单号则与需要传入或者生成。<br>（3）记录对象的前后状态。举个例子，2021-12-01 10:00:00 用户：张三，修改了订单备注信息，由“微辣”修改为“中辣”。可以看到此处需要同时记录对象的前后状态。</p><p>当然实际可能修改的字段不止以上几种，可能涉及到的内容较多，但基本上和上述三类差异不大。</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h3 id="使用Canal监听数据库"><a href="#使用Canal监听数据库" class="headerlink" title="使用Canal监听数据库"></a>使用Canal监听数据库</h3><p>Canal是一款基于MySQL数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库Binglog的方式来知道具体是哪些数据发生了修改，然后根据修改的数据来记录用户操作日志。</p><p>这种方式完全不侵入原来的业务代码，但是缺点也很明显，就是只能针对数据库的更改做记录，如果涉及到其他团队的RPC调用，这无法监听数据库因此只能手动记录操作日志。举个简单的例子，用户下单后调用短信通知服务，告诉用户下单成功，毫无疑问短信通知服务肯定是公共服务，只能下单方法调用了这个RPC，那么只能在下单方法中记录给用户发送通知的操作记录。关于一部分的内容，可以参考后续文章。</p><h3 id="通过日志文件记录"><a href="#通过日志文件记录" class="headerlink" title="通过日志文件记录"></a>通过日志文件记录</h3><p>通过日志文件方式，这是最常用的方式，直接在调用的时候输出一些调用信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;用户登录&quot;);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，创建订单，订单号为&#123;&#125;&quot;,userId,orderId);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，修改了订单备注信息，由“&#123;&#125;”修改为“&#123;&#125;”&quot;,userId,oldInfo,newInfo);</span><br></pre></td></tr></table></figure><p>可以看到这里存在三个问题：（1）如何获取到用户信息；（2）操作日志如何与系统日志分开；（3）如何生成可读性高的日志信息。</p><h5 id="如何获取到用户信息"><a href="#如何获取到用户信息" class="headerlink" title="如何获取到用户信息"></a>如何获取到用户信息</h5><p>如何获取用户信息，这里有很多种方式，可以通过拦截器或者AOP方式，传入请求然后从请求中获取，并将用户信息存入MDC（Mapped Diagnostic Context，映射调试上下文）中，那么相应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserInterceptor extends HandlerInterceptor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    //获取到用户ID</span><br><span class="line">    String userId = getUserInfo(request);</span><br><span class="line">    //把用户ID放入MDC上下文中</span><br><span class="line">    MDC.put(&quot;userId&quot;, userId );</span><br><span class="line">    return super.preHandle(request, response, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getUserInfo(HttpServletRequest request) &#123;</span><br><span class="line">    // 通过SSO、Cookie或者Auth信息获取当前登陆的用户信息</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将用户ID格式化到日志文件中，可使用<code>%X&#123;userId&#125;</code>变量来获取MDC中的用户ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br></pre></td></tr></table></figure><h5 id="操作日志如何与系统日志分开"><a href="#操作日志如何与系统日志分开" class="headerlink" title="操作日志如何与系统日志分开"></a>操作日志如何与系统日志分开</h5><p>针对这种情况，通俗做法就是通过Log的配置文件来将操作日志放到单独的日志文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=&quot;businessLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;File&gt;logs/business.log&lt;/File&gt;</span><br><span class="line">    &lt;append&gt;true&lt;/append&gt;</span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">        &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">        &lt;fileNamePattern&gt;logs/业务A.%d.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">        &lt;maxHistory&gt;90&lt;/maxHistory&gt;</span><br><span class="line">        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br><span class="line">        &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">        </span><br><span class="line">&lt;logger name=&quot;userlogInLog&quot; additivity=&quot;false&quot; level=&quot;INFO&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;userlogInLogAppender&quot;/&gt;</span><br><span class="line">&lt;/logger&gt;</span><br></pre></td></tr></table></figure><p>之后只需在使用的时候记录一下这个日志即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//记录特定的日志类</span><br><span class="line">private final Logger userlogInLog= LoggerFactory.getLogger(&quot;userlogInLog&quot;);</span><br><span class="line"> </span><br><span class="line">//日志存储</span><br><span class="line">userlogInLog.info(&quot;用户登录&quot;);</span><br></pre></td></tr></table></figure><h5 id="如何生成可读性高的日志信息"><a href="#如何生成可读性高的日志信息" class="headerlink" title="如何生成可读性高的日志信息"></a>如何生成可读性高的日志信息</h5><p>这种一般可以使用AOP或者LogUtil方式，之后将生成的日志单独保存在一个文件中，后续通过ELK系统将其收集、过滤、存储和展示。</p><h3 id="通过LogUtil方式记录"><a href="#通过LogUtil方式记录" class="headerlink" title="通过LogUtil方式记录"></a>通过LogUtil方式记录</h3><p>可以在业务逻辑代码中调用封装好的日志记录工具类来随时记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogUtil.log(&quot;用户登录，登录人：%s&quot;,userId)</span><br><span class="line">LogUtil.log(&quot;用户：%s，创建订单，订单号为%d&quot;,userId,orderId);</span><br><span class="line">String template = &quot;用户：%s，修改了订单号%d的备注信息，由“%s”修改为“%s”&quot;;</span><br><span class="line">LogUtil.log(String.format(tempalte, &quot;张三&quot;, &quot;10001, &quot;微辣&quot;,&quot;中辣&quot;));</span><br></pre></td></tr></table></figure><p>这只是记录用户的简单操作，在实际开发过程中可能比这要复杂的多，可能针对不同的业务逻辑，记录的格式和值完全不同，更重要的是将日志这种与实际业务逻辑不相关的内容深度融合在了业务代码中。</p><h3 id="通过AOP方式记录"><a href="#通过AOP方式记录" class="headerlink" title="通过AOP方式记录"></a>通过AOP方式记录</h3><p>为了让日志与业务逻辑解耦，更多的是使用AOP配合注解方式来记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以做到完全不侵入业务代码，但是记录的日志格式不符合预期，格式是固定的，其实这个可以使用动态模板来实现。</p><h1 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h1><p>动态模板其实就是通过解析变量占位符来解析模板，进而实现通过注解记录操作日志这一目的。模板解析的方式有很多种，这里使用SpEL（Spring Expression Language）来实现，我们希望的日志记录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看上面的日志输出格式只提到了oldRemark和newRemark这两个参数，其实隐含了两个更重要的信息，即操作人和订单id，那么这两个参数如何获取呢？同时这个方法传入的是修改值，而旧值如果用户不传入，此时还需要在业务中查询，而这个仅仅是因为操作日志记录需要，实际业务却不需要，所以使得方式不够优雅。</p><p>为了解决操作人和订单id的显示问题，我们需要将操作日志修改为如下所示格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  operator=&quot;#request.userId&quot;,bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在日志记录格式中添加了操作人和订单号，其实这种获取操作人的方式可能不太正确，一般在Web项目中，用户信息都是保存在一个线程上下文的静态方法中，所以操作人的信息一般是通过如下方式，假设获取当前登录用户信息的方法为<code>UserContext.getCurrentUserInfo()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator=&quot;#&#123;T(com.bamboo.user.UserContext).getCurrentUserInfo()&#125;&quot;</span><br></pre></td></tr></table></figure><p>但是这样获取用户信息的方式也太长了，而且并不是所有的地方都需要获取登录用户的信息，因此可以将这个operator参数的值设置为可选项，这样用户可以填写操作人，如果没填那么就可以从UserContext山下文中获取当前登录用户的信息。此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还有一个问题，就是需要添加一个旧的值oldRemark，这个值的获取非常尴尬，因为用户不传入这个参数，因此我们必须自行将这个oldRemark查询出来，然后将其放到操作日志的线程上下文中，这样后续模板在解析的时候就可以使用了。那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    //查询出原来的备注信息</span><br><span class="line">    Stirng oldRemark = orderService.query(reuest);</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemark&quot;,oldRemark);</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用<code>LogRecordContext</code>这个日志记录线程上下文来记录方法参数之外的变量，更重要的是它不破坏原有方法传递的参数信息。不过这种方式还是有问题的，因为它在业务代码中插入了一些实际业务逻辑不需要的代码，这一点其实可通过自定义函数来解决，后面会介绍。</p><p>经过上面的修改，此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;。</span><br></pre></td></tr></table></figure><p>如果这个oldRemark和newRemark是人可读的字符串，这肯定没问题，但是如果是某种业务代码，如口味代码，那么就可能变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;101&quot;，修改为&quot;102&quot;。</span><br></pre></td></tr></table></figure><p>用户不知道这个101和102具体是指什么，用户关心的是可读的信息，所以此时还需要通过<code>LogRecordContext</code>来查询并进行替换展示。</p><p>前面说过如果开发者不想将业务逻辑和日志记录糅杂在一起，可以使用自定义函数来进行实现。可以自定义函数将oldRemark和newRemark转换成人可读的数据，那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderInfo&#123;#oldRemarkInfo&#125;&#125;&quot;，修改为&quot;&#123;OrderInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemarkInfo&quot;,orderService.query(reuest));</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>OrderInfo</code>是自定义函数，我们使用大括号将Spring的SpEL表达式包裹起来，这样不仅可以将SpEL表达式和自定义函数区分开，便于解析；还可以在模板中不需要SpEL表达式的时候容易识别出来，减少不必要的SpEL解析，以提升性能。</p><p>看到这里，开发者完全可以将<code>LogRecordContext</code>线程上下文去掉，直接将<code>oldRemark</code>信息也通过自定义新的函数来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderOldInfo&#123;#request.orderId&#125;&#125;&quot;，修改为&quot;&#123;OrderNewInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些操作，开发者就能通过自定义新函数传入订单id就能获取到之前的订单信息，当然这要求该方法的执行必须在updateOrder方法之前，这样就可以获取到对应信息，如此一来所有的目标都实现了，同时代码几乎没有任何的侵入性。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>新建项目并添加web和aop依赖，接着自定义一个注解，后续所有添加该注解的方法都会被拦截并记录对应的操作记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value = RetentionPolicy.RUNTIME )</span><br><span class="line">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface OperationRecord &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作类型</span><br><span class="line">     */</span><br><span class="line">    OperationEnum type();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作内容</span><br><span class="line">     */</span><br><span class="line">    String operation();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 备注</span><br><span class="line">     */</span><br><span class="line">    String remark() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于备注这个信息不是所有场景下都具有的，因此这里就给了一个默认值。同时这里的操作类型定义了一个枚举类型，所以接下来就定义这个枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作类型</span><br><span class="line"> */</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public enum OperationEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 首页</span><br><span class="line">     */</span><br><span class="line">    INDEX(0),</span><br><span class="line">    /**</span><br><span class="line">     * 用户</span><br><span class="line">     */</span><br><span class="line">    USER(1),</span><br><span class="line">    /**</span><br><span class="line">     * 红包</span><br><span class="line">     */</span><br><span class="line">    REDPACKET(2),</span><br><span class="line">    /**</span><br><span class="line">     * 版本</span><br><span class="line">     */</span><br><span class="line">    APPVERSION(3),</span><br><span class="line">    /**</span><br><span class="line">     * 登录</span><br><span class="line">     */</span><br><span class="line">    LOGIN(4)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    private Integer typeId;</span><br><span class="line"></span><br><span class="line">    public Integer getTypeId() &#123;</span><br><span class="line">        return typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTypeId(Integer typeId) &#123;</span><br><span class="line">        this.typeId = typeId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志记录类"><a href="#自定义日志记录类" class="headerlink" title="自定义日志记录类"></a>自定义日志记录类</h3><p>由于用户的操作日志记录需要保存到数据库中，因此接下来定义数据表和对应的实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_operation_record` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `job_number` varchar(255) NOT NULL COMMENT &#x27;工号&#x27;,</span><br><span class="line">  `login_ip` varchar(255) NOT NULL COMMENT &#x27;登录IP&#x27;,</span><br><span class="line">  `type` int(11) NOT NULL COMMENT &#x27;操作类型&#x27;,</span><br><span class="line">  `operation` varchar(1000) DEFAULT NULL COMMENT &#x27;操作内容&#x27;,</span><br><span class="line">  `operate_time` datetime DEFAULT NULL COMMENT &#x27;操作时间&#x27;,</span><br><span class="line">  `remark` varchar(1000) DEFAULT NULL COMMENT &#x27;备注&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>实体类信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class TbOperationRecord &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String jobNumber;</span><br><span class="line">    private String loginIp;</span><br><span class="line">    private Integer type;</span><br><span class="line">    private String operation;</span><br><span class="line">    private Date operateTime;</span><br><span class="line">    private String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志Dao层"><a href="#自定义日志Dao层" class="headerlink" title="自定义日志Dao层"></a>自定义日志Dao层</h3><p>这里我们直接通过<code>mybatis-generate</code>工具来生成对应的Dao代码。</p><h3 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h3><p>接下来我们需要自定义切面类<code>AdminOperationRecordAop</code>，然后通过AOP来拦截请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">public class AdminOperationRecordAop &#123;</span><br><span class="line">    private final SpelExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">    private final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();</span><br><span class="line">    @Autowired</span><br><span class="line">    private TbOperationRecordDao tbOperationRecordDao;</span><br><span class="line"></span><br><span class="line">    public static final String TYPE = &quot;type&quot;;</span><br><span class="line">    public static final String OPERATION = &quot;operation&quot;;</span><br><span class="line">    public static final String REMARK = &quot;remark&quot;;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.poly.myinterface.OperationRecord)&quot;)</span><br><span class="line">    public void myPointCut()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @After(&quot;myPointCut()&quot;)</span><br><span class="line">    public void operationRecord(JoinPoint joinPoint)&#123;</span><br><span class="line">        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //IP地址</span><br><span class="line">        String userIp = IpUtils.getIpAddr(request);</span><br><span class="line">        //工号</span><br><span class="line">        Object jobNumber = request.getSession().getAttribute(&quot;adminId&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String, String&gt; operationRecordInfo = getOperationRecordInfo(joinPoint);</span><br><span class="line">            int type = Integer.parseInt(operationRecordInfo.get(TYPE));</span><br><span class="line">            String remark = operationRecordInfo.get(REMARK);</span><br><span class="line">            String operation = operationRecordInfo.get(OPERATION);</span><br><span class="line">            fillOperationRecord(type,remark,operation,userIp,jobNumber.toString());</span><br><span class="line">            log.info(&quot;【日志操作花费时间=&#123;&#125;秒】&quot;,(System.currentTimeMillis()-start)/1000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">        String str = null;</span><br><span class="line">        if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">            Expression expression = parser.parseExpression(speLString);</span><br><span class="line">            //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">            EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">            //获取被注解的方法</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            //获取被注解的方法的形参</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            //获取运行时参数的名称</span><br><span class="line">            String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">            for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">                context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str = String.valueOf(expression.getValue(context));</span><br><span class="line">            log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Map&lt;String,String&gt; getOperationRecordInfo(JoinPoint joinPoint) throws ClassNotFoundException &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        OperationRecord annotation = method.getAnnotation(OperationRecord.class);</span><br><span class="line">        map.put(TYPE,annotation.type().getTypeId().toString());</span><br><span class="line">        map.put(REMARK,annotation.remark());</span><br><span class="line">        String operation = annotation.operation();</span><br><span class="line">        if(!operation.contains(&quot;;&quot;))&#123;</span><br><span class="line">            map.put(OPERATION,operation);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String[] strings = operation.split(&quot;;&quot;);</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            for(int i=0;i&lt;strings.length;i++)&#123;</span><br><span class="line">                String[] split = strings[i].split(&quot;#&quot;);</span><br><span class="line">                String spel =&quot;#&quot;+split[1];</span><br><span class="line">                String spelValue = getSPELValue(spel, joinPoint);</span><br><span class="line">                if(i!=strings.length-1)&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue).append(&quot;,&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(OPERATION,stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fillOperationRecord(Integer type,String remark,String operation,String loginIp,String jobNumber)&#123;</span><br><span class="line">        TbOperationRecord tbOperationRecord = new TbOperationRecord();</span><br><span class="line">        tbOperationRecord.setType(type);</span><br><span class="line">        tbOperationRecord.setRemark(remark);</span><br><span class="line">        tbOperationRecord.setOperation(operation);</span><br><span class="line">        tbOperationRecord.setLoginIp(loginIp);</span><br><span class="line">        tbOperationRecord.setJobNumber(jobNumber);</span><br><span class="line">        tbOperationRecord.setOperateTime(new Date());</span><br><span class="line">        tbOperationRecordDao.insert(tbOperationRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myPointCut()</code>是一个切点，里面设置的是之前定义的<code>OperationRecord</code>注解。接着我们定义了一个<code>operationRecord</code>方法，添加后置通知，表示在被拦截的方法执行之后这个<code>operationRecord</code>方法才会执行。我们通过下面的代码获取到用户请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br></pre></td></tr></table></figure><p>之后就通过<code>IpUtils.getIpAddr(request)</code>方法来获取请求来源的IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line">String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从请求携带的session中获取用户工号，之后就是获取被拦截的方法信息，从JoinPoint对象中可以得到方法签名，从方法签名中可以得到方法这个对象，然后通过字节码信息得到<code>OperationRecord</code>这个注解对象，然后就是将取出的信息放到map中进行存储。注意在获取<code>OperationRecord</code>这个注解对象的信息时，需要对传入的参数进行解析，这里使用SpEL进行解析，具体逻辑都在<code>getSPELValue</code>这个方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">        Expression expression = parser.parseExpression(speLString);</span><br><span class="line">        //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">        EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">        //获取被注解的方法</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        //获取被注解的方法的形参</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        //获取运行时参数的名称</span><br><span class="line">        String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">        for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">            context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        str = String.valueOf(expression.getValue(context));</span><br><span class="line">        log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过对传入的字符串进行解析，得到里面的Spring表达式对象，之后新建Spring表达式上下文对象，这个上下文对象中包含占位符信息以及每种占位符的值。接着我们获取到被注解的方法，并从方法中得到方法的形参，然后获取到运行时参数的名词，这种方式其实得到的只是方法中传递的参数值，对于方法中值没有传递的参数，目前还没获取，这一块等有空完善一下相关逻辑。</p><p>最后在使用的时候，只需在被使用的方法上添加类似如下的注解信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecord(type = OperationEnum.REDPACKET,operation = &quot;给用户id#userId;变更红包余额，相应的订单id#orderId;变动金额#changeBalance;变动类型#type;备注#remark&quot;,remark = &quot;变更红包金额&quot;)</span><br><span class="line">public ResultVO changeRedPacketBalance(int userId, String orderId, double changeBalance, int type, String remark) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在调用这个<code>changeRedPacketBalance</code>方法的时候就会在数据表<code>tb_operation_record</code>中新增一条对应的记录。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/JC51S_bI02npm4CE5NEEow">如何优雅地记录操作日志?</a>、<a href="https://mp.weixin.qq.com/s/JamcyrQdocnb0d0D0tSXNg">使用Aop记录带参数的复杂接口日志</a>、<a href="https://mp.weixin.qq.com/s/szhCq0tLCb_870uqAyIwPg">搞定 SpringBoot 操作日志</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。&lt;/p&gt;</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Canal实现数据增量同步</title>
    <link href="http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/"/>
    <id>http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/</id>
    <published>2022-08-02T09:55:30.000Z</published>
    <updated>2022-09-12T08:50:27.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随着业务系统的迭代、数据量的增多以及多种复杂场景下的分库分表实现，使得数据同步变得越来越具挑战性。针对这种情况，笔者决定使用阿里开源的Canal这一中间件来解决数据同步问题。</p><h1 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h1><h3 id="Canal简说"><a href="#Canal简说" class="headerlink" title="Canal简说"></a>Canal简说</h3><p>Canal是阿里巴巴开源的一款基于MySQL数据库的增量日志解析中间件，提供增量数据的订阅和消费功能。由于它是基于MySQL的日志进行的增量解析，因此对原有的业务代码完全不侵入。</p><p>Canal的工作原理是解析MySQL的binlog日志，提供增量数据的订阅和消费功能，具体包括：数据库镜像、数据库实时备份、业务缓存刷新、带业务逻辑的增量数据处理以及索引构建和实时维护（拆分异构索引和倒排索引）。</p><p>Canal官方文档，点击 <a href="https://github.com/alibaba/canal">这里</a> 进行查阅。</p><h3 id="Canal如何传输数据"><a href="#Canal如何传输数据" class="headerlink" title="Canal如何传输数据"></a>Canal如何传输数据</h3><p>下图是Canal官方展示的Canal传输数据架构图，可以看到Canal支持RabbitMQ、RocketMQ或者ES等常用的消息中间件：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-13f6424488da68e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从上图中可以知道Canal分为服务端和客户端，一般阿里开源的程序都是这个规范。其中服务端负责解析MySQL的binlog日志，并传输增量数据给客户端或者消息中间件；而客户端负责解析服务端传递过来的数据，并处理自己的业务逻辑。</p><p>当然，数据同步除了本篇学习的Canal外，还有其他一些优秀的开源工具，它们均支持MySQL，但是也存在一些区别。下面笔者将从支持实时同步、增量同步、需要编写保存变更数据的业务代码以及社区活跃度这4个方面进行对比，如下表所示：</p><table><thead><tr><th align="center"></th><th align="center">Canal</th><th align="center">Debezium</th><th align="center">DataX</th><th align="center">Databus</th><th align="center">Flinkx</th><th align="center">Bifrost</th></tr></thead><tbody><tr><td align="center">实时同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">增量同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">是否需要自己编写保存变更数据的代码</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">社区活跃度</td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">不高</td><td align="center">一般</td><td align="center">一般</td></tr></tbody></table><p>接下来将以Canal为例，来学习如何进行数据的同步。</p><h1 id="搭建服务端"><a href="#搭建服务端" class="headerlink" title="搭建服务端"></a>搭建服务端</h1><h3 id="安装Canal服务端"><a href="#安装Canal服务端" class="headerlink" title="安装Canal服务端"></a>安装Canal服务端</h3><p>点击 <a href="https://github.com/alibaba/canal/releases">这里</a> 下载Canal的服务端，即名称为<code>canal.developer</code>前缀的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-788d8d5206d6533d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>解压后的目录如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-7ae80252d4789fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中bin里面存放的是启动和停止脚本；conf目录存放的是配置文件；lib目录存放的是项目所依赖的包；logs目录存放的是项目运行的日志文件；plugin目录存放的是插件。其实这个canal服务端是一个SpringBoot项目，可以从其启动脚本中看出：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3fbb162356f8fa3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="修改MySQL配置信息"><a href="#修改MySQL配置信息" class="headerlink" title="修改MySQL配置信息"></a>修改MySQL配置信息</h3><p>第一步，找到MySQL安装目录下的<code>my.ini</code>文件，在里面新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">#使用ROW模式</span><br><span class="line">binlog-format=ROW</span><br><span class="line"># 设置MySQL replication，注意不要和canal的slaveId重复就行</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure><p>第二步，设置Canal服务端中关于MySQL的相关配置信息，即告诉Canal应该去监听哪个数据库的哪个表的日志文件。</p><p>注意一个Canal服务端中可以监听多个MySQL实例，Canal默认自带了一个example实例（在其<code>conf/example</code>目录下有一个名为<code>instance.properties</code>的文件），本篇笔记就以example为例来进行学习。如果开发者需要增加实例，那么需要复制example文件夹中的内容到同级目录中，并在同级目录下的<code>canal.properties</code>文件中指定所添加的实例名称。这里我们就使用默认的实例即可。</p><p>修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># position info</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># listener database name</span><br><span class="line">canal.instance.defaultDatabaseName=delaytask</span><br><span class="line"># table regex</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure><p>最后一行表示设置监听的数据库表信息，可以监听多个表，多个之间使用逗号进行分割，此处设置的是监听所有的表。</p><h3 id="修改RabbitMQ配置信息"><a href="#修改RabbitMQ配置信息" class="headerlink" title="修改RabbitMQ配置信息"></a>修改RabbitMQ配置信息</h3><p>由于Canal服务端默认的传输方式为tcp，因此我们需要在canal的配置文件中设置RabbitMQ相关的信息。</p><p>第一步，修改<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">#########     RabbitMQ     #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host = /</span><br><span class="line">rabbitmq.exchange = canal.exchange</span><br><span class="line">rabbitmq.username = guest</span><br><span class="line">rabbitmq.password = guest</span><br><span class="line"># 是否持久化，2表示是</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure><p>第二步，修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mq config</span><br><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure><p>其实就是设置RabbitMQ路由的key，这样才能将信息准确路由到指定的队列里面。</p><p>第三步，在RabbitMQ中创建交换机和队列。接着我们需要在RabbitMQ中新建一个名为<code>canal.exchange</code>的交换机，注意这个名字必须与<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中设置的<code>rabbitmq.exchange</code>选项值保持一致。</p><p>第四步，新建一个名为<code>canal.queue</code>的队列，这个队列的名称随意，不过为了区分实际业务，建议此队列还是命名为<code>canal.queue</code>。</p><p>第五步，定义交换机和队列之间的绑定键，名称为<code>canal.routing.key</code>，注意这个名字必须与<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中设置的<code>canal.mq.topic</code>选项值保持一致：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-6bb6ed9d27412ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="启动各个服务"><a href="#启动各个服务" class="headerlink" title="启动各个服务"></a>启动各个服务</h3><p>在完成上述准备工作后，接下来我们尝试启动MySQL，之后启动Canal服务端，只需直接双击bin目录下的<code>startup.bat</code>文件。或者在Canal的bin目录下打开终端，然后输入<code>start /min startup.bat</code>命令来启动Canal服务端：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-f17fef8ee5eeba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，这里有一个小坑，就是如果你的Java版本大于1.7，那么程序就会报错，因为此时永久代已经取消了，应该使用元空间。打开<code>startup.bat</code>文件，将其中的如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:PermSize=128m</span><br></pre></td></tr></table></figure><p>修改为如下后的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:MetaspaceSize=128m</span><br></pre></td></tr></table></figure><p>之后再重新执行<code>startup.bat</code>文件，进而启动Canal服务端。</p><h3 id="测试一下数据"><a href="#测试一下数据" class="headerlink" title="测试一下数据"></a>测试一下数据</h3><p>接下来使用如下命令往delaytask数据库中的<code>order_master</code>数据表里面新增一条信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (1, &#x27;2001&#x27;);</span><br></pre></td></tr></table></figure><p>然后查看一下RabbitMQ中的<code>canal.queue</code>队列里面的数据，可以看到里面已经有对应数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-db628944ef9fd5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这其实就是一个JSON字符串，格式化一下信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2001&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654495807000,</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654495807981,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个JOSN字符串中将用户执行的插入操作记录的非常清楚，如表名称、方法、参数、参数类型、参数值等。</p><p>既然服务端已经通过解析MySQL的binlog日志，并传输增量数据给消息中间件，那么接下来就是客户端监听MQ来获取JSON信息，并将其解析出来为后续业务逻辑服务。</p><h1 id="搭建客户端"><a href="#搭建客户端" class="headerlink" title="搭建客户端"></a>搭建客户端</h1><p>客户端就比较简单，就是消费Canal服务端传递过来的信息，而它传递的消息都存在了MQ中，因此客户端就只需监听<code>canal.queue</code>队列。</p><h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>由于MQ传递来的是JSON信息，因此接下来需要创建一个实体类来完成与JSON信息的数据绑定工作。新建一个名为CanalMessage的类，由于JSON中的data可能存在多种形式，因此可以将CanalMessage类定义为一个泛型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;String&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private String es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private String ts;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听MQ消息"><a href="#监听MQ消息" class="headerlink" title="监听MQ消息"></a>监听MQ消息</h3><p>接下来就是监听RabbitMQ中的<code>canal.queue</code>队列了，这样只要Canal服务端有数据推送过来就可以及时的消费掉。</p><p>简单起见，这里笔者就通过<code>@RabbitListener</code>来完成RabbitMQ中交换机、队列的声明和绑定工作。新建一个名为<code>CanalRabbitMQListener</code>的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 监听RabbitMQ中信息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings=&#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;,durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handlerCanalData(String message)&#123;</span><br><span class="line">        //message则是MQ中canal.queue中的消息</span><br><span class="line">        //将message消息转换为之前定义的CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class, true);</span><br><span class="line">        String databaseName = canalMessage.getDatabase();</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal监听，&#123;&#125;数据库的&#123;&#125;数据表发生变化，变化信息为&#123;&#125;&quot;,databaseName,tableName,message);</span><br><span class="line">        //其他后续的业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你还需要配置RabbitMQ的相关信息，可以在<code>application.properties</code>配置文件中新增如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=127.0.0.1</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>接下来我们启动项目，首先往<code>order_master</code>数据表中新增一条记录，命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (2, &#x27;2002&#x27;);</span><br></pre></td></tr></table></figure><p>可以看到此时项目控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Canal监听，delaytask数据库的order_master数据表发生变化，变化信息为：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2002&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654507483000,</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654507483543,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Canal客户端已经成功消费了MQ中的消息并接收到，后续开发者可根据实际业务进行后续逻辑开发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>在完整Kubernetes集群上部署微服务</title>
    <link href="http://envyzhan.asia/2022/07/08/2022-k8s-5-deploy-microservices-on-a-complete-cluster/"/>
    <id>http://envyzhan.asia/2022/07/08/2022-k8s-5-deploy-microservices-on-a-complete-cluster/</id>
    <published>2022-07-08T09:55:30.000Z</published>
    <updated>2022-09-12T08:47:31.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>接下来我们尝试在完整集群上部署微服务，首先来复习之前的一些命令以及学习一个新的命令，了解这些对于学习和熟悉Kubernetes有非常大的帮助。</p><h1 id="新的命令"><a href="#新的命令" class="headerlink" title="新的命令"></a>新的命令</h1><p>首先查看一下当前其他节点的运行状态信息，可以看到它们都是Ready状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get node</span><br><span class="line">NAME             STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.51.121   Ready     &lt;none&gt;    4h        v1.9.0</span><br><span class="line">192.168.51.123   Ready     &lt;none&gt;    4h        v1.9.0</span><br></pre></td></tr></table></figure><p>再来查看一下services，可以看到这里有一个Kubernetes默认的services：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get svc</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.68.0.1    &lt;none&gt;        443/TCP   1d</span><br></pre></td></tr></table></figure><p>再来查看一下pods，正常应该就是没有的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>接下来我们尝试通过<code>kubectl run</code>命令在k8s集群中部署一个命名为<code>kubernetes-bootcamp</code>的应用，Docker镜像通过<code>--image</code>指定，<code>--port</code>设置应用对外服务的端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl run kubernetes-bootcamp --image=jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; created</span><br></pre></td></tr></table></figure><p>然后我们查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           41s</span><br></pre></td></tr></table></figure><p>才是再来查看一下pods，可以发现这里就创建了一个pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ssf78   1/1       Running   0          1m</span><br></pre></td></tr></table></figure><p>然后我们尝试查看一下某个pods中的运行日志信息，可使用<code>kubectl logs +pods名称</code>命令来进行查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl logs kubernetes-bootcamp-6b7849c495-ssf78</span><br><span class="line">Kubernetes Bootcamp App Started At: 2021-09-04T13:12:56.352Z | Running On:  kubernetes-bootcamp-6b7849c495-ssf78</span><br></pre></td></tr></table></figure><p>也可以借鉴docker logs命令，在上述kubectl logs命令后面添加<code>-f</code>参数来跟踪日志，这样一旦有刷新日志就会实时的刷新出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl logs kubernetes-bootcamp-6b7849c495-ssf78 -f</span><br></pre></td></tr></table></figure><p>我们再来查看一下这个pods的详细信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe pods kubernetes-bootcamp-6b7849c495-ssf78</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4d4ad6b504184977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到它多了一个Mounts的配置信息，值为<code>/var/run/secrets/kubernetes.io/serviceaccount</code>，然后我们可以使用类似于docker中的exec命令来以终端方式进入到该pods中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl exec -it kubernetes-bootcamp-6b7849c495-ssf78 bash</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/# ls -l /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 13 Sep  4 13:12 ca.crt -&gt; ..data/ca.crt</span><br><span class="line">lrwxrwxrwx 1 root root 16 Sep  4 13:12 namespace -&gt; ..data/namespace</span><br><span class="line">lrwxrwxrwx 1 root root 12 Sep  4 13:12 token -&gt; ..data/token</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/# cd /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/var/run/secrets/kubernetes.io/serviceaccount# ls</span><br><span class="line">ca.crtnamespace  token</span><br><span class="line">root@kubernetes-bootcamp-6b7849c495-ssf78:/var/run/secrets/kubernetes.io/serviceaccount# </span><br></pre></td></tr></table></figure><p>可以看到这个<code>/var/run/secrets/kubernetes.io/serviceaccount</code>其实是一个目录，里面有三个文件，ca.crt是根证书文件，namespace的值为default，以及一个token文件。这些值是怎么来的呢？通过前面的学习可以知道它是与serviceaccount相关联的值。接下来我们看看当前是否存在serviceaccount，使用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get serviceaccount</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         1d</span><br></pre></td></tr></table></figure><p>也可以使用简写命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get sa</span><br><span class="line">NAME      SECRETS   AGE</span><br><span class="line">default   1         1d</span><br></pre></td></tr></table></figure><p>可以看到这里有一个默认的名为default的namespace，可以使用如下命令来查看它的详细信息，其中<code>-o</code>指令用于指定输出的格式，这里我们让信息以yaml格式进行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get sa -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  kind: ServiceAccount</span><br><span class="line">  metadata:</span><br><span class="line">    creationTimestamp: 2022-09-03T10:56:39Z</span><br><span class="line">    name: default</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;142&quot;</span><br><span class="line">    selfLink: /api/v1/namespaces/default/serviceaccounts/default</span><br><span class="line">    uid: 16487d73-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">  secrets:</span><br><span class="line">  - name: default-token-tq5m2</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure><p>你要是以json格式进行输出，这也是可以的。可以看到上面有一个名为<code>secrets.name</code>的配置项，它的值为default-token-tq5m2。开发者也可以使用如下命令查看一下当前所有的secrets：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get secrets</span><br><span class="line">NAME                  TYPE                                  DATA      AGE</span><br><span class="line">default-token-tq5m2   kubernetes.io/service-account-token   3         1d</span><br></pre></td></tr></table></figure><p>然后我们查看一下这个secrets的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get secrets -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">items:</span><br><span class="line">- apiVersion: v1</span><br><span class="line">  data:</span><br><span class="line">    ca.crt: ca.crt文件的内容</span><br><span class="line">    namespace: ZGVmYXVsdA==</span><br><span class="line">    token: token的值</span><br><span class="line">  kind: Secret</span><br><span class="line">  metadata:</span><br><span class="line">    annotations:</span><br><span class="line">      kubernetes.io/service-account.name: default</span><br><span class="line">      kubernetes.io/service-account.uid: 16487d73-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">    creationTimestamp: 2021-09-03T10:56:39Z</span><br><span class="line">    name: default-token-tq5m2</span><br><span class="line">    namespace: default</span><br><span class="line">    resourceVersion: &quot;139&quot;</span><br><span class="line">    selfLink: /api/v1/namespaces/default/secrets/default-token-tq5m2</span><br><span class="line">    uid: 164a148f-2b77-11ed-85ff-000c29e3dc2b</span><br><span class="line">  type: kubernetes.io/service-account-token</span><br><span class="line">kind: List</span><br><span class="line">metadata:</span><br><span class="line">  resourceVersion: &quot;&quot;</span><br><span class="line">  selfLink: &quot;&quot;</span><br></pre></td></tr></table></figure><p>这其实就和我们之前在<code>/var/run/secrets/kubernetes.io/serviceaccount</code>目录中所看到的三个文件是一一对应的，相当于将这个secret赋给了每一个pod。这就说明如果APIServer的<code>kube-apiserver.service</code>文件中的<code>admission-control</code>配置项，如果配置了ServiceAccount，那么它就会在default这个namespace下创建一个默认的serviceaccount，然后每个pod在启动的时候会将这个service中的secret以文件的形式挂载到pod中。有了这些挂载的文件之后，我们的pod就可以通过https的方式去访问APIServer，也就是说让pod可以通过APIServer的认证。</p><p>接下来继续学习Kubernetes，回到<code>/home/envy/services</code>目录，可以看到里面有三个文件，这是之前我们创建的三个用于配置对应信息的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# ls -l /home/envy/services/</span><br><span class="line">-rw-r--r-- 1 root root 274 8月  31 21:51 nginx-deployment.yaml</span><br><span class="line">-rw-r--r-- 1 root root 151 8月  31 21:24 nginx-pod.yaml</span><br><span class="line">-rw-r--r-- 1 root root 174 9月   2 21:47 nginx-service.yaml</span><br></pre></td></tr></table></figure><p>之前我们创建对应的deployment、pod和service时，使用了<code>kubectl create</code>命令，接下来我们尝试使用新的命令<code>kubectl apply</code>。我们利用<code>kubectl apply</code>来创建一个pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure><p>再来看一下当前所有的pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ssf78   1/1       Running   0          1h</span><br><span class="line">nginx                                  1/1       Running   0          4m</span><br></pre></td></tr></table></figure><p>然后查看一下名为nginx的pod的详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl describe pods nginx</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2b90a2488a3badb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到相比于kubectl create命令，它多了一个Annotations，里面记录的是最近一次的修改，会将修改的内容添加到里面，你会发现这个命令并没有将完整的修改内容都显示全，如果你想显示完全，可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods nginx -o json</span><br><span class="line">&quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.7.9\&quot;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;ports\&quot;:[&#123;\&quot;containerPort\&quot;:80&#125;]&#125;]&#125;&#125;\n&quot;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到这里面是我们上一次应用的完整配置，它起到了一个记录的功能，会将最近一次文件的配置内容放到annotations中进行存储，这样当应用出现问题的时候，它作为应用回滚的依据。还有一个区别，就是在使用<code>kubectl create</code>命令的时候，如果应用已经存在，那么必须将该应用删除，才能重新创建。而<code>kubectl apply</code>命令并不会重新去创建应用，而是会在之前应用的基础上进行修改。</p><p>举个例子，我们想创建一个基于nginx1.13版本的nginx-pod，此时该如何操作呢？可以使用<code>kubectl apply</code>命令，首先将<code>nginx-pod.yaml</code>文件中的nginx镜像版本由1.7.9修改为1.13：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: nginx</span><br><span class="line">      image: nginx:1.13</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br></pre></td></tr></table></figure><p>接着执行如下命令来创建nginx-pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; configured</span><br></pre></td></tr></table></figure><p>然后使用如下命令来查看一下是否真的更新成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods nginx -o json</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;annotations&quot;: &#123;</span><br><span class="line">        &quot;kubectl.kubernetes.io/last-applied-configuration&quot;: &quot;&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;kind\&quot;:\&quot;Pod\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;image\&quot;:\&quot;nginx:1.13\&quot;,\&quot;name\&quot;:\&quot;nginx\&quot;,\&quot;ports\&quot;:[&#123;\&quot;containerPort\&quot;:80&#125;]&#125;]&#125;&#125;\n&quot;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>当然了，更新镜像还有之前使用的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl set image pods nginx nginx=nginx:1.7.9</span><br><span class="line">pod &quot;nginx&quot; image updated</span><br></pre></td></tr></table></figure><p>再来看一下容器中的镜像，可以看到此时容器中的镜像已经变成1.7.9，但是Annotations中显示的镜像版本还是1.13，这是因为这个Annotations中始终保持的是配置文件中最新的配置，而无论开发者使用命令做任何修改，Annotations中始终都不会进行显示，这里只会显示配置文件中的修改。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cc966d8f1931319b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们使用<code>kubectl apply</code>来创建nginx-deployment和nginx-service这两个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl apply -f nginx-deployment.yaml </span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br><span class="line">[root@server02 services]# kubectl apply -f nginx-service.yaml </span><br><span class="line">service &quot;nginx-service&quot; created</span><br></pre></td></tr></table></figure><p>接下来我们尝试使用NodeIP+NodePort方式来访问其他的Node节点，这是可以访问的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes      ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          2d</span><br><span class="line">nginx-service   NodePort    10.68.199.24   &lt;none&gt;        8080:20000/TCP   4m</span><br></pre></td></tr></table></figure><p>然后我们使用另一种方式，就是通过进入到容器中使用CLUSTER_IP+ServicePort这一方式来访问。由于这里需要进入到一个容器中，如果现在没有容器，可以使用<code>kubectl run busybox --rm=true --image=busybox --restart=Never --tty -i</code>来启动一个busybox镜像，这个镜像是专门用于测试，它启动完之后提供一些命令，就相当于运行在这个集群中的一个沙盒。<code> --rm=true</code>参数表示在结束的时候会自动删除，<code>--image=busybox</code>用于指定镜像为busybox，<code>--restart=Never</code>表示重启方案，此处设置从来不重启，即退出后就不重启。<code>--tty</code>表示开启一个伪终端，<code> -i</code>表示获取到标准输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl run busybox --rm=true --image=busybox --restart=Never --tty -i</span><br><span class="line">If you don&#x27;t see a command prompt, try pressing enter.</span><br><span class="line">/ # </span><br><span class="line">/ # </span><br><span class="line">/ # ls</span><br><span class="line">bin   dev   etc   home  proc  root  sys   tmp   usr   var</span><br></pre></td></tr></table></figure><p>这样我们就进入了这个容器，我们可以使用wget命令，将wget输出定位到标准输出中，然后我们使用CLUSTER_IP+ServicePort这一方式来访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -qO - 10.68.199.24:8080</span><br></pre></td></tr></table></figure><p>如果出现nginx相关的页面信息，这就说明kube-proxy是正常的，然后我们将上面的IP修改为services的命令看看是否也能成功访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ # wget -qO - nginx-service:8080</span><br></pre></td></tr></table></figure><p>如果也出现nginx相关的页面信息，这就说明kube-dns也是正常的。</p><h1 id="微服务项目部署"><a href="#微服务项目部署" class="headerlink" title="微服务项目部署"></a>微服务项目部署</h1><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul><li>消息服务：message-service</li><li>课程dubbo服务：course-dubbo-service</li><li>课程web服务：course-edge-service</li><li>用户thrift服务：user-thrift-service</li><li>用户web服务：user-edge-service</li><li>API网关：api-gateway</li></ul><p>如果将它们放到kunernetes集群中运行，我们需要考虑哪些问题呢？<br><strong>（1）哪些服务适合单独成一个pod？哪些服务适合在一个pod中？</strong><br>在Kubernetes中，最小的单元是pod，一个pod中可以包含一个或者多个容器，因此我们需要考虑我们有哪些服务是适合放在同一个pod中，还有哪些是适合单独成一个pod。如果将多个服务放在一个pod中，会有什么特征呢？毫无疑问两者之间的访问效率肯定是很高的，它们之间通过本机localhost就可以访问到处于同一个pod中的服务。</p><p>消息服务与其他的服务关联程度不大，而且所有的服务都可能去调用消息服务，因此它和谁放在一起都不太合适，可以将其单独做成一个pod。然后课程的dubbo服务和web服务这两个是紧密相关的，因为课程的dubbo服务大部分都是由web服务去调用的，两者的交换频率肯定会很高。因此课程的dubbo服务和web服务这两个可以放在同一个pod中。同理用户的thrift服务和web服务也应该放在同一个pod中。api网关可能会调用很多的服务，因此它并不适合和其他的服务放在一起，所以将其放在一个单独的pod中。</p><p><strong>（2）在一个pod里面的服务如何彼此访问？它们的服务如何对外提供服务？</strong><br>举个例子，如课程的dubbo服务和web服务，它们都在同一个pod中，两者是如何进行彼此通信的呢？可以通过本机的端口直接去访问，这是没问题的。在前面我们学习过service，知道我们的服务可以通过CLUSTER_IP或者通过kube-dns根据名字来进行解析，让我们的服务可以在集群内部进行访问，并且在一个service中可以同时定义多个端口，其实就是允许我们同时对外提供多个服务。这一点从技术上来说也是没有任何问题的。</p><p><strong>（3）单独的pod如何对外提供服务？</strong><br>单独的pod其实就更简单了，直接通过CLUSTER_IP或者通过kube-dns根据名字来进行解析，就可以直接提供集群内的服务了。</p><p><strong>（4）哪个服务作为整个服务的入口，入口服务如何对外提供服务？</strong><br>最后比较特殊的就是API网关，它作为整个服务的入口，为了对外提供服务，它需要提供一个NodePort，这样就让我们在集群外，也可以访问到这个服务，这就是api-gateway需要对外提供服务的方式，即它需要使用到NodePort。</p><h3 id="搞定配置"><a href="#搞定配置" class="headerlink" title="搞定配置"></a>搞定配置</h3><p>配置的模板已经设置好了，就是按照前面所说的服务划分，但是开发者还需要做一些配置，将这些配置文件中的变量进行配置。进入到主节点中，我们先进入到如下目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/service-config/</span><br></pre></td></tr></table></figure><p>然后查看一下当前的目录文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">api-gateway.yaml     message-service.yaml</span><br><span class="line">course-service.yaml  user-service.yaml</span><br><span class="line">#替换变量 - (hub.envyzhan.com:9080是我的环境的镜像仓库地址，大家修改为各自的仓库)</span><br><span class="line">$ sed -i &#x27;s/&#123;&#123;HUB&#125;&#125;/hub.envyzhan.com:9080/g&#x27; *</span><br></pre></td></tr></table></figure><p>接下来查看各个文件的信息，<code>api-gateway.yaml</code>配置文件内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: api-gateway</span><br><span class="line">  name: api-gateway</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    nodePort: 80</span><br><span class="line">  selector:</span><br><span class="line">    app: api-gateway</span><br><span class="line">  type: NodePort</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: api-gateway-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: api-gateway</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: api-gateway</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/api-gateway-zuul:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure><p>接着我们再来看一下<code>message-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: message-service</span><br><span class="line">  name: message-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 9090</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9090</span><br><span class="line">  selector:</span><br><span class="line">    app: message-service</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: message-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: message-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: message-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/message-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br></pre></td></tr></table></figure><p>可以看到这个Service的类型是ClusterIP，因为它不需要对外提供服务，只需在集群内提供服务。</p><p>再来看一下<code>course-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: course-service</span><br><span class="line">  name: course-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8081</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8081</span><br><span class="line">  selector:</span><br><span class="line">    app: course-service</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: course-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: course-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: course-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/course-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 20880</span><br><span class="line">      - name: course-edge-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/course-edge-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8081</span><br></pre></td></tr></table></figure><p>可以看到里面有两个容器，一个是course-service，容器端口为20880，另一个则是course-edge-service，容器端口为8081，这个与名为course-service的service所指定的service端口是一致的。这是因为这个8081是在集群内提供给其他服务所使用的，而这个20880它只需要给这个course-edge-service使用就可以，因为别的服务并没有使用到它，也没有依赖它，因此上面我们只需指定一个端口。</p><p>最后再来看一下这个<code>user-service.yaml</code>配置文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: user-service</span><br><span class="line">  name: user-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: user-edge-service-port</span><br><span class="line">    port: 8082</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8082</span><br><span class="line">  - name: user-service-port</span><br><span class="line">    port: 7911</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 7911</span><br><span class="line">  selector:</span><br><span class="line">    app: user-service</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: user-service-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: user-service</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: user-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/user-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 7911</span><br><span class="line">      - name: user-edge-service</span><br><span class="line">        image: hub.envyzhan.com:9080/micro-service/user-edge-service:latest</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8082</span><br></pre></td></tr></table></figure><p>可以看到这个名为user-service的service里面提供了两个port，一个是user-edge-service-port，端口号为8082；另一个则是user-service-port，端口号为7911，注意定义多个port时就需要开发者指定名称。一个是方便我们记忆，另一个则是方便后来维护的人，这些port分别用于做什么事情。这就表明这两个port在集群中，都是提供给集群内其他port来使用的。后面的user-service-deployment中也是有两个容器，一个是user-service，另一个则是user-edge-service。</p><p>可以看到user-service和course-service这两个service的唯一区别在于，course-service只定义了一个端口用于对外提供服务，而user-service却需要提供两个端口，且这两个端口都需要对外提供服务。</p><h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>（1）启动Harbor。由于在前面我们已经将harbor设置为开机自启动，因此这里会自己启动。<br>（2）启动MySQL。进入到<code>/opt/mysql</code>目录，在里面执行其中的<code>start.sh</code>脚本文件即可启动MySQL。<br>（3）启动Redis。进入到<code>/opt/redis</code>目录，在里面执行其中的<code>start.sh</code>脚本文件即可启动Redis。<br>（4）启动Zookeeper。由于在前面我们已经将Zookeeper设置为开机自启动，因此这里会自己启动。</p><h1 id="梳理代码"><a href="#梳理代码" class="headerlink" title="梳理代码"></a>梳理代码</h1><p><strong>（1）api-gateway-zuul微服务配置信息改造。</strong>api-gateway-zuul微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: gateway-zuul-service</span><br><span class="line">  port: 8080</span><br><span class="line"># zuul相关配置信息</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    course:</span><br><span class="line">      path: /course/**</span><br><span class="line">      url: http://course-edge-service:8023/course/</span><br><span class="line">    user:</span><br><span class="line">      path: /user/**</span><br><span class="line">      url: http://user-edge-service:8022/user/</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64bbb1922dbb23e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b8aba803fb800f22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: gateway-zuul-service</span><br><span class="line">  port: 8080</span><br><span class="line"># zuul相关配置信息</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    course:</span><br><span class="line">      path: /course/**</span><br><span class="line">      url: http://course-service:8081/course/</span><br><span class="line">    user:</span><br><span class="line">      path: /user/**</span><br><span class="line">      url: http://user-service:8082/user/</span><br></pre></td></tr></table></figure><p><strong>（2）course-dubbo-service微服务配置信息改造。</strong>course-dubbo-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.51.100:3306/db_course</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://192.168.51.100:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">#    host: 192.168.51.6</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br></pre></td></tr></table></figure><p>通过对比发现这个服务的配置信息无需进行修改。<br><strong>（3）course-edge-service微服务配置信息改造。</strong>course-edge-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: course-edge-service</span><br><span class="line">  port: 8023</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://$&#123;zookeeper.url&#125;:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">#    host: 192.168.51.6</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: course-edge-service</span><br><span class="line">  port: 8023</span><br><span class="line"># dubbo相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: course-service</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://192.168.51.100:2181</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: 20880</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.envy.course</span><br><span class="line">user:</span><br><span class="line">  edge:</span><br><span class="line">    service:</span><br><span class="line">      addr: user-service:8082</span><br></pre></td></tr></table></figure><p><strong>（4）user-edge-service微服务配置信息改造。</strong>user-edge-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-edge-service</span><br><span class="line">  port: 8022</span><br><span class="line"></span><br><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 短信服务的IP和端口号</span><br><span class="line">  message:</span><br><span class="line">    ip: message-service</span><br><span class="line">    port: 9090</span><br><span class="line"></span><br><span class="line"># Redis配置信息</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: $&#123;redis.url&#125;</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 30000</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-edge-service</span><br><span class="line">  port: 8022</span><br><span class="line"></span><br><span class="line"># 用户服务的IP和端口号</span><br><span class="line">thrift:</span><br><span class="line">  user:</span><br><span class="line">    ip: user-service</span><br><span class="line">    port: 7911</span><br><span class="line"># 短信服务的IP和端口号</span><br><span class="line">  message:</span><br><span class="line">    ip: message-service</span><br><span class="line">    port: 9090</span><br><span class="line"></span><br><span class="line"># Redis配置信息</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.51.100</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 30000</span><br></pre></td></tr></table></figure><p><strong>（5）user-thrift-service微服务配置信息改造。</strong>user-thrift-service微服务原有的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-thrift-service</span><br><span class="line">  port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://$&#123;mysql.url&#125;:3306/db_user</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br></pre></td></tr></table></figure><p>修改之后的<code>application.yml</code>配置文件的信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 服务名称和端口号</span><br><span class="line">server:</span><br><span class="line">  name: user-thrift-service</span><br><span class="line">  port: 7911</span><br><span class="line"># 数据源的配置信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://192.168.51.100:3306/db_user</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br></pre></td></tr></table></figure><h3 id="重新打包镜像"><a href="#重新打包镜像" class="headerlink" title="重新打包镜像"></a>重新打包镜像</h3><p>将下来我们需要将之前我们修改过配置文件的服务，都重新打包成镜像，这个过程在前面都已经进行了介绍，这里就不过多介绍了。</p><h3 id="删除现有的服务"><a href="#删除现有的服务" class="headerlink" title="删除现有的服务"></a>删除现有的服务</h3><p>首先进入到主节点，查看一下当前所有的服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get svc</span><br><span class="line">NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes      ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          3d</span><br><span class="line">nginx-service   NodePort    10.68.199.24   &lt;none&gt;        8080:20000/TCP   1d</span><br></pre></td></tr></table></figure><p>考虑到后面这个nginx-service可能会影响到现有的服务，这里我们将这个服务给删除掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete svc nginx-service</span><br><span class="line">service &quot;nginx-service&quot; deleted</span><br></pre></td></tr></table></figure><p>同理查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           2d</span><br><span class="line">nginx-deployment      2         2         2            2           1d</span><br></pre></td></tr></table></figure><p>删除上述两个deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete deploy nginx-deployment</span><br><span class="line">deployment &quot;nginx-deployment&quot; deleted</span><br><span class="line">[root@server02 service-config]# kubectl delete deploy kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; deleted</span><br></pre></td></tr></table></figure><p>再来查看一下当前所有的pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get pods</span><br><span class="line">NAME      READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx     1/1       Running   0          1d</span><br></pre></td></tr></table></figure><p>删除这个名为nginx的pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl delete pod nginx</span><br><span class="line">pod &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure><p>接着进入到主节点所在机器，我们需要在它的<code>/etc/hosts</code>文件中新增一条映射信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.100 hub.envyzhan.com</span><br></pre></td></tr></table></figure><p>然后我们进入到<code>/home/envy/kubernetes-starter/service-config</code>目录，开始根据对应的配置文件创建对应的Service、Deployment。注意它们是有依赖关系的，因此创建顺序不能搞错，必须是【message-service.yaml】–&gt;【user-service.yaml】–&gt;【course-service.yaml】–&gt;【api-gateway.yaml】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl apply -f message-service.yaml </span><br><span class="line">service &quot;message-service&quot; created</span><br><span class="line">deployment &quot;message-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f user-service.yaml </span><br><span class="line">service &quot;user-service&quot; created</span><br><span class="line">deployment &quot;user-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f course-service.yaml </span><br><span class="line">service &quot;course-service&quot; created</span><br><span class="line">deployment &quot;course-service-deployment&quot; created</span><br><span class="line"></span><br><span class="line">[root@server02 service-config]# kubectl apply -f api-gateway.yaml </span><br><span class="line">deployment &quot;api-gateway-deployment&quot; created</span><br><span class="line">The Service &quot;api-gateway&quot; is invalid: spec.ports[0].nodePort: Invalid value: 80: provided port is not in the valid range. The range of valid ports is 20000-40000</span><br></pre></td></tr></table></figure><p>可以看到我们在创建api-gateway这一NodePort时出现问题，原因是我们在APIServer中规定了节点端口必须在2万-4万之间，而此处的80端口是不在里面，所以就抛出异常。此时我们可以修改APIServer的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# vi /lib/systemd/system/kube-apiserver.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-51e96c44aa35c6cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>我们可以将其中的2万-4万修改为80-4万，这样就好了，当然你可以让api-gateway它的NodePort修改为2万-4万之间的值，只是此时用起来就不太方便了。之后依次执行如下命令来重启APIServer：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# systemctl daemon-reload</span><br><span class="line">[root@server02 service-config]# systemctl restart kube-apiserver</span><br></pre></td></tr></table></figure><p>之后我们再次重新执行上述<code>kubectl apply -f api-gateway.yaml</code>命令，可以看到此时就不抛出异常了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl apply -f api-gateway.yaml </span><br><span class="line">service &quot;api-gateway&quot; created</span><br><span class="line">deployment &quot;api-gateway-deployment&quot; unchanged</span><br></pre></td></tr></table></figure><p>接着我们查看一下当前所有的service信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get svc</span><br><span class="line">NAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">api-gateway       NodePort    10.68.180.221   &lt;none&gt;        80:80/TCP           22s</span><br><span class="line">course-service    ClusterIP   10.68.54.94     &lt;none&gt;        8081/TCP            7m</span><br><span class="line">kubernetes        ClusterIP   10.68.0.1       &lt;none&gt;        443/TCP             3d</span><br><span class="line">message-service   ClusterIP   10.68.24.72     &lt;none&gt;        9090/TCP            7m</span><br><span class="line">user-service      ClusterIP   10.68.77.158    &lt;none&gt;        8082/TCP,7911/TCP   7m</span><br></pre></td></tr></table></figure><p>再来查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get deploy</span><br><span class="line">NAME                         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">api-gateway-deployment       1         1         1            0           8m</span><br><span class="line">course-service-deployment    1         1         1            0           9m</span><br><span class="line">message-service-deployment   1         1         1            0           9m</span><br><span class="line">user-service-deployment      1         1         1            0           9m</span><br></pre></td></tr></table></figure><p>可以看到现在AVAILABLE的个数为0，表示一个都无法使用。那我们查看当前所有的pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl get pods -o wide</span><br><span class="line">NAME                                          READY     STATUS             RESTARTS   AGE       IP              NODE</span><br><span class="line">api-gateway-deployment-68f4694877-2s8nv       0/1       ImagePullBackOff   0          14m       172.20.188.9    192.168.51.121</span><br><span class="line">course-service-deployment-ff6f7d4b8-snm7l     0/2       ImagePullBackOff   0          14m       172.20.40.198   192.168.51.123</span><br><span class="line">message-service-deployment-64c49f8ff8-48r8g   0/1       ImagePullBackOff   0          14m       172.20.188.7    192.168.51.121</span><br><span class="line">user-service-deployment-8674c798b7-8bbck      0/2       ImagePullBackOff   0          14m       172.20.188.8    192.168.51.12</span><br></pre></td></tr></table></figure><p>可以看到原来它们都在拉取镜像，这个速度有点慢。为了保险起见，接下来我们查看一下日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 service-config]# kubectl logs -f api-gateway-deployment-68f4694877-2s8nv</span><br><span class="line">Error from server (BadRequest): container &quot;api-gateway&quot; in pod &quot;api-gateway-deployment-68f4694877-2s8nv&quot; is waiting to start: trying and failing to pull image</span><br></pre></td></tr></table></figure><p>可以看到镜像拉取失败，我们尝试登陆到harbor镜像仓库上<code>docker login http://hub.envyzhan.com:9080</code>，可以看到错误信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get &quot;https://hub.envyzhan.com:9080/v2/&quot;: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>在主节点上的<code>/etc/docker/daemon.json</code>文件中新增一个不安全镜像仓库的配置信息，注意值必须是数组形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;],</span><br><span class="line"> &quot;insecure-registries&quot;: [&quot;hub.envyzhan.com:9080&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们依次执行如下命令来重新启动docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 docker]# systemctl daemon-reload</span><br><span class="line">[root@server02 docker]# systemctl restart docker</span><br></pre></td></tr></table></figure><p>之后我们再重新执行上述<code>kubectl apply -f</code>命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;接下来我们尝试在完整集群上部署微服务，首先来复习之前的一些命令以及学习一个新的命令，了解这些对于学习和熟悉Kubernete</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes完整集群搭建</title>
    <link href="http://envyzhan.asia/2022/07/06/2022-k8s-4-complete-cluster-construction/"/>
    <id>http://envyzhan.asia/2022/07/06/2022-k8s-4-complete-cluster-construction/</id>
    <published>2022-07-06T09:55:30.000Z</published>
    <updated>2022-09-12T08:45:54.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完整集群部署"><a href="#完整集群部署" class="headerlink" title="完整集群部署"></a>完整集群部署</h1><p>本篇尝试对之前使用的基础集群进行改造和升级，使其成为一个比较完整的Kubernetes集群。</p><h1 id="理解认证授权"><a href="#理解认证授权" class="headerlink" title="理解认证授权"></a>理解认证授权</h1><h3 id="为什么要认证"><a href="#为什么要认证" class="headerlink" title="为什么要认证"></a>为什么要认证</h3><p>想理解认证，我们得从认证用于解决什么问题、防止什么问题的发生入手？<br>防止什么问题呢？是防止有人入侵你的集群，root你的机器后我们集群依然安全吗？不是吧，root都到手了，那就为所欲为，防不胜防了。</p><p>其实网络安全本身就是为了解决在某些假设成立的条件下如何防范的问题。比如一个非常重要的假设就是两个节点或者ip之间的通讯网络是不可信任的，可能会被第三方窃取，也可能会被第三方篡改。就像我们上学时候给心仪的女孩传纸条，传送的过程可能会被别的同学偷看，甚至内容可能会从我喜欢你修改成我不喜欢你了。当然这种假设不是随便想出来的，而是从网络技术现状和实际发生的问题中发现、总结出来的。kubernetes的认证也是从这个问题出发来实现的。</p><h3 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h3><p>为了解决上面说的问题，kubernetes并不需要自己想办法，毕竟是网络安全层面的问题，是每个服务都会遇到的问题，业内也有成熟的方案来解决。这里我们一起了解一下业内方案和相关的概念。<br>（1）对称加密/非对称加密。（2）SSL/TLS。</p><h3 id="什么是授权"><a href="#什么是授权" class="headerlink" title="什么是授权"></a>什么是授权</h3><p>授权的概念就简单多了，就是什么人具有什么样的权限，一般通过角色作为纽带把他们组合在一起。也就是一个角色一边拥有多种权限，一边拥有多个人。这样就把人和权限建立了一个关系。</p><h1 id="kubernetes的认证授权"><a href="#kubernetes的认证授权" class="headerlink" title="kubernetes的认证授权"></a>kubernetes的认证授权</h1><p>Kubernetes集群的所有操作基本上都是通过kube-apiserver这个组件进行的，它提供HTTP RESTful形式的API供集群内外客户端调用。需要注意的是，认证授权过程只存在HTTPS形式的API中。也就是说，如果客户端使用HTTP连接到kube-apiserver，此时是不会进行认证授权的。因此开发者可以这样设置，在集群内部组件间通信使用HTTP，集群外部则使用HTTPS，这样既增加了安全性，也不至于太复杂。</p><p>对APIServer的访问要经过的三个步骤，前面两个是认证和授权，第三个是 Admission Control，它也能在一定程度上提高安全性，不过更多是资源管理方面的作用。</p><h3 id="kubernetes的认证"><a href="#kubernetes的认证" class="headerlink" title="kubernetes的认证"></a>kubernetes的认证</h3><p>kubernetes提供了多种认证方式，比如客户端证书、静态token、静态密码文件、ServiceAccountTokens等等。开发者可以同时使用一种或多种认证方式，只要通过任何一种都被认为是认证通过。下面我们就来认识几个常见的认证方式。<br>（1）客户端证书认证。客户端证书认证（TLS双向认证），也就是服务器客户端互相验证证书的正确性，只有在双方都正确的情况下协调通信加密方案。 为了使用这个方案，api-server需要用<code>--client-ca-file</code>选项来开启。</p><p>（2）引导Token。当我们有非常多的node节点时，手动为每个node节点配置TLS认证比较麻烦，这时就可以用到引导token的认证方式，前提是需要在api-server开启<code>experimental-bootstrap-token-auth</code>特性，客户端的token信息与预先定义的token匹配认证通过后，自动为node颁发证书。当然引导token是一种机制，可以用到各种场景中。</p><p>（3）Service Account Tokens认证。有些情况下，我们希望在pod内部访问api-server，获取集群的信息，甚至对集群进行改动。针对这种情况，kubernetes提供了一种特殊的认证方式：<code>Service Account</code>。 Service Account 和 pod、service、deployment 一样，也是 kubernetes 集群中的一种资源，用户也可以创建自己的 Service Account。 ServiceAccount主要包含了三个内容：namespace、Token 和 CA。namespace 指定了pod 所在的 namespace，CA 用于验证apiserver 的证书，token 用作身份验证。它们都通过mount的方式保存在 pod 的文件系统中。</p><h3 id="kubernetes的授权"><a href="#kubernetes的授权" class="headerlink" title="kubernetes的授权"></a>kubernetes的授权</h3><p>Kubernetes1.6版本中新增角色访问控制机制（Role-Based Access，RBAC），目的是让集群管理员可以针对特定使用者或服务账号的角色，进行更精确的资源访问控制。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。 目前 Kubernetes 中有一系列的鉴权机制，因为Kubernetes社区的投入和偏好，相对于其它鉴权机制而言，RBAC是更好的选择。具体RBAC是如何体现在kubernetes系统中的我们会在后面的部署中逐步的深入了解。</p><h3 id="kubernetes的AdmissionControl"><a href="#kubernetes的AdmissionControl" class="headerlink" title="kubernetes的AdmissionControl"></a>kubernetes的AdmissionControl</h3><p>AdmissionControl （准入控制）本质上为一段准入代码，在对kubernetes api的请求过程中，顺序如下：先经过认证和授权，然后执行准入操作，最后对目标对象进行操作。这个准入代码在api-server中，而且必须被编译到二进制文件中才能被执行。 在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的error信息。</p><p> 常用组件（控制代码）如下：<br>（1）AlwaysAdmit：允许所有请求。<br>（2）AlwaysDeny：禁止所有请求，多用于测试环境。<br>（3）ServiceAccount：它将serviceAccounts实现了自动化，它会辅助serviceAccount做一些事情，比如如果pod没有serviceAccount属性，它会自动添加一个default，并确保pod的serviceAccount始终存在。<br>（4）LimitRanger：它会观察所有的请求，以确保没有违反已经定义好的约束条件，这些条件定义在namespace中LimitRange对象中。如果在kubernetes中使用LimitRange对象，则必须使用这个插件。<br>（5）NamespaceExists：它会观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h3 id="停止原有kubernetes相关服务"><a href="#停止原有kubernetes相关服务" class="headerlink" title="停止原有kubernetes相关服务"></a>停止原有kubernetes相关服务</h3><p>在开始之前，我们需要先将基础版本的集群停掉，包括service，deployments，pods以及运行的所有kubernetes组件，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#删除master节点上自己创建的各种组件</span><br><span class="line">#删除services</span><br><span class="line">$ kubectl delete services kubernetes-bootcamp</span><br><span class="line">$ kubectl delete services nginx-service</span><br><span class="line">#删除deployments</span><br><span class="line">$ kubectl delete deploy kubernetes-bootcamp</span><br><span class="line">$ kubectl delete deploy nginx-deployment</span><br><span class="line">#删除pods</span><br><span class="line">$ kubectl delete pod nginx</span><br><span class="line"></span><br><span class="line">#停掉worker节点的服务</span><br><span class="line">$ service kubelet stop &amp;&amp; rm -fr /var/lib/kubelet/*</span><br><span class="line">$ service kube-proxy stop &amp;&amp; rm -fr /var/lib/kube-proxy/*</span><br><span class="line">$ service kube-calico stop</span><br><span class="line"></span><br><span class="line">#停掉master节点的服务</span><br><span class="line">$ service kube-calico stop</span><br><span class="line">$ service kube-scheduler stop</span><br><span class="line">$ service kube-controller-manager stop</span><br><span class="line">$ service kube-apiserver stop</span><br><span class="line">$ service etcd stop &amp;&amp; rm -fr /var/lib/etcd/*</span><br></pre></td></tr></table></figure><h3 id="生成配置（所有节点）"><a href="#生成配置（所有节点）" class="headerlink" title="生成配置（所有节点）"></a>生成配置（所有节点）</h3><p>和基础环境搭建一样，我们需要生成<code>kubernetes-with-ca</code>的所有相关配置文件。进入到<code>/home/envy/kubernetes-starter</code>目录，修改其中的config.properties配置文件为如下所示，其实也就是将ETCD_ENDPOINTS配置项中的http修改为了https，其他都没有变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#kubernetes二进制文件目录,eg: /home/envy/bin</span><br><span class="line">BIN_PATH=/home/envy/bin</span><br><span class="line"></span><br><span class="line">#当前节点ip, eg: 192.168.1.102</span><br><span class="line">NODE_IP=192.168.51.122</span><br><span class="line"></span><br><span class="line">#etcd服务集群列表, eg: http://192.168.1.102:2379</span><br><span class="line">#如果已有etcd集群可以填写现有的。没有的话填写：http://$&#123;MASTER_IP&#125;:2379 （MASTER_IP自行替换成自己的主节点ip）</span><br><span class="line">##如果用了证书，就要填写https://$&#123;MASTER_IP&#125;:2379 （MASTER_IP自行替换成自己的主节点ip）</span><br><span class="line">ETCD_ENDPOINTS=https://192.168.51.122:2379</span><br><span class="line"></span><br><span class="line">#kubernetes主节点ip地址, eg: 192.168.1.102</span><br><span class="line">MASTER_IP=192.168.51.122</span><br></pre></td></tr></table></figure><p>之后在该文件目录下执行如下命令来生成对应的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gen-config.sh with-ca</span><br></pre></td></tr></table></figure><p>生成的文件依旧是在target目录中，它会覆盖之前target目录中的文件。</p><h3 id="安装cfssl（所有节点）"><a href="#安装cfssl（所有节点）" class="headerlink" title="安装cfssl（所有节点）"></a>安装cfssl（所有节点）</h3><p>cfssl是非常好用的CA工具，我们用它来生成证书和秘钥文件。它安装过程比较简单，使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装wget工具</span><br><span class="line">$ yum install -y wget</span><br><span class="line">#下载</span><br><span class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">#修改为可执行权限</span><br><span class="line">$ chmod +x cfssl_linux-amd64 cfssljson_linux-amd64</span><br><span class="line">#移动到bin目录</span><br><span class="line">$ mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line">$ mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line">#验证</span><br><span class="line">$ cfssl version</span><br></pre></td></tr></table></figure><h3 id="生成根证书（主节点）"><a href="#生成根证书（主节点）" class="headerlink" title="生成根证书（主节点）"></a>生成根证书（主节点）</h3><p>根证书是证书信任链的根，各个组件通讯的前提是有一份大家都信任的证书（根证书），每个人使用的证书都是由这个根证书签发的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#所有证书相关的东西都放在这</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca</span><br><span class="line">#准备生成证书的配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/ca-config.json /etc/kubernetes/ca</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/ca-csr.json /etc/kubernetes/ca</span><br><span class="line">#生成证书和秘钥</span><br><span class="line">$ cd /etc/kubernetes/ca</span><br><span class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br><span class="line">#生成完成后会有以下文件（我们最终想要的就是ca-key.pem和ca.pem，一个秘钥，一个证书）</span><br><span class="line">$ ls</span><br><span class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</span><br></pre></td></tr></table></figure><h1 id="改造etcd（主节点执行）"><a href="#改造etcd（主节点执行）" class="headerlink" title="改造etcd（主节点执行）"></a>改造etcd（主节点执行）</h1><h3 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h3><p>etcd节点需要提供给其他服务访问，就要验证其他服务的身份，所以需要一个标识自己监听服务的server证书，当有多个etcd节点时，也需要client证书与etcd集群的其他节点交互，当然client和server也可以使用同一个证书，因为它们本质上没有区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#etcd证书放在这</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/etcd</span><br><span class="line">#准备etcd证书配置</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/etcd/etcd-csr.json /etc/kubernetes/ca/etcd/</span><br><span class="line">$ cd /etc/kubernetes/ca/etcd/</span><br><span class="line">#使用根证书(ca.pem)签发etcd证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br><span class="line"></span><br><span class="line">#跟之前类似生成三个文件etcd.csr是个中间证书请求文件，我们最终要的是etcd-key.pem和etcd.pem</span><br><span class="line">$ ls</span><br><span class="line">etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem</span><br></pre></td></tr></table></figure><h3 id="改造etcd服务"><a href="#改造etcd服务" class="headerlink" title="改造etcd服务"></a>改造etcd服务</h3><p>先比较一下增加认证的etcd配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装vim</span><br><span class="line">$ yum install -y vim</span><br><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/etcd.service kubernetes-with-ca/master-node/etcd.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-316a716346cb66ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到之前的<code>listen-client-urls</code>和<code>advertise-client-urls</code>现在都变成了https，同时新增了如下新的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--listen-peer-urls=https://&#123;&#123;NODE_IP&#125;&#125;:2380</span><br><span class="line">--initial-advertise-peer-urls=https://&#123;&#123;NODE_IP&#125;&#125;:2380</span><br><span class="line">--cert-file=/etc/kubernetes/ca/etcd/etcd.pem</span><br><span class="line">--key-file=/etc/kubernetes/ca/etcd/etcd-key.pem</span><br><span class="line">--peer-cert-file=/etc/kubernetes/ca/etcd/etcd.pem</span><br><span class="line">--peer-key-file=/etc/kubernetes/ca/etcd/etcd-key.pem</span><br><span class="line">--trusted-ca-file=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--peer-trusted-ca-file=/etc/kubernetes/ca/ca.pem</span><br></pre></td></tr></table></figure><h3 id="更新etcd服务"><a href="#更新etcd服务" class="headerlink" title="更新etcd服务"></a>更新etcd服务</h3><p>更新etcd服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/etcd.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service etcd start</span><br><span class="line">#验证etcd服务（endpoints自行替换）</span><br><span class="line">$ ETCDCTL_API=3 etcdctl \</span><br><span class="line">  --endpoints=https://192.168.51.122:2379  \</span><br><span class="line">  --cacert=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">  --cert=/etc/kubernetes/ca/etcd/etcd.pem \</span><br><span class="line">  --key=/etc/kubernetes/ca/etcd/etcd-key.pem \</span><br><span class="line">  endpoint health</span><br></pre></td></tr></table></figure><p>这样etcd我们就成功的改造完了，接下来我们继续改造其他的组件。</p><h1 id="改造api-server（主节点执行）"><a href="#改造api-server（主节点执行）" class="headerlink" title="改造api-server（主节点执行）"></a>改造api-server（主节点执行）</h1><h3 id="准备证书-1"><a href="#准备证书-1" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#定义api-server证书存放位置，由于api-server是核心，因此这里文件夹名为kubernetes，也可以叫apiserver，只是对应地方需要修改</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/kubernetes</span><br><span class="line">#准备apiserver证书配置</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/kubernetes/kubernetes-csr.json /etc/kubernetes/ca/kubernetes/</span><br><span class="line">$ cd /etc/kubernetes/ca/kubernetes/</span><br><span class="line">#使用根证书(ca.pem)签发kubernetes证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes</span><br><span class="line"></span><br><span class="line">#和之前类似，生成了三个文件，其中kubernetes.csr是个中间证书请求文件，我们最终要的是kubernetes-key.pem和kubernetes.pem</span><br><span class="line">$ ls</span><br><span class="line">kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem</span><br></pre></td></tr></table></figure><h3 id="改造api-server服务"><a href="#改造api-server服务" class="headerlink" title="改造api-server服务"></a>改造api-server服务</h3><p>先比较一下增加认证的api-server配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-apiserver.service kubernetes-with-ca/master-node/kube-apiserver.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ed5901de06be4363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这个<code>admission-control</code>选项多了一个ServiceAccount值（认证授权会使用到），同时<code>insecure-bind-address</code>参数值由0.0.0.0变成了127.0.0.1（不安全地址之前是所有IP都可以访问，现在只有本机才可以访问）以及<code>kubelet-https</code>参数值为true。同时新增了如下新的配置项，这些都是与认证和授权相关的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--bind-address=&#123;&#123;NODE_IP&#125;&#125;</span><br><span class="line">--authorization-mode=Node,RBAC  # 授权模式RBAC</span><br><span class="line">--runtime-config=rbac.authorization.k8s.io/v1</span><br><span class="line">--enable-bootstrap-token-auth</span><br><span class="line">--token-auth-file=/etc/kubernetes/ca/kubernetes/token.csv # 指定token-auth-file的地址，我们需要生成这个文件</span><br><span class="line">--tls-cert-file=/etc/kubernetes/ca/kubernetes/kubernetes.pem</span><br><span class="line">--tls-private-key-file=/etc/kubernetes/ca/kubernetes/kubernetes-key.pem</span><br><span class="line">--client-ca-file=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--service-account-key-file=/etc/kubernetes/ca/ca-key.pem</span><br><span class="line">--etcd-cafile=/etc/kubernetes/ca/ca.pem</span><br><span class="line">--etcd-certfile=/etc/kubernetes/ca/kubernetes/kubernetes.pem</span><br><span class="line">--etcd-keyfile=/etc/kubernetes/ca/kubernetes/kubernetes-key.pem</span><br><span class="line">--service-cluster-ip-range=10.68.0.0/16</span><br><span class="line">--service-cluster-ip-range=10.68.0.0/16</span><br><span class="line">--service-node-port-range=20000-40000</span><br><span class="line">--service-node-port-range=20000-40000</span><br><span class="line">--etcd-servers=&#123;&#123;ETCD_ENDPOINTS&#125;&#125;</span><br><span class="line">--etcd-servers=&#123;&#123;ETCD_ENDPOINTS&#125;&#125;</span><br><span class="line">--enable-swagger-ui=true</span><br><span class="line">--enable-swagger-ui=true</span><br><span class="line">--allow-privileged=true</span><br><span class="line">--allow-privileged=true</span><br><span class="line">--audit-log-maxage=30</span><br><span class="line">--audit-log-maxage=30</span><br></pre></td></tr></table></figure><p>注意，这里面有一个<code>bootstrap-token-auth</code>验证，而我们指定了<code>token-auth-file</code>的存储位置，因此将下来就是生成这个名为token.csv的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#生成随机token</span><br><span class="line">$ head -c 16 /dev/urandom | od -An -t x | tr -d &#x27; &#x27;</span><br><span class="line">49dd2bb99bc687e21dfa34e78fe098b1</span><br><span class="line"></span><br><span class="line">#按照固定格式写入token.csv，注意替换token内容</span><br><span class="line">$ echo &quot;49dd2bb99bc687e21dfa34e78fe098b1,kubelet-bootstrap,10001,\&quot;system:kubelet-bootstrap\&quot;&quot; &gt; /etc/kubernetes/ca/kubernetes/token.csv</span><br></pre></td></tr></table></figure><h3 id="更新api-server服务"><a href="#更新api-server服务" class="headerlink" title="更新api-server服务"></a>更新api-server服务</h3><p>更新api-server服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/kube-apiserver.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-apiserver start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-apiserver</span><br></pre></td></tr></table></figure><h1 id="改造controller-manager（主节点执行）"><a href="#改造controller-manager（主节点执行）" class="headerlink" title="改造controller-manager（主节点执行）"></a>改造controller-manager（主节点执行）</h1><p>由于controller-manager一般与api-server在同一台机器上，因此可使用非安全端口与api-server进行通讯，故不需要生成证书和私钥。</p><h3 id="查看diff内容"><a href="#查看diff内容" class="headerlink" title="查看diff内容"></a>查看diff内容</h3><p>先比较一下增加认证的controller-manager配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-controller-manager.service kubernetes-with-ca/master-node/kube-controller-manager.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5a1d4caa696aa664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这个<code>cluster-signing-cert-file</code>和<code>cluster-signing-key-file</code>这两个配置项的值都从空字符串变成了我们设置的ca证书的文件和私钥。这里你可能会有疑问，它里面设置的master参数就是127.0.0.10:8080这不就是本地么，这里为什么还需要ca证书呢？原因在于这些证书并不是在访问api-server时才使用的，而是当签名为tls/bootstrap时的证书和私钥。同时新增了如下新的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--service-account-private-key-file=/etc/kubernetes/ca/ca-key.pem</span><br><span class="line">--root-ca-file=/etc/kubernetes/ca/ca.pem</span><br></pre></td></tr></table></figure><h3 id="更新controller-manager服务"><a href="#更新controller-manager服务" class="headerlink" title="更新controller-manager服务"></a>更新controller-manager服务</h3><p>更新controller-manager服务使用的命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/master-node/kube-controller-manager.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-controller-manager start</span><br><span class="line"></span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-controller-manager</span><br></pre></td></tr></table></figure><h1 id="改造scheduler（主节点执行）"><a href="#改造scheduler（主节点执行）" class="headerlink" title="改造scheduler（主节点执行）"></a>改造scheduler（主节点执行）</h1><p>由于scheduler一般与api-server在同一台机器上，因此可使用非安全端口与api-server进行通讯，故不需要生成证书和私钥。</p><h3 id="查看diff内容-1"><a href="#查看diff内容-1" class="headerlink" title="查看diff内容"></a>查看diff内容</h3><p>先比较一下增加认证的scheduler配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/master-node/kube-scheduler.service kubernetes-with-ca/master-node/kube-scheduler.service</span><br></pre></td></tr></table></figure><p>可以发现这个文件前后没有任何变化，因此不需要进行改造。</p><h3 id="启动scheduler服务"><a href="#启动scheduler服务" class="headerlink" title="启动scheduler服务"></a>启动scheduler服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ service kube-scheduler start</span><br><span class="line">#检查日志</span><br><span class="line">$ journalctl -f -u kube-scheduler</span><br></pre></td></tr></table></figure><h1 id="改造kubectl（任意节点）"><a href="#改造kubectl（任意节点）" class="headerlink" title="改造kubectl（任意节点）"></a>改造kubectl（任意节点）</h1><p>由于前面我们将kubectl安装在了主节点上，其实我们是不需要对kubectl进行改造的。但是如果你的kubectl不是安装在了主节点，那么就需要进行改造。当然了就算kubectl安装在了主节点，我们还是可以对kubectl进行改造。</p><h3 id="准备证书-2"><a href="#准备证书-2" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#kubectl证书放在这，由于kubectl相当于系统管理员，因此这里使用admin命名</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/admin</span><br><span class="line">#准备admin证书配置，由于kubectl只需客户端证书，因此证书请求中的 hosts 字段可以为空</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/admin/admin-csr.json /etc/kubernetes/ca/admin/</span><br><span class="line">$ cd /etc/kubernetes/ca/admin/</span><br><span class="line">#使用根证书(ca.pem)签发admin证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class="line"></span><br><span class="line">#最终需要的是admin-key.pem和admin.pem</span><br><span class="line">$ ls</span><br><span class="line">admin.csr  admin-csr.json  admin-key.pem  admin.pem</span><br></pre></td></tr></table></figure><h3 id="配置kubectl"><a href="#配置kubectl" class="headerlink" title="配置kubectl"></a>配置kubectl</h3><p>接下来使用如下命令来对kubectl进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#指定apiserver的地址和证书位置（ip自行修改）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443</span><br><span class="line">#设置客户端认证参数，指定admin证书和秘钥</span><br><span class="line">$ kubectl config set-credentials admin \</span><br><span class="line">        --client-certificate=/etc/kubernetes/ca/admin/admin.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --client-key=/etc/kubernetes/ca/admin/admin-key.pem</span><br><span class="line">#关联用户和集群</span><br><span class="line">$ kubectl config set-context kubernetes \</span><br><span class="line">        --cluster=kubernetes --user=admin</span><br><span class="line">#设置当前上下文</span><br><span class="line">$ kubectl config use-context kubernetes</span><br><span class="line"></span><br><span class="line">#设置结果就是一个配置文件，可以看看内容，此处的~其实就是/root</span><br><span class="line">$ cat ~/.kube/config</span><br></pre></td></tr></table></figure><p><code>~/.kube/config</code>文件里面多了很多配置信息，这里面就是上面配置的各种项。然后运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 admin]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>出现上述结构，则说明kubectl可通过https来访问apiserver了。</p><h3 id="验证主节点"><a href="#验证主节点" class="headerlink" title="验证主节点"></a>验证主节点</h3><p>回到主节点，我们使用刚刚配置好的kubectl来查看一下组件的状态，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 admin]# kubectl get componentstatus</span><br><span class="line">NAME                 STATUS    MESSAGE              ERROR</span><br><span class="line">controller-manager   Healthy   ok                   </span><br><span class="line">scheduler            Healthy   ok                   </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;: &quot;true&quot;&#125; </span><br></pre></td></tr></table></figure><h1 id="改造calico-node（所有节点执行）"><a href="#改造calico-node（所有节点执行）" class="headerlink" title="改造calico-node（所有节点执行）"></a>改造calico-node（所有节点执行）</h1><h3 id="准备证书（只在主节点上执行）"><a href="#准备证书（只在主节点上执行）" class="headerlink" title="准备证书（只在主节点上执行）"></a>准备证书（只在主节点上执行）</h3><p>后面你就会知道，calico证书会用在如下四个地方：<br>（1）calico/node，docker容器运行时访问etcd时，使用证书；<br>（2）cni 配置文件中，cni 插件需要访问etcd时，使用证书；<br>（3）calicoctl 操作集群网络访问etcd时， 使用证书；<br>（4）calico/kube-controllers 同步集群网络策略访问etcd时，使用证书。</p><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#定义calico证书存放目录</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/calico</span><br><span class="line">#准备calico证书配置，由于calico只需客户端证书，因此证书请求中 hosts 字段可以为空</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/calico/calico-csr.json /etc/kubernetes/ca/calico/</span><br><span class="line">$ cd /etc/kubernetes/ca/calico/</span><br><span class="line">#使用根证书(ca.pem)签发calico证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes calico-csr.json | cfssljson -bare calico</span><br><span class="line">#最终需要的是calico-key.pem和calico.pem</span><br><span class="line">$ ls</span><br><span class="line">calico.csr  calico-csr.json  calico-key.pem  calico.pem</span><br></pre></td></tr></table></figure><h3 id="改造calico服务（所有节点执行）"><a href="#改造calico服务（所有节点执行）" class="headerlink" title="改造calico服务（所有节点执行）"></a>改造calico服务（所有节点执行）</h3><h5 id="查看diff内容-2"><a href="#查看diff内容-2" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><p>先比较一下增加认证的calico配置与原有配置的区别，这样可以做到心中有数，可使用的比较命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/all-node/kube-calico.service kubernetes-with-ca/all-node/kube-calico.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-262d1d5f09ccc9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，calico服务相比于之前多了一些与认证相关的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e ETCD_CA_CERT_FILE=/etc/kubernetes/ca/ca.pem</span><br><span class="line">-e ETCD_CERT_FILE=/etc/kubernetes/ca/calico/calico.pem</span><br><span class="line">-e ETCD_KEY_FILE=/etc/kubernetes/ca/calico/calico-key.pem</span><br></pre></td></tr></table></figure><p>由于calico服务是所有节点都需要安装的，因此需要将上述三个对应目录下的证书文件拷贝到每个节点的<code>/etc/kubernetes/</code>目录下，可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /etc/kubernetes/ca root@其他节点ip:/etc/kubernetes/</span><br></pre></td></tr></table></figure><h5 id="更新calico服务"><a href="#更新calico服务" class="headerlink" title="更新calico服务"></a>更新calico服务</h5><p>接着我们依次执行如下命令来更新calico服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/all-node/kube-calico.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kube-calico start</span><br></pre></td></tr></table></figure><p>之后使用如下命令来验证calico，如果能看到其他节点的列表，这就说明calico更新是成功的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">|  PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |    INFO     |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+</span><br><span class="line">| 192.168.51.123 | node-to-node mesh | up    | 01:32:56 | Established |</span><br><span class="line">| 192.168.51.121 | node-to-node mesh | up    | 01:42:58 | Established |</span><br><span class="line">+----------------+-------------------+-------+----------+-------------+```</span><br></pre></td></tr></table></figure><h1 id="改造kubelet（所有节点执行）"><a href="#改造kubelet（所有节点执行）" class="headerlink" title="改造kubelet（所有节点执行）"></a>改造kubelet（所有节点执行）</h1><p>这里我们让kubelet采用引导token的方式认证，所以认证方式跟之前的组件不同，它的证书不是手动生成，而是由工作节点TLS BootStrap 向api-server请求，由主节点的controller-manager 自动签发。<strong>首先需要使用<code>service kubelet stop</code>命令来停止各个节点上kubelet的运行。</strong></p><h3 id="创建角色绑定（只在主节点上执行）"><a href="#创建角色绑定（只在主节点上执行）" class="headerlink" title="创建角色绑定（只在主节点上执行）"></a>创建角色绑定（只在主节点上执行）</h3><p>引导token的方式要求客户端向api-server发起请求时，告诉它你的用户名和token，并且这个用户是具有一个特定的角色<code>system:node-bootstrapper</code>，因此需要先将 bootstrap token 文件中的<code>kubelet-bootstrap</code>用户赋予这个特定角色，然后 kubelet 才有权限发起创建认证请求。</p><p>开发者需要在主节点执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#可以通过下面命令查询clusterrole列表</span><br><span class="line">$ kubectl -n kube-system get clusterrole</span><br><span class="line"></span><br><span class="line">#查看一下token文件的内容</span><br><span class="line">$ cat /etc/kubernetes/ca/kubernetes/token.csv</span><br><span class="line">49dd2bb99bc687e21dfa34e78fe098b1,kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;</span><br><span class="line"></span><br><span class="line">#创建角色绑定（即将用户kubelet-bootstrap与角色system:node-bootstrapper进行绑定）</span><br><span class="line">$ kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">         --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap</span><br></pre></td></tr></table></figure><h3 id="创建bootstrap-kubeconfig（所有工作节点执行）"><a href="#创建bootstrap-kubeconfig（所有工作节点执行）" class="headerlink" title="创建bootstrap.kubeconfig（所有工作节点执行）"></a>创建<code>bootstrap.kubeconfig</code>（所有工作节点执行）</h3><p>此配置用于完成bootstrap token认证，里面保存了用户、token等重要认证信息，注意这个文件可以借助kubectl命令生成，也可以由开发者自己通过书写配置文件生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数(注意替换ip)</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443 \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#设置客户端认证参数(注意替换token)</span><br><span class="line">$ kubectl config set-credentials kubelet-bootstrap \</span><br><span class="line">        --token=49dd2bb99bc687e21dfa34e78fe098b1 \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#设置上下文</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster=kubernetes \</span><br><span class="line">        --user=kubelet-bootstrap \</span><br><span class="line">        --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span><br><span class="line">#将刚生成的文件移动到合适的位置</span><br><span class="line">$ mv bootstrap.kubeconfig /etc/kubernetes/</span><br></pre></td></tr></table></figure><h3 id="准备cni配置（所有工作节点执行）"><a href="#准备cni配置（所有工作节点执行）" class="headerlink" title="准备cni配置（所有工作节点执行）"></a>准备cni配置（所有工作节点执行）</h3><h5 id="查看diff内容-3"><a href="#查看diff内容-3" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install vim -y</span><br><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/10-calico.conf kubernetes-with-ca/worker-node/10-calico.conf</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c7fb6692753a1f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，相比于之前多了一些与认证相关的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;etcd_key_file&quot;: &quot;/etc/kubernetes/ca/calico/calico-key.pem&quot;</span><br><span class="line">&quot;etcd_cert_file&quot;: &quot;/etc/kubernetes/ca/calico/calico.pem&quot;,                                            </span><br><span class="line">&quot;etcd_ca_cert_file&quot;: &quot;/etc/kubernetes/ca/ca.pem&quot;, </span><br></pre></td></tr></table></figure><p>同时<code>k8s_api_root</code>这一选项变成了kubeconfig这一选项的值，配置文件就是<code>/etc/kubernetes/kubelet.kubeconfig</code>。</p><h3 id="覆盖之前配置信息"><a href="#覆盖之前配置信息" class="headerlink" title="覆盖之前配置信息"></a>覆盖之前配置信息</h3><p>接下来我们使用如下命令来覆盖之前的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/10-calico.conf /etc/cni/net.d/</span><br></pre></td></tr></table></figure><h3 id="改造kubelet服务（所有工作节点执行）"><a href="#改造kubelet服务（所有工作节点执行）" class="headerlink" title="改造kubelet服务（所有工作节点执行）"></a>改造kubelet服务（所有工作节点执行）</h3><h5 id="查看diff内容-4"><a href="#查看diff内容-4" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/kubelet.service kubernetes-with-ca/worker-node/kubelet.service</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-72af2a188de270cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以看到，相比于之前多了一些配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig \                             </span><br><span class="line">--cert-dir=/etc/kubernetes/ca \                                                                        </span><br><span class="line">--hairpin-mode hairpin-veth \</span><br></pre></td></tr></table></figure><h5 id="更新服务"><a href="#更新服务" class="headerlink" title="更新服务"></a>更新服务</h5><p>在所有工作节点上执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kubelet.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ service kubelet start</span><br></pre></td></tr></table></figure><p>之后使用<code>journalctl -f -u kubelet</code>命令来检查日志，以确保kubelet已经成功启动，接着回到主节点，执行如下命令看一下前一个工作节点是否向主节点发送了添加集群的请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr</span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE   33s       kubelet-bootstrap   Pending</span><br></pre></td></tr></table></figure><p>然后执行如下命令来允许worker加入(批准worker的tls证书请求)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr|grep &#x27;Pending&#x27; | awk &#x27;&#123;print $1&#125;&#x27;| xargs kubectl certificate approve</span><br><span class="line">certificatesigningrequest &quot;node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE&quot; approved</span><br></pre></td></tr></table></figure><p>最后再在主节点上确认其他两个节点都已经加入到集群中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get csr</span><br><span class="line">NAME                                                   AGE       REQUESTOR           CONDITION</span><br><span class="line">node-csr-52ZQYhjSU70AqZJahaD52YDdeSKFDRjJ2eGOSVIkMlw   1m        kubelet-bootstrap   Approved,Issued</span><br><span class="line">node-csr-zM7Em4BCVTGhDVJqlsY5P37zmbwImAMPWta67SHaaqE   1h        kubelet-bootstrap   Approved,Issued</span><br></pre></td></tr></table></figure><h1 id="改造kube-proxy（工作节点执行）"><a href="#改造kube-proxy（工作节点执行）" class="headerlink" title="改造kube-proxy（工作节点执行）"></a>改造kube-proxy（工作节点执行）</h1><h3 id="准备证书-3"><a href="#准备证书-3" class="headerlink" title="准备证书"></a>准备证书</h3><p>首先我们需要使用如下命令来创建证书存放位置和生成证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#定义proxy证书的存放位置</span><br><span class="line">$ mkdir -p /etc/kubernetes/ca/kube-proxy</span><br><span class="line"></span><br><span class="line">#准备proxy证书配置，由于proxy只需客户端证书，因此证书请求中 hosts 字段可以为空。</span><br><span class="line">#CN 指定该证书的 User 为 system:kube-proxy，预定义的 ClusterRoleBinding为system:node-proxy，即将User用户system:kube-proxy 与 Role角色system:node-proxier进行绑定，授予了调用 kube-api-server proxy的相关 API 的权限</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/ca/kube-proxy/kube-proxy-csr.json /etc/kubernetes/ca/kube-proxy/</span><br><span class="line">$ cd /etc/kubernetes/ca/kube-proxy/</span><br><span class="line"></span><br><span class="line">#使用根证书(ca.pem)签发kube-proxy证书</span><br><span class="line">$ cfssl gencert \</span><br><span class="line">        -ca=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        -ca-key=/etc/kubernetes/ca/ca-key.pem \</span><br><span class="line">        -config=/etc/kubernetes/ca/ca-config.json \</span><br><span class="line">        -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br><span class="line">#最终需要的是kube-proxy-key.pem和kube-proxy.pem</span><br><span class="line">$ ls</span><br><span class="line">kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem</span><br></pre></td></tr></table></figure><h3 id="创建kube-proxy-kubeconfig配置"><a href="#创建kube-proxy-kubeconfig配置" class="headerlink" title="创建kube-proxy.kubeconfig配置"></a>创建<code>kube-proxy.kubeconfig</code>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#设置集群参数（注意替换ip）</span><br><span class="line">$ kubectl config set-cluster kubernetes \</span><br><span class="line">        --certificate-authority=/etc/kubernetes/ca/ca.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --server=https://192.168.51.122:6443 \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#置客户端认证参数</span><br><span class="line">$ kubectl config set-credentials kube-proxy \</span><br><span class="line">        --client-certificate=/etc/kubernetes/ca/kube-proxy/kube-proxy.pem \</span><br><span class="line">        --client-key=/etc/kubernetes/ca/kube-proxy/kube-proxy-key.pem \</span><br><span class="line">        --embed-certs=true \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#设置上下文参数</span><br><span class="line">$ kubectl config set-context default \</span><br><span class="line">        --cluster=kubernetes \</span><br><span class="line">        --user=kube-proxy \</span><br><span class="line">        --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#选择上下文</span><br><span class="line">$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span><br><span class="line">#将刚生成的文件移动到合适的位置</span><br><span class="line">$ mv kube-proxy.kubeconfig /etc/kubernetes/kube-proxy.kubeconfig</span><br></pre></td></tr></table></figure><h3 id="改造kube-proxy服务"><a href="#改造kube-proxy服务" class="headerlink" title="改造kube-proxy服务"></a>改造kube-proxy服务</h3><h5 id="查看diff内容-5"><a href="#查看diff内容-5" class="headerlink" title="查看diff内容"></a>查看diff内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter/</span><br><span class="line">$ vimdiff kubernetes-simple/worker-node/kube-proxy.service kubernetes-with-ca/worker-node/kube-proxy.service</span><br></pre></td></tr></table></figure><p>从diff结果中可以看出，<code>kube-proxy.service</code>文件前后没有发生任何变化。</p><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#复制配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.service /lib/systemd/system/</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">#安装依赖软件</span><br><span class="line">$ yum install conntrack -y</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">$ service kube-proxy start</span><br><span class="line">#查看日志</span><br><span class="line">$ journalctl -f -u kube-proxy</span><br></pre></td></tr></table></figure><h1 id="改造kube-dns（app）"><a href="#改造kube-dns（app）" class="headerlink" title="改造kube-dns（app）"></a>改造kube-dns（app）</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>kube-dns有些特别，因为它是以kubernetes应用的形式，运行在kubernetes集群中，因此它的认证授权方式和之前的组件都不一样，需要用到service account认证和RBAC授权。<br>（1）<strong>service account认证</strong>：每个service account都会自动生成自己的secret，用于包含一个ca，token和secret，用于跟api-server认证。<br>（2）<strong>RBAC授权</strong>：权限、角色和角色绑定都是kubernetes自动创建好的，开发者只需要创建一个名为kube-dns的ServiceAccount即可，官方现有的配置已经将它包含进去了。</p><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>我们只需在官方的基础上，通过更改或者添加变量，然后就能生成适合我们集群的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/envy/kubernetes-starter</span><br><span class="line">$ vimdiff kubernetes-simple/services/kube-dns.yaml kubernetes-with-ca/services/kube-dns.yaml</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7149d1e38a3d870a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过对比可以知道，新的配置文件中去掉了<code>kube-master-url=http://&#123;&#123;MASTER_IP&#125;&#125;:8080</code>这一项，这是用于访问kube-apiserver的地址。你可能有一个疑问，不设置api-server的地址，那它是怎么知道每个服务的CLUSTER_IP和pod的ENDPOINTS的呢？这是因为Kubernetes在启动每个服务Service时，会以环境变量的方式将所有服务的ip、端口等信息注入进来。</p><h3 id="创建kube-dns"><a href="#创建kube-dns" class="headerlink" title="创建kube-dns"></a>创建kube-dns</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br><span class="line">#看看启动是否成功</span><br><span class="line">$ kubectl -n kube-system get pods</span><br></pre></td></tr></table></figure><p>如果出现如下所示的信息，则说明kube-dns已经改造成功了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE</span><br><span class="line">kube-dns-795f5f6f9c-fn5kp   3/3       Running   3          2m</span><br></pre></td></tr></table></figure><p>那么这样安全版的Kubernetes集群我们就部署完成了，接下来我们就是学习如何使用它，以及如何在里面部署我们的微服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;完整集群部署&quot;&gt;&lt;a href=&quot;#完整集群部署&quot; class=&quot;headerlink&quot; title=&quot;完整集群部署&quot;&gt;&lt;/a&gt;完整集群部署&lt;/h1&gt;&lt;p&gt;本篇尝试对之前使用的基础集群进行改造和升级，使其成为一个比较完整的Kubernetes集群。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes简易环境使用</title>
    <link href="http://envyzhan.asia/2022/07/04/2022-k8s-3-simple-environemnt-use/"/>
    <id>http://envyzhan.asia/2022/07/04/2022-k8s-3-simple-environemnt-use/</id>
    <published>2022-07-04T09:55:30.000Z</published>
    <updated>2022-09-12T08:44:34.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>接下来我们开始在Kubernetes简易环境中，来练习和使用一些常用的kubectl的命令，了解这些对于后续熟练和使用kubernetes有非常大的帮助。笔者将kubectl命令安装在了主节点上，因此接下来就在主节点上执行对应的kubectl命令。</p><p>（1）使用<code>kubectl version</code>命令查看k8s的版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# ·</span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.0&quot;, GitCommit:&quot;925c127ec6b946659ad0fd596fa959be43f0cc05&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-12-15T21:07:38Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.0&quot;, GitCommit:&quot;925c127ec6b946659ad0fd596fa959be43f0cc05&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2017-12-15T20:55:30Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure><p>（2）使用<code>kubectl get nodes</code>命令查看k8s集群中所有的节点信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get nodes</span><br><span class="line">NAME             STATUS    ROLES     AGE       VERSION</span><br><span class="line">192.168.51.121   Ready     &lt;none&gt;    24m       v1.9.0</span><br><span class="line">192.168.51.123   Ready     &lt;none&gt;    24m       v1.9.0</span><br></pre></td></tr></table></figure><p>（3）使用<code>kubectl get pods</code>命令查看k8s集群中所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods</span><br><span class="line">No resources found.</span><br></pre></td></tr></table></figure><p>（4）使用<code>kubectl --help</code>来查看所有kubectl所支持的命令及帮助信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create         Create a resource from a file or from stdin.</span><br><span class="line">  expose         使用 replication controller, service, deployment 或者 pod 并暴露它作为一个 新的Kubernetes Service</span><br><span class="line">  run            在集群中运行一个指定的镜像</span><br><span class="line">  set            为 objects 设置一个指定的特征</span><br><span class="line">  run-container  在集群中运行一个指定的镜像. This command is deprecated, use &quot;run&quot; instead</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  get            显示一个或更多 resources</span><br><span class="line">  explain        查看资源的文档</span><br><span class="line">  edit           在服务器上编辑一个资源</span><br><span class="line">  delete         Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout        Manage the rollout of a resource</span><br><span class="line">  rolling-update 完成指定的 ReplicationController 的滚动升级</span><br><span class="line">  scale          为 Deployment, ReplicaSet, Replication Controller 或者 Job 设置一个新的副本数量</span><br><span class="line">  autoscale      自动调整一个 Deployment, ReplicaSet, 或者 ReplicationController 的副本数量</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate    修改 certificate 资源.</span><br><span class="line">  cluster-info   显示集群信息</span><br><span class="line">  top            Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon         标记 node 为 unschedulable</span><br><span class="line">  uncordon       标记 node 为 schedulable</span><br><span class="line">  drain          Drain node in preparation for maintenance</span><br><span class="line">  taint          更新一个或者多个 node 上的 taints</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe       显示一个指定 resource 或者 group 的 resources 详情</span><br><span class="line">  logs           输出容器在 pod 中的日志</span><br><span class="line">  attach         Attach 到一个运行中的 container</span><br><span class="line">  exec           在一个 container 中执行一个命令</span><br><span class="line">  port-forward   Forward one or more local ports to a pod</span><br><span class="line">  proxy          运行一个 proxy 到 Kubernetes API server</span><br><span class="line">  cp             复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.</span><br><span class="line">  auth           Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  apply          通过文件名或标准输入流(stdin)对资源进行配置</span><br><span class="line">  patch          使用 strategic merge patch 更新一个资源的 field(s)</span><br><span class="line">  replace        通过 filename 或者 stdin替换一个资源</span><br><span class="line">  convert        在不同的 API versions 转换配置文件</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label          更新在这个资源上的 labels</span><br><span class="line">  annotate       更新一个资源的注解</span><br><span class="line">  completion     Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  api-versions   Print the supported API versions on the server, in the form of &quot;group/version&quot;</span><br><span class="line">  config         修改 kubeconfig 文件</span><br><span class="line">  help           Help about any command</span><br><span class="line">  plugin         Runs a command-line plugin</span><br><span class="line">  version        输出 client 和 server 的版本信息</span><br></pre></td></tr></table></figure><p>接下来我们尝试通过<code>kubectl run</code>命令在k8s集群中部署一个命名为kubernetes-bootcamp的应用，Docker镜像通过<code>--image</code>指定，<code>--port</code>设置应用对外服务的端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl run kubernetes-bootcamp --image=jocatalin/kubernetes-bootcamp:v1 --port=8080</span><br></pre></td></tr></table></figure><p>然后我们查看一下所有应用的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            0           4m</span><br></pre></td></tr></table></figure><p>再来查看一下所有Pod的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-5d7f968ccb-z59rw   0/1       ContainerCreating   0          5m</span><br></pre></td></tr></table></figure><p>也可以使用如下命令查看所有pod的更多信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS              RESTARTS   AGE       IP        NODE</span><br><span class="line">kubernetes-bootcamp-5d7f968ccb-z59rw   0/1       ContainerCreating   0          6m        &lt;none&gt;    192.168.51.123</span><br></pre></td></tr></table></figure><p>如果开发者希望删除某个deployment，此时可以使用如下命令，后面的<code>kubernetes-bootcamp</code>则是应用的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 target]# kubectl delete deployments kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; deleted</span><br></pre></td></tr></table></figure><p>其实kubernetes对一些命令也提供了一些别名，举个例子，假设当前使用的是<code>kubectl get</code>命令，它可以显示一个或更多的resources，此时就可以使用<code>kubectl get --help</code>查看后面所跟一些命令的别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Valid resource types include: </span><br><span class="line"></span><br><span class="line">  * all  </span><br><span class="line">  * certificatesigningrequests (aka &#x27;csr&#x27;)  </span><br><span class="line">  * clusterrolebindings  </span><br><span class="line">  * clusterroles  </span><br><span class="line">  * componentstatuses (aka &#x27;cs&#x27;)  </span><br><span class="line">  * configmaps (aka &#x27;cm&#x27;)  </span><br><span class="line">  * controllerrevisions  </span><br><span class="line">  * cronjobs  </span><br><span class="line">  * customresourcedefinition (aka &#x27;crd&#x27;)  </span><br><span class="line">  * daemonsets (aka &#x27;ds&#x27;)  </span><br><span class="line">  * deployments (aka &#x27;deploy&#x27;)  </span><br><span class="line">  * endpoints (aka &#x27;ep&#x27;)  </span><br><span class="line">  * events (aka &#x27;ev&#x27;)  </span><br><span class="line">  * horizontalpodautoscalers (aka &#x27;hpa&#x27;)  </span><br><span class="line">  * ingresses (aka &#x27;ing&#x27;)  </span><br><span class="line">  * jobs  </span><br><span class="line">  * limitranges (aka &#x27;limits&#x27;)  </span><br><span class="line">  * namespaces (aka &#x27;ns&#x27;)  </span><br><span class="line">  * networkpolicies (aka &#x27;netpol&#x27;)  </span><br><span class="line">  * nodes (aka &#x27;no&#x27;)  </span><br><span class="line">  * persistentvolumeclaims (aka &#x27;pvc&#x27;)  </span><br><span class="line">  * persistentvolumes (aka &#x27;pv&#x27;)  </span><br><span class="line">  * poddisruptionbudgets (aka &#x27;pdb&#x27;)  </span><br><span class="line">  * podpreset  </span><br><span class="line">  * pods (aka &#x27;po&#x27;)  </span><br><span class="line">  * podsecuritypolicies (aka &#x27;psp&#x27;)  </span><br><span class="line">  * podtemplates  </span><br><span class="line">  * replicasets (aka &#x27;rs&#x27;)  </span><br><span class="line">  * replicationcontrollers (aka &#x27;rc&#x27;)  </span><br><span class="line">  * resourcequotas (aka &#x27;quota&#x27;)  </span><br><span class="line">  * rolebindings  </span><br><span class="line">  * roles  </span><br><span class="line">  * secrets  </span><br><span class="line">  * serviceaccounts (aka &#x27;sa&#x27;)  </span><br><span class="line">  * services (aka &#x27;svc&#x27;)  </span><br><span class="line">  * statefulsets (aka &#x27;sts&#x27;)  </span><br><span class="line">  * storageclasses (aka &#x27;sc&#x27;)</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  # List all pods in ps output format.</span><br><span class="line">  kubectl get pods</span><br><span class="line">  </span><br><span class="line">  # List all pods in ps output format with more information (such as node name).</span><br><span class="line">  kubectl get pods -o wide</span><br><span class="line">  </span><br><span class="line">  # List a single replication controller with specified NAME in ps output format.</span><br><span class="line">  kubectl get replicationcontroller web</span><br><span class="line">  </span><br><span class="line">  # List a single pod in JSON output format.</span><br><span class="line">  kubectl get -o json pod web-pod-13je7</span><br><span class="line">  </span><br><span class="line">  # List a pod identified by type and name specified in &quot;pod.yaml&quot; in JSON output format.</span><br><span class="line">  kubectl get -f pod.yaml -o json</span><br><span class="line">  </span><br><span class="line">  # Return only the phase value of the specified pod.</span><br><span class="line">  kubectl get -o template pod/web-pod-13je7 --template=&#123;&#123;.status.phase&#125;&#125;</span><br><span class="line">  </span><br><span class="line">  # List all replication controllers and services together in ps output format.</span><br><span class="line">  kubectl get rc,services</span><br><span class="line">  </span><br><span class="line">  # List one or more resources by their type and names.</span><br><span class="line">  kubectl get rc/web service/frontend pods/web-pod-13je7</span><br><span class="line">  </span><br><span class="line">  # List all resources with different types.</span><br><span class="line">  kubectl get all</span><br></pre></td></tr></table></figure><p>例如，查看所有应用的信息所使用的命令，可由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deployments</span><br></pre></td></tr></table></figure><p>简化为如下的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get deploy</span><br></pre></td></tr></table></figure><p>我们再来看一下查看所有pod的更多信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   0          22h       172.20.40.194   192.168.51.123</span><br></pre></td></tr></table></figure><p>如果想要查看k8s的日志运行信息，可以使用<code>journalctl -f</code>命令。可以使用<code>kubectl describe deploy +应用名称</code>命令来查看某个应用的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe deploy kubernetes-bootcamp</span><br><span class="line">Name:                   kubernetes-bootcamp</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 29 Aug 2022 22:30:58 +0800</span><br><span class="line">Labels:                 run=kubernetes-bootcamp</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision=1</span><br><span class="line">Selector:               run=kubernetes-bootcamp</span><br><span class="line">Replicas:               1 desired | 1 updated | 1 total | 1 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=kubernetes-bootcamp</span><br><span class="line">  Containers:</span><br><span class="line">   kubernetes-bootcamp:</span><br><span class="line">    Image:        jocatalin/kubernetes-bootcamp:v1</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   kubernetes-bootcamp-6b7849c495 (1/1 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  22h   deployment-controller  Scaled up replica set kubernetes-bootcamp-6b7849c495 to 1</span><br></pre></td></tr></table></figure><p>我们再来看一下查看所有pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   0          22h       172.20.40.194   192.168.51.123</span><br></pre></td></tr></table></figure><p>再来看一下这个Pod的信息，可使用<code>kubectl describe pods +pod名称</code>命令：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9b62866055a8c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>基础命令的学习就到此结束了，接下来我们继续学习其他的知识。deployment已经创建起来了，我们该如何去访问它呢？第一种方式是使用<code>kubectl proxy</code>命令 ，它会在本地监听8001端口，这个主要用于测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl proxy</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br></pre></td></tr></table></figure><p>然后我们就可以通过这个REST API来访问这个集群中运行的每一个服务。可以新开一个终端，在里面先查看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d</span><br></pre></td></tr></table></figure><p>然后我们再来通过REST API访问这个pod，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/kubernetes-bootcamp-6b7849c495-mgzpp/</span><br><span class="line">Hello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-6b7849c495-mgzpp | v=1</span><br></pre></td></tr></table></figure><p>这样我们就成功的访问了这个服务。接着我们停掉这个<code>kubectl proxy</code>，开始学习扩缩容相关内容。首先我们查看一下当前所有的deployments信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   1         1         1            1           1d</span><br></pre></td></tr></table></figure><p>接着我们来对这个deployments进行扩缩容，设置4个副本数，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl scale deploy kubernetes-bootcamp --replicas=4</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; scaled</span><br></pre></td></tr></table></figure><p>然后我们来看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-85bvf   1/1       Running   0          3m        172.20.188.1    192.168.51.121</span><br><span class="line">kubernetes-bootcamp-6b7849c495-ddcnq   1/1       Running   0          3m        172.20.188.2    192.168.51.121</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d        172.20.40.195   192.168.51.123</span><br><span class="line">kubernetes-bootcamp-6b7849c495-nqwdv   1/1       Running   0          3m        172.20.40.196   192.168.51.123</span><br></pre></td></tr></table></figure><p>现在4个实例都已经启动了，可以看到在121上运行了2个实例，在123上也运行了2个实例，也就是说Kubernetes会尽可能的分散资源，不会在一台机器上运行很多，而在另一台机器上运行很少。接下来我们使用同样的命令，将其缩容为2个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl scale deploy kubernetes-bootcamp --replicas=2</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; scaled</span><br></pre></td></tr></table></figure><p>之后再来查看一下当前所有的pods信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-6b7849c495-mgzpp   1/1       Running   1          1d        172.20.40.195   192.168.51.123</span><br><span class="line">kubernetes-bootcamp-6b7849c495-nqwdv   1/1       Running   0          10m       172.20.40.196   192.168.51.123</span><br></pre></td></tr></table></figure><p>接下来学习如何更新镜像，首先查看一下当前列表中所有的deployments信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl describe deployments</span><br><span class="line">Name:                   kubernetes-bootcamp</span><br><span class="line">Namespace:              default</span><br><span class="line">CreationTimestamp:      Mon, 29 Aug 2022 22:30:58 +0800</span><br><span class="line">Labels:                 run=kubernetes-bootcamp</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision=1</span><br><span class="line">Selector:               run=kubernetes-bootcamp</span><br><span class="line">Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable</span><br><span class="line">StrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0</span><br><span class="line">RollingUpdateStrategy:  1 max unavailable, 1 max surge</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  run=kubernetes-bootcamp</span><br><span class="line">  Containers:</span><br><span class="line">   kubernetes-bootcamp:</span><br><span class="line">    Image:        jocatalin/kubernetes-bootcamp:v1</span><br><span class="line">    Port:         8080/TCP</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Conditions:</span><br><span class="line">  Type           Status  Reason</span><br><span class="line">  ----           ------  ------</span><br><span class="line">  Available      True    MinimumReplicasAvailable</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   kubernetes-bootcamp-6b7849c495 (2/2 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  12m   deployment-controller  Scaled up replica set kubernetes-bootcamp-6b7849c495 to 4</span><br><span class="line">  Normal  ScalingReplicaSet  4m    deployment-controller  Scaled down replica set kubernetes-bootcamp-6b7849c495 to 2</span><br></pre></td></tr></table></figure><p>可以看到这个名为kubernetes-bootcamp的deployments所使用的的镜像为<code>jocatalin/kubernetes-bootcamp:v1</code>，接下来我们尝试更新这个镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl set image deploy kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; image updated</span><br></pre></td></tr></table></figure><p>注意使用这个命令的时候，默认deployment的名称和容器的名称是一样的。然后使用如下命令来查看命令的更新结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl rollout status deploy kubernetes-bootcamp</span><br><span class="line">deployment &quot;kubernetes-bootcamp&quot; successfully rolled out</span><br></pre></td></tr></table></figure><p>从执行结果中可以看出它更新成功了，然后我们继续使用<code>kubectl describe deployments</code>命令来确认已经更新成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-467c41bd5c96a94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者对某一deployment执行了错误的命令，现在想回滚到上一步的操作状态，说白了就是撤销当前的操作，可以使用<code>kubectl rollout undo deploy +deployment的名称</code>这一命令。之后可以使用<code>kubectl rollout status deploy +deployment的名称</code>这一命令来查看当前执行状态。</p><p>上面学习的都是使用命令来管理服务，但是当服务较多时，还使用命令就显得捉襟见肘了，此时就可以通过配置文件来进行管理。</p><p>回到主节点所在机器上，在<code>/home/envy</code>目录下新建一个名为services的目录，然后在这个services目录中新建一个名为<code>nginx-pod.yaml</code>文件。一般来说，我们都会使用yaml格式的文件来创建k8s服务的配置文件。<code>nginx-pod.yaml</code>文件里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers: </span><br><span class="line">    - name: nginx  </span><br><span class="line">      image: nginx:1.7.9  </span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 版本号</span><br><span class="line">apiVersion: v1</span><br><span class="line"># 类型</span><br><span class="line">kind: Pod</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  containers: # 容器</span><br><span class="line">    - name: nginx  # 容器名称</span><br><span class="line">      image: nginx:1.7.9  # 容器所使用的镜像版本信息</span><br><span class="line">      ports:</span><br><span class="line">      - containerPort: 80  # 容器端口</span><br></pre></td></tr></table></figure><p>然后我们尝试使用<code>kubectl create</code>命令从指定文件或者输入中创建一个资源，当然这里就是从<code>nginx-pod.yaml</code>配置文件中来创建一个名为nginx的Pod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-pod.yaml </span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure><p>然后我们来看一下这个Pod的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  0/1       ImagePullBackOff   0          1m</span><br></pre></td></tr></table></figure><p>我们再来看一下deployment，可以发现不存在新的deployment，这是因为我们创建的是一个Pod，一个Pod就是一个Pod，这个和deployment没有任何关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           1d</span><br></pre></td></tr></table></figure><p>但是当我们使用<code>kubectl run</code>命令时，它会创建一个deployment，而不只是仅仅创建一个Pod而已。</p><p>再来看一下当前所有的Pods，可以看到我们前面创建的Pods已经创建完成并启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  1/1       Running            0          1m</span><br></pre></td></tr></table></figure><p>现在问题来了，我们该如何去访问这个nginx呢？还是采用之前的方式，在当前窗口执行<code>kubectl proxy</code>命令，然后新开一个终端执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# curl http://localhost:8001/api/v1/proxy/namespaces/default/pods/nginx/</span><br></pre></td></tr></table></figure><p>接下来我们尝试创建一个nginx的deployment，在<code>/home/envy/services</code>目录中新建一个名为<code>nginx-deployment.yaml</code>的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx:1.7.9</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 版本号，注意固定格式</span><br><span class="line">apiVersion: apps/v1beta1</span><br><span class="line"># 类型</span><br><span class="line">kind: Deployment</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2  # 两个副本</span><br><span class="line">  template:  # 模板信息</span><br><span class="line">    metadata:  #模板元数据</span><br><span class="line">      labels: # 标签</span><br><span class="line">        app: nginx</span><br><span class="line">    spec: # 比较特别的配置</span><br><span class="line">      containers: # 容器</span><br><span class="line">      - name: nginx  # 容器名称</span><br><span class="line">        image: nginx:1.7.9  # 容器所使用的镜像版本信息</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80  # 容器端口</span><br></pre></td></tr></table></figure><p>之后我们继续使用之前的命令来创建一个deployment：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-deployment.yaml </span><br><span class="line">deployment &quot;nginx-deployment&quot; created</span><br></pre></td></tr></table></figure><p>然后我们查看一下当前所有的deployments，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get deploy</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           1d</span><br><span class="line">nginx-deployment      2         2         2            1           1m</span><br></pre></td></tr></table></figure><p>可以看到这个<code>nginx-deployment</code>目前只有一个，因为它正在去另一个服务器上下载，目前只有一个节点下载了这个镜像。然后我们还可以查看一下所有的pods:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods</span><br><span class="line">NAME                                   READY     STATUS             RESTARTS   AGE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-rlz44   1/1       Running            0          1h</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running            0          1h</span><br><span class="line">nginx                                  1/1       Running            0          31m</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c      0/1       ImagePullBackOff   0          3m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh      1/1       Running            0          3m</span><br></pre></td></tr></table></figure><p>这里主要关心以<code>nginx-deployment</code>开头的两个deployment，可以看到一个正在运行，另一个正在拉取镜像。我们还可以使用如下命令来查看指定标签的Pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods -l app=nginx</span><br><span class="line">NAME                                READY     STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c   0/1       ImagePullBackOff   0          5m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh   1/1       Running            0          5m</span><br></pre></td></tr></table></figure><p>可以看到这里就只是查看以app=nginx为标签的pods的信息，service的原理其实也是根据这个label（标签）来筛选出它所想要服务的Pod，然后实现一个负载均衡。</p><p>最后可以看到这两个以app=nginx为标签的pods已经成功启动了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get pods -l app=nginx</span><br><span class="line">NAME                                READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-6c54bd5869-q5z6c   1/1       Running   0          10m</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh   1/1       Running   0          10m</span><br></pre></td></tr></table></figure><p>接下来我们尝试在这基础的集群之上，再给它添加两个功能，也就是kube-proxy和kube-dns。当开发者需要给集群增加service功能，此时就需要增加kube-proxy组件；当需要dns，通过名称解析服务这样的功能，此时就可以增加kube-dns组件。k8s会把一些不必要的功能做成一个组件，这样有效的降低了各个组件之间的耦合程度。</p><h1 id="给集群增加service功能–kube-proxy（工作节点执行）"><a href="#给集群增加service功能–kube-proxy（工作节点执行）" class="headerlink" title="给集群增加service功能–kube-proxy（工作节点执行）"></a>给集群增加service功能–kube-proxy（工作节点执行）</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每台工作节点上都应该运行一个kube-proxy服务，它负责监听APIServer中service和endpoint的变化，并通过iptables等来为服务配置负载均衡，是让服务在集群外可以被访问到的重要方式。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>kube-proxy的部署方式也是通过系统服务，部署流程跟etcd完全一样，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 确保工作目录存在</span><br><span class="line">$ mkdir -p /var/lib/kube-proxy</span><br><span class="line">#复制kube-proxy服务配置文件到系统服务目录</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.service /lib/systemd/system/</span><br><span class="line">#复制kube-proxy依赖的配置文件</span><br><span class="line">$ cp /home/envy/kubernetes-starter/target/worker-node/kube-proxy.kubeconfig /etc/kubernetes/</span><br><span class="line">#enable服务</span><br><span class="line">$ systemctl enable kube-proxy.service</span><br><span class="line"># 启动服务</span><br><span class="line">$ service kube-proxy start</span><br><span class="line"># 查看服务日志，看是否有错误信息，确保服务正常</span><br><span class="line">$ journalctl -f -u kube-proxy.service</span><br></pre></td></tr></table></figure><p>然后我们查看一下监听的端口号，看到10249和10256端口都是正常启动的，说明配置是成功的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br></pre></td></tr></table></figure><p>接下来我们看一下这个<code>kube-proxy.service</code>文件的内容，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kube-Proxy Server</span><br><span class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory=/var/lib/kube-proxy</span><br><span class="line">ExecStart=/home/envy/bin/kube-proxy \</span><br><span class="line">  --bind-address=192.168.51.121 \</span><br><span class="line">  --hostname-override=192.168.51.121 \</span><br><span class="line">  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig \</span><br><span class="line">  --logtostderr=true \</span><br><span class="line">  --v=2</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>这里主要关注Service部分，其中WorkingDirectory是kube-proxy的工作目录，ExecStart是启动的命令，<code>/home/envy/bin/kube-proxy</code>则是需要启动的程序名称，通过<code>--bind-address</code>参数来设置监听的地址，<code>kubeconfig</code>则是它所依赖的配置文件，描述了kube-proxy如何访问api-server。</p><p>下面是<code>kube-proxy.kubeconfig</code>配置文件的内容，它配置了kube-proxy如何访问api-server，内容与kubelet雷同，不再赘述。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    server: http://192.168.51.122:8080</span><br><span class="line">  name: kubernetes</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">  name: default</span><br><span class="line">current-context: default</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users: []</span><br></pre></td></tr></table></figure><p>这样我们就给集群添加了kube-proxy，那么问题来了，我们该如何使用它呢？往下看，回到主节点，首先使用如下命令来查看所有的服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get services</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.68.0.1    &lt;none&gt;        443/TCP   3d</span><br></pre></td></tr></table></figure><p>注意这个服务是APIServer在启动的时候就默认创建的服务，它的作用是什么呢？我们先看一下它有什么东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl describe service kubernetes</span><br><span class="line">Name:              kubernetes</span><br><span class="line">Namespace:         default</span><br><span class="line">Labels:            component=apiserver</span><br><span class="line">                   provider=kubernetes</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          &lt;none&gt;</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.68.0.1</span><br><span class="line">Port:              https  443/TCP</span><br><span class="line">TargetPort:        6443/TCP</span><br><span class="line">Endpoints:         192.168.51.122:6443</span><br><span class="line">Session Affinity:  ClientIP</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure><p>可以看到它的Type是ClusterIP，而且IP地址为10.68.0.1，相当于给APIServer做成了一个服务，它有什么作用呢？第一，集群内其他的组件可通过这个IP来访问到APIServer，这样它就不需要依赖于具体的IP地址；第二，负载均衡，它可以用来负责APIServer这一组件的高可用，当然前提是我们有多个APIServer实例的时候，然后他就可以通过这个Server IP来实现负载均衡，并且会自动过滤掉不可用的节点，进而实现APIServer的高可用。</p><p>其实我们自己也可以创建service，首先查看一下当前所有的deployments：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get deployments</span><br><span class="line">NAME                  DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubernetes-bootcamp   2         2         2            2           2d</span><br><span class="line">nginx-deployment      2         2         2            2           23h</span><br></pre></td></tr></table></figure><p>可以看到这里有两个deployments，之前我们访问这两个deployments的时候，使用的都是代理的方式，即<code>kubectl proxy</code>，开一个HTTP的EndPoint，然后通过这个EndPoint的地址去访问这个Pod。接下来我们看看kube-proxy如何给我们带来方便，让我们如何访问这个Pod。可使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl expose deploy kubernetes-bootcamp --type=&quot;NodePort&quot; --target-port=8080 --port=80</span><br><span class="line">service &quot;kubernetes-bootcamp&quot; exposed</span><br></pre></td></tr></table></figure><p>该命令说明为<code>kubectl expose deploy deployment名称 --type=&quot;NodePort&quot; --target-port=容器端口 --port=Service端口</code>，接着我们再次使用之前的命令来获取当前所有的service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get services</span><br><span class="line">NAME                  TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes            ClusterIP   10.68.0.1     &lt;none&gt;        443/TCP        3d</span><br><span class="line">kubernetes-bootcamp   NodePort    10.68.37.19   &lt;none&gt;        80:30735/TCP   1m</span><br></pre></td></tr></table></figure><p>可以看到这里多了一个service，它的类型为NodePort，所分配的IP地址为10.68.37.19，注意这里的端口映射，将80端口映射到30735，这个30735是随机的端口号，查看一下这个30735端口是否为监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# netstat -ntlp|grep 30735</span><br><span class="line">[root@server02 ~]#</span><br></pre></td></tr></table></figure><p>可以看到这个30735不是监听端口，但是这个端口应该是监听端口才是，为什么这里没有监听呢？是因为当前节点是master节点，而不是工作节点，它并没有kube-proxy。我们去另一台机器，如123机器，反正只要是工作节点就可以，之后查看 一下这台机器上的30735端口是否为监听端口，可以看到它确实是监听者。</p><p>这个30735是随机的端口号，也就是kube-proxy实际在节点上启动的一个端口，可以通过这个端口来访问我们的服务。上述命令中的<code>target-port</code>则是当前容器，也就是Pod它真正提供服务的端口，也就是说这个容器实际上监听的端口是8080。port则是我们在这个CLUSTER-IP虚拟IP上去访问这个服务的时候需要提供的端口，这里提供的则是80端口。也就是说此时我们可以通过Service的CLUSTER-IP加上80服务端口，或者是通过NodeIP+NodePort去访问这个服务，这是两种方式。</p><p>接下来我们看一下当前所有的Pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl get pods -o wide</span><br><span class="line">NAME                                   READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kubernetes-bootcamp-7689dc585d-x7bft   1/1       Running   0          55m       172.20.188.12   192.168.51.121</span><br><span class="line">kubernetes-bootcamp-7689dc585d-z2678   1/1       Running   2          2d        172.20.188.10   192.168.51.121</span><br><span class="line">nginx                                  1/1       Running   2          1d        172.20.188.9    192.168.51.121</span><br><span class="line">nginx-deployment-6c54bd5869-chjwn      1/1       Running   0          55m       172.20.188.13   192.168.51.121</span><br><span class="line">nginx-deployment-6c54bd5869-rt4zh      1/1       Running   2          1d        172.20.188.11   192.168.51.121</span><br></pre></td></tr></table></figure><p>从原理上来说，上述pod列表中的任意一个pod所包含的容器，都是可以访问到CLUSTER-IP，并且它们之间也都是可以互相连通的，这是Kubernetes在设计上所做的要求，前提是我们的环境是正常的。此处以192.168.51.121节点上容器为例，我们查看其中包含bootcamp的容器，可以看到它有多个，选择一个id为0b4380c9fb67的容器，并进入到该容器，直接访问CLUSTER-IP加上80端口，可以看到它是可以访问这个服务的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server01 ~]# docker exec -it 0b4380c9fb67 bash</span><br><span class="line">root@kubernetes-bootcamp-7689dc585d-x7bft:/# curl 10.68.37.19:80</span><br></pre></td></tr></table></figure><p>同样的我们可以在这个容器中尝试看一下是否可以连通其他的Pod，可以选择之前的nginx，它的IP地址为172.20.188.9，可以看到访问结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9893a47bc2d0287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>回到主节点，在前面我们创建的服务，它的NodePort是随机的，也就是前面多次提到的30735，我们希望将这个端口给固定下来，即我们给它指定一个NodePort，这也是可以的，但是需要我们通过配置文件的方式来进行设置。</p><p>截止到目前，<code>/home/envy/services</code>目录下已经有两个配置文件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# ls</span><br><span class="line">nginx-deployment.yaml  nginx-pod.yaml</span><br></pre></td></tr></table></figure><p>接下来我们创建一个新的配置文件，名为<code>nginx-service.yaml</code>，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8080</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 20000</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>以下是对上述配置文件中一些配置项的说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 版本号，注意固定格式</span><br><span class="line">apiVersion: v1</span><br><span class="line"># 类型</span><br><span class="line">kind: Service</span><br><span class="line"># 元数据</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-service</span><br><span class="line"># 比较特别的配置</span><br><span class="line">spec:</span><br><span class="line">  ports: # 端口</span><br><span class="line">  - port: 8080  # Service端口（即CLUSTRER_IP所对应的端口）</span><br><span class="line">    targetPort: 80  # 容器端口（即具体的Nginx服务所对应的端口）</span><br><span class="line">    nodePort: 20000 # 节点端口（即能对节点外部提供服务的端口）</span><br><span class="line">  selector: # 给谁提供这样的服务，需要指定具体的Pod</span><br><span class="line">    app: nginx # 通过app=nginx进行指定</span><br><span class="line">  type: NodePort # 类型，默认的类型是CLUSTRER_IP，此处使用NodePort</span><br></pre></td></tr></table></figure><p>之后我们继续使用之前的命令来创建一个service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f nginx-service.yaml </span><br><span class="line">service &quot;nginx-service&quot; created</span><br></pre></td></tr></table></figure><p>然后我们再来查看当前所有的service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl get services</span><br><span class="line">NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes            ClusterIP   10.68.0.1      &lt;none&gt;        443/TCP          5d</span><br><span class="line">kubernetes-bootcamp   NodePort    10.68.37.19    &lt;none&gt;        80:30735/TCP     1d</span><br><span class="line">nginx-service         NodePort    10.68.235.19   &lt;none&gt;        8080:20000/TCP   1m</span><br></pre></td></tr></table></figure><p>可以看到这里多了一个名为nginx-service的service，而且类型为NodePort，它也有一个CLUSTER-IP，重要的是它的端口映射为8080:20000，即8080为服务的端口，而20000则是节点的端口。然后我们尝试在主节点，使用<code>192.168.51.121:2000</code>来访问121工作节点的nginx服务，可以看到可以访问成功了。同理也可以使用<code>192.168.51.123:2000</code>来访问123工作节点的nginx服务，这也是可以的。通过命令和配置文件方式创建出来的service都是一样的，没有任何区别，只是Kubernetes给我们提供了不同的操作方式而已。</p><h1 id="给集群增加dns功能–kube-dns（以app方式启动）"><a href="#给集群增加dns功能–kube-dns（以app方式启动）" class="headerlink" title="给集群增加dns功能–kube-dns（以app方式启动）"></a>给集群增加dns功能–kube-dns（以app方式启动）</h1><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>kube-dns为Kubernetes集群提供命名服务，主要用于解析集群服务名和Pod的hostname，目的是让pod可以通过名字访问到集群内的服务。它通过添加A记录的方式实现名字和service的解析，其中普通的service会解析到service-ip，而headless的service则会解析到pod列表，并且实现负载均衡。</p><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>kube-dns则是通过Kubernetes应用的方式进行部署，其中我们之前生成的target文件里面<code>kube-dns.yaml</code>的配置文件与官方基本上一致，除了镜像名称不同而已。</p><p>kube-dns这个服务比较特殊的一点在于它的namespace为kube-system，而不是main这个空间中。这个服务所涉及到的东西比较多，如果我们手动创建它的配置文件，这其实是很难的，一般做法是直接使用官方提供的文件，然后在里面根据实际情况进行配置，多个组件之间使用<code>---</code>进行区分。</p><p>查看一下这个<code>/home/envy/kubernetes-starter/target/services/kube-dns.yaml</code>配置文件中的信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">#ConfigMap是我们见到的一个新类型，顾名思义是做配置管理的，这里用作kube-dns配置存储</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: EnsureExists</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#认证授权使用，这里未用到</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#dns服务</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">    kubernetes.io/name: &quot;KubeDNS&quot;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    #选择器，一个服务包含了哪些pods</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">  #服务的clusterip，需要跟kubelet保持一致</span><br><span class="line">  clusterIP: 10.68.0.2</span><br><span class="line">  ports:</span><br><span class="line">  - name: dns</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: UDP</span><br><span class="line">  - name: dns-tcp</span><br><span class="line">    port: 53</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#具体的pod定义，包含了三个容器</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">spec:</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 10%</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kube-dns</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kube-dns</span><br><span class="line">      annotations:</span><br><span class="line">        scheduler.alpha.kubernetes.io/critical-pod: &#x27;&#x27;</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;CriticalAddonsOnly&quot;</span><br><span class="line">        operator: &quot;Exists&quot;</span><br><span class="line">      volumes:</span><br><span class="line">      - name: kube-dns-config</span><br><span class="line">        configMap:</span><br><span class="line">          name: kube-dns</span><br><span class="line">          optional: true</span><br><span class="line">      containers:</span><br><span class="line">      #实现dns解析功能</span><br><span class="line">      - name: kubedns</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-kube-dns-amd64:1.14.5</span><br><span class="line">        resources:</span><br><span class="line">          # TODO: Set memory limits when we&#x27;ve profiled the container for large</span><br><span class="line">          # clusters, then set request = limit to keep this container in</span><br><span class="line">          # guaranteed class. Currently, this container falls into the</span><br><span class="line">          # &quot;burstable&quot; category so the kubelet doesn&#x27;t backoff from restarting it.</span><br><span class="line">          limits:</span><br><span class="line">            memory: 170Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 70Mi</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/kubedns</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /readiness</span><br><span class="line">            port: 8081</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          # we poll on pod startup for the Kubernetes master service and</span><br><span class="line">          # only setup the /readiness HTTP server once that&#x27;s available.</span><br><span class="line">          initialDelaySeconds: 3</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        args:</span><br><span class="line">        - --domain=cluster.local.</span><br><span class="line">        - --dns-port=10053</span><br><span class="line">        - --config-dir=/kube-dns-config</span><br><span class="line">        #访问kube-apiserver的地址</span><br><span class="line">        - --kube-master-url=http://192.168.51.122:8080</span><br><span class="line">        - --v=2</span><br><span class="line">        env:</span><br><span class="line">        - name: PROMETHEUS_PORT</span><br><span class="line">          value: &quot;10055&quot;</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-local</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-tcp-local</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 10055</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kube-dns-config</span><br><span class="line">          mountPath: /kube-dns-config</span><br><span class="line">      #dnsmasq类似一个dns缓存，用于提高访问效率</span><br><span class="line">      - name: dnsmasq</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-dnsmasq-nanny-amd64:1.14.5</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/dnsmasq</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        args:</span><br><span class="line">        - -v=2</span><br><span class="line">        - -logtostderr</span><br><span class="line">        - -configDir=/etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">        - -restartDnsmasq=true</span><br><span class="line">        - --</span><br><span class="line">        - -k</span><br><span class="line">        - --cache-size=1000</span><br><span class="line">        - --log-facility=-</span><br><span class="line">        - --server=/cluster.local./127.0.0.1#10053</span><br><span class="line">        - --server=/in-addr.arpa/127.0.0.1#10053</span><br><span class="line">        - --server=/ip6.arpa/127.0.0.1#10053</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns-tcp</span><br><span class="line">          protocol: TCP</span><br><span class="line">        # see: https://github.com/kubernetes/kubernetes/issues/29055 for details</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 150m</span><br><span class="line">            memory: 20Mi</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kube-dns-config</span><br><span class="line">          mountPath: /etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">      #sidecar是一个监控功能，负责监控另外两个容器的运行</span><br><span class="line">      - name: sidecar</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/imooc/k8s-dns-sidecar-amd64:1.14.5</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /metrics</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">        args:</span><br><span class="line">        - --v=2</span><br><span class="line">        - --logtostderr</span><br><span class="line">        - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local.,5,A</span><br><span class="line">        - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local.,5,A</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10054</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            memory: 20Mi</span><br><span class="line">            cpu: 10m</span><br><span class="line">      dnsPolicy: Default  # Don&#x27;t use cluster DNS.</span><br><span class="line">      serviceAccountName: kube-dns</span><br></pre></td></tr></table></figure><p>之后执行如下命令即可启动kube-dns服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br></pre></td></tr></table></figure><p>可以看到输出信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl create -f /home/envy/kubernetes-starter/target/services/kube-dns.yaml</span><br><span class="line">configmap &quot;kube-dns&quot; created</span><br><span class="line">serviceaccount &quot;kube-dns&quot; created</span><br><span class="line">service &quot;kube-dns&quot; created</span><br><span class="line">deployment &quot;kube-dns&quot; created</span><br></pre></td></tr></table></figure><p>configMap用于配置管理，serviceaccount也是一种类型，主要用于Kubernetes的认证与授权，这里未使用到。</p><p>然后我们就可以使用如下命令来查看这个名为kube-system的namespace中的服务信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 services]# kubectl -n kube-system get svc</span><br><span class="line">NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kube-dns   ClusterIP   10.68.0.2    &lt;none&gt;        53/UDP,53/TCP   3m</span><br></pre></td></tr></table></figure><p>可以看到这里面有一个CLUSTER-IP，这个就是之前我们在创建kubelet的时候所配置的地址，这样在使用kube-dns的时候它就会自动生效。注意我们在kube-dns的yaml配置文件中也需要配置一个与它完全一样的地址。</p><p>再来看一下这个名为kube-system的namespace中的deployment信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get deploy </span><br><span class="line">NAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kube-dns   1         1         1            1           9h</span><br></pre></td></tr></table></figure><p>然后看一下这个名为kube-system的namespace中的pod信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE</span><br><span class="line">kube-dns-7d7b4f767d-6xnnm   3/3       Running   3          9h</span><br></pre></td></tr></table></figure><p>可以看到这个Pod中运行了三个容器，它们都是Running状态，接下来我们看一下这些容器运行在哪些机器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server02 ~]# kubectl -n kube-system get pods -o wide</span><br><span class="line">NAME                        READY     STATUS    RESTARTS   AGE       IP              NODE</span><br><span class="line">kube-dns-7d7b4f767d-6xnnm   3/3       Running   3          9h        172.20.40.202   192.168.51.123</span><br></pre></td></tr></table></figure><p>可以看到它们都运行在192.168.51.123这台机器上，接下来我们我们先查看这个192.168.51.123机器上运行的容器，然后进入到某一容器中，使用<code>curl nginx-service:8080</code>来访问之前创建的名为nginx-service的service。可以看到它是可以访问的，这就说明dns确实给我们提供了解析的功能，通过名字解析到了对应的CLUSTER-IP。也就是说其实它最终访问的还是<code>CLUSTER-IP:SERVICED_PORT</code>。然后我们还可以查看当前容器的dns配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@kubernetes-bootcamp-7689dc585d-x7bft:/# cat /etc/resolv.conf </span><br><span class="line">nameserver 10.68.0.2</span><br><span class="line">search default.svc.cluster.local. svc.cluster.local. cluster.local.</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure><p>可以看到它第一个nameserver的值就是10.68.0.2，实际上就是通过这个值来解析的，这也可以证实为什么我们通过名字就可以映射到CLUSTER-IP。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;接下来我们开始在Kubernetes简易环境中，来练习和使用一些常用的kubectl的命令，了解这些对于后续熟练和使用kub</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes基础知识</title>
    <link href="http://envyzhan.asia/2022/06/28/2022-k8s-2-simple-environment-construction/"/>
    <id>http://envyzhan.asia/2022/06/28/2022-k8s-2-simple-environment-construction/</id>
    <published>2022-06-28T09:55:30.000Z</published>
    <updated>2022-09-12T08:40:06.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><p>Kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理，用于管理云平台中多个主机上的容器化的应用。Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h1 id="Kubernetes集群"><a href="#Kubernetes集群" class="headerlink" title="Kubernetes集群"></a>Kubernetes集群</h1><p><a href="https://kubernetes.io/zh-cn/">Kubernetes</a> 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。一个Kubernetes集群包含两种类型的资源：Master（调度整个集群）和Nodes（负责运行应用）。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8332cf68b444bf54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Master调度整个集群"><a href="#Master调度整个集群" class="headerlink" title="Master调度整个集群"></a>Master调度整个集群</h3><p>Master协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><h3 id="Nodes负责运行应用"><a href="#Nodes负责运行应用" class="headerlink" title="Nodes负责运行应用"></a>Nodes负责运行应用</h3><p>Node是一个虚拟机或者物理机，它在Kubernetes集群中充当工作机器的角色。每个Node都有Kubelet，它管理Node，而且是Node与Master通信的代理。 Node还具有用于处理容器操作的工具，如Docker或rkt。</p><p>请注意生产级别的Kubernetes集群至少包含三个Node，因为如果一个Node出现故障，那么其对应的etcd成员和控制平面节点都会丢失，并且冗余会受到影响。当然了，开发者可以通过添加更多控制平面节点方式来降低这种风险 。</p><p>在Kubernetes上部署应用时，需要告诉Master来启动应用容器，之后Master就会编排容器在集群的Node上运行。 Node使用Master暴露的Kubernetes API与Master通信。当然了，终端用户也可以使用Kubernetes API与集群进行交互。</p><p>Kubernetes既可以部署在物理机上，也可以部署在虚拟机上。开发者可以使用Minikube开始部署Kubernetes集群。 Minikube是一种轻量级的Kubernetes实现，可在本地计算机上创建VM并部署仅包含一个节点的简单集群。Minikube可用于Linux，macOS和Windows系统。Minikube CLI提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Kubernetes应用部署"><a href="#Kubernetes应用部署" class="headerlink" title="Kubernetes应用部署"></a>Kubernetes应用部署</h1><p>一旦运行了Kubernetes集群，就可以在其上部署容器化应用程序。 为此，你需要创建Kubernetes Deployment配置。Deployment指挥Kubernetes如何创建和更新应用程序的实例。创建Deployment后，Kubernetes master将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则Deployment控制器会将该实例替换为集群中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。</p><p>在没有Kubernetes这种编排系统之前，启动应用程序通常会采取安装脚本这一方式，但它们不允许从机器故障中恢复。Kubernetes Deployments提供了一种与众不同的应用程序管理方法，通过创建应用程序实例并使它们在节点之间运行。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-86d72371396d79dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>你可以使用Kubernetes命令行界面 <strong>Kubectl</strong> 创建和管理Deployment。Kubectl使用Kubernetes API 与集群进行交互。创建Deployment 时，你需要指定应用程序的容器镜像以及要运行的副本数。你可以稍后通过更新Deployment来更改该信息。</p><h1 id="Kubernetes中的概念"><a href="#Kubernetes中的概念" class="headerlink" title="Kubernetes中的概念"></a>Kubernetes中的概念</h1><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes处理的最基本单元，容器本身不会直接分配到主机上，而是会封装到名为Pod的对象中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a020c6f11413799f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图中Pod1里面有一个应用容器，且该Pod有一个独立的IP地址。Pod2里面有一个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。</p><p>Pod3里面有两个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。也就是说这个Pod中的两个应用容器是可以共享IP与磁盘。</p><p>Pod4里面有多个应用容器和磁盘，该Pod也有一个独立的IP地址。也就是说同一个Pod中可以有任意多个应用容器（多个容器间网络共享）和磁盘（多个共享目录）。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Pod是运行在Node上的，kubelet负责调度Pod的运行。只要资源足够，一个Node上可以有任意多个Pod。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3b6cc5f1a8669401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>粗蓝线框的节点是Master节点，其他的都是Node节点。看一下左下角的Node节点，里面运行了一个Pod，然后这个Pod的外面有一层黄色的虚线，这层虚线就是Service。这个Pod有一个IP，地址是10.10.10.1，这个Service也有一个IP，地址是10.10.9.1，可以看到Service和Pod的IP是不一样的。现在有个问题，为什么Pod有了IP，而外面还包一层Service，同时它也有独立的IP呢？</p><p>原因在于Pod是运行在具体的一个Node上，可能在某些场景下这个Pod出了问题（不稳定挂掉了或者服务容器异常退出，甚至整个Node挂掉了），这样的话这个Node就挂掉了，服务就无法访问了。那可能会去其他的位置重新启动一个Node，运行Pod，此时Pod的IP地址肯定变化了，因此就需要一个Service。当我们的Pod出了问题，它的IP地址发生了变化，此时我们还可以通过Service的IP来找到这个Pod。注意Service的IP与其生命周期是对应的，只要这个Service没有被删除，那么Service的IP就会一直存在，并且永远不会发生变化。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看上面两个Node，左侧Node中只有一个Pod，而右侧Node中有两个Pod，一共三个Pod。在多个Pod的情况下，一般都是同一个应用的多个副本，也就是对同一个应用进行扩容，由1个实例变成3个实例，然后它们对外会提供相同的服务。此时这个Service的IP除了可以向上面那样，定位到Pod的地址之外，还有另外一个作用，即对多个Pod的地址进行负载均衡。举个例子，如轮询访问每个Pod。当然了这个Pod不一定是一模一样的，也可以是同一应用的不同版本。比如我在进行灰度发布的时候，一个可能是旧版本，一个可能是新版本，这都是可以的。所以说Kubernetes并没有对Pod本身做任何限制，那怕是完全不同的应用，你也可以将其作为一个Service去管理。只是一般情况下，我们都不会这么做。</p><p>Service的概念我们已经知道了，那么Kubernetes是如何确定哪些Pod属于同一个Service呢？Kubernetes使用Label Selector来进行确定。当我们定义一个Service的时候，可以给它指定一个标签，如<code>s:app=B</code>，有这样一对标签的时候，就可以认为它属于ServiceB。之后它会去搜索所有的Pod，发现上面三个Pod都携带有<code>app=B</code>标签，那么这三个Pod就会自动归属于这个ServiceB。这就让Service和Pod之间的耦合变得很松，非常灵活。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a426db0b2191d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来梳理几个概念，首先是Pod，Pod里面可以运行多个容器，Service里面可以包含多个Pod，然后Development就比较宽泛，可以是部署Pod，也可以是部署Service。</p><p>接下来看一下通过Development来完成应用的扩容过程：首先从Master节点发起了一个Development，向给这个Service里面的Pod扩容成4个实例，而目前就只有一个实例。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1261d3c9878ba39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>扩容的目标对象是Pod，Pod才是一个真实存在的东西，才有扩容和缩容的概念，而Service是没有的，Service只是一个逻辑上存在的东西。它只是通过Label Selector将一组Pod划分为一个逻辑组，从而实现它们的负载均衡而已。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a2783b07670d2b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后就扩容完成了，在其他的两个节点上，也有了运行的Pod，一共是4个实例。然后这个Service就自动将新的Pod包含进来，那么问题来了，它是如何知道这些新的Pod呢？肯定是通过标签，既然是扩容，那么新Pod的标签和原来的Pod的标签是一样的，然后它通过标签选择，将新的Pod都选择上，接着Service就可以对外进行负载均衡，将流量转发给每个Pod。当某个Pod出问题的时候，Service会通过某种机制，不会将流量转发给出现问题的Pod上。</p><p>接下来看一下滚动更新的过程：首先停掉了一个旧的Pod，然后又新启动了一个Pod，此时这个Service中就同时有旧的版本和新的版本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7d06f1f15b9f0fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着又停掉了最下面那个Pod，又启动了一个新的Pod：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a7c59cbcfcb569e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如此进行，直到所有旧的Pod都更新完成，滚动更新就结束了。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-29af65060a479877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在所有的更新和扩容的过程，这个Service的IP都是始终保持不变的，以上就是Kubernetes中的核心概念。</p><h1 id="Kubernetes整体架构"><a href="#Kubernetes整体架构" class="headerlink" title="Kubernetes整体架构"></a>Kubernetes整体架构</h1><p>接下来我们看一下Kubernetes的整体架构，下面这张图初看可能觉得非常乱：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ad6ac17a412e734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先上面这一块是Master节点，然后下面两块分别都是Node节点。Master节点中部署的都是Kubernetes的核心模块，中间的虚线框表示APIServer，它提供了资源操作的唯一入口，并且提供认证、授权和Kubernetes的访问控制。开发者可以通过kuberctl或者自己开发的客户端通过HTTP请求以RESTful API的形式来访问这个APIServer，进而实现对整个集群的控制。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cbcd7e364e6f1a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>ControllerManager负责维护集群的状态，如故障检测、扩缩容、滚动更新等。Scheduler负责资源的调度，它会按照预定的调度策略，将Pod调度给相应的Node节点。前面学习的Mesos和Docker Swarm也都有调度模块，也有非常多的调度策略可以选择，而Kubernetes则有更加丰富的调度策略，关于这一块后面会详细进行介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec9354017f73b5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>右上角还有一个ETCD，主要用作于一致性存储，保存了Pod，Service，还有集群的一些状态等信息，其实就相当于所有的这些Kubernetes集群需要持久化的数据都会存储到这个ETCD中。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-101e46cba059c589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在这个Master节点中还运行了一个kube-dns组件，它负责整个集群的DNS服务，注意这个组件不是必须的。不过一般我们都选择安装它，因为通过名字访问是一个非常重要的功能。右侧还有一个名为dashboard的组件，它提供了集群数据管理的可视化界面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-999fad975491287c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下Node节点。从上图中可以看到，每个Node节点中都有一个Kubelet，Kubelet负责维护当前节点上的容器的生命周期，也负责维护当前节点的网络等。在每个Node节点上都运行一个kube-proxy，kube-proxy负责Service，负责提供内部的服务发现和负载均衡，相当于为Service这个概念提供了一个落地的方法。</p><p>接下来看一下一个Pod Developed全过程：首先用户执行kubectl，向APIServer发起一个命令，然后请求经过认证之后，再由Schedluer的各种策略来评分计算，得到一个目标的Node，然后告诉APIServer。</p><p>APIServer就会请求相关Node的kubelet，然后通过这个kubelet将这个Pod运行起来，同时APIServer会将这个Pod的信息存储到ETCD中。当Pod运行起来之后，这个ControllerManager就会负责管理这个Pod的状态。举个例子，假设这个Pod不小心挂了，那么ControllerManager就会重新创建一个一样的Pod，Pod的扩缩容也是由这个ControllerManager来管理的。此时这个Pod有一个独立的IP地址，我们可以在整个集群内使用这个IP来访问它。但是这个Pod的IP是容易发生变化，比如异常重启、服务升级时IP就变化了。再有一个就是当存在多个实例的时候，我们也不可能实时的去关注这些Pod的IP，并访问它们，于是就有了Service。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9e6b98c295d73335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>图中绿色虚线内有三个Pod，它们同属一一个Service，不再此绿色虚线内的Pod则是单独存在的，并没有提供Service的入口。而具体完成Service工作的则是kube-proxy模块，可以看到在每个Node上都有一个kube-proxy。在任何一个节点上访问这个Service的虚拟IP（即给Service分配的IP）都可以访问到这三个Pod，因此这两个节点对这一个Service都会有一个IP的指向，负载均衡的访问它们。Service的IP虽然在集群内部是可以访问得到，但是在这个集群之外呢？我们是想要在集群外的服务，访问集群内的一个服务，此时应该怎么办？这一点kube-proxy也考虑到了，它可以将服务端口直接暴露在当前的Node上，然后外面的请求直接访问Node上的一个IP就可以关联到这个Service了。</p><p>我们在学习Docker Swarm的时候，知道在容器中可以通过名字来访问其他的容器，Kubernetes也是可以的，这就是kube-dns所做的工作，它提供了整个集群的dns服务，让每个Pod都可以通过名字来访问对方。也就是说，任何一个Pod都可以通过名字来访问另一个Pod。</p><h1 id="Kubernetes-Scheduler调度策略"><a href="#Kubernetes-Scheduler调度策略" class="headerlink" title="Kubernetes Scheduler调度策略"></a>Kubernetes Scheduler调度策略</h1><p>Scheduler用于决定每个Pod应该调度到哪个节点上，Kubernetes的分配方式有两种：预选规则（preselect）和优选规则（optimize-select）。</p><p>【预选规则】预选规则（preselect）这里介绍五个比较重要的规则：NodiskConflict、CheckNodeMemoryPressure、NodeSelector、FitResource和Affinity。<br>（1）NodiskConflict，即看看有没有挂载的冲突。如果一个Pod需要一个挂载，然后在这台机器上，这个挂载已经被其他Pod占用的话，这就是挂载冲突，它不会让挂载冲突这件事情发生。<br>（2）CheckNodeMemoryPressure，即检查当前节点的内存压力，所有内存压力为0的节点可以调度，当然了还存在对磁盘的检查等等。<br>（3）NodeSelector，即选择指定hostname或者具有某些标签的节点，这是非常基础的，所有的服务编排框架都有这样的功能。<br>（4）FitResource，这也是非常基础的，Node需要满足Pod的CPU、内存、GPU等资源的要求。<br>（5）Affinity，亲和性，这个逻辑比较复杂，它可以满足很多需求，如一个Pod必须与另一个Pod运行在一起，一个Pod最好与另一个Pod运行在一起，这是两种描述，它都可以实现。既然有亲和性，那么就有反亲和性，即一个Pod不能与另一个Pod运行在一起，一个Pod最好不要与另一个Pod运行在一起。</p><p>【优选规则】优选规则（optimize-select）是指通过预选规则选出来一系列的Node之后，对这些Node进行打分。Kubernetes会使用一组优先级函数去处理每一个待选的Node，每一个优先级函数会返回一个0-10的分数，分数越高表示这台机器越好，越适合，同时每个函数也会对应一个权重，最终选择一个分值最高的机器来部署Pod。</p><p>这里介绍三个比较重要的规则：SelectorSpreadPriority、LeastRequestedPriority和AffinityPriority。</p><p>（1）SelectorSpreadPriority。对于同一个Service或者Controller的Pod，尽量会分布在不同的机器上，如果指定了区域，则会尽量将Pod分散在不同区域的不同主机上。<br>（2）LeastRequestedPriority。如果一个新的Pod需要分配节点，那么这个节点的优先级就由节点空闲的那部分容量的比值来决定。其实就是使用节点上Pod的总容量减去新的Pod的容量得到的值再除以总容量。也就是说当这个Pod运行在这个节点上之后，当前节点还存在多少空闲，如果空闲越高则分数越大。<br>（3）AffinityPriority，调度综合亲和性机制。Node Selector在调度的时候将Pod限定在某些节点上的时候，它是支持多种操作符的，如in、not in、exists、gt/lt等，它不会去限定对Label的精确匹配，然后会根据这些匹配条件和匹配结果进行一个算法级别的打分。</p><h1 id="Kubernetes-Pod通讯"><a href="#Kubernetes-Pod通讯" class="headerlink" title="Kubernetes Pod通讯"></a>Kubernetes Pod通讯</h1><p>接下来学习Kubernetes Pod与Pod之间的通讯方式有三种，下面分别进行介绍。</p><p>第一种，Pod的内部通讯，同一个Pod中的容器之间的相互通信。这就是近的两个Pod之间的通讯，同一个Pod肯定是运行在同一个主机上，然后它有共享的网络，同一个IP，所以它们之间的访问可以使用localhost加上端口号就能进行访问，这是最简单的一种通信方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-144babbc777e7e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二种，同一个Node上，不同Pod间的通讯。同一个Node上的Pod，它的默认路由都是docker0，由于它们都关联在同一个网桥docker0上，地址网段是相通的，所以它们之间可以直接通过该网桥来进行通讯。然后访问的方式就是可通过Pod的IP来直接访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c647c864ed5f872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三种，不同Node上，不同Pod间的通讯。它们要想实现访问，需要满足几个条件，一个是Pod的IP不能冲突（不能有相同的IP），其次就是Pod的IP要和Node所在IP关联起来，通过这个关联让Pod之间可以相互访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-287c7cdb834a0c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Kubernetes服务发现"><a href="#Kubernetes服务发现" class="headerlink" title="Kubernetes服务发现"></a>Kubernetes服务发现</h1><p>Kubernetes服务发现主要有两个组件，一个是kube-proxy，另一个则是kube-dns。</p><p>kube-proxy其实分为两种类型，一种是ClusterIP，这种对于每个服务都按照一个IPtable规则，会给相关的Pod做一个虚拟IP，会将虚拟IP的流量直接重定向到后端服务的一个集合。这个虚拟IP只能在集群内访问，并且是固定的，前提是Service不删除。另一种则是NodePort，NodePort就是在每一个Node上都起一个监听端口，相当于将服务暴露在节点上，这样就可以让集群外部的服务，通过NodeIP和NodePort去访问到我们集群内部的服务。</p><p>kube-dns是Kubernetes的一个插件，负责集群内部的DNS解析，目的是在集群内部可以让Pod之间通过名字来进行访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes简介&quot;&gt;&lt;a href=&quot;#Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes简介&quot;&gt;&lt;/a&gt;Kubernetes简介&lt;/h1&gt;&lt;p&gt;Kubernetes，简称K8s，是用8代替名字中间的8个字</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes基础知识</title>
    <link href="http://envyzhan.asia/2022/06/28/2022-k8s-1-basic-knowledge/"/>
    <id>http://envyzhan.asia/2022/06/28/2022-k8s-1-basic-knowledge/</id>
    <published>2022-06-28T09:55:30.000Z</published>
    <updated>2022-09-12T08:40:06.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes简介"><a href="#Kubernetes简介" class="headerlink" title="Kubernetes简介"></a>Kubernetes简介</h1><p>Kubernetes，简称K8s，是用8代替名字中间的8个字符“ubernete”而成的缩写。是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理，用于管理云平台中多个主机上的容器化的应用。Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p><h1 id="Kubernetes集群"><a href="#Kubernetes集群" class="headerlink" title="Kubernetes集群"></a>Kubernetes集群</h1><p><a href="https://kubernetes.io/zh-cn/">Kubernetes</a> 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。一个Kubernetes集群包含两种类型的资源：Master（调度整个集群）和Nodes（负责运行应用）。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8332cf68b444bf54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Master调度整个集群"><a href="#Master调度整个集群" class="headerlink" title="Master调度整个集群"></a>Master调度整个集群</h3><p>Master协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><h3 id="Nodes负责运行应用"><a href="#Nodes负责运行应用" class="headerlink" title="Nodes负责运行应用"></a>Nodes负责运行应用</h3><p>Node是一个虚拟机或者物理机，它在Kubernetes集群中充当工作机器的角色。每个Node都有Kubelet，它管理Node，而且是Node与Master通信的代理。 Node还具有用于处理容器操作的工具，如Docker或rkt。</p><p>请注意生产级别的Kubernetes集群至少包含三个Node，因为如果一个Node出现故障，那么其对应的etcd成员和控制平面节点都会丢失，并且冗余会受到影响。当然了，开发者可以通过添加更多控制平面节点方式来降低这种风险 。</p><p>在Kubernetes上部署应用时，需要告诉Master来启动应用容器，之后Master就会编排容器在集群的Node上运行。 Node使用Master暴露的Kubernetes API与Master通信。当然了，终端用户也可以使用Kubernetes API与集群进行交互。</p><p>Kubernetes既可以部署在物理机上，也可以部署在虚拟机上。开发者可以使用Minikube开始部署Kubernetes集群。 Minikube是一种轻量级的Kubernetes实现，可在本地计算机上创建VM并部署仅包含一个节点的简单集群。Minikube可用于Linux，macOS和Windows系统。Minikube CLI提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Kubernetes应用部署"><a href="#Kubernetes应用部署" class="headerlink" title="Kubernetes应用部署"></a>Kubernetes应用部署</h1><p>一旦运行了Kubernetes集群，就可以在其上部署容器化应用程序。 为此，你需要创建Kubernetes Deployment配置。Deployment指挥Kubernetes如何创建和更新应用程序的实例。创建Deployment后，Kubernetes master将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则Deployment控制器会将该实例替换为集群中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。</p><p>在没有Kubernetes这种编排系统之前，启动应用程序通常会采取安装脚本这一方式，但它们不允许从机器故障中恢复。Kubernetes Deployments提供了一种与众不同的应用程序管理方法，通过创建应用程序实例并使它们在节点之间运行。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-86d72371396d79dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>你可以使用Kubernetes命令行界面 <strong>Kubectl</strong> 创建和管理Deployment。Kubectl使用Kubernetes API 与集群进行交互。创建Deployment 时，你需要指定应用程序的容器镜像以及要运行的副本数。你可以稍后通过更新Deployment来更改该信息。</p><h1 id="Kubernetes中的概念"><a href="#Kubernetes中的概念" class="headerlink" title="Kubernetes中的概念"></a>Kubernetes中的概念</h1><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes处理的最基本单元，容器本身不会直接分配到主机上，而是会封装到名为Pod的对象中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a020c6f11413799f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上图中Pod1里面有一个应用容器，且该Pod有一个独立的IP地址。Pod2里面有一个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。</p><p>Pod3里面有两个应用容器，还挂载了一个磁盘，该Pod也有一个独立的IP地址。也就是说这个Pod中的两个应用容器是可以共享IP与磁盘。</p><p>Pod4里面有多个应用容器和磁盘，该Pod也有一个独立的IP地址。也就是说同一个Pod中可以有任意多个应用容器（多个容器间网络共享）和磁盘（多个共享目录）。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Pod是运行在Node上的，kubelet负责调度Pod的运行。只要资源足够，一个Node上可以有任意多个Pod。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3b6cc5f1a8669401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>粗蓝线框的节点是Master节点，其他的都是Node节点。看一下左下角的Node节点，里面运行了一个Pod，然后这个Pod的外面有一层黄色的虚线，这层虚线就是Service。这个Pod有一个IP，地址是10.10.10.1，这个Service也有一个IP，地址是10.10.9.1，可以看到Service和Pod的IP是不一样的。现在有个问题，为什么Pod有了IP，而外面还包一层Service，同时它也有独立的IP呢？</p><p>原因在于Pod是运行在具体的一个Node上，可能在某些场景下这个Pod出了问题（不稳定挂掉了或者服务容器异常退出，甚至整个Node挂掉了），这样的话这个Node就挂掉了，服务就无法访问了。那可能会去其他的位置重新启动一个Node，运行Pod，此时Pod的IP地址肯定变化了，因此就需要一个Service。当我们的Pod出了问题，它的IP地址发生了变化，此时我们还可以通过Service的IP来找到这个Pod。注意Service的IP与其生命周期是对应的，只要这个Service没有被删除，那么Service的IP就会一直存在，并且永远不会发生变化。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2c8d3ac05e843df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看上面两个Node，左侧Node中只有一个Pod，而右侧Node中有两个Pod，一共三个Pod。在多个Pod的情况下，一般都是同一个应用的多个副本，也就是对同一个应用进行扩容，由1个实例变成3个实例，然后它们对外会提供相同的服务。此时这个Service的IP除了可以向上面那样，定位到Pod的地址之外，还有另外一个作用，即对多个Pod的地址进行负载均衡。举个例子，如轮询访问每个Pod。当然了这个Pod不一定是一模一样的，也可以是同一应用的不同版本。比如我在进行灰度发布的时候，一个可能是旧版本，一个可能是新版本，这都是可以的。所以说Kubernetes并没有对Pod本身做任何限制，那怕是完全不同的应用，你也可以将其作为一个Service去管理。只是一般情况下，我们都不会这么做。</p><p>Service的概念我们已经知道了，那么Kubernetes是如何确定哪些Pod属于同一个Service呢？Kubernetes使用Label Selector来进行确定。当我们定义一个Service的时候，可以给它指定一个标签，如<code>s:app=B</code>，有这样一对标签的时候，就可以认为它属于ServiceB。之后它会去搜索所有的Pod，发现上面三个Pod都携带有<code>app=B</code>标签，那么这三个Pod就会自动归属于这个ServiceB。这就让Service和Pod之间的耦合变得很松，非常灵活。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a426db0b2191d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来梳理几个概念，首先是Pod，Pod里面可以运行多个容器，Service里面可以包含多个Pod，然后Development就比较宽泛，可以是部署Pod，也可以是部署Service。</p><p>接下来看一下通过Development来完成应用的扩容过程：首先从Master节点发起了一个Development，向给这个Service里面的Pod扩容成4个实例，而目前就只有一个实例。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1261d3c9878ba39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>扩容的目标对象是Pod，Pod才是一个真实存在的东西，才有扩容和缩容的概念，而Service是没有的，Service只是一个逻辑上存在的东西。它只是通过Label Selector将一组Pod划分为一个逻辑组，从而实现它们的负载均衡而已。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a2783b07670d2b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后就扩容完成了，在其他的两个节点上，也有了运行的Pod，一共是4个实例。然后这个Service就自动将新的Pod包含进来，那么问题来了，它是如何知道这些新的Pod呢？肯定是通过标签，既然是扩容，那么新Pod的标签和原来的Pod的标签是一样的，然后它通过标签选择，将新的Pod都选择上，接着Service就可以对外进行负载均衡，将流量转发给每个Pod。当某个Pod出问题的时候，Service会通过某种机制，不会将流量转发给出现问题的Pod上。</p><p>接下来看一下滚动更新的过程：首先停掉了一个旧的Pod，然后又新启动了一个Pod，此时这个Service中就同时有旧的版本和新的版本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7d06f1f15b9f0fee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着又停掉了最下面那个Pod，又启动了一个新的Pod：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a7c59cbcfcb569e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如此进行，直到所有旧的Pod都更新完成，滚动更新就结束了。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-29af65060a479877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在所有的更新和扩容的过程，这个Service的IP都是始终保持不变的，以上就是Kubernetes中的核心概念。</p><h1 id="Kubernetes整体架构"><a href="#Kubernetes整体架构" class="headerlink" title="Kubernetes整体架构"></a>Kubernetes整体架构</h1><p>接下来我们看一下Kubernetes的整体架构，下面这张图初看可能觉得非常乱：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ad6ac17a412e734.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先上面这一块是Master节点，然后下面两块分别都是Node节点。Master节点中部署的都是Kubernetes的核心模块，中间的虚线框表示APIServer，它提供了资源操作的唯一入口，并且提供认证、授权和Kubernetes的访问控制。开发者可以通过kuberctl或者自己开发的客户端通过HTTP请求以RESTful API的形式来访问这个APIServer，进而实现对整个集群的控制。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cbcd7e364e6f1a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>ControllerManager负责维护集群的状态，如故障检测、扩缩容、滚动更新等。Scheduler负责资源的调度，它会按照预定的调度策略，将Pod调度给相应的Node节点。前面学习的Mesos和Docker Swarm也都有调度模块，也有非常多的调度策略可以选择，而Kubernetes则有更加丰富的调度策略，关于这一块后面会详细进行介绍。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec9354017f73b5c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>右上角还有一个ETCD，主要用作于一致性存储，保存了Pod，Service，还有集群的一些状态等信息，其实就相当于所有的这些Kubernetes集群需要持久化的数据都会存储到这个ETCD中。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-101e46cba059c589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在这个Master节点中还运行了一个kube-dns组件，它负责整个集群的DNS服务，注意这个组件不是必须的。不过一般我们都选择安装它，因为通过名字访问是一个非常重要的功能。右侧还有一个名为dashboard的组件，它提供了集群数据管理的可视化界面。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-999fad975491287c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下Node节点。从上图中可以看到，每个Node节点中都有一个Kubelet，Kubelet负责维护当前节点上的容器的生命周期，也负责维护当前节点的网络等。在每个Node节点上都运行一个kube-proxy，kube-proxy负责Service，负责提供内部的服务发现和负载均衡，相当于为Service这个概念提供了一个落地的方法。</p><p>接下来看一下一个Pod Developed全过程：首先用户执行kubectl，向APIServer发起一个命令，然后请求经过认证之后，再由Schedluer的各种策略来评分计算，得到一个目标的Node，然后告诉APIServer。</p><p>APIServer就会请求相关Node的kubelet，然后通过这个kubelet将这个Pod运行起来，同时APIServer会将这个Pod的信息存储到ETCD中。当Pod运行起来之后，这个ControllerManager就会负责管理这个Pod的状态。举个例子，假设这个Pod不小心挂了，那么ControllerManager就会重新创建一个一样的Pod，Pod的扩缩容也是由这个ControllerManager来管理的。此时这个Pod有一个独立的IP地址，我们可以在整个集群内使用这个IP来访问它。但是这个Pod的IP是容易发生变化，比如异常重启、服务升级时IP就变化了。再有一个就是当存在多个实例的时候，我们也不可能实时的去关注这些Pod的IP，并访问它们，于是就有了Service。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9e6b98c295d73335.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>图中绿色虚线内有三个Pod，它们同属一一个Service，不再此绿色虚线内的Pod则是单独存在的，并没有提供Service的入口。而具体完成Service工作的则是kube-proxy模块，可以看到在每个Node上都有一个kube-proxy。在任何一个节点上访问这个Service的虚拟IP（即给Service分配的IP）都可以访问到这三个Pod，因此这两个节点对这一个Service都会有一个IP的指向，负载均衡的访问它们。Service的IP虽然在集群内部是可以访问得到，但是在这个集群之外呢？我们是想要在集群外的服务，访问集群内的一个服务，此时应该怎么办？这一点kube-proxy也考虑到了，它可以将服务端口直接暴露在当前的Node上，然后外面的请求直接访问Node上的一个IP就可以关联到这个Service了。</p><p>我们在学习Docker Swarm的时候，知道在容器中可以通过名字来访问其他的容器，Kubernetes也是可以的，这就是kube-dns所做的工作，它提供了整个集群的dns服务，让每个Pod都可以通过名字来访问对方。也就是说，任何一个Pod都可以通过名字来访问另一个Pod。</p><h1 id="Kubernetes-Scheduler调度策略"><a href="#Kubernetes-Scheduler调度策略" class="headerlink" title="Kubernetes Scheduler调度策略"></a>Kubernetes Scheduler调度策略</h1><p>Scheduler用于决定每个Pod应该调度到哪个节点上，Kubernetes的分配方式有两种：预选规则（preselect）和优选规则（optimize-select）。</p><p>【预选规则】预选规则（preselect）这里介绍五个比较重要的规则：NodiskConflict、CheckNodeMemoryPressure、NodeSelector、FitResource和Affinity。<br>（1）NodiskConflict，即看看有没有挂载的冲突。如果一个Pod需要一个挂载，然后在这台机器上，这个挂载已经被其他Pod占用的话，这就是挂载冲突，它不会让挂载冲突这件事情发生。<br>（2）CheckNodeMemoryPressure，即检查当前节点的内存压力，所有内存压力为0的节点可以调度，当然了还存在对磁盘的检查等等。<br>（3）NodeSelector，即选择指定hostname或者具有某些标签的节点，这是非常基础的，所有的服务编排框架都有这样的功能。<br>（4）FitResource，这也是非常基础的，Node需要满足Pod的CPU、内存、GPU等资源的要求。<br>（5）Affinity，亲和性，这个逻辑比较复杂，它可以满足很多需求，如一个Pod必须与另一个Pod运行在一起，一个Pod最好与另一个Pod运行在一起，这是两种描述，它都可以实现。既然有亲和性，那么就有反亲和性，即一个Pod不能与另一个Pod运行在一起，一个Pod最好不要与另一个Pod运行在一起。</p><p>【优选规则】优选规则（optimize-select）是指通过预选规则选出来一系列的Node之后，对这些Node进行打分。Kubernetes会使用一组优先级函数去处理每一个待选的Node，每一个优先级函数会返回一个0-10的分数，分数越高表示这台机器越好，越适合，同时每个函数也会对应一个权重，最终选择一个分值最高的机器来部署Pod。</p><p>这里介绍三个比较重要的规则：SelectorSpreadPriority、LeastRequestedPriority和AffinityPriority。</p><p>（1）SelectorSpreadPriority。对于同一个Service或者Controller的Pod，尽量会分布在不同的机器上，如果指定了区域，则会尽量将Pod分散在不同区域的不同主机上。<br>（2）LeastRequestedPriority。如果一个新的Pod需要分配节点，那么这个节点的优先级就由节点空闲的那部分容量的比值来决定。其实就是使用节点上Pod的总容量减去新的Pod的容量得到的值再除以总容量。也就是说当这个Pod运行在这个节点上之后，当前节点还存在多少空闲，如果空闲越高则分数越大。<br>（3）AffinityPriority，调度综合亲和性机制。Node Selector在调度的时候将Pod限定在某些节点上的时候，它是支持多种操作符的，如in、not in、exists、gt/lt等，它不会去限定对Label的精确匹配，然后会根据这些匹配条件和匹配结果进行一个算法级别的打分。</p><h1 id="Kubernetes-Pod通讯"><a href="#Kubernetes-Pod通讯" class="headerlink" title="Kubernetes Pod通讯"></a>Kubernetes Pod通讯</h1><p>接下来学习Kubernetes Pod与Pod之间的通讯方式有三种，下面分别进行介绍。</p><p>第一种，Pod的内部通讯，同一个Pod中的容器之间的相互通信。这就是近的两个Pod之间的通讯，同一个Pod肯定是运行在同一个主机上，然后它有共享的网络，同一个IP，所以它们之间的访问可以使用localhost加上端口号就能进行访问，这是最简单的一种通信方式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-144babbc777e7e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二种，同一个Node上，不同Pod间的通讯。同一个Node上的Pod，它的默认路由都是docker0，由于它们都关联在同一个网桥docker0上，地址网段是相通的，所以它们之间可以直接通过该网桥来进行通讯。然后访问的方式就是可通过Pod的IP来直接访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c647c864ed5f872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三种，不同Node上，不同Pod间的通讯。它们要想实现访问，需要满足几个条件，一个是Pod的IP不能冲突（不能有相同的IP），其次就是Pod的IP要和Node所在IP关联起来，通过这个关联让Pod之间可以相互访问：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-287c7cdb834a0c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Kubernetes服务发现"><a href="#Kubernetes服务发现" class="headerlink" title="Kubernetes服务发现"></a>Kubernetes服务发现</h1><p>Kubernetes服务发现主要有两个组件，一个是kube-proxy，另一个则是kube-dns。</p><p>kube-proxy其实分为两种类型，一种是ClusterIP，这种对于每个服务都按照一个IPtable规则，会给相关的Pod做一个虚拟IP，会将虚拟IP的流量直接重定向到后端服务的一个集合。这个虚拟IP只能在集群内访问，并且是固定的，前提是Service不删除。另一种则是NodePort，NodePort就是在每一个Node上都起一个监听端口，相当于将服务暴露在节点上，这样就可以让集群外部的服务，通过NodeIP和NodePort去访问到我们集群内部的服务。</p><p>kube-dns是Kubernetes的一个插件，负责集群内部的DNS解析，目的是在集群内部可以让Pod之间通过名字来进行访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes简介&quot;&gt;&lt;a href=&quot;#Kubernetes简介&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes简介&quot;&gt;&lt;/a&gt;Kubernetes简介&lt;/h1&gt;&lt;p&gt;Kubernetes，简称K8s，是用8代替名字中间的8个字</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://envyzhan.asia/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot轻松实现接口加解密</title>
    <link href="http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/"/>
    <id>http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/</id>
    <published>2022-06-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:27:28.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开发者可以自定义过滤器，将请求和响应分别拦截并进行相应的解密与加密操作。可以看到这种方式简单粗暴，灵活度高，适应性强。不过呢，本篇决定使用另一种思录，即使用SpringMVC提供的<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理（预处理）。</p><p>本篇尝试利用<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理，并在此基础上对请求和响应进行解密和加密操作，接着将其制作成一个starter并发布到jitPack中，最后新建一个项目来尝试使用该starter。</p><h1 id="编写加解密场景启动器"><a href="#编写加解密场景启动器" class="headerlink" title="编写加解密场景启动器"></a>编写加解密场景启动器</h1><p>第一步，新建一个名为<code>encrypt-spring-boot-starter</code>的SpringBoot项目，在其POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>由于此项目用于接口的加解密，适用于Web环境，因此此处必须添加Web依赖，同时可设置scope值为provided。</p><p>第二步，新建model包，并在该包内新建一个名为ResultBean的响应结果类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class ResultBean &#123;</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatus(Integer status) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getObject() &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObject(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean(Integer status, String message, Object object) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean build()&#123;</span><br><span class="line">        return new ResultBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(200,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message)&#123;</span><br><span class="line">        return new ResultBean(200,message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(500,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message)&#123;</span><br><span class="line">        return new ResultBean(500,message,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建annotations包，并在该包内新建一个名为Decrypt的注解，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Decrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在annotations包内新建一个名为Encrypt的注解，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 加密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解其实是标记注解，其中<code>@Decrypt</code>注解用于标识解密，可用在方法和参数中；<code>@Encrypt</code>注解用于标识加密，可用在方法上。一般来说，我们是对请求或者请求中的参数进行解密，而对响应进行加密。</p><p>第四步，新建config包，并在该包内新建一个名为EncryptProperties的属性配置类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptProperties &#123;</span><br><span class="line">    private final static String DEFAULT_KEY = &quot;www.kenbings.top&quot;;</span><br><span class="line">    private String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用户可能会配置自己的加密key，因此我们需要定义EncryptProperties类，用于将用户在<code>application.properties</code>配置文件中设置的参数进行映射。注意这个加密key必须是16位的字符串，笔者的博客域名刚好满足这个条件。如果开发者没有在<code>application.properties</code>配置文件中配置自己的加密key，那么就会默认使用笔者的博客域名作为默认的加密key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kenbings.encrypt.key=www.kenbings.top</span><br></pre></td></tr></table></figure><p>第五步，新建utils包，并在该包内新建一个名为Base64Utils的工具类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Base64Utils &#123;</span><br><span class="line">    public Base64Utils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decode(byte[] data)&#123;</span><br><span class="line">        return Base64.getDecoder().decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 编码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encode(byte[] data)&#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们定义了两个方法，decode方法用于解码，因为请求或者参数是先解码，转换成可读数据字节数组，之后才进行解密。而encode方法用于编码，注意响应先是先加密，然后在编码为Base64字符串。</p><p>接着在utils包内新建一个名为AESUtils的加解密类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class AESUtils &#123;</span><br><span class="line">    private static final String AES_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个Cipher</span><br><span class="line">     * @param key</span><br><span class="line">     * @param model</span><br><span class="line">     * @return Cipher密码对象</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    private static Cipher getCipher(byte[] key,int model) throws Exception &#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = new SecretKeySpec(key,&quot;AES&quot;);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model,secretKeySpec);</span><br><span class="line">        return cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES解密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.DECRYPT_MODE);</span><br><span class="line">        return cipher.doFinal(Base64Utils.decode(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES加密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return Base64字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.ENCRYPT_MODE);</span><br><span class="line">        return Base64Utils.encode(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们选择了对称加密，且使用了AES算法，采用的是Java自带的Cipher来实现对称加密。这个<code>AES_ALGORITHM</code>变量必须是一个包含三部分的字符串，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p><p>第六步，新建request包，并在该包内新建一个名为DecryptRequest的类，该类用于对接口进行解密，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口解密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class DecryptRequest extends RequestBodyAdviceAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return methodParameter.hasMethodAnnotation(Decrypt.class)|| methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        byte[] body = new byte[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        try&#123;</span><br><span class="line">            byte[] decrypt = AESUtils.decrypt(encryptProperties.getKey().getBytes(), body);</span><br><span class="line">            final ByteArrayInputStream bais = new ByteArrayInputStream(decrypt);</span><br><span class="line">            return new HttpInputMessage() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public InputStream getBody() throws IOException &#123;</span><br><span class="line">                    return bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public HttpHeaders getHeaders() &#123;</span><br><span class="line">                    return inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return super.beforeBodyRead(inputMessage,parameter,targetType,converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>DecryptRequest</code>类继承了<code>RequestBodyAdviceAdapter</code>类，并重写了其中的<code>supports</code>和<code>beforeBodyRead</code>方法，当然了也可以实现<code>RequestBodyAdvice</code>接口，因为<code>RequestBodyAdviceAdapter</code>类其实也是实现了<code>RequestBodyAdvice</code>接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RequestBodyAdviceAdapter implements RequestBodyAdvice &#123;</span><br><span class="line">    public RequestBodyAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        return inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然实现<code>RequestBodyAdvice</code>接口或者继承<code>RequestBodyAdviceAdapter</code>类都可以，那么我们应该使用哪种方式呢？这个很简单，你就看自己需要重写什么方法，如果你只想重写<code>supports</code>和<code>beforeBodyRead</code>方法，那么只需继承<code>RequestBodyAdviceAdapter</code>类，其他方法使用父类的实现即可。<br>（2）<code>supports</code>方法用于判断哪些接口或者参数需要解密，这里的逻辑如果方法上或者方法参数中使用了<code>@Decrypt</code>注解，就表示需要进行解密。<br>（3）<code>beforeBodyRead</code>方法会在参数转换成具体的对象之前执行，这里我们先从流中加载数据，接着对数据进行解密，解密之后构造<code>HttpInputMessage</code>对象并进行返回。<br>（4）注意自定义的RequestBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对请求进行预处理。</p><p>第七步，新建response包，并在该包内新建一个名为EncryptResponse的类，该类用于对接口进行加密，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口加密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class EncryptResponse implements ResponseBodyAdvice&lt;ResultBean&gt; &#123;</span><br><span class="line">    ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ResultBean beforeBodyWrite(ResultBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">        byte[] keyBytes = encryptProperties.getKey().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        try &#123;</span><br><span class="line">            String bodyMessage = body.getMessage();</span><br><span class="line">            if(null != bodyMessage)&#123;</span><br><span class="line">                body.setMessage(AESUtils.encrypt(keyBytes,bodyMessage.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            &#125;</span><br><span class="line">            Object bodyObject = body.getObject();</span><br><span class="line">            if(null != bodyObject)&#123;</span><br><span class="line">                body.setObject(AESUtils.encrypt(keyBytes,objectMapper.writeValueAsBytes(bodyObject)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>EncryptResponse</code>类实现了<code>ResponseBodyAdvice</code>接口，并重写了其中的<code>supports</code>和<code>beforeBodyWrite</code>方法。这个<code>ResponseBodyAdvice</code>接口就不存在对应的实现类了。<br>（2）<code>supports</code>方法用于判断哪些接口需要加密，参数returnType表示返回类型，这里的逻辑如果方法上使用了<code>@Encrypt</code>注解，就表示需要进行加密。<br>（3）<code>beforeBodyWrite</code>方法会在数据响应之前执行，即先对响应数据进行处理，之后才转换为JSON数据进行返回。这里处理逻辑非常简单，如果返回的ResultBean对象中的message和object对象不为空，那么就将这些信息进行加密，状态码这个就无需加密，之后将加密后的数据设置回ResultBean对象中。<br>（4）注意自定义的ResponseBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对响应进行预处理。</p><p>第八步，回到config包中，在里面定义一个名为<code>EncryptAutoConfiguration</code>的自动配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类需要添加<code>@ComponentScan</code>注解，并将当前项目下的所有包都交由SpringIOC容器来管理。</p><p>第九步，定义<code>spring.factories</code>文件。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第八步定义好的<code>EncryptAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.kenbings.encrypt.config.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样我们就完成了自定义场景启动器的定义工作。</p><h1 id="项目本地打包"><a href="#项目本地打包" class="headerlink" title="项目本地打包"></a>项目本地打包</h1><p>第十步，一般来说我们会将自定义的场景启动器打包，然后上传到Maven私服，以供其他同事使用，这里笔者就不上传了，直接本地打包并安装了。点击IDEA中的Maven插件，选择Lifecycle，然后先clean一下，再install一下，这样自定义场景启动器就安装到本地仓库了。</p><h1 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h1><p>接下来我们新建一个SpringBoot项目，然后在其中引入web依赖以及上面自定义的场景启动器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.kenbings&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>接着新建一个名为Book的实体类，这样便于后续进行测试传参和解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个名为<code>BookController</code>的接口类，里面需要提供两个方法，一个是添加新书籍，另一个则是查询书籍信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(BookController.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean getBook()&#123;</span><br><span class="line">        Book book = new Book();</span><br><span class="line">        book.setName(&quot;三国演义&quot;);</span><br><span class="line">        book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">        return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean addBook(@RequestBody Book book)&#123;</span><br><span class="line">       logger.info(&quot;book is=&#123;&#125;&quot;,book);</span><br><span class="line">        return ResultBean.ok(&quot;成功添加该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就可以启动项目进行测试，先来测试一下查询书籍信息的getBook方法，可以看到返回信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0082c41d387bd908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后再来测试一下添加新书籍的addBook方法，以JSON形式传递一个Book对象，添加成功后返回如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9969f1084f8d11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们对上述接口进行改造。对于查询书籍信息的getBook方法，我们可以对返回的响应数据进行加密，因此在该方法上添加<code>@Encrypt</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/book&quot;)</span><br><span class="line">@Encrypt</span><br><span class="line">public ResultBean getBook()&#123;</span><br><span class="line">    Book book = new Book();</span><br><span class="line">    book.setName(&quot;三国演义&quot;);</span><br><span class="line">    book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">    return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启项目，重新访问一下该接口，可以看到页面返回信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8e7c265562fe10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到响应中的信息都被加密了。接下来我们再来看一下用于添加新书籍的addBook方法，该方法以JSON形式传递一个Book对象，接下来我们使用<code>@Decrypt</code>注解来对请求中的参数进行解密，这里直接将上面接口返回的object数据作为参数进行传入，可以看到方法返回结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-85aa87d0d8bd81ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这也就说明接口数据解密成功了。</p><h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p>接下来我们就来看一下前面使用的<code>AES/ECB/PKCS5Padding</code>这个算法字符串。该字符串包含三部分，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p><p>ECB模式是最简单的工作模式，它直接将明文进行分组，然后每组分别加密，这样使得每个分组独立且前后无任何关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * AES/ECB/PKCS5Padding (128)</span><br><span class="line">  * AES加密 ECB模式 PKCS5填充方式 密钥长度必须为16个字节(128位)</span><br><span class="line">  */</span><br><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">     //密钥生成器</span><br><span class="line">     KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">     //设置密钥长度128位</span><br><span class="line">     kgen.init(128, new SecureRandom());</span><br><span class="line">     //生成key</span><br><span class="line">     SecretKey key = kgen.generateKey();</span><br><span class="line"></span><br><span class="line">     //长度为16的二进制数组，密钥我们自己生成也可以.</span><br><span class="line">     byte[] keyBytes = key.getEncoded();</span><br><span class="line">     System.out.println(&quot;keyBytes长度是16 = &quot; + keyBytes.length);</span><br><span class="line"></span><br><span class="line">     //创建AES的密钥</span><br><span class="line">     SecretKeySpec aesKey = new SecretKeySpec(keyBytes, &quot;AES&quot;);</span><br><span class="line"></span><br><span class="line">     //加密 模式 填充方式</span><br><span class="line">     Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</span><br><span class="line">     cipher.init(Cipher.ENCRYPT_MODE, aesKey);</span><br><span class="line"></span><br><span class="line">     //对abc进行加密，因为明文长度不固定，所以需要先分组在加密，每一组长度16个字节</span><br><span class="line">     //不够16的需要进行填充，abc的长度是3个字节，所以要填充13个字节在进行加密</span><br><span class="line">     //所以encrypt的长度为16，因为在加密之前填充了</span><br><span class="line">     //如果长度正好为16个字节，那么也要新填充一个16长度的组，那么加密后的encrypt的长度为32</span><br><span class="line">     byte[] encrypt = cipher.doFinal(&quot;abc&quot;.getBytes());</span><br><span class="line">     System.out.println(encrypt.length);</span><br><span class="line"></span><br><span class="line">     cipher.init(Cipher.DECRYPT_MODE, aesKey);</span><br><span class="line">     byte[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">     System.out.println(new String(decrypt));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>整个加密和解密过程如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-83541dcae149f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章通过对RequestBodyAdvice和ResponseBodyAdvice的介绍让我们知道了如何对请求和响应进行预处理操作，同时结合平常使用的接口加解密需求来实践该知识点。当然了本篇所介绍的接口加解密非常简单，后续笔者会在此基础上扩展加解密方式、支持类上加解密（类中所有接口加解密）、接口动态实现加解密以及定义一个加解密可视化平台。感兴趣的小伙伴可以关注公众号“啃饼思录”，笔者会在那里更新该场景启动器的开发进度信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现图形验证码</title>
    <link href="http://envyzhan.asia/2022/06/06/13-spring-boot-implements-graphic-verification-code/"/>
    <id>http://envyzhan.asia/2022/06/06/13-spring-boot-implements-graphic-verification-code/</id>
    <published>2022-06-06T09:55:30.000Z</published>
    <updated>2022-09-12T08:25:22.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在实际生活中，我们经常会遇到在登陆的时候，需要输入图形验证码这样的场景，验证码不仅可以防止爬虫的抓取，还可以限制接口短时间内被访问的次数，可以说也是一种限流措施。本篇来学习如何在前后端分离架构下，基于SpringBoot实现图形验证码这一功能。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>verify-code</code>的SpringBoot项目，并在其POM文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="创建状态枚举类"><a href="#创建状态枚举类" class="headerlink" title="创建状态枚举类"></a>创建状态枚举类</h3><p>第二步，新建一个enums包，并在该包内新建一个名为RespCode的响应状态枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public enum RespCode &#123;</span><br><span class="line">    SUCCESS(0,&quot;success&quot;),   //成功</span><br><span class="line">    ERROR(1,&quot;error&quot;),   //失败</span><br><span class="line">    ILLEGAL_ARGUMENT(2,&quot;ILLEGAL_ARGUMENT&quot;);   //参数错误</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    RespCode(int code, String desc)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RespCode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode()&#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建响应状态类"><a href="#创建响应状态类" class="headerlink" title="创建响应状态类"></a>创建响应状态类</h3><p>第三步，新建entity包，并在该包内新建一个名为RespBean的响应状态类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class RespBean&lt;T&gt; implements Serializable &#123;</span><br><span class="line">    private int status;</span><br><span class="line">    private String msg;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    private RespBean(int status)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean(int status, String msg)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.msg=msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean(int status, T data)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean(int status, String msg, T data)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.msg=msg;</span><br><span class="line">        this.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStatus()&#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()&#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData()&#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok()&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(String msg)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(T data)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(String msg,T data)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error()&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.ERROR.getCode(),RespCode.ERROR.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error(String errorMessage)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.ERROR.getCode(),errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error(int errorCode,String errorMessage)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(errorCode,errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis工具类"><a href="#Redis工具类" class="headerlink" title="Redis工具类"></a>Redis工具类</h3><p>第四步，新建redis包，并在该包内新建一个名为RedisCache的工具类，该类封装了Redis对字符串类型的操作，即设置值和获取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCacheObject(final String key)&#123;</span><br><span class="line">        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void setCacheObject(final String key, final T value, Integer timeout, TimeUnit timeUnit)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，在redis包内新建一个名为RedisConfig的配置类，该类用于重写Redis的序列化方式。一般来说我们更倾向于在SpringBoot中使用 Spring Data Redis来操作Redis，但是随着而来的则是它的序列化问题，默认使用的是<code>JdkSerializationRedisSerializer</code>，采用的是二进制方式，且会自动的给存入的key和value添加一些前缀，导致实际情况与开发者预想的不一致。针对这种情况我们可以使用<code>Jackson2JsonRedisSerializer</code>这一序列化方式，不建议使用<code>StringRedisTemplate</code>来替代<code>RedisTemplate</code>，因为它提供的数据类型和操作都有限，无法满足日常需要。</p><p>定义一个名为RedisConfig的类，该类用于重写RedisTempplate的序列化逻辑，使用<code>Jackson2JsonRedisSerializer</code>取代默认的<code>JdkSerializationRedisSerializer</code>，这样利于后续开发和使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>第六步，定义一个名为<code>application.yml</code>的配置文件，在里面定义Redis连接信息，同时自定义验证码的一些参数，如缓存中key前缀、验证码过期时间和验证码格式等信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1 # Redis服务器地址</span><br><span class="line">    database: 4 # Redis数据库索引（默认为0）</span><br><span class="line">    port: 6379 # Redis服务器连接端口</span><br><span class="line">    password: root # Redis服务器连接密码（默认为空）</span><br><span class="line">    timeout: 300ms # 连接超时时间（毫秒）</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">verify:</span><br><span class="line">  code:</span><br><span class="line">    prefix: verify_code # 缓存中key前缀</span><br><span class="line">    type: jpg # 验证码格式</span><br><span class="line">    timeout: 60 # 验证码过期时间，单位秒</span><br></pre></td></tr></table></figure><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>第七步，新建config包，并在该包内新建一个名为VerifyCodeConfig的属性配置类，该类用于将用户在<code>application.yml</code>配置文件中定义的配置项与VerifyCodeConfig这一属性POJO类进行映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;verify.code&quot;)</span><br><span class="line">public class VerifyCodeConfig &#123;</span><br><span class="line">    private String prefix;</span><br><span class="line">    private String type;</span><br><span class="line">    private int timeout;</span><br><span class="line"></span><br><span class="line">    //setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建验证码工具类"><a href="#创建验证码工具类" class="headerlink" title="创建验证码工具类"></a>创建验证码工具类</h3><p>第八步，新建utils包，并在该包内新建一个名为CodeUtils的工具类，该类用于生成验证码及图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class CodeUtils &#123;</span><br><span class="line">    //验证码字符集</span><br><span class="line">    private static final char[] chars = &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,</span><br><span class="line">            &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,</span><br><span class="line">            &#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">    //字符数量</span><br><span class="line">    public static final int SIZE = 4;</span><br><span class="line">    //干扰线数量</span><br><span class="line">    public static final int LINES = 4;</span><br><span class="line">    //图片宽度</span><br><span class="line">    public static final int WIDTH = 200;</span><br><span class="line">    //图片高度</span><br><span class="line">    public static final int HEIGHT = 60;</span><br><span class="line">    //字体大小</span><br><span class="line">    public static final int FONT_SIZE = 30;</span><br><span class="line"></span><br><span class="line">    public static Random random = new Random();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回验证码字符串和图片BufferedImage对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Object[] createImage()&#123;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">        //创建空白图片</span><br><span class="line">        BufferedImage image = new BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        //获取图片画笔</span><br><span class="line">        Graphics graphics = image.getGraphics();</span><br><span class="line">        //设置画笔颜色</span><br><span class="line">        graphics.setColor(Color.LIGHT_GRAY);</span><br><span class="line">        //绘制矩形背景</span><br><span class="line">        graphics.fillRect(0,0,WIDTH,HEIGHT);</span><br><span class="line">        //画随机字符</span><br><span class="line">        for (int i = 0; i &lt; SIZE; i++) &#123;</span><br><span class="line">            //获取随机字符串索引</span><br><span class="line">            int n = random.nextInt(chars.length);</span><br><span class="line">            //设置随机颜色</span><br><span class="line">            graphics.setColor(getRandomColor());</span><br><span class="line">            //设置字体大小</span><br><span class="line">            graphics.setFont(new Font(null, Font.BOLD + Font.ITALIC,FONT_SIZE));</span><br><span class="line">            //绘制字符</span><br><span class="line">            graphics.drawString(chars[n]+&quot;&quot;, i * WIDTH/SIZE, HEIGHT*2/3);</span><br><span class="line">            //记录字符</span><br><span class="line">            stringBuffer.append(chars[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        //画干扰线</span><br><span class="line">        for (int i = 0; i &lt; LINES; i++) &#123;</span><br><span class="line">            //设置随机颜色</span><br><span class="line">            graphics.setColor(getRandomColor());</span><br><span class="line">            //随机画线</span><br><span class="line">            graphics.drawLine(random.nextInt(WIDTH),random.nextInt(HEIGHT),random.nextInt(WIDTH),random.nextInt(HEIGHT));</span><br><span class="line">        &#125;</span><br><span class="line">        //返回验证码和图片</span><br><span class="line">        return new Object[]&#123;stringBuffer.toString(),image&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机取色</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Color getRandomColor()&#123;</span><br><span class="line">        Color color = new Color(random.nextInt(256),random.nextInt(256),random.nextInt(256));</span><br><span class="line">        return color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义业务处理类"><a href="#定义业务处理类" class="headerlink" title="定义业务处理类"></a>定义业务处理类</h3><p>第九步，新建service包，并在该包内新建一个名为VerifyCodeService的业务类，该类用于生成验证码及校验用户输入的验证码是否准确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class VerifyCodeService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private VerifyCodeConfig verifyCodeConfig;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    public RespBean generateVerifyCode()&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Object[] objects = CodeUtils.createImage();</span><br><span class="line">        //验证码字符串和图片BufferedImage对象</span><br><span class="line">        //获取验证码字符串，全部转为小写</span><br><span class="line">        String codeStr = objects[0].toString().toLowerCase();</span><br><span class="line">        //获取图片BufferedImage对象</span><br><span class="line">        BufferedImage codeImg = (BufferedImage) objects[1];</span><br><span class="line">        //图片Key对象</span><br><span class="line">        String codeKey = System.currentTimeMillis() + &quot;&quot;;</span><br><span class="line">        //构造缓存Key</span><br><span class="line">        String cacheKey = verifyCodeConfig.getPrefix() + codeKey;</span><br><span class="line">        //将数据存入缓存</span><br><span class="line">        redisCache.setCacheObject(cacheKey,codeStr, verifyCodeConfig.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        try&#123;</span><br><span class="line">            ImageIO.write(codeImg, verifyCodeConfig.getType(), baos);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return RespBean.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String codePic = new String(Base64.getEncoder().encode(baos.toByteArray()));</span><br><span class="line">        map.put(&quot;codeKey&quot;,codeKey);</span><br><span class="line">        map.put(&quot;codePic&quot;,codePic);</span><br><span class="line">        return RespBean.ok(&quot;验证码生成成功&quot;,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean checkVerifyCode(String codeKey,String inputCode)&#123;</span><br><span class="line">        //构造缓存Key</span><br><span class="line">        String cacheKey = verifyCodeConfig.getPrefix() + codeKey;</span><br><span class="line">        //获取缓存Value</span><br><span class="line">        String cacheValue = redisCache.getCacheObject(cacheKey);</span><br><span class="line">        if(Objects.nonNull(cacheValue) &amp;&amp; cacheValue.equalsIgnoreCase(inputCode))&#123;</span><br><span class="line">            return RespBean.ok(&quot;验证码匹配成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.error(&quot;验证码匹配失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）定义<code>generateVerifyCode()</code>方法用于生成图形验证码，然后构建一个返回Map对象，接着构造图片key对象，这个需要在用户请求成功并返回验证码的时候一并携带过去，目的就是后续可以构造缓存key进而从缓存中取出生成的验证码并与用户输入提交的验证码进行对比，进而判断用户验证码是否输入正确；<br>（2）图片key对象这里比较简单，直接采用了时间戳，开发者还可以采用UUID或者其他分布式环境下能唯一标识请求的信息；<br>（3）然后调用<code>mageIO.write()</code>方法通过IO流形式将图片写入到<code>ByteArrayOutputStream </code>中，并将其转成一个Base64字符串添加到返回Map对象中。当然如果你不是前后端分离的架构，可以将其存入Session中，然后从Session中通过<code>session.getAttribute()</code>方法来获取验证码字符串，而图片直接可通过前端显示在页面上；<br>（4）<code>checkVerifyCode()</code>方法就是从缓存中取出返给前端的图形验证码中的验证码字符串，然后与用户输入提交的字符串进行对比，如果校验通过，则说明验证码匹配成功，反之匹配失败。</p><h3 id="定义业务控制器类"><a href="#定义业务控制器类" class="headerlink" title="定义业务控制器类"></a>定义业务控制器类</h3><p>第十步，新建controller包，并在该包内新建一个名为VerifyCodeController的控制器类，该类用于提供生成验证码及校验用户输入验证码是否准确的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class VerifyCodeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private VerifyCodeService verifyCodeService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/generateVerifyCode&quot;)</span><br><span class="line">    public RespBean generateVerifyCode()&#123;</span><br><span class="line">        return verifyCodeService.generateVerifyCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/checkVerifyCode&quot;)</span><br><span class="line">    public RespBean checkVerifyCode(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">        //获取图片key对象</span><br><span class="line">        String codeKey = map.get(&quot;codeKey&quot;);</span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">        String inputCode = map.get(&quot;inputCode&quot;);</span><br><span class="line">        return verifyCodeService.checkVerifyCode(codeKey, inputCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行项目进行测试"><a href="#运行项目进行测试" class="headerlink" title="运行项目进行测试"></a>运行项目进行测试</h3><p>第十一步，启动项目，开始进行测试。打开Postman，按照图示进行操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bc7bfd1a0e773b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到接口返回了成功信息，但是用户无法直接看到生成的图形验证码，只能看到Base64字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;验证码生成成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;codeKey&quot;: &quot;1653484305664&quot;,</span><br><span class="line">        &quot;codePic&quot;: &quot;/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以在Postman的Tests模块，从接口中取出返回的Base64字符串，然后构建HTML字符串模板，由于我们返回的Base64字符串中不包含<code>data:image/jpg;base64,</code>这段标志，因此需要在前面补上，最后将得到的信息设置到visualizer中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1、将接口返回数据赋值</span><br><span class="line">var data = &#123;</span><br><span class="line">    response:pm.response.json()</span><br><span class="line">&#125;</span><br><span class="line">//2、构建HTML模板字符串</span><br><span class="line">//如果base64代码中没有包含&quot;data:image/jpg;base64,&quot;，那么就需要在base64代码前添加</span><br><span class="line">var template = `&lt;html&gt;&lt;img src=&quot;data:image/jpg;base64,&#123;&#123;response.data.codePic&#125;&#125;&quot;/&gt;&lt;/html&gt;`;</span><br><span class="line"></span><br><span class="line">//3、设置visualizer数据，传入模板并进行解析</span><br><span class="line">pm.visualizer.set(template,data);</span><br></pre></td></tr></table></figure><p>注意代码的添加位置，然后再次请求一下生成图形验证码的接口，点击右侧Body区域的Visualizer，可以看到图形验证码已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ae04d123d66d6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着按照图示操作来校验图形验证码，在Body区域选择raw，然后以JSON形式传入之前返回的codeKey以及用户输入的inputCode：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e0974b254b925599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到请求返回成功，并显示验证码匹配成功。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇基于SpringBoot+Redis实现了生成和校验图形验证码的功能，原理就是先生成图形验证码及验证码字符串，然后将验证码字符串存入缓存中，接着将图形验证码及字符串key返回给用户，后续用户在提交验证码时，根据字符串key及输入的验证码，从缓存中取出验证码字符串，并与用户输入提交的验证码进行对比，进而判断是否匹配成功。</p><p>在了解这种原理之后，你就可以举一反三，利用SpringBoot+Redis这一组合拳实现发送和校验短信验证码，接口防刷、防重复提交等功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在实际生活中，我们经常会遇到在登陆的时候，需要输入图形验证码这样的场景，验证码不仅可以防止爬虫的抓取，还可以限制接口短时间内</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现JSON数据重复读取</title>
    <link href="http://envyzhan.asia/2022/06/01/12-springboot-realizes-the-repeated-reading-of-json-data/"/>
    <id>http://envyzhan.asia/2022/06/01/12-springboot-realizes-the-repeated-reading-of-json-data/</id>
    <published>2022-06-01T09:55:30.000Z</published>
    <updated>2022-09-12T08:57:58.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近遇到一个很尴尬的问题，前端传给后端的JSON数据，如果开发者对此进行了拦截并进行了消费，那么后续在controller中就无法再次获取对应数据。原因在于服务端是通过IO流来解析JSON数据，而流是一种特殊的结构，只要读完就没有了，而在某些场景下往往希望可以多次读取。</p><p>举一个非常简单的例子，接口幂等性实现，即同一个接口在规定时间内多次接收到相同参数的请求，那么此时需要拒绝这些相同请求。我们在具体实现的时候，可能会先将请求中的参数提取出来，如果参数是JOSN数据，那么由于流已经读取了，因此后续在接口是无法再次获取JSON数据的。</p><h1 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h1><p>第一步，新建一个名为<code>many-json</code>的SpringBoot项目，并在其中新增Web依赖。</p><p>第二步，新建一个interceptor包，并在该包内新建一个RequestInterceptor类，这个类需要实现HandlerInterceptor接口并重写其中的preHandle方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RequestInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RequestInterceptor.class);</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String line = request.getReader().readLine();</span><br><span class="line">        logger.info(&quot;读取的信息为：&#123;&#125;&quot;,line);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就简单一些，通过流将请求中的参数打印输出一下，这样流就读完了。</p><p>第三步，新建一个config包，并在该包内新建一个MyWebMvcConfig类，这个类需要实现WebMvcConfigurer接口并重写其中的addInterceptors方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new RequestInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是注册拦截器，并设置该拦截器对所有请求都进行拦截。</p><p>第四步，新建一个controller包，并在该包内新建一个KenBingsController类，然后提供一个名为test的接口，注意该接口中参数通过JSON格式来传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class KenBingsController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(KenBingsController.class);</span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String message)&#123;</span><br><span class="line">        logger.info(&quot;用户输入的信息为：&#123;&#125;&quot;,message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，启动项目进行测试。可以看到当用户访问<code>/test</code>接口的时候，该请求被拦截器所拦截，因此preHandle方法将会执行，输入如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a7bb65c7c8133bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>但是由于我们在test方法的参数中使用了<code>@RequestBody</code>注解，而该注解底层是通过解析IO流来解析JSON数据的，加上我们在拦截器中已经读取了流，因此后续接口中就得不到数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5d1a69b2707af08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可是现在我们希望IO流可以被多次读取，此时该如何操作呢？可以利用装饰者模式对HttpServletRequest进行增强，即拦截HttpServletRequest请求且请求参数为JOSN格式调用新的HttpServletRequest包装类。</p><h1 id="装饰者模式对HttpServletRequest进行增强"><a href="#装饰者模式对HttpServletRequest进行增强" class="headerlink" title="装饰者模式对HttpServletRequest进行增强"></a>装饰者模式对HttpServletRequest进行增强</h1><p>第一步，新建一个wrapper包，并在该包内新建一个MyRequestWrapper类，这个类需要继承HttpServletRequestWrapper类并重写其中的getInputStream和getReader方法，同时重载一下父类ServletRequestWrapper中有HttpServletRequest和HttpServletResponse对象的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义请求包装类</span><br><span class="line"> */</span><br><span class="line">public class MyRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private final byte[] bytes;</span><br><span class="line"></span><br><span class="line">    public MyRequestWrapper(HttpServletRequest request,HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        bytes = request.getReader().readLine().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() throws IOException &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int available() throws IOException &#123;</span><br><span class="line">                return bytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() throws IOException &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是自定义了一个新的HttpServletRequest类，并重载了一个包含HttpServletRequest和HttpServletResponse对象的构造方法，目的就是修改请求和响应的字符编码格式以及从IO流出读取数据，然后存入一个字节数组中，并通过重写getInputStream和getReader方法分别从字节数组中获取数据并构造IO流进行返回，这样就实现了IO流的多次读取。</p><p>第二步，新建一个filter包，并在该包内新建一个MyRequestFilter类，这个类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 请求拦截器，只有JSON数据才会使用自定义的RequestWrapper</span><br><span class="line"> */</span><br><span class="line">public class MyRequestFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        if(servletRequest instanceof HttpServletRequest)&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">            if(StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE))&#123;</span><br><span class="line">                MyRequestWrapper wrapper = new MyRequestWrapper(request,(HttpServletResponse) servletResponse);</span><br><span class="line">                filterChain.doFilter(wrapper,servletResponse);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(request,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们重写了doFilter方法，目的就是判断请求的类型，如果请求是HttpServletRequest且请求数据类型为JSON格式才会调用自定义的MyRequestWrapper，即将HttpServletRequest替换为MyRequestWrapper，走IO流可以多次读取的逻辑，之后让过滤器继续往下执行。</p><p>请注意，过滤器最好不要使用<code>@Component</code>注解交由Spring容器来管理，这样会导致每个接口都会被进行过滤，最好是开发者自己手动注册，并且配置过滤的接口。</p><p>第三步，在之前定义的MyWebMvcConfig类中将这个自定义的MyRequestFilter过滤器注册进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new RequestInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FilterRegistrationBean&lt;MyRequestFilter&gt; myRequestFilterFilterRegistrationBean()&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyRequestFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        bean.setFilter(new MyRequestFilter());</span><br><span class="line">        bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，启动项目进行测试。可以发现现在访问<code>/test</code>接口，Postman会返回正常数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aadc04433ce13a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>查看一下控制台可以看到现在controller中也能获取到JSON数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c4e2fe0dda61714c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过装饰者模式对HttpServletRequest进行增强这一方式可以解决JSON重复读取问题，其本质上是对请求数据格式进行判断。如果是JOSN格式，则自定义HttpServletRequest对象，先将数据从IO流中读取，然后存入一个字节数组中，后续多次读取则是多次读取该字节数组并以IO流形式进行返回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近遇到一个很尴尬的问题，前端传给后端的JSON数据，如果开发者对此进行了拦截并进行了消费，那么后续在controller中</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现定时任务</title>
    <link href="http://envyzhan.asia/2022/05/26/11-springboot-implements-timed-tasks/"/>
    <id>http://envyzhan.asia/2022/05/26/11-springboot-implements-timed-tasks/</id>
    <published>2022-05-26T09:55:30.000Z</published>
    <updated>2022-09-12T08:21:37.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中，定时任务是一个很常见的功能，如定时统计订单数、数据库备份、定时发送短信和邮件、定时统计博客访客等等，简单的定时任务可以直接通过Spring提供的<code>@Scheduled</code>注解来实现，复杂一点的定时任务则可以通过集成<code>Quartz</code>（[kwɔːts]）来实现，本篇将分别介绍如何使用这两种方式实现定时任务。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>新建一个名为<code>time-task</code>的SpringBoot项目，后续将在该项目中进行定时任务的实现。</p><h1 id="Scheduled注解方式"><a href="#Scheduled注解方式" class="headerlink" title="@Scheduled注解方式"></a><code>@Scheduled</code>注解方式</h1><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p><strong>第一步，添加依赖。</strong>在项目的POM文件中新增Web依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步，开启定时任务。</strong>在项目启动类上添加<code>@EnableScheduling</code>注解，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TimeTaskApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TimeTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步，配置定时任务。</strong>定时任务主要是通过<code>@Scheduled</code>注解来进行配置。新建一个component包，并在其中创建一个<code>FirstSchedule</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstSchedule &#123;</span><br><span class="line">    @Scheduled(fixedDelay = 1000)</span><br><span class="line">    public void fixedDelay()&#123;</span><br><span class="line">        System.out.println(&quot;fixedDelay：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(fixedRate = 2000)</span><br><span class="line">    public void fixedRate()&#123;</span><br><span class="line">        System.out.println(&quot;fixedRate：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(initialDelay = 1000,fixedRate = 2000)</span><br><span class="line">    public void initialDelay()&#123;</span><br><span class="line">        System.out.println(&quot;initialDelay：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(cron = &quot;0 * * * * ?&quot;)</span><br><span class="line">    public void cron()&#123;</span><br><span class="line">        System.out.println(&quot;cron：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li>通过<code>@Scheduled</code>注解来标注一个定时任务，其中<code>fixedDelay=1000</code>表示在当前任务执行<strong>结束</strong>1秒后开启另一个任务；<code>fixedRate=2000</code>表示在当前任务执行2秒后开启另一个定时任务；<code>initialDelay=1000</code>则表示首次执行的延迟时间为1秒，即任务首次启动任务的延迟时间。</li><li>在<code>@Scheduled</code>注解中也可以使用cron表达式，<code>cron=&quot;0 * * * * ?&quot;</code>表示该定时任务每分钟执行一次。</li><li>以上注解值的单位默认为<code>TimeUnit.MILLISECONDS</code>，即毫秒。</li></ul><p>配置完成后，接下来启动SpringBoot项目，定时任务部分打印日志如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-90f391184cbb6ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h3><p>cron表达式由6个部分组成，从左到右分别是：秒(second)、分(minute)、时(hour)、日(day of month)、月(month)、周(day of week)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────── second (0-59)</span><br><span class="line">│ ┌───────────── minute (0 - 59)</span><br><span class="line">│ │ ┌───────────── hour (0 - 23)</span><br><span class="line">│ │ │ ┌───────────── day of the month (1 - 31)</span><br><span class="line">│ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)</span><br><span class="line">│ │ │ │ │ ┌───────────── day of the week (0 - 7)  (0 or 7 is Sunday, or MON-SUN)</span><br><span class="line">│ │ │ │ │ │</span><br><span class="line">│ │ │ │ │ │</span><br><span class="line">* * * * * *</span><br></pre></td></tr></table></figure><p>各个部分的取值情况如下表所示：</p><table><thead><tr><th align="center">部分</th><th align="center">是否为必填项</th><th align="center">允许填写的值</th><th align="center">允许的通配符</th></tr></thead><tbody><tr><td align="center">秒(second)</td><td align="center">是</td><td align="center">0-59</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">分(minute)</td><td align="center">是</td><td align="center">0-59</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">时(hour)</td><td align="center">是</td><td align="center">0-23</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">日(day of month)</td><td align="center">是</td><td align="center">1-31</td><td align="center"><code>- * ? / L W</code></td></tr><tr><td align="center">月(month)</td><td align="center">是</td><td align="center">1-12 or JAN-DEC</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">周(day of week)</td><td align="center">是</td><td align="center">0-7 or SUN-SAT</td><td align="center"><code>- * ? / L #</code></td></tr></tbody></table><p>解释一下上述通配符的含义：<br>（1）<code>?</code>表示不指定值，如果开发者不关心某个部分的取值时，就可以使用它。请注意，月份中的日期和星期可能会起冲突，因此在配置时这两个必须有一个值是<code>?</code>；</p><p>（2）<code>*</code>表示所有值，举个例子，当你在“秒”上设置<code>*</code>时，则表示每秒都会触发；</p><p>（3）<code>, </code>用于分开多个值，举个例子，当你在“周”上设置 “MON,WED,FRI”，分别表示周一，周三和周五触发；</p><p>（4）<code>-</code> 表示区间，举个例子，当你在“秒”上设置 “10-12”，则表示10,11,12秒都会触发；</p><p>（5）<code>/</code>用于递增触发，举个例子，当你在“秒”上面设置”5/15”，则表示从5秒开始，每增15秒触发(5,20,35,50)；</p><p>（6）<code>#</code>表示序号(即每月的第几个周几)，举个例子，当你在“周”上设置”6#3”，则表示在每月的第三个周六，这种可以用在母亲节和父亲节之类的动态变化节日上面。请注意，在“周”这一部分中，英文字母是不分大小写的，即MON与mon是一样的；</p><p>（7）<code>L</code>表示最后。用在“日”上，表示当月的最后一天(依据当前月份，如果是二月系统会自动判断是否是润年)。 在“周”字段上表示星期六，相当于”7”或”SAT”（周日是第一天，即每个星期的开始）。如果在”L”前加上数字，则表示该数据的最后一个。举个例子，当你在“周”上设置”6L”，则表示”本月最后一个星期五”；</p><p>（8）<code>W</code>表示离指定日期最近的工作日(周一至周五)。举个例子，如果你在“日”上设置”15W”，则表示离每月15号最近的那个工作日触发。如果15号是周六，那么找最近的周五(14号)触发，如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”，它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字，不允许区间”-“)</p><p>（9）<code>L</code>和<code>W</code>可以组合使用。举个例子，如果在“日”上设置”LW”，则表示在本月的最后一个工作日触发，一般用于发薪日。</p><h3 id="一些常用的例子"><a href="#一些常用的例子" class="headerlink" title="一些常用的例子"></a>一些常用的例子</h3><p>（1）<code>0 0 * * * *</code>，表示每天每个小时的开始，即0分0秒；<br>（2）<code>*/10 * * * * *</code>，表示每10秒钟；<br>（3）<code>0 0 8-10 * * *</code>，表示每天8点、9点和10点；<br>（4）<code>0 0 6,19 * * *</code>，表示每天早上 6:00 和晚上 7:00；<br>（5）<code>0 0/30 8-10 * * *</code>，表示每天 8:00、8:30、9:00、9:30、10:00 和 10:30；<br>（6）<code>0 0 9-17 * * MON-FRI</code>，表示工作日朝九晚五；<br>（7）<code>0 0 0 25 12 ?</code>，表示每个圣诞节的午夜；<br>（8）<code>0 0 0 L * *</code>，表示每月最后一天的午夜；<br>（9）<code>0 0 0 L-3 * *</code>，表示每月倒数第三天午夜；<br>（10）<code>0 0 0 1W * *</code>，表示每月第一个工作日的午夜；<br>（11）<code>0 0 0 LW * *</code>，表示每月最后一个工作日的午夜；<br>（12）<code>0 0 0 * * 5L</code>，表示每月最后一个星期五午夜；<br>（13）<code>0 0 0 * * THUL</code>，表示每月最后一个星期四的午夜；<br>（14）<code>0 0 0 ? * 5#2</code>，表示每月第二个星期五午夜；<br>（15）<code>0 0 0 ? * MON#1</code>，表示每月第一个星期一的午夜。</p><h1 id="Quartz-方式"><a href="#Quartz-方式" class="headerlink" title="Quartz 方式"></a>Quartz 方式</h1><h3 id="Quartz-简介"><a href="#Quartz-简介" class="headerlink" title="Quartz 简介"></a>Quartz 简介</h3><p>Quartz是一个功能丰富的开源作业调度库，它由Java编写，可以集成在任何Java应用程序中。开发者可以使用Quartz来创建简单或者复杂的执行计划，它支持数据库、集群、插件以及邮件，且支持cron表达式，具有极高的灵活性。</p><p>一般来说，除非定时任务业务非常简单，否则一般是不会使用<code>@Scheduled</code>注解方式，而是使用Quartz框架。</p><h3 id="小试牛刀-1"><a href="#小试牛刀-1" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p> <strong>第一步，添加依赖。</strong>在项目的POM文件中新增Quartz依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步，开启定时任务。</strong>在项目启动类上添加<code>@EnableScheduling</code>注解，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TimeTaskApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TimeTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步，配置定时任务。</strong>Quartz有三个比较重要的概念，其中JobDetail是用户要做的事情；<br>Trigger是触发器，即事情什么时候做；SchedulerFactory是调度工厂，里面包含多个触发器。</p><p>我们先要确定用户要做的事情（JobDetail），由于用户要做的可能不是一件事，因此需要先定义每件事情（Job）。定义Job有两种方式，可以直接定义Bean或者继承QuartzJobBean这一方式。</p><p>新建一个component包，如果我们选择“直接定义Bean”这一方式，那么在其中创建一个<code>FirstJob</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstJob &#123;</span><br><span class="line">    public void first()&#123;</span><br><span class="line">        System.out.println(&quot;FirstJob---&gt;first:&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比较简单，直接将这个Bean注册到Spring容器中，但是也有缺点，无法传递参数。如果开发者需要传递参数，那么可以选择“继承QuartzJobBean”这一方式，在其中创建一个<code>SecondJob</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SecondJob extends QuartzJobBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;SecondJob---&gt;name:&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来新建一个config包，并在其中创建<code>QuartzConfig</code>类用于对<code>JobDetail</code>和<code>Trigger</code>进行配置，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class QuartzConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    MethodInvokingJobDetailFactoryBean jobDetailOne()&#123;</span><br><span class="line">        MethodInvokingJobDetailFactoryBean bean = new MethodInvokingJobDetailFactoryBean();</span><br><span class="line">        bean.setTargetBeanName(&quot;firstJob&quot;);</span><br><span class="line">        bean.setTargetMethod(&quot;first&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JobDetailFactoryBean jobDetailTwo()&#123;</span><br><span class="line">        JobDetailFactoryBean bean = new JobDetailFactoryBean();</span><br><span class="line">        bean.setJobClass(SecondJob.class);</span><br><span class="line">        JobDataMap jobDataMap = new JobDataMap();</span><br><span class="line">        jobDataMap.put(&quot;name&quot;,&quot;kenbings&quot;);</span><br><span class="line">        bean.setJobDataMap(jobDataMap);</span><br><span class="line">        bean.setDurability(true);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SimpleTriggerFactoryBean simpleTrigger()&#123;</span><br><span class="line">        SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(jobDetailOne().getObject());</span><br><span class="line">        bean.setRepeatCount(3);</span><br><span class="line">        bean.setStartDelay(1000);</span><br><span class="line">        bean.setRepeatInterval(2000);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    CronTriggerFactoryBean cronTrigger()&#123;</span><br><span class="line">        CronTriggerFactoryBean bean = new CronTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(jobDetailTwo().getObject());</span><br><span class="line">        bean.setCronExpression(&quot;* * * * * ?&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SchedulerFactoryBean schedulerFactory()&#123;</span><br><span class="line">        SchedulerFactoryBean bean = new SchedulerFactoryBean();</span><br><span class="line">        SimpleTrigger simpleTrigger = simpleTrigger().getObject();</span><br><span class="line">        CronTrigger cronTrigger = cronTrigger().getObject();</span><br><span class="line">        bean.setTriggers(simpleTrigger,cronTrigger);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上述代码的含义：</p><ul><li><code>JobDetail</code>的配置方式方式：第一种方式通过<code>MethodInvokingJobDetailFactoryBean</code>类配置 <code>JobDetail</code>，只需要指定Job的实例名称和要调用的方法即可，注册这种方式无法在创建 <code>JobDetail</code>时传递参数；第二种方式是通过 <code>JobDetailFactoryBean</code>来实现的，这种方式只需要指定 <code>JobClass</code>即可，当然可以通过 <code>JobDataMap</code>传递参数到Job中，Job中只需要提供属性名，并且提供一个相应的set方法即可接收到参数。</li><li><code>Trigger</code>有多种不同实现，这里展示两种最常使用的<code>Trigger</code>：<code>SimpleTrigger</code>和<code>CronTrigger</code>，这两种<code>Trigger</code>分别使用<code>SimpleTriggerFactoryBean</code>和<code>CronTriggerFactoryBean</code>进行创建。在<code>SimpleTriggerFactoryBean</code>对象中，首先设置<code>JobDetail</code>，然后通过<code>setRepeatCount</code>配置任务循环次数，<code>setStartDelay</code>配置任务启动延迟时间，<code>setRepeatInterval</code>配置任务的时间间隔。在<code>CronTriggerFactoryBean</code>对象中，则主要配置<code>JobDetail</code>和Cron表达式。</li><li>最后通过<code>SchedulerFactoryBean</code>创建<code>SchedulerFactory</code>对象，然后配置<code>Trigger</code>即可。</li></ul><p>经过这几步的配置，定时任务就配置成功了。接下来启动SpringBoot项目，可以看到控制台输出一些信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-559914325add722c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中，定时任务是一个很常见的功能，如定时统计订单数、数据库备份、定时发送短信和邮件、定时统计博客访客等等，简单的定时</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Vue实现一个代码生成器</title>
    <link href="http://envyzhan.asia/2022/05/18/10-use-springboot-and-vue-to-achieve-a-code-generator/"/>
    <id>http://envyzhan.asia/2022/05/18/10-use-springboot-and-vue-to-achieve-a-code-generator/</id>
    <published>2022-05-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:20:01.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们学习了SpringBoot+Vue这一套前后端分离的优秀架构，接下来我们尝试基于此实现一个代码生成器。在平时工作中，可能我们使用比较多的还是Mybatis Generate生成器，以此来根据数据表逆向生成对应的Dao层和Mapper层代码。其实生成器的核心，是使用JDBC来获取数据库中的各种元数据信息，并基于此来实现各种功能。本篇要实现的代码生成器不仅可以生成Dao层和Mapper层代码，还可以生成Service和Controller层代码，涵盖了一些基本操作，开发者要是实现一个简单的项目，几乎可以做到不写任何一行代码。</p><h1 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h1><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0d2004dfa4526ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>用户在序号1/2/3分别输入数据库用户名，密码、连接地址，然后点击序号4，如果数据库可以连接得上，那么序号5就会展示连接成功的提示信息，否则展示连接失败；如果成功接着在序号6中输入要生成的包的名称，也就是<code>$&#123;groupId&#125;.$&#123;artifactId&#125;</code>，接着点击序号7来生成配置，如果成功那么序号8处就会生成对应的数据表名称、实体类名称、mapper文件名称、service名称和controller名称，开发者也可以对这些名称进行修改，之后点击序号9来生成代码，如果生成成功，那么序号10会显示代码生成成功，并在序号11处显示生成的文件地址；如果生成失败，那么序号10会显示代码生成失败，序号11没有内容。</p><h1 id="数据库连接实现"><a href="#数据库连接实现" class="headerlink" title="数据库连接实现"></a>数据库连接实现</h1><p>下图是本部分需要实现的界面，用户输入用户名、密码和连接地址，然后点击测试连接按钮，后展示后台接口返回的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8118579f0861f86d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="数据库连接后端接口实现"><a href="#数据库连接后端接口实现" class="headerlink" title="数据库连接后端接口实现"></a>数据库连接后端接口实现</h3><p>第一步，新建一个名为<code>code-generator</code>的SpringBoot项目，在其POM文件中新增web、mysql和freemarker依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>其中web用于展示页面，mysql用于连接数据库并获取连接元数据信息，freemarker用于制作生成的代码模板。</p><p>第二步，新建controller、model、service和utils包，并在model包里面新建Db实体类，这个表示用户前端输入的用户名，密码和连接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Db &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在model包内新建一个名为RespBean的响应类，后端返给前端的所有数据结构均满足这个类的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class RespBean &#123;</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String msg;</span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public static RespBean ok(String msg, Object data)&#123;</span><br><span class="line">        return new RespBean(200,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean ok(String msg)&#123;</span><br><span class="line">        return new RespBean(200,msg,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean error(String msg, Object data)&#123;</span><br><span class="line">        return new RespBean(500,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean error(String msg)&#123;</span><br><span class="line">        return new RespBean(500,msg,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean(Integer status, String msg, Object data) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，在utils包内新建一个名为DBUtils的工具类，用于返回一个数据库连接和初始化数据库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * DB工具类，用于获取连接信息</span><br><span class="line"> */</span><br><span class="line">public class DBUtils &#123;</span><br><span class="line">    private static Connection connection;</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Connection initDb(Db db)&#123;</span><br><span class="line">        if(null == connection)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                connection = DriverManager.getConnection(db.getUrl(),db.getUsername(), db.getPassword());</span><br><span class="line">            &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，在controller包内新建一个名为DbController的数据库类，用于提供所需要的数据库测试，信息获取等接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DbController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户设置的数据库信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/connect&quot;)</span><br><span class="line">    public RespBean connect(@RequestBody Db db)&#123;</span><br><span class="line">        Connection connection = DBUtils.initDb(db);</span><br><span class="line">        if(null == connection)&#123;</span><br><span class="line">            return RespBean.error(&quot;数据库连接失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;数据库连接成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样数据库连接后端的连接测试接口就已经实现了。</p><h3 id="数据库连接前端页面实现"><a href="#数据库连接前端页面实现" class="headerlink" title="数据库连接前端页面实现"></a>数据库连接前端页面实现</h3><p>在项目<code>resources/static</code>目录下新建一个名为<code>index.html</code>的文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;代码生成器&lt;/title&gt;</span><br><span class="line">    &lt;!--在导入Element之前导入Vue--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/vue@2.6.11/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入ElementUI样式--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">    &lt;!--导入Element所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/element-ui@2.13.0/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入Axios所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户名&lt;/el-tag&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.username&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户密码&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库连接地址&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.url&quot;&gt;</span><br><span class="line">                    &lt;template slot=&quot;prepend&quot;&gt;jdbc:mysql://&lt;/template&gt;</span><br><span class="line">                    &lt;template slot=&quot;append&quot;&gt;</span><br><span class="line">                        ?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">                    &lt;/template&gt;</span><br><span class="line">                &lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; :disabled=&quot;!connectBtnEnabled&quot; @click=&quot;connect&quot;&gt;测试连接&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            connect()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                this.db.url = &quot;jdbc:mysql://&quot; + this.db.url + &quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;;</span><br><span class="line">                axios.post(&#x27;/connect&#x27;, this.db)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                        //还原数据库初始信息</span><br><span class="line">                        _this.db = &#123;</span><br><span class="line">                            username: &quot;root&quot;,</span><br><span class="line">                            password: &quot;root1234&quot;,</span><br><span class="line">                            url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        //禁用按钮</span><br><span class="line">                        _this.connectBtnEnabled = false;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）导入ElementUI、Vue和网络请求Axios库，注意Vue需要在ElementUI之前进行导入；<br>（2）使用了ElementUI的栅格布局，上面三行均采用3 12 9这一布局，标签名使用<code>el-tag</code>元素；输入框使用<code>el-input</code>元素；然后由于数据库连接地址我们采用了拼接这一方式，因此需要使用<code>el-input</code>元素中的prepend和append分别表示输入框的前置和后置内容，注意这与prefix和suffix的区别，后者分别表示输入框头部和尾部内容；<br>（3）用户未点击测试连接按钮之前，该按钮可以点击，一旦点击之后该按钮就会置灰，无法再次点击，除非刷新页面。点击该按钮之后会去请求后端名为<code>/connect</code>的接口，然后从返回的数据中取出信息并进行展示，也就是图中的msg。这里我们使用axios向后端发起请求；<br>（4）请注意axios请求如果成功，那么返回的RespBean对象存在于response的data选项中，之后就可以从中取出对应的数据。这里有两个注意点，第一需要先定义一个局部变量<code>_this</code>用于指代提交前的初始值，因为用户传入的url是只含地址，不包含前缀和后缀，而你如果直接提交，不还原之前的数据，那么之后提交的URL都是错的，所以我们让用户提交之后，让数据还原。第二，点击提交之后按钮需要置灰，用户无法再次点击，这些都是ElementUI中的基本用法。</p><p>用户未点击连接按钮之前，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bde392576d326df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当用户信息输入正确，点击测试连接按钮之后，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96f8d22fc5beff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当用户信息输入错误，点击测试连接按钮之后，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-037082ca4ae2d05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="表对应实体类-Mapper-Service-Controller名称生成实现"><a href="#表对应实体类-Mapper-Service-Controller名称生成实现" class="headerlink" title="表对应实体类/Mapper/Service/Controller名称生成实现"></a>表对应实体类/Mapper/Service/Controller名称生成实现</h1><p>下图是本部分需要实现的界面，用户输入需要生成的包的前缀，点击生成配置按钮，即可显示对应表的实体类/Mapper/Service/Controller名称：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69d4d42d9f53d95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="实体映射后端接口实现"><a href="#实体映射后端接口实现" class="headerlink" title="实体映射后端接口实现"></a>实体映射后端接口实现</h3><p>由于我们需要根据数据库的表来生成与之对应的实体类/Mapper/Service/Controller名称，而数据表和Java实体类之间需要有映射关系，这些关系具体点就是数据表中某个字段与Java实体类对应属性的映射，因此需要先定义一个ColumnClass类来描述映射信息。</p><p>第一步，在model包中新建一个名为ColumnClass的类，用于描述数据表中字段与Java实体类中属性映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述数据表中字段与Java实体类中属性映射关系</span><br><span class="line"> */</span><br><span class="line">public class ColumnClass &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Java实体类中属性名称</span><br><span class="line">     */</span><br><span class="line">    private String propertyName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段名称</span><br><span class="line">     */</span><br><span class="line">    private String columnName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段类型</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段是否为主键</span><br><span class="line">     */</span><br><span class="line">    private Boolean isPrimary;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段是否为空</span><br><span class="line">     */</span><br><span class="line">    private Boolean isNull;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段备注</span><br><span class="line">     */</span><br><span class="line">    private String remark;</span><br><span class="line"></span><br><span class="line">    //toString、setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在model包中新建一个名为TableClass的类，用于描述数据表与Java中对应模块名称的映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述数据表与Java中对应模块名称的映射关系</span><br><span class="line"> */</span><br><span class="line">public class TableClass &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 数据表名称</span><br><span class="line">     */</span><br><span class="line">    private String tableName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实体类名称</span><br><span class="line">     */</span><br><span class="line">    private String modelName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Mapper名称</span><br><span class="line">     */</span><br><span class="line">    private String mapperName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Service名称</span><br><span class="line">     */</span><br><span class="line">    private String serviceName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Controller名称</span><br><span class="line">     */</span><br><span class="line">    private String controllerName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所在包的名称</span><br><span class="line">     */</span><br><span class="line">    private String packageName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所对应的字段信息</span><br><span class="line">     */</span><br><span class="line">    private List&lt;ColumnClass&gt; columns;</span><br><span class="line"></span><br><span class="line">    //toString、setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，将下来完成“生成配置”这一按钮所请求的后端接口。由于用户传入的只有包的名称，因此不建议直接定义一个对象，而是通过Map来传值，否则还需要修改axios的默认传值方式（默认是传对象）。</p><p>在之前定义的DbController类中新增一个名为config的方法，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/config&quot;)</span><br><span class="line">public RespBean config(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    String packageName = map.get(&quot;packageName&quot;);</span><br><span class="line">    try&#123;</span><br><span class="line">        Connection connection = DBUtils.getConnection();</span><br><span class="line">        //获取数据库的元数据</span><br><span class="line">        DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">        //获取数据库中所有的表</span><br><span class="line">        ResultSet tables = metaData.getTables(connection.getCatalog(), null, null, null);</span><br><span class="line">        //将这些表都转换为之前定义的TableClass对象</span><br><span class="line">        List&lt;TableClass&gt; tableClassList = new ArrayList&lt;&gt;();</span><br><span class="line">        while (tables.next())&#123;</span><br><span class="line">            TableClass tableClass = new TableClass();</span><br><span class="line">            //获取表名称</span><br><span class="line">            String tableName = tables.getString(&quot;TABLE_NAME&quot;);</span><br><span class="line">            tableClass.setTableName(tableName);</span><br><span class="line">            tableClass.setPackageName(packageName);</span><br><span class="line">            //获取实体类名称(一般是表名驼峰法且首字母大写这一方式)</span><br><span class="line">            //表名目前是小写下划线形式，转成首字母大写驼峰形式</span><br><span class="line">            String modelName = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, tableName);</span><br><span class="line">            tableClass.setModelName(modelName);</span><br><span class="line">            tableClass.setMapperName(modelName + &quot;Mapper&quot;);</span><br><span class="line">            tableClass.setServiceName(modelName + &quot;Service&quot;);</span><br><span class="line">            tableClass.setControllerName(modelName + &quot;Controller&quot;);</span><br><span class="line">            tableClassList.add(tableClass);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;数据表信息读取成功&quot;,tableClassList);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return RespBean.error(&quot;数据表信息读取成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法就是获取数据库连接并从中得到数据库的元数据信息，然后调用<code> metaData.getTables()</code>方法得到所选择数据库的所有表，该方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet getTables(String catalog, String schemaPattern,</span><br><span class="line">          String tableNamePattern, String types[]) throws SQLException;</span><br></pre></td></tr></table></figure><p>catalog是目录名称，它必须与存储在数据库中的目录名称匹配；如果值为””，则表示检索那些没有目录的；如果值为null，则表示不使用目录名称来缩小搜索范围。</p><p>schemaPattern是模式名称模式，它必须与存储在数据库中的模式名称匹配；如果值为””，则表示检索那些没有模式的； 如果值为null，则表示不使用模式名称来缩小搜索范围。</p><p>tableNamePattern是表名模式，它必须与存储在数据库类型中的表名匹配。<code>types[]</code>是表类型列表，它必须是<code>getTableTypes()</code>方法返回的表类型列表，这样才能包括在内； 如果值为null，则表示返回所有类型。因此此处后续三个参数均使用null值。</p><p>在得到所有的数据表之后，接下来我们就可以通过<code>tables.getString(&quot;TABLE_NAME&quot;)</code>方法得到表的名称，由于表的名称是小写下划线形式，而Java实体类及其他模块都是首字母大写驼峰形式，因此需要进行转换。这里使用谷歌提供的Guava工具进行转换，开发者也可以自行进行编写转换逻辑，这个很简单的。既然使用了Guava，那么就需要在POM文件中进行依赖引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;20.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后就是设置TableClass对象对应的属性，当然了这里我们没有对它的columns属性进行设置，这里直接使用默认值，且一般数据库字段和实体类字段习惯上也是采用表默认的小写下划线形式转成首字母大写驼峰形式。</p><h3 id="实体映射前端页面实现"><a href="#实体映射前端页面实现" class="headerlink" title="实体映射前端页面实现"></a>实体映射前端页面实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;代码生成器&lt;/title&gt;</span><br><span class="line">    &lt;!--在导入Element之前导入Vue--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/vue@2.6.11/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入ElementUI样式--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">    &lt;!--导入Element所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/element-ui@2.13.0/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入Axios所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户名&lt;/el-tag&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.username&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户密码&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库连接地址&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.url&quot;&gt;</span><br><span class="line">                    &lt;template slot=&quot;prepend&quot;&gt;jdbc:mysql://&lt;/template&gt;</span><br><span class="line">                    &lt;template slot=&quot;append&quot;&gt;</span><br><span class="line">                        ?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">                    &lt;/template&gt;</span><br><span class="line">                &lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; :disabled=&quot;!connectBtnEnabled&quot; @click=&quot;connect&quot;&gt;测试连接&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;6&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-tag size=&quot;mini&quot; style=&quot;width: 80px&quot;&gt;请输入包名&lt;/el-tag&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;packageName&quot; size=&quot;mini&quot; style=&quot;width: 300px&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;config&quot;&gt;生成配置&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                packageName: &quot;com.kenbingthoughts.test&quot;,</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            config()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                axios.post(&#x27;/config&#x27;, &#123;packageName: this.packageName&#125;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            connect()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                this.db.url = &quot;jdbc:mysql://&quot; + this.db.url + &quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;;</span><br><span class="line">                axios.post(&#x27;/connect&#x27;, this.db)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                        //还原数据库初始信息</span><br><span class="line">                        _this.db = &#123;</span><br><span class="line">                            username: &quot;root&quot;,</span><br><span class="line">                            password: &quot;root1234&quot;,</span><br><span class="line">                            url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        //禁用按钮</span><br><span class="line">                        _this.connectBtnEnabled = false;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在里面添加如下代码，具体的看代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5c8eceabdd2f948f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-112e40ba1c96b85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>表中数据获取到之后，接下来就是通过表格展示数据了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-table</span><br><span class="line">                :data=&quot;tableData&quot;</span><br><span class="line">                style=&quot;width: 100%&quot;&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;tableName&quot;</span><br><span class="line">                    label=&quot;数据表名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;modelName&quot;</span><br><span class="line">                    label=&quot;实体类名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;mapperName&quot;</span><br><span class="line">                    label=&quot;mapper名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;serviceName&quot;</span><br><span class="line">                    label=&quot;service名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;controllerName&quot;</span><br><span class="line">                    label=&quot;controller名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">        &lt;/el-table&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                tableData: [],</span><br><span class="line">                packageName: &quot;com.kenbingthoughts.test&quot;,</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            config()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                axios.post(&#x27;/config&#x27;, &#123;packageName: this.packageName&#125;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.tableData = response.data.data;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>之后重启项目，页面展示如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-290729e1fb690a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>输入正确信息后，点击测试连接通过后，再点击右侧的生成配置按钮：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-210224ddffc0bec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们所需要的数据已经得到了，但是目前表格还不能编辑，因此我们需要对代码进行修改。其实我们要修改的只是表格中prop字段的值，因此可以使用template中的slot方式来进行替换，同时为了验证上述方式可以修改表格中的值，这里我们还定义了一个updateCode方法用于进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-row&gt;</span><br><span class="line">    &lt;el-table</span><br><span class="line">            :data=&quot;tableData&quot;</span><br><span class="line">            style=&quot;width: 100%&quot;&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                prop=&quot;tableName&quot;</span><br><span class="line">                label=&quot;数据表名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;实体类名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.modelName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;mapper名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.mapperName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;service名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.serviceName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;controller名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.controllerName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;el-button @click=&quot;updateCode&quot; type=&quot;success&quot;&gt;修改代码&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><p>然后在methods选项中新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">updateCode()&#123;</span><br><span class="line">    axios.post(&#x27;/updateCode&#x27;, this.tableData)</span><br><span class="line">        .then(function (response) &#123;</span><br><span class="line">             console.log(response.data);</span><br><span class="line">         &#125;)</span><br><span class="line">        .catch(function (error) &#123;</span><br><span class="line">            console.log(error);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其实这个<code>/updateCode</code>接口后端是不用提供的，这里只是为了测试用户是否真的修改了表格中的数据，只需通过查看用户提交的信息就能确定。之后启动项目，刷新一下首页，可以看到页面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04ce7d86fcc91100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后修改出现两个数据表所对应的实体类名称，然后点击修改代码按钮，可以看到提交给后端的API中实体类名称已经是修改之后的值了，这就说明前面修改数据的方法是有效的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cdb4704079274668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="后端表对应实体类模板生成实现"><a href="#后端表对应实体类模板生成实现" class="headerlink" title="后端表对应实体类模板生成实现"></a>后端表对应实体类模板生成实现</h1><p>下图是本部分需要实现的界面，用户输入需要生成的包的前缀，点击生成配置按钮，即可显示对应表的实体类/Mapper/Service/Controller名称，然后点击生成代码按钮，即可出现生成实体类的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c825e060553a7f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f07a2663b5c8add.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="后端模板生成实现"><a href="#后端模板生成实现" class="headerlink" title="后端模板生成实现"></a>后端模板生成实现</h3><p>前面我们已经得到了TableClass对象，这里面的信息就可以指导我们生成对应的模板信息，之所以有“表对应实体类/Mapper/Service/Controller名称生成实现”这一过程，是因为我们允许用户对TableClass对象进行修改，也就是说我们得到的最终对象是用户提交后的TableClass对象。接下来我们就依据这个TableClass对象来生成对应的模板文件。模板文件类型使用FreeMarker来实现，这也是比较通用的做法。</p><p>第一步，制作实体类模板，由于之前我们在ColumnClass类中定义的只是数据表中的type，而不是实体类中的type，因此这里涉及到一个类型的转换，即根据数据表中字段的类型来选择使用对应的Java数据类型。在项目的<code>resources/templates</code>目录下新建一个名为<code>Model.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.model;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class $&#123;modelName&#125; &#123;</span><br><span class="line">&lt;#if columns??&gt;</span><br><span class="line">    &lt;#list columns as column&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;VARCHAR&#x27;||column.type = &#x27;TEXT&#x27;||column.type = &#x27;CHAR&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private String $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;INT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Integer $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIGINT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Long $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DOUBLE&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Double $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DATETIME&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Date $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Boolean $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">&lt;#if columns??&gt;</span><br><span class="line">    &lt;#list columns as column&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;VARCHAR&#x27;||column.type = &#x27;TEXT&#x27;||column.type = &#x27;CHAR&#x27;&gt;</span><br><span class="line">            public String get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(String $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;INT&#x27;&gt;</span><br><span class="line">            public Integer get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Integer $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIGINT&#x27;&gt;</span><br><span class="line">            public Long get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Long $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DATETIME&#x27;&gt;</span><br><span class="line">            public Date get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Date $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DOUBLE&#x27;&gt;</span><br><span class="line">            public Double get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Double $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIT&#x27;&gt;</span><br><span class="line">            public Boolean get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Boolean $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类之后就是生成的实体类，这里我们导入基本的信息，注意这里面的一些变量均来自用户传入的信息。这里我们需要对用户在数据表中的字段属性和Java中的实体类属性类型进行转换，转换的规则代码中可以看到，这里就不介绍了。</p><p>第二步，在controller包内新建一个名为UpdateCodeController的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UpdateCodeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UpdateCodeService updateCodeService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/updateCode&quot;)</span><br><span class="line">    public RespBean updateCode(@RequestBody List&lt;TableClass&gt; tableClassList, HttpServletRequest req)&#123;</span><br><span class="line">        return updateCodeService.updateCode(tableClassList,req.getServletContext().getRealPath(&quot;/&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建service包，并在该包中新建UpdateCodeService类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UpdateCodeService &#123;</span><br><span class="line"></span><br><span class="line">    //加载FreeMarker配置文件</span><br><span class="line">    Configuration cfg = null;</span><br><span class="line">    &#123;</span><br><span class="line">        //创建当前FreeMarker对应版本的配置类</span><br><span class="line">        cfg = new Configuration(VERSION_2_3_31);</span><br><span class="line">        //设置模板的存放位置</span><br><span class="line">        cfg.setTemplateLoader(new ClassTemplateLoader(UpdateCodeService.class,&quot;/templates&quot;));</span><br><span class="line">        //设置模板的编码格式</span><br><span class="line">        cfg.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean updateCode(List&lt;TableClass&gt; tableClassList, String realPath) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //定义模板</span><br><span class="line">            Template modelTemplate = cfg.getTemplate(&quot;Model.java.ftlh&quot;);</span><br><span class="line">            //获取数据库连接</span><br><span class="line">            Connection connection = DBUtils.getConnection();</span><br><span class="line">            //获取数据库元数据，需要使用里面的表名和字段名</span><br><span class="line">            DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">            //遍历用户传进来的tableClassList信息</span><br><span class="line">            for (TableClass tableClass:tableClassList)&#123;</span><br><span class="line">                //获取指定数据表中所有的字段信息</span><br><span class="line">                ResultSet columns = metaData.getColumns(connection.getCatalog(), null, tableClass.getTableName(), null);</span><br><span class="line">                //获取指定数据表中所有的主键信息</span><br><span class="line">                ResultSet primaryKeys = metaData.getPrimaryKeys(connection.getCatalog(),null, tableClass.getTableName());</span><br><span class="line"></span><br><span class="line">                //定义一个集合用于存放某个数据表中的所有字段</span><br><span class="line">                List&lt;ColumnClass&gt; columnClassList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                //遍历数据表中所有的字段信息</span><br><span class="line">                while (columns.next())&#123;</span><br><span class="line">                    //获取字段名称</span><br><span class="line">                    String columnName = columns.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                    //字段是否是否为空，值为NO或者YES</span><br><span class="line">                    String isNullable = columns.getString(&quot;IS_NULLABLE&quot;);</span><br><span class="line">                    //数据表中字段类型</span><br><span class="line">                    String dataType = columns.getString(&quot;TYPE_NAME&quot;);</span><br><span class="line">                    //数据表中字段备注</span><br><span class="line">                    String columnComment = columns.getString(&quot;REMARKS&quot;);</span><br><span class="line"></span><br><span class="line">                    //组装字段信息</span><br><span class="line">                    ColumnClass columnClass = new ColumnClass();</span><br><span class="line">                    //数据表中字段名称</span><br><span class="line">                    columnClass.setColumnName(columnName);</span><br><span class="line">                    //Java实体类中属性名称</span><br><span class="line">                    columnClass.setPropertyName(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL,columnName));</span><br><span class="line">                    //数据表中字段是否为空</span><br><span class="line">                    if(&quot;YES&quot;.equals(isNullable))&#123;</span><br><span class="line">                        columnClass.setNull(true);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        columnClass.setNull(false);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    //数据表中字段备注</span><br><span class="line">                    columnClass.setRemark(columnComment);</span><br><span class="line">                    //数据表中字段类型</span><br><span class="line">                    columnClass.setType(dataType);</span><br><span class="line"></span><br><span class="line">                    //将主键遍历游标置为0，重新开始</span><br><span class="line">                    primaryKeys.first();</span><br><span class="line">                    while (primaryKeys.next())&#123;</span><br><span class="line">                        String pkName = primaryKeys.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                        //如果主键名称等于字段名称，那么该字段就是主键</span><br><span class="line">                        if(columnName.equals(pkName))&#123;</span><br><span class="line">                            //数据表中字段是否为主键</span><br><span class="line">                            columnClass.setPrimary(true);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    columnClassList.add(columnClass);</span><br><span class="line">                &#125;</span><br><span class="line">                tableClass.setColumns(columnClassList);</span><br><span class="line">                //将包名转换成路径地址</span><br><span class="line">                String path = realPath + &quot;/&quot; + tableClass.getPackageName().replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line">                //生成该表对应的实体类</span><br><span class="line">                update(modelTemplate,tableClass,path + &quot;/model/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return RespBean.ok(&quot;代码生成成功&quot;,realPath);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.error(&quot;代码生成失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成对应的实体类</span><br><span class="line">     * @param template 实体类模板</span><br><span class="line">     * @param tableClass 实体类对应的TableClass对象</span><br><span class="line">     * @param path 实体类存放路径</span><br><span class="line">     */</span><br><span class="line">    private void update(Template template, TableClass tableClass, String path) throws IOException, TemplateException &#123;</span><br><span class="line">        //创建文件夹</span><br><span class="line">        File folder = new File(path);</span><br><span class="line">        if(!folder.exists())&#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        //创建对应的实体类文件(xxx.java文件)</span><br><span class="line">        String fileName = path + &quot;/&quot;+ tableClass.getModelName()+ template.getName().replace(&quot;Model&quot;,&quot;&quot;).replace(&quot;ftlh&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(fileName);</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(fos);</span><br><span class="line"></span><br><span class="line">        //将数据写入模板中</span><br><span class="line">        template.process(tableClass,osw);</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法的作用笔者已经代码中进行了详细介绍，这里就不过多介绍了。</p><p>第四步，在<code>resources/static</code>目录下的<code>index.html</code>中新增如下代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1d3c56bb0206bd61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8929f0f9f22b7e5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第五步，启动项目进行测试，刷新一下页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9e8768e56d79bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后输入正确的信息，点击测试连接按钮后，成功的话再次点击生成配置按钮，最后点击生成代码按钮，可以看到此时页面出现了生成代码的存放位置，且对应位置下确实已经生成了对应的实体类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c825e060553a7f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f07a2663b5c8add.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>本部分后端代码是整个代码生成器的核心，在了解和知悉实体类的生成原理后，其他对应模板的制作和生成差不多。</p><h1 id="后端表对应Mapper-Service-Controller模板生成实现"><a href="#后端表对应Mapper-Service-Controller模板生成实现" class="headerlink" title="后端表对应Mapper/Service/Controller模板生成实现"></a>后端表对应Mapper/Service/Controller模板生成实现</h1><h3 id="后端mapper模板实现"><a href="#后端mapper模板实现" class="headerlink" title="后端mapper模板实现"></a>后端mapper模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Mapper.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.mapper;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface $&#123;mapperName&#125; &#123;</span><br><span class="line">  List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端service模板实现"><a href="#后端service模板实现" class="headerlink" title="后端service模板实现"></a>后端service模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Service.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.service;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.mapper.$&#123;mapperName&#125;;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class $&#123;serviceName&#125; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private $&#123;mapperName&#125; $&#123;mapperName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    public List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s()&#123;</span><br><span class="line">        return $&#123;mapperName?uncap_first&#125;.getAll$&#123;modelName&#125;s();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端controller模板实现"><a href="#后端controller模板实现" class="headerlink" title="后端controller模板实现"></a>后端controller模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Controller.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.controller;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.mapper.$&#123;mapperName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.service.$&#123;serviceName&#125;;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class $&#123;controllerName&#125; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private $&#123;serviceName&#125; $&#123;serviceName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/$&#123;modelName?lower_case&#125;s&quot;)</span><br><span class="line">    public List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s()&#123;</span><br><span class="line">        return $&#123;serviceName?uncap_first&#125;.getAll$&#123;modelName&#125;s();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端mapper-XML模板实现"><a href="#后端mapper-XML模板实现" class="headerlink" title="后端mapper XML模板实现"></a>后端mapper XML模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Controller.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;$&#123;packageName&#125;.mapper.$&#123;mapperName&#125;&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;$&#123;packageName&#125;.model.$&#123;modelName&#125;&quot;&gt;</span><br><span class="line">        &lt;#list columns as column&gt;</span><br><span class="line">            &lt;&lt;#if column.isPrimary??&gt;id&lt;#else&gt;result&lt;/#if&gt; column=&quot;$&#123;column.columnName&#125;&quot; property=&quot;$&#123;column.propertyName?uncap_first&#125;&quot; jdbcType=&quot;&lt;#if column.type=&#x27;INT&#x27;&gt;INTEGER&lt;#elseif column.type=&#x27;DATETIME&#x27;&gt;TIMESTAMP&lt;#elseif column.type=&#x27;TEXT&#x27;&gt;VARCHAR&lt;#else&gt;$&#123;column.type&#125;&lt;/#if&gt;&quot;/&gt;</span><br><span class="line">        &lt;/#list&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAll$&#123;modelName&#125;s&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select * from $&#123;tableName&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>可以看到这里我们生成的模板中都只提供了一个查询全部数据的方法，后续开发者可以自行进行扩展，而且service层没有定义对应的接口文件，而是直接使用了实现类，这个后续也可以进行升级和修改。</p><h3 id="更新模板生成接口"><a href="#更新模板生成接口" class="headerlink" title="更新模板生成接口"></a>更新模板生成接口</h3><p>修改service包下的<code>UpdateCodeService#updateCode()</code>方法为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public RespBean updateCode(List&lt;TableClass&gt; tableClassList, String realPath) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //定义实体类模板</span><br><span class="line">        Template modelTemplate = cfg.getTemplate(&quot;Model.java.ftlh&quot;);</span><br><span class="line">        //定义mapper接口模板</span><br><span class="line">        Template mapperTemplate = cfg.getTemplate(&quot;Mapper.java.ftlh&quot;);</span><br><span class="line">        //定义mapper XML模板</span><br><span class="line">        Template mapperXMLTemplate = cfg.getTemplate(&quot;Mapper.xml.ftlh&quot;);</span><br><span class="line">        //定义Service类模板</span><br><span class="line">        Template serviceTemplate = cfg.getTemplate(&quot;Service.java.ftlh&quot;);</span><br><span class="line">        //定义Controller类模板</span><br><span class="line">        Template controllerTemplate = cfg.getTemplate(&quot;Controller.java.ftlh&quot;);</span><br><span class="line"></span><br><span class="line">        //获取数据库连接</span><br><span class="line">        Connection connection = DBUtils.getConnection();</span><br><span class="line">        //获取数据库元数据，需要使用里面的表名和字段名</span><br><span class="line">        DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">        //遍历用户传进来的tableClassList信息</span><br><span class="line">        for (TableClass tableClass:tableClassList)&#123;</span><br><span class="line">            //获取指定数据表中所有的字段信息</span><br><span class="line">            ResultSet columns = metaData.getColumns(connection.getCatalog(), null, tableClass.getTableName(), null);</span><br><span class="line">            //获取指定数据表中所有的主键信息</span><br><span class="line">            ResultSet primaryKeys = metaData.getPrimaryKeys(connection.getCatalog(),null, tableClass.getTableName());</span><br><span class="line"></span><br><span class="line">            //定义一个集合用于存放某个数据表中的所有字段</span><br><span class="line">            List&lt;ColumnClass&gt; columnClassList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            //遍历数据表中所有的字段信息</span><br><span class="line">            while (columns.next())&#123;</span><br><span class="line">                //获取字段名称</span><br><span class="line">                String columnName = columns.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                //字段是否是否为空，值为NO或者YES</span><br><span class="line">                String isNullable = columns.getString(&quot;IS_NULLABLE&quot;);</span><br><span class="line">                //数据表中字段类型</span><br><span class="line">                String dataType = columns.getString(&quot;TYPE_NAME&quot;);</span><br><span class="line">                //数据表中字段备注</span><br><span class="line">                String columnComment = columns.getString(&quot;REMARKS&quot;);</span><br><span class="line"></span><br><span class="line">                //组装字段信息</span><br><span class="line">                ColumnClass columnClass = new ColumnClass();</span><br><span class="line">                //数据表中字段名称</span><br><span class="line">                columnClass.setColumnName(columnName);</span><br><span class="line">                //Java实体类中属性名称</span><br><span class="line">                columnClass.setPropertyName(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL,columnName));</span><br><span class="line">                //数据表中字段是否为空</span><br><span class="line">                if(&quot;YES&quot;.equals(isNullable))&#123;</span><br><span class="line">                    columnClass.setNull(true);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    columnClass.setNull(false);</span><br><span class="line">                &#125;;</span><br><span class="line">                //数据表中字段备注</span><br><span class="line">                columnClass.setRemark(columnComment);</span><br><span class="line">                //数据表中字段类型</span><br><span class="line">                columnClass.setType(dataType);</span><br><span class="line"></span><br><span class="line">                //将主键遍历游标置为0，重新开始</span><br><span class="line">                primaryKeys.first();</span><br><span class="line">                while (primaryKeys.next())&#123;</span><br><span class="line">                    String pkName = primaryKeys.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                    //如果主键名称等于字段名称，那么该字段就是主键</span><br><span class="line">                    if(columnName.equals(pkName))&#123;</span><br><span class="line">                        //数据表中字段是否为主键</span><br><span class="line">                        columnClass.setPrimary(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                columnClassList.add(columnClass);</span><br><span class="line">            &#125;</span><br><span class="line">            tableClass.setColumns(columnClassList);</span><br><span class="line">            //将包名转换成路径地址</span><br><span class="line">            String path = realPath + &quot;/&quot; + tableClass.getPackageName().replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">            //生成该表对应的实体类</span><br><span class="line">            update(modelTemplate,tableClass,path + &quot;/model/&quot;);</span><br><span class="line">            //生成该表对应的mapper接口类</span><br><span class="line">            update(mapperTemplate,tableClass,path + &quot;/mapper/&quot;);</span><br><span class="line">            //生成该表对应的mapper XML</span><br><span class="line">            update(mapperXMLTemplate,tableClass,path + &quot;/mapper/&quot;);</span><br><span class="line">            //生成该表对应的Service类</span><br><span class="line">            update(serviceTemplate,tableClass,path + &quot;/service/&quot;);</span><br><span class="line">            //生成该表对应的Controller类</span><br><span class="line">            update(controllerTemplate,tableClass,path + &quot;/controller/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;代码生成成功&quot;,realPath);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return RespBean.error(&quot;代码生成失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是读取上面新增的模板信息并生成对应的文件，因此实际上新增的代码只有下图所示的内容：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-da6eb7e2825c69d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e838784eb84701a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><p>运行项目，然后按照之前的操作点击生成对应的代码。接下来我们创建一个项目，来使用这个代码生成器生成的代码，看看生成的代码是否有效。注意由于你指定了包的名称，因此新建项目的包名称也就确定了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e6b06afe27e1bacb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>因此新建一个名为test的项目，前缀就是<code>com.kenbingthoughts</code>，之后在POM文件中引入Web、MySQL和Mybatis依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b0c3db0ed45a025e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后在其<code>application.properties</code>配置文件中新增如下配置项，即用户名、密码和连接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root1234</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/code-generator?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>由于此处我们的Mapper接口和XML文件放在一起，因此需要在其POM文件中新增如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!--Mapper文件和XML放在一起需要添加--&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>接着启动项目，依次访问controller中的接口，可以看到接口返回正常值，这就说明生成的代码是正确的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64fe2999a0fb3e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇利用SpringBoot+Vue+FreeMarker实现了一个简易版的代码生成器，其实它还有很多可以改进的地方，如可以显示数据表中的字段信息详情，支持用户修改字段所对应的实体属性信息，页面布局优化，生成的地址固定等，这些等后期有空会进行升级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们学习了SpringBoot+Vue这一套前后端分离的优秀架构，接下来我们尝试基于此实现一个代码生成器。在平时工作中</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>关于Freemarker模板引擎，需要知道这些</title>
    <link href="http://envyzhan.asia/2022/04/26/9-what-you-need-to-know-about-freemarker-template-engine/"/>
    <id>http://envyzhan.asia/2022/04/26/9-what-you-need-to-know-about-freemarker-template-engine/</id>
    <published>2022-04-26T09:55:30.000Z</published>
    <updated>2022-09-12T08:18:03.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>尽管在目前企业级的应用开发中，前后端分离是趋势，但是视图层技术还是占用一席之地。SpringBoot对视图层技术也提供了很好的支持，官方推荐使用的模板引擎是Thymeleaf，但是FreeMaker也支持，当然你可以像SSM中使用JSP等，但是非常不推荐使用。</p><h1 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h1><h3 id="FreeMarker简介"><a href="#FreeMarker简介" class="headerlink" title="FreeMarker简介"></a>FreeMarker简介</h3><p>FreeMarker是一个非常古老的Java模板引擎，可以用在Web或者非Web环境中。与Thymeleaf不同的是FreeMarker需要经过解析才能够在浏览器中展示出来。FreeMarker不仅可以用来配置HTML页面模板，也可以作为电子邮箱模板、配置文件模板以及源码模板等。正是由于它可以适应不同的应用场景，因此它虽然古老但是依旧还是有人愿意使用它。</p><p>下面是一张摘自FreeMarker官网的图片：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-45e88181a0d1c2ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到FreeMarker可以将模板（Template）和数据（Java Objects）进行渲染为HTML页面。</p><h3 id="FreeMarker模板文件及存放位置"><a href="#FreeMarker模板文件及存放位置" class="headerlink" title="FreeMarker模板文件及存放位置"></a>FreeMarker模板文件及存放位置</h3><p>查看一下这个<code>spring-boot-autoconfigure</code>依赖的<code>META-INF</code>文件夹下面的<code>spring.factories</code>文件，里面有如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br></pre></td></tr></table></figure><p>然后进入查看一下这个类，源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FreeMarkerTemplateAvailabilityProvider extends PathBasedTemplateAvailabilityProvider &#123;</span><br><span class="line">    public FreeMarkerTemplateAvailabilityProvider() &#123;</span><br><span class="line">        super(&quot;freemarker.template.Configuration&quot;, FreeMarkerTemplateAvailabilityProvider.FreeMarkerTemplateAvailabilityProperties.class, &quot;spring.freemarker&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static final class FreeMarkerTemplateAvailabilityProperties extends TemplateAvailabilityProperties &#123;</span><br><span class="line">        private List&lt;String&gt; templateLoaderPath = new ArrayList(Arrays.asList(&quot;classpath:/templates/&quot;));</span><br><span class="line"></span><br><span class="line">        FreeMarkerTemplateAvailabilityProperties() &#123;</span><br><span class="line">            super(&quot;&quot;, &quot;.ftlh&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected List&lt;String&gt; getLoaderPath() &#123;</span><br><span class="line">            return this.templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;String&gt; getTemplateLoaderPath() &#123;</span><br><span class="line">            return this.templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTemplateLoaderPath(List&lt;String&gt; templateLoaderPath) &#123;</span><br><span class="line">            this.templateLoaderPath = templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到FreeMarker模板后缀为<code>ftlh</code>（FreeMarker Template Language）。FTL是一种简单专用的语言，不是编程语言，因此在模板中开发者只需专注于如何展现数据， 而数据的获取则在模板之外确定。FreeMarker模板文件的存放路径位于<code>classpath:/templates/</code>路径下，这一点需要引起注意。</p><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p><strong>第一步</strong>，新建一个名为<code>learn-freemarker</code>的SpringBoot项目，然后在POM文件中新增FreeMarker和Web依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接着继续查看这个<code>spring-boot-autoconfigure</code>依赖的<code>META-INF</code>文件夹下面的<code>spring.factories</code>文件中关于FreeMarker的自动配置类<code>FreeMarkerAutoConfiguration</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>查看一下这个<code>FreeMarkerAutoConfiguration</code>自动配置类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class&#125;)</span><br><span class="line">@EnableConfigurationProperties(&#123;FreeMarkerProperties.class&#125;)</span><br><span class="line">@Import(&#123;FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfiguration.class&#125;)</span><br><span class="line">public class FreeMarkerAutoConfiguration &#123;</span><br><span class="line">    private static final Log logger = LogFactory.getLog(FreeMarkerAutoConfiguration.class);</span><br><span class="line">    private final ApplicationContext applicationContext;</span><br><span class="line">    private final FreeMarkerProperties properties;</span><br><span class="line"></span><br><span class="line">    //有参构造方法注入ApplicationContext、FreeMarkerProperties对象</span><br><span class="line">    public FreeMarkerAutoConfiguration(ApplicationContext applicationContext, FreeMarkerProperties properties) &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">        this.checkTemplateLocationExists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检查模板存放位置是否存在</span><br><span class="line">    public void checkTemplateLocationExists() &#123;</span><br><span class="line">        if (logger.isWarnEnabled() &amp;&amp; this.properties.isCheckTemplateLocation()) &#123;</span><br><span class="line">            List&lt;TemplateLocation&gt; locations = this.getLocations();</span><br><span class="line">            if (locations.stream().noneMatch(this::locationExists)) &#123;</span><br><span class="line">                logger.warn(&quot;Cannot find template location(s): &quot; + locations + &quot; (please add some templates, check your FreeMarker configuration, or set spring.freemarker.checkTemplateLocation=false)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取模板的位置</span><br><span class="line">    private List&lt;TemplateLocation&gt; getLocations() &#123;</span><br><span class="line">        List&lt;TemplateLocation&gt; locations = new ArrayList();</span><br><span class="line">        String[] var2 = this.properties.getTemplateLoaderPath();</span><br><span class="line">        int var3 = var2.length;</span><br><span class="line"></span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String templateLoaderPath = var2[var4];</span><br><span class="line">            TemplateLocation location = new TemplateLocation(templateLoaderPath);</span><br><span class="line">            locations.add(location);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否存在模板位置</span><br><span class="line">    private boolean locationExists(TemplateLocation location) &#123;</span><br><span class="line">        return location.exists(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从里面可以看出，当classpath下面存在<code>freemarker.template.Configuration</code>和<code>FreeMarkerConfigurationFactory</code>类时，这个自动配置类才会生效，实际上这两个类在我们引入freemarker场景启动器时就已经存在了。属性POJO类则是FreeMarkerProperties，到时候开发者需要重写配置项的时候可以从该类中进行查阅。</p><p>同时还导入了<code>FreeMarkerServletWebConfiguration</code>、<code>FreeMarkerReactiveWebConfiguration</code>和<code>FreeMarkerNonWebConfiguration</code>这三个类，由于我们使用的是普通的Web项目，因此真正用到的还是<code>FreeMarkerServletWebConfiguration</code>这个类。查看一下这个类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, FreeMarkerConfigurer.class&#125;)</span><br><span class="line">@AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class&#125;)</span><br><span class="line">class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration &#123;</span><br><span class="line">    protected FreeMarkerServletWebConfiguration(FreeMarkerProperties properties) &#123;</span><br><span class="line">        super(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(&#123;FreeMarkerConfig.class&#125;)</span><br><span class="line">    FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();</span><br><span class="line">        this.applyProperties(configurer);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    freemarker.template.Configuration freeMarkerConfiguration(FreeMarkerConfig configurer) &#123;</span><br><span class="line">        return configurer.getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        name = &#123;&quot;freeMarkerViewResolver&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    @ConditionalOnProperty(</span><br><span class="line">        name = &#123;&quot;spring.freemarker.enabled&quot;&#125;,</span><br><span class="line">        matchIfMissing = true</span><br><span class="line">    )</span><br><span class="line">    FreeMarkerViewResolver freeMarkerViewResolver() &#123;</span><br><span class="line">        FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();</span><br><span class="line">        this.getProperties().applyToMvcViewResolver(resolver);</span><br><span class="line">        return resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnEnabledResourceChain</span><br><span class="line">    @ConditionalOnMissingFilterBean(&#123;ResourceUrlEncodingFilter.class&#125;)</span><br><span class="line">    FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; resourceUrlEncodingFilter() &#123;</span><br><span class="line">        FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; registration = new FilterRegistrationBean(new ResourceUrlEncodingFilter(), new ServletRegistrationBean[0]);</span><br><span class="line">        registration.setDispatcherTypes(DispatcherType.REQUEST, new DispatcherType[]&#123;DispatcherType.ERROR&#125;);</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>@Configuration</code>注解表示当前类为一个配置类，可以被Spring扫描的到；<br>（2）<code>@ConditionalOnWebApplication</code>表示当前配置类在Web环境下才生效；<br>（3）<code>@ConditionalOnClass</code>表示当前环境中只有存在Servlet和FreeMarkerConfigurer时才会生效；<br>（4）<code>@AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class&#125;)</code>表示当前自动化配置需要在WebMvcAutoConfiguration之后才会完成；<br>（5）之后这个<code>FreeMarkerServletWebConfiguration</code>提供了一个有参的构造方法，里面注入了FreeMarkerProperties所对应的属性POJO类；<br>（6）当我们没有提供<code>FreeMarkerConfig</code>实例时，系统会自动提供一个<code>FreeMarkerConfigurer</code>实例。<code>FreeMarkerConfigurer</code>是一个类，实现了<code>FreeMarkerConfig</code>接口，里面定义了Freemarker的基本配置；<br>（7）<code>FreeMarkerViewResolver</code>则是FreeMarker视图解析器，上面使用了<code>@ConditionalOnMissingBean</code>和<code>@ConditionalOnProperty</code>注解表示只有当前环境中缺失<code>FreeMarkerViewResolver</code>对象和<code>spring.freemarker.enabled</code>属性值为true，系统会自动提供一个<code>FreeMarkerViewResolver</code>实例。</p><p>接下来我们再来看一下这个<code>FreeMarkerProperties</code>属性POJO类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.freemarker&quot;</span><br><span class="line">)</span><br><span class="line">public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties &#123;</span><br><span class="line">    public static final String DEFAULT_TEMPLATE_LOADER_PATH = &quot;classpath:/templates/&quot;;</span><br><span class="line">    public static final String DEFAULT_PREFIX = &quot;&quot;;</span><br><span class="line">    public static final String DEFAULT_SUFFIX = &quot;.ftlh&quot;;</span><br><span class="line">    private Map&lt;String, String&gt; settings = new HashMap();</span><br><span class="line">    private String[] templateLoaderPath = new String[]&#123;&quot;classpath:/templates/&quot;&#125;;</span><br><span class="line">    private boolean preferFileSystemAccess;</span><br><span class="line"></span><br><span class="line">    public FreeMarkerProperties() &#123;</span><br><span class="line">        super(&quot;&quot;, &quot;.ftlh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, String&gt; getSettings() &#123;</span><br><span class="line">        return this.settings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSettings(Map&lt;String, String&gt; settings) &#123;</span><br><span class="line">        this.settings = settings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getTemplateLoaderPath() &#123;</span><br><span class="line">        return this.templateLoaderPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isPreferFileSystemAccess() &#123;</span><br><span class="line">        return this.preferFileSystemAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPreferFileSystemAccess(boolean preferFileSystemAccess) &#123;</span><br><span class="line">        this.preferFileSystemAccess = preferFileSystemAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTemplateLoaderPath(String... templateLoaderPaths) &#123;</span><br><span class="line">        this.templateLoaderPath = templateLoaderPaths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>FreeMarkerProperties</code>属性POJO类中配置了FreeMarker的一些基本信息，如模板默认存放地址为<code>classpath:/templates/</code>，模板后缀为<code>.ftlh</code>，这些后续开发者可以在项目配置文件中进行覆盖。</p><p><strong>第二步</strong>，出于简单考虑，这里就不使用数据库了，直接定义一个实体类Book：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int price;</span><br><span class="line">    //getter和setter方法，无参和全参构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，新建BookController类，提供一个访问数据的接口<code>/books</code>，注意它返回的是视图，因此不能使用<code>@RestController</code>注解，必须使用<code>@Controller</code>注解。</p><p>ModelAndView是模型数据和逻辑视图对象，它装载了模型的数据和逻辑视图，你可以通过<code>modelAndView.addObject(&quot;key&quot;,ojbect);</code>方式来添加模型数据，然后使用<code>modelAndView.setViewName(&quot;视图名称&quot;);</code>方式来设置逻辑视图。BookController类里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @GetMapping(value = &quot;/books&quot;)</span><br><span class="line">    public ModelAndView books()&#123;</span><br><span class="line">        List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">                new Book(1, &quot;三国演义&quot;, 168),</span><br><span class="line">                new Book(2, &quot;红楼梦&quot;, 188),</span><br><span class="line">                new Book(2, &quot;西游记&quot;, 128),</span><br><span class="line">                new Book(2, &quot;水浒传&quot;, 108)</span><br><span class="line">        );</span><br><span class="line">        //实例化模型数据和逻辑视图对象</span><br><span class="line">        ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">        //添加模型数据</span><br><span class="line">        modelAndView.addObject(&quot;books&quot;,books);</span><br><span class="line">        //设置逻辑视图</span><br><span class="line">        modelAndView.setViewName(&quot;index&quot;);</span><br><span class="line">        return modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在resources目录下的templates文件夹中新建<code>index.ftlh</code>（请注意这里的index就是你在<code>modelAndView.setViewName(&quot;index&quot;)</code>中设置的逻辑视图名称，这个需要保持一致），里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;图书列表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;图书列表&lt;/h2&gt;</span><br><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books as book&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>请注意首先你需要判断model中的books不为空且books中有数据，然后才能进行遍历，接着通过遍历books集合，将集合中的数据通过表格展示出来。</p><p><strong>第五步</strong>，启动项目。在浏览器地址栏中输入<code>http://localhost:8080/books</code>即可看到运行结果，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c191dac8b552d921.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>如果开发者需要覆盖<code>FreeMarkerProperties</code>属性POJO类中的默认值，那么可以在<code>aplication.properties</code>文件中进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># HttpServletRequest的属性是否可以覆盖Controller中的model的同名项</span><br><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line"># HttpSession的属性是否可以覆盖Controller中的model的同名项</span><br><span class="line">spring.freemarker.allow-session-override=false</span><br><span class="line"># 是否开启缓存，开发时可设置为false，默认为true</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line"># 检查模板位置是否存在，默认为true</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line"># 模板文件编码</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line"># 模板文件位置</span><br><span class="line">spring.freemarker.prefix=classpath:/templates/</span><br><span class="line"># Content-Type配置</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line"># 模板文件后缀</span><br><span class="line">spring.freemarker.suffix=.ftlh</span><br><span class="line"># 是否将HttpServletRequest中的属性添加到Model中</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line"># 是否将HttpSession中的属性添加到Model中</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br></pre></td></tr></table></figure><h1 id="FreeMarker详细使用"><a href="#FreeMarker详细使用" class="headerlink" title="FreeMarker详细使用"></a>FreeMarker详细使用</h1><h3 id="插值与表达式"><a href="#插值与表达式" class="headerlink" title="插值与表达式"></a>插值与表达式</h3><h5 id="直接输出值"><a href="#直接输出值" class="headerlink" title="直接输出值"></a>直接输出值</h5><p><strong>（1）数字。</strong>在FreeMarker中使用数字有两个注意事项：（a）小数点之前的0不能省略，即<code>0.1</code>不能写成<code>.1</code>；（b）对于1、+1、和1.0而言，它们是一致的。</p><p>查看一下如下的ftlh语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=11&gt;</span><br><span class="line">&lt;div&gt;$&#123;num&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;#assign num=11&gt;</code>表示定义一个名为num的变量，值为11，然后通过<code>&lt;div&gt;$&#123;num&#125;&lt;/div&gt;</code>将其进行输出：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a3f555bbff0fa4e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者需要输出人民币，可以使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=11&gt;</span><br><span class="line">&lt;div&gt;$&#123;num?string.currency&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到数字前面就多出了一个人民币符号：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7ec18457cea5dd44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果需要展示百分数，可以使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=0.66&gt;</span><br><span class="line">&lt;div&gt;$&#123;num?string.percent&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到数字就以百分数形式进行展示了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bdf44364e089a0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（2）字符串。</strong>在FreeMarker中可以使用如下方式直接输出字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;&quot;啃饼思录&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到文字就直接显示了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1c36a2c4780f2646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要输出一些包含特殊符号的字符串，如<code>文件磁盘D:\测试</code>，那么需要使用<code>\</code>进行转义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;&quot;文件磁盘D:\\测试&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样上述字符串才可以被显示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa0d710a9c9f8792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>不过转义这种太麻烦了，尤其是字符串中包含很多需要转义的字符，此时可以在目标字符串引号之前添加r字符，表示自然转义，那么该目标字符串就会被直接输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;r&quot;文件磁盘D:\测试&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样上述字符串也是可以被显示的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa0d710a9c9f8792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（3）布尔值。</strong>在FreeMarker中布尔值可以直接定义，不需要使用引号引起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign flag=false&gt;</span><br><span class="line">&lt;div&gt;$&#123;flag?string(&quot;A&quot;,&quot;B&quot;)&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;#assign flag=false&gt;</code>表示定义一个名为flag的变量，值为false，然后通过<code>&lt;div&gt;$&#123;flag?string(&quot;A&quot;,&quot;B&quot;)&#125;&lt;/div&gt;</code>将其进行输出，它判断flag值是否为true，如果是则输出A，否则输出B：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d037ab0f463cb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（4）集合。</strong>在FreeMarker中开发者可以直接定义一个集合，然后遍历该集合进行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [&quot;春天&quot;, &quot;夏天&quot;, &quot;秋天&quot;, &quot;冬天&quot;] as season&gt;</span><br><span class="line">    &lt;p&gt;$&#123;season&#125;&lt;/p&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>season表示其中的每个季节，遍历输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6d8efa391c77df9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，集合中的元素也可以是一个表达式，可以是字符串，不要求这些元素的类型是一致的，如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [1+1,8-1,2*4,6/3,&quot;kenbingthoughts&quot;] as v&gt;</span><br><span class="line">    &lt;p&gt;$&#123;v&#125;&lt;/p&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>此时的遍历输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c7a74172f07ffc46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果你需要输出某些特殊的序列，如1-6这个序列，那么只需使用<code>1..6</code>来表示，而<code>6..1</code>则表示从6输出到1这个序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;顺序&lt;/p&gt;</span><br><span class="line">&lt;#list 1..6 as v1&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v1&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;倒序&lt;/p&gt;</span><br><span class="line">&lt;#list 6..1 as v2&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v2&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>此时页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-37aa74f1b07537c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了这个集合中也是可以表示Map对象，Map对象是使用大括号括起来的，就像下面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;所有的key&lt;/p&gt;</span><br><span class="line">&lt;#list &#123;&quot;name&quot;: &quot;kenbingthoughts&quot;,&quot;nickName&quot;: &quot;kenbing&quot;&#125;?keys as k&gt;</span><br><span class="line">    &lt;text&gt;$&#123;k&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;所有的value&lt;/p&gt;</span><br><span class="line">&lt;#list &#123;&quot;name&quot;: &quot;kenbingthoughts&quot;,&quot;nickName&quot;: &quot;kenbing&quot;&#125;?values as v&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>上面这两种语法分别表示遍历Map对象的所有key和value，页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9288e318b06c6125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h5><p>首先我们创建一个接口，然后准备一些数据，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value = &quot;/test&quot;)</span><br><span class="line">public ModelAndView test()&#123;</span><br><span class="line">    List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">            new Book(1, &quot;三国演义&quot;, 168),</span><br><span class="line">            new Book(2, &quot;红楼梦&quot;, 188),</span><br><span class="line">            new Book(2, &quot;西游记&quot;, 128),</span><br><span class="line">            new Book(2, &quot;水浒传&quot;, 108)</span><br><span class="line">    );</span><br><span class="line">    Map&lt;String,String&gt; userMap = new HashMap&lt;&gt;();</span><br><span class="line">    userMap.put(&quot;name&quot;,&quot;kenbingthoughts&quot;);</span><br><span class="line">    userMap.put(&quot;nickName&quot;,&quot;kenbing&quot;);</span><br><span class="line">    userMap.put(&quot;website&quot;,&quot;kenbingthoughts.top&quot;);</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">    modelAndView.addObject(&quot;books&quot;,books);</span><br><span class="line">    modelAndView.addObject(&quot;userMap&quot;,userMap);</span><br><span class="line">    modelAndView.addObject(&quot;address&quot;,&quot;上海&quot;);</span><br><span class="line">    modelAndView.setViewName(&quot;index&quot;);</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（1）普通变量。</strong>普通变量的展示很简单，直接通过变量名称就可以展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;address&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-277f816f4f7fe50b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（2）集合变量。</strong>集合的展示有多种方式，如下所示，输出书籍信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e4e2d1b4ce6c86a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果你需要输出第三本书的名称（下标从0开始），只需将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;books[2].name&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-743ba6619195c750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要输出第二和三本书的名称，即子集合，此时只需将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books[1..2] as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a43788c473dd0934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者想要输出当前变量的下标，此时只需使用<code>变量名称_index</code>就可以输出下标信息，此时将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书下标&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books[1..2] as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book_index&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9ffb9e7be7e23400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（3）Map变量。</strong>如果开发者想直接输出Map中的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap.name&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap[&#x27;name&#x27;]&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ba1bf7dd23e867b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要获取Map中的所有key并输出对应value的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list userMap?keys as k&gt;</span><br><span class="line">        &lt;div&gt;$&#123;k&#125;--$&#123;userMap[k]&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dc9930b0c80ac259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果只是单纯的想输出所有value的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list userMap?values as v&gt;</span><br><span class="line">        &lt;div&gt;$&#123;v&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-314c9d0155499af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（4）字符串拼接。</strong>如果开发者想对字符串进行拼接，可以使用如下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;&quot;My name is $&#123;userMap.name&#125;&quot;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;&quot;My name is &quot;+ userMap.name&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-119af75f1e5b184f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（5）字符串截取。</strong>如果开发者想对字符串进行截取，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap.name[0..6]&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4a60bde2135f2308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（6）集合相加。</strong>如果开发者想对集合相加，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list [&quot;春天&quot;, &quot;夏天&quot;, &quot;秋天&quot;, &quot;冬天&quot;] + [&quot;昨天&quot;,&quot;今天&quot;,&quot;明天&quot;] as time&gt;</span><br><span class="line">        &lt;p&gt;$&#123;time&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7c8e9598127e51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（7）Map相加。</strong>如果开发者想对Map相加，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list (userMap +&#123;&#x27;sex&#x27;: &#x27;male&#x27;&#125;)?keys as key&gt;</span><br><span class="line">        &lt;p&gt;$&#123;key&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ef6ac02a55877216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>FreeMarker支持一些常用的<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>等运算，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign num=1&gt;</span><br><span class="line">    &lt;div&gt;$&#123;num*2/2%2+2-2&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-78ae43c2cb3e6f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>FreeMarker支持一些常用的比较运算操作，举个例子：<br>（1）= 或者 == 用于判断两个值是否相等；<br>（2）!=用于 判断两个值是否不等；<br>（3）&gt; 或者 gt 用于判断左边值是否大于右边值；<br>（4）&gt;= 或者 gte用于 判断左边值是否大于等于右边值；<br>（5）&lt; 或者 lt 用于判断左边值是否小于右边值；<br>（6）&lt;= 或者 lte 用于判断左边值是否小于等于右边值。<br>建议使用后面的英文符号，不要使用比较号，这样能避免带来一些不必要的错误。一些例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;#assign num=1&gt;</span><br><span class="line">        &lt;#if num=1&gt; num=1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num==1&gt; num==1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num!=1&gt; num!=1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num gt 1&gt; num gt 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num gte 1&gt; num gte 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num lt 1&gt; num lt 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num lte 1&gt; num lte 1&lt;/#if&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a36534bcc210d689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>FreeMarker中有三个逻辑运算符，分别是与（<code>&amp;&amp;</code>）或（<code>||</code>）非（<code>！</code>），注意逻辑运算符只能作用于布尔值，其他类型无法使用，这个很好理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign num=1&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if num=1 &amp;&amp; 1 gt 2&gt; num=1 &amp;&amp; 1 gt 2 &lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if num=1 || 1 gt 2&gt; num=1 || 1 gt 2&lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if !(num=1)&gt; !(num=1)&lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-20549757c9901506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><p>为了处理变量的空值，FreeMarker提供了两个运算符<code>!</code>和<code>??</code>，其中<code>!</code>用于指定缺失变量的默认值；<code>??</code>则用于判断某个变量是否存在。</p><p>举个例子，判断hobby变量是否存在，如果不存在则设置值为reading：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;hobby!&#x27;reading&#x27;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5169b74eb48321f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果希望hobby变量不存在，则设置值为空字符串，那么可以有如下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;hobby!&#125;</span><br><span class="line">        $&#123;hobby!&quot;&quot;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>也就是说如果<code>!</code>后面没有设置值，那么默认值就是空字符串。关于<code>FreeMarker</code>的更多资料可以点击 <a href="https://freemarker.apache.org/">这里</a>，或者 <a href="http://freemarker.foofun.cn/">国内翻译站</a> 。</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>由于FreeMarker内置的函数有多个，因此这里只列举几个比较常用的进行学习，具体的可以点击  <a href="http://freemarker.foofun.cn/ref_builtins.html">国内翻译站</a>  进行阅读。</p><h5 id="cap-first"><a href="#cap-first" class="headerlink" title="cap_first"></a>cap_first</h5><p><code>cap_first</code>可以让字符串的第一个字母变成大写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;kenbing&quot;?cap_first&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7e52499da744d7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="lower-case"><a href="#lower-case" class="headerlink" title="lower_case"></a>lower_case</h5><p><code>lower_case</code>可以让字符串转变成小写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;KENBING&quot;?lower_case&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-acae326c3126c2a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="upper-case"><a href="#upper-case" class="headerlink" title="upper_case"></a>upper_case</h5><p><code>upper_case</code>可以让字符串转变成大写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;kenbing&quot;?upper_case&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebfbf741c1c4982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><p>FreeMarker，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign someDate = &quot;10/25/1995&quot;?date(&quot;MM/dd/yyyy&quot;)&gt;</span><br><span class="line">    &lt;#assign someTime = &quot;15:05:30&quot;?time(&quot;HH:mm:ss&quot;)&gt;</span><br><span class="line">    &lt;#assign someDatetime = &quot;1995-10-25 03:05 PM&quot;?datetime(&quot;yyyy-MM-dd hh:mm&quot;)&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someDate&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someTime&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someDatetime&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c548b74a5b2fa822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><p><code>trim</code>可以去掉字符串前后的空白字符，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign str=&quot;  kenbing  &quot;&gt;</span><br><span class="line">    &lt;div&gt;$&#123;str?trim&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f81900974f23f854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p><code>int</code>可以获取数值的整数部分，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;3.1415926?int&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e306a3168c4a81e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p><code>size</code>可以获取序列中元素的个数，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;userMap?size&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e306a3168c4a81e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h5 id="if-else-elseif"><a href="#if-else-elseif" class="headerlink" title="if, else, elseif"></a>if, else, elseif</h5><p>这是分支控制语句，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if condition&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;#elseif condition2&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;#elseif condition3&gt;</span><br><span class="line">  ...</span><br><span class="line">...</span><br><span class="line">&lt;#else&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure><p>注意这其中的condition和condition2都将被计算成布尔值的表达式，同时elseif 和else是可选的。详细使用细节可以参考 <a href="http://freemarker.foofun.cn/ref_directive_if.html">这里</a> 。</p><h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>开发者可以使用该指令来创建一个新变量或者替换一个已存在的变量。注意仅仅顶级变量可以被创建/替换 (也就是说你不能创建/替换<code>some_hash.subvar</code>， 除了<code>some_hash</code>)，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign same as above... in namespacehash&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign name&gt;</span><br><span class="line">  capture this</span><br><span class="line">&lt;/#assign&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign name in namespacehash&gt;</span><br><span class="line">  capture this</span><br><span class="line">&lt;/#assign&gt;</span><br></pre></td></tr></table></figure><p>关于变量的更多内容，请阅读：<a href="http://freemarker.foofun.cn/dgui_misc_var.html">模板开发指南/其它/在模板中定义变量</a></p><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>该指令用于引入一个库，即创建一个新的空命名空间， 然后在该命名空间中执行给定 path 参数中的模板， 所以模板用变量(宏，函数等)填充命名空间，之后新创建的命名空间对哈希表的调用者可用。 这个哈希表变量将会在命名空间中，由 import (就像你可以用 assign 指令来创建一样。) 的调用者被创建成一个普通变量，名字就是hash参数给定的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#import path as hash&gt;</span><br></pre></td></tr></table></figure><h6 id="switch-case-default-break"><a href="#switch-case-default-break" class="headerlink" title="switch, case, default, break"></a>switch, case, default, break</h6><p>switch, case, default, break是分支指令，有点类似于Java中的switch，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;#switch value&gt;</span><br><span class="line">  &lt;#case refValue1&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  &lt;#case refValue2&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;#case refValueN&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  &lt;#default&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/#switch&gt;</span><br></pre></td></tr></table></figure><p>注意这里的break和default是可选的，不过笔者不太推荐使用这个指令，因为向下通过的行为容易出错，开发者可以使用 <a href="http://freemarker.foofun.cn/ref_directive_if.html#ref.directive.elseif"><code>elseif</code></a>来代替， 除非想利用向下通过这种行为。</p><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>include可以包含一个外部页面，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include path&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#include path options&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include &quot;./kenbing.ftlh&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="macro-nested-return"><a href="#macro-nested-return" class="headerlink" title="macro, nested, return"></a>macro, nested, return</h5><p>macro指令用于定义一个宏，由于宏在实际工作中用的比较多，所以这里建议还是看 <a href="http://freemarker.foofun.cn/ref_directive_macro.html">官方文档</a> 最为合适。举个例子，这里我们定义一个名为book的宏，然后引用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro book&gt;</span><br><span class="line">        西游记</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;div&gt;&lt;@book/&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4a3391caa128db6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，在定义宏的时候也可以传入参数，那么此时在引入宏的时候，也需要传入对应的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;div&gt;&lt;@books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]/&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这里的bs其实就是定义的名为books的宏的参数，可以传入多个参数，所以我们在使用这个宏的时候通过集合也传入了参数。页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9608f60aab860f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>除此之外，开发者还可以使用nested指令还引入开发者自定义的标签体，这个有点类似于Vue中的slot插槽这个概念，即只是起到一个占位的作用。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">            &lt;#nested&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;@books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">        &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">    &lt;/@books&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f01efefccd3a5ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到上面我们添加的p标签的内容就取代了books这一宏中的<code>&lt;#nested&gt;</code>标签所占据的位置。</p><p>在实际开发过程中，宏一般都是单独定义的，然后在使用的地方进行导入，定义一个名为<code>kenbing.ftlh</code>的文件，在里面定义一个名为books的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">            &lt;#nested&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>之后在<code>index.ftlh</code>文件中导入这个<code>kenbing.ftlh</code>文件并使用这个名为books的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#import &quot;./kenbing.ftlh&quot; as kb&gt;</span><br><span class="line">    &lt;@kb.books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">        &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">    &lt;/@kb.books&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意宏需要先导入才能使用，否则会报找不到文件的错误。页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f01efefccd3a5ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h5><p>noparse指令顾名思义就是不解析，因此如果开发者想直接在HTML页面上展示Freemarker语法，而不被页面渲染，那么就可以将Freemarker语法使用noparse指令包括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#noparse&gt;</span><br><span class="line">        &lt;#import &quot;./kenbing.ftlh&quot; as kb&gt;</span><br><span class="line">        &lt;@kb.books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">            &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">        &lt;/@kb.books&gt;</span><br><span class="line">    &lt;/#noparse&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bf6f4990eab2b0c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="function-return"><a href="#function-return" class="headerlink" title="function, return"></a>function, return</h5><p>Freemarker中也允许开发者自定义函数，且函数是可以有返回值的，格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#function name param1 param2 ... paramN&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;#return returnValue&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/#function&gt;</span><br></pre></td></tr></table></figure><p>举个例子，下面的函数用于计算两个数值的平均值，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#function avg x y&gt;</span><br><span class="line">        &lt;#return (x+y)/2&gt;</span><br><span class="line">    &lt;/#function&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;avg(12,18)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c8179a2f0759bbcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇对FreeMarker模板引擎有了一个较为清晰的介绍，了解和学习这些基本上能满足日常的开发需要，如果开发者需要实现更具定制化的功能，需要点击 <a href="http://freemarker.foofun.cn/">这里</a> ，阅读文档进行深度学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;尽管在目前企业级的应用开发中，前后端分离是趋势，但是视图层技术还是占用一席之地。SpringBoot对视图层技术也提供了很好</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>自定义SpringBoot中的Starter场景启动器</title>
    <link href="http://envyzhan.asia/2022/04/15/8-customize-the-starter-scenario-launcher-in-springboot/"/>
    <id>http://envyzhan.asia/2022/04/15/8-customize-the-starter-scenario-launcher-in-springboot/</id>
    <published>2022-04-15T09:55:30.000Z</published>
    <updated>2022-09-12T08:15:31.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们对SpringBoot的自动装配原理有了一个较为深刻的研究，那么接下来我们就分析一下其中的场景启动器（starter），并尝试自定义一个属于自己的场景启动器（starter）。</p><h1 id="场景启动器简介"><a href="#场景启动器简介" class="headerlink" title="场景启动器简介"></a>场景启动器简介</h1><p>场景启动器（starter），其实就是一个个的功能。SpringBoot会将用户常用的一些功能抽离出来，做成一个个的场景启动器，这些场景启动器会导入实现这些功能所需的全部依赖组件，这样开发者只需在项目中引入这些场景启动器，那么相应的依赖就会加载进来。开发者只需通过修改配置文件，就能实现使用相应功能这一目的。</p><h1 id="父场景启动器介绍"><a href="#父场景启动器介绍" class="headerlink" title="父场景启动器介绍"></a>父场景启动器介绍</h1><p>当我们新建一个SpringBoot项目时，POM文件中会自动添加一个父依赖，该依赖名称为<code>spring-boot-starter-parent</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>spring-boot-starter-parent</code>是一个场景启动器，点进去查看一下这个依赖，可以看到里面又有一个名为<code>spring-boot-dependencies</code>的依赖，用于进行项目依赖的版本管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">&lt;name&gt;spring-boot-starter-parent&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Parent pom providing dependency and plugin management for applications built with Maven&lt;/description&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">  &lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">  &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>同时里面配置了6个默认的配置信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--默认Java版本1.8--&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;!--默认资源分隔符为@--&gt;</span><br><span class="line">&lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;!--默认编码格式使用UTF-8--&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br></pre></td></tr></table></figure><p>实际上这个<code>spring-boot-starter-parent</code>还提供了默认的资源过滤和插件配置。</p><p>再来看一下这个<code>spring-boot-dependencies</code>依赖的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;activemq.version&gt;5.16.4&lt;/activemq.version&gt;</span><br><span class="line">    &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;</span><br><span class="line">    &lt;appengine-sdk.version&gt;1.9.96&lt;/appengine-sdk.version&gt;</span><br><span class="line">    &lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt;</span><br><span class="line">    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;</span><br><span class="line">    &lt;assertj.version&gt;3.21.0&lt;/assertj.version&gt;</span><br><span class="line">    ......</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>可以看到它定义了所需场景启动器的版本信息，因此开发者在需要某场景启动器时，只需导入对应的场景启动器名称，无需再指定具体的版本号，这里已经指定并解决了各个场景启动器版本之间的冲突问题。</p><h1 id="场景启动器原理"><a href="#场景启动器原理" class="headerlink" title="场景启动器原理"></a>场景启动器原理</h1><p>当开发者导入所需的starter之后，SpringBoot会将该starter所依赖的组件自动导入并自动配置，这就是我们常说的SpringBoot的自动配置。</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><h5 id="自动配置类的获取与注入"><a href="#自动配置类的获取与注入" class="headerlink" title="自动配置类的获取与注入"></a>自动配置类的获取与注入</h5><p>尽管在前一篇我们已经分析了SpringBoot的自动装配原理，但是笔者没有结合项目和一些图片来介绍，所以可能比较难以理解，这里再分析一次，可以加深理解。</p><p>首先查看一下项目的启动类源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class KenBingThoughtsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(KenBingThoughtsApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析可以知道这个<code>@SpringBootApplication</code>注解内部的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0288a1f2740c2ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里面有一个非常重要的类<code>AutoConfigurationImportSelector</code>，该类的作用图中已经说清楚了，不过说一下其中一个名为<code>selectImports</code>的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它返回了一个字符串数组，下图是它的处理过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-58d20d34bccde1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来再来看一下这个<code>spring.factories</code>文件，这里以<code>spring-boot-autoconfigure</code>包为例进行查阅：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5413b80eeb1a8fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这里面所有以<code>xxxAutoConfiguration</code>结尾的类都是SpringBoot官方为所有场景启动器所提供的自动配置类。这里以常用的<code>WebMvcAutoConfiguration</code>为例进行介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="line">@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)</span><br><span class="line">@AutoConfigureOrder(-2147483638)</span><br><span class="line">@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)</span><br><span class="line">public class WebMvcAutoConfiguration &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个类上使用了很多条件注解，以及配置注解表明这个类会向Spring容器中注册，同时也是有条件的生效。</p><p>【自动配置类的获取与注入原理】<br>（1）SpringBoot项目在启动时会扫描入口类所在包及其子包下的所有类并注入到Spring容器中；<br>（2）同时也会扫描类路径下<code>META-INF/spring.factories</code>文件，并从中加载所有以<code>xxxAutoConfiguration</code>结尾的自动配置类，这样就完成了自动配置类的获取与注入工作。</p><h3 id="自动配置过程"><a href="#自动配置过程" class="headerlink" title="自动配置过程"></a>自动配置过程</h3><p>前面以<code>xxxAutoConfiguration</code>结尾的自动配置类被注册到容器中后，会完成自动导入和自动配置工作。首先我们来查看一下SpringBoot中配置文件与POJO对象之间的映射关系，这也是实现自动配置的基础。</p><p>SpringBoot采用了配置集中化管理这一理念，即所有的配置信息都可以在一个名为<code>application.yml</code>或者<code>application.properties</code>的配置文件中进行设置。实际上这个配置文件可以通过<code>@ConfigurationProperties</code>注解来与定义的属性POJO类进行关联，注意POJO类的命名格式建议为<code>xxxProperties</code>，不一定非得是这样，但是无论怎样都要与在<code>@EnableConfigurationProperties(xxxProperties.class)</code>注解中设置的类名保持一致，还有这个POJO类中各个属性字段都要有默认值。这其实就是SpringBoot所推崇的约定大于配置这一理念，在尽可能减少用户配置的同时又不减少灵活性，即用户可以随心所欲的覆盖这些属性的默认值。</p><p>这里我们在配置文件中定义一个名为<code>person</code>的前缀，然后又定义了一个名为Person的实体类，那么接下来两者就可以通过<code>@ConfigurationProperties(prefix=&quot;person&quot;)</code>注解进行配置映射：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a9924a43b8b05fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，在实际使用时还需要配合<code>@EnableConfigurationProperties(&#123;person.class&#125;)</code>注解，这样才会自动将与配置文件绑定好的POJO类注入到Spring容器中。</p><p>接下来我们以最常用的<code>HttpEncodingAutoConfiguration</code>(http编码自动配置类)为例，介绍这个自动配置类进行自动配置的整个过程。先查阅<code>HttpEncodingAutoConfiguration</code>自动配置类源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//表示此类为一个配置类，可以被Spring扫描的到</span><br><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">//表示将与配置文件绑定好的ServerProperties POJO类注入到IOC容器中，使之生效</span><br><span class="line">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="line">//@Conditional是条件注解，会根据不同的判断条件，如果满足指定的条件，该配置类中的配置才会生效</span><br><span class="line">//判断是否为web应用，是的话当前配置类中的配置才会生效</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">//判断是否存在CharacterEncodingFilter这个类，如果有的话当前配置类中的配置才会生效</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="line">//判断是否存在server.servlet.encoding.enabled属性，如果matchIfMissing = true表示即使我们不配置属性值为true，该配置类默认也会生效</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;server.servlet.encoding&quot;,</span><br><span class="line">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line">public class HttpEncodingAutoConfiguration &#123;</span><br><span class="line">    //注入与配置文件属性相绑定的属性配置类</span><br><span class="line">    private final Encoding properties;</span><br><span class="line">    </span><br><span class="line">    //提供一个有参的构造方法，并在HttpEncodingAutoConfiguration对象实例化的时候注入其中</span><br><span class="line">    public HttpEncodingAutoConfiguration(ServerProperties properties) &#123;</span><br><span class="line">        this.properties = properties.getServlet().getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当系统中没有提供CharacterEncodingFilter这一实例的时候，系统会默认提供一个CharacterEncodingFilter实例</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));</span><br><span class="line">        return filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义本地语言字符编码映射器</span><br><span class="line">    @Bean</span><br><span class="line">    public HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() &#123;</span><br><span class="line">        return new HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123;</span><br><span class="line">        private final Encoding properties;</span><br><span class="line"></span><br><span class="line">        LocaleCharsetMappingsCustomizer(Encoding properties) &#123;</span><br><span class="line">            this.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void customize(ConfigurableServletWebServerFactory factory) &#123;</span><br><span class="line">            if (this.properties.getMapping() != null) &#123;</span><br><span class="line">                factory.setLocaleCharsetMappings(this.properties.getMapping());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getOrder() &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过一张图来了解自动配置的整个过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9f8dbe1e5fe9a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>【自动配置过程】<br>（1）容器会根据当前不同注解中的条件来决定当前这个自动配置类是否生效；<br>（2）如果当前自动配置类生效，那么就会给容器中添加所需的对应组件；<br>（3）这些对应组件的属性是从对应的属性POJO类中获取，而这些属性POJO类则是与配置文件相绑定的；<br>（4）配置文件中可以配置项的项都是在属性POJO类中定义的，后续开发者可以根据名称及前缀进行判断。</p><p>一句话总结：配置文件与POJO类进行属性映射绑定，自动配置类确定是否生效，生效则添加对应的POJO类。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SpringBoot在启动时会加载大量的自动配置类，如果开发者所需要的功能在默认自动配置类中有则会进行自动导入和自动配置工作；如果没有则需要手动添加对应的组件。一般需要定义一个属性POJO类完成与<code>application.yml</code>或者<code>application.properties</code>配置文件的属性映射绑定工作，然后再定义一个以<code>xxxAutoConfiguration</code>结尾的自动配置类，根据条件来选择性的让自动配置类生效，并注入自定义的属性POJO类。</p><p>这里我们再提一下这个由<code>@Conditional</code>注解所派生出来的注解，作用是只有满足这些注解的条件，才会给容器中注入所需的组件，里面的配置内容才会生效。一些常用的由<code>@Conditional</code>派生注解如下表所示：</p><table><thead><tr><th align="center">@Conditional派生注解</th><th align="center">作用（判断是否满足指定条件）</th></tr></thead><tbody><tr><td align="center">@ConditionalOnNotWebApplication</td><td align="center">当前不是Web环境</td></tr><tr><td align="center">@ConditionalOnWebApplication</td><td align="center">当前是Web环境</td></tr><tr><td align="center">@ConditionalOnResource</td><td align="center">类路径下是否有指定资源文件</td></tr><tr><td align="center">@ConditionalOnExpression</td><td align="center">满足SPEL表达式</td></tr><tr><td align="center">@ConditionalOnMissingBean</td><td align="center">容器中不存在指定的Bean</td></tr><tr><td align="center">@ConditionalOnBean</td><td align="center">容器中存在指定的Bean</td></tr><tr><td align="center">@ConditionalOnSingleCandidate</td><td align="center">容器中只有一个指定的Bean或者这个Bean是首选Bean</td></tr><tr><td align="center">@ConditionalOnJava</td><td align="center">系统的Java版本是否满足指定</td></tr><tr><td align="center">@ConditionalOnMissingClass</td><td align="center">系统中没有指定的类</td></tr><tr><td align="center">@ConditionalOnClass</td><td align="center">系统中有指定的类</td></tr><tr><td align="center">@ConditionalOnProperty</td><td align="center">系统中指定的属性是否有指定的值</td></tr></tbody></table><p>别看上面有这么多自动配置类，但是这些配置类都需要在一定的条件下才会生效，即加载了这么多的配置类，生效的都是满足了指定条件。开发者可以通过在<code>application.yml</code>或者<code>application.properties</code>配置文件中添加<code>debug=true</code>属性来开启SpringBoot的调试类，并让控制台输出条件评估报告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//条件评估报告</span><br><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">//已启用的自动配置类（正匹配）</span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">    AopAutoConfiguration.ClassProxyingConfiguration matched:</span><br><span class="line">      - @ConditionalOnMissingClass did not find unwanted class &#x27;org.aspectj.weaver.Advice&#x27; (OnClassCondition)</span><br><span class="line">      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   JmxAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &#x27;org.springframework.jmx.export.MBeanExporter&#x27; (OnClassCondition)</span><br><span class="line">      - @ConditionalOnProperty (spring.jmx.enabled=true) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   TaskSchedulingAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &#x27;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&#x27; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">//未启用的自动配置类（负匹配）</span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &#x27;javax.jms.ConnectionFactory&#x27; (OnClassCondition)</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">//排除的的自动配置类</span><br><span class="line">Exclusions:</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">    None</span><br><span class="line"></span><br><span class="line">//没有限定条件的自动配置类</span><br><span class="line">Unconditional classes:</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h1 id="自定义场景启动器步骤"><a href="#自定义场景启动器步骤" class="headerlink" title="自定义场景启动器步骤"></a>自定义场景启动器步骤</h1><h3 id="starter命名约定"><a href="#starter命名约定" class="headerlink" title="starter命名约定"></a>starter命名约定</h3><p>SpringBoot遵循约定大于配置这一原则，因此对于starter的命名也有一定的约定规则，了解这些规则可便于开发者知悉这些starter功能及作用。</p><p>对于官方提供的starter而言，命名规则为：<code>spring-boot-starter-</code>+模块名，如<code>spring-boot-starter-web</code>。</p><p>对于非官方（即自定义）提供的starter而言，命名规则为：模块名+<code>spring-boot-starter</code>，如<code>mybatis-spring-boot-starter</code>。</p><h3 id="starter模块整体架构"><a href="#starter模块整体架构" class="headerlink" title="starter模块整体架构"></a>starter模块整体架构</h3><p>通过前面的分析，我们知道starter模块整体主要由<code>xxxAutoConfiguration</code>和<code>xxxProperties</code>组成。</p><p><code>xxxAutoConfiguration</code>是自动配置类，用于自动注入所需的一些组件，并使用<code>xxxProperties</code>类来获取组件相关的一些配置信息。<code>xxxProperties</code>是属性配置类，即从配置文件中获取对应的属性值以覆盖默认值。请注意，由于starter的作用只是依赖聚合，因此不建议直接在starter内部通过代码来更改属性值。</p><p>一般来说，具体的逻辑应当由其他模块来实现，然后由starter导入相应的模块，即starter只起导入依赖的作用，因此starter模块整体架构如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ab57c1ec7a5ad113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从图中可以看到，starter模块依赖了两部分，一部分是常用依赖，另一部分则是自动配置模块所需的依赖。前面说的<code>xxxAutoConfiguration</code>和<code>xxxProperties</code>实际上则是自动配置模块的具体实现，starter通过该模块来对外提供相应功能。</p><h3 id="autoconfigure模块开发"><a href="#autoconfigure模块开发" class="headerlink" title="autoconfigure模块开发"></a>autoconfigure模块开发</h3><p>第一步，POM文件引入相应依赖。明确所有的starter都需要引入<code>spring-boot-autoconfigure</code>依赖，该依赖中包含很多与自动配置相关的注解及定义；其次还可以选择是否引入<code>spring-boot-configuration-processor</code>依赖，该依赖可以让开发者在配置文件中输入想修改的配置项信息时，能给出相应的提示信息。这里的配置文件不仅仅是以<code>.properties</code>结尾的，还可以是以<code>.yml</code>结尾的，不过SpringBoot中默认使用<code>application.yml</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>其他依赖则按需进行引入，这里就没什么好说的了。</p><p>第二步，<code>xxxAutoConfiguration</code>自动配置类实现。autoconfigure模块中<code>xxxAutoConfiguration</code>自动配置类的编写非常重要，它可以帮助开发者实现组件的自动装配与自动注入，进而让开发者更加专注于需要什么组件，如何去配置它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">@ConditionalOnxxx  //限定自动配置类生效的一些条件</span><br><span class="line">@EnableConfigurationProperties(xxxProperties.class)</span><br><span class="line">public class xxxAutoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private xxxProperties properties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public YouNeedBean youNeedBean() &#123;</span><br><span class="line">     YouNeedBean bean = new YouNeedBean()</span><br><span class="line">     bean.setField1(properties.get(field1));</span><br><span class="line">     bean.setField2(properties.get(field2));</span><br><span class="line">     bean.setField3(properties.get(field3));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在自动配置类中添加了一些自动配置类生效的条件，这些在实际开发过程中还是非常重要的。</p><p>第三步，<code>xxxProperties</code>属性配置类实现。请注意这个属性配置类的命名要与在第二步中，使用<code>@EnableConfigurationProperties(xxxProperties.class)</code>注解中配置的文件名保持一致。同时这个<code>xxxProperties</code>属性配置类用于从外部的以<code>.properties</code>或者<code>.yml</code>结尾的配置文件中读取对应的配置信息，以覆盖默认的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;yourproperties&quot;) </span><br><span class="line">public class xxxProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enabled = true;</span><br><span class="line"></span><br><span class="line">    private String clientId;</span><br><span class="line"></span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    private String scanBasePackage;</span><br><span class="line"></span><br><span class="line">    private String path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用<code>@ConfigurationProperties</code>注解来绑定配置文件，并从中获取以<code>yourproperties</code>为前缀的配置项信息。</p><p>第四步，配置<code>spring.factories</code>文件。在介绍原理的时候就说过，它会扫描这个<code>spring.factories</code>文件中的<code>xxxAutoConfiguration</code>自动配置类并加载到Spring容器中。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第二步定义好的<code>xxxAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.kenbingthoughts.mystarter.xxxAutoConfiguration</span><br></pre></td></tr></table></figure><h1 id="自定义场景启动器实战"><a href="#自定义场景启动器实战" class="headerlink" title="自定义场景启动器实战"></a>自定义场景启动器实战</h1><p>第一步，使用Maven创建一个名为<code>mystarter-spring-boot-starter</code>的项目，然后在其POM文件中新增<code>spring-boot-autoconfigure</code>和<code>spring-boot-configuration-processor</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kenbingthoughts&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mystarter-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;mystarter-spring-boot-starter&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;自定义Starter启动器&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;11&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;11&lt;/target&gt;</span><br><span class="line">                    &lt;compilerVersion&gt;11&lt;/compilerVersion&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>当然了，由于笔者使用的JDK版本为11，同时使用了<code>spring-boot-starter-parent</code>父场景启动器，因此这里覆盖了默认的1.8版本。请注意，此项目中由于不包含main方法，因此不能添加如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>这个配置项会加载main方法，导致后续应用程序无法打包。</p><p>第二步，新建一个名为<code>KenBingProperties</code>的属性配置类。这里使用了<code>@ConfigurationProperties()</code>这一注解来实现类型安全的属性注入，即将<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的属性注入到这个类所对应的属性上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;kenbing&quot;)</span><br><span class="line">public class KenBingProperties &#123;</span><br><span class="line">    private static final String DEFAULT_NAME = &quot;啃饼思录&quot;;</span><br><span class="line">    private static final String DEFAULT_WEBSITE = &quot;啃饼网&quot;;</span><br><span class="line"></span><br><span class="line">    private String name = DEFAULT_NAME;</span><br><span class="line"></span><br><span class="line">    private String website = DEFAULT_WEBSITE;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWebsite() &#123;</span><br><span class="line">        return website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWebsite(String website) &#123;</span><br><span class="line">        this.website = website;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，自定义<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的对应配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kenbing.name=kenbingthoughts</span><br><span class="line">kenbing.website=kenbingthoughts.top</span><br></pre></td></tr></table></figure><p>第四步，定义一个用于提供实际功能的业务逻辑类<code>KenBingService</code>，这里我们逻辑比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class KenBingService &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String website;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWebsite() &#123;</span><br><span class="line">        return website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWebsite(String website) &#123;</span><br><span class="line">        this.website = website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;hello,welcome to &quot;+this.website+&quot;,i am &quot;+ this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两个属性，然后提供对应的getter和setter方法，以及一个用于输出信息的index方法。</p><p>第五步，自定义<code>xxxAutoConfiguration</code>自动配置类。这里定义一个名为<code>KenBingServiceAutoConfiguration</code>的自动配置类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(KenBingProperties.class)</span><br><span class="line">@ConditionalOnClass(KenBingService.class)</span><br><span class="line">public class KenBingServiceAutoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KenBingProperties kenBingProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    KenBingService kenBingService()&#123;</span><br><span class="line">        KenBingService kenBingService = new KenBingService();</span><br><span class="line">        kenBingService.setName(kenBingProperties.getName());</span><br><span class="line">        kenBingService.setWebsite(kenBingProperties.getWebsite());</span><br><span class="line">        return kenBingService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>@Configuration</code>注解表明这是一个配置类，可以被Spring容器扫描的到；<br>（2）使用<code>@EnableConfigurationProperties(KenBingProperties.class)</code>注解并绑定之前定义的属性配置类，表示让之前定义的被<code>@ConfigurationProperties(prefix = &quot;kenbing&quot;)</code>注解所修饰的KenBingProperties类生效，让从配置文件中读取的属性值可以成功的绑定到KenBingProperties类上；<br>（3）<code>@ConditionalOnClass(KenBingService.class)</code>是一个条件注解，表示只有项目当前classpath环境下存在KenBingService类时，这个类中的业务逻辑才会生效；<br>（4）使用<code>@Autowired</code>注解将业务逻辑所需要的<code>KenBingProperties</code>对象给注入进来；<br>（5）提供一个<code>KenBingService</code>对象，并将这个对象的值从<code>application.properties </code>配置文件中获取后返回。</p><p>第六步，定义<code>spring.factories</code>文件。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第五步定义好的<code>KenBingServiceAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.kenbingthoughts.mystarterspringbootstarter.config.KenBingServiceAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样我们就完成了自定义场景启动器的定义工作。</p><p>第七步，打包自定义场景启动器。一般来说我们会将自定义的场景启动器打包，然后上传到Maven私服，以供其他同事使用，这里笔者就不上传了，直接本地打包并安装了。点击IDEA中的Maven插件，选择Lifecycle，然后先clean一下，再install一下，这样自定义场景启动器就安装到本地仓库了。</p><p>第八步，新建一个SpringBoot项目，然后在POM文件中引入刚才自定义场景启动器<code>mystarter-spring-boot-starter</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入自定义的starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.kenbingthoughts&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mystarter-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后刷新一下Maven，可以看到扩展包里面已经出现了自定义的场景启动器：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c2ecf94527f9eed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第九步，测试。实际上现在项目中已经有一个默认的<code>KenBingService</code>实例，而且里面还有默认值。我们可以测试一下，出于简单考虑直接在项目测试类中进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">class LearnFreemarkerApplicationTests &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(LearnFreemarkerApplicationTests.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KenBingService kenBingService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        logger.info(kenBingService.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述测试方法，可以看到控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,welcome to 啃饼网,i am 啃饼思录</span><br></pre></td></tr></table></figure><p>这些信息可以从引入的<code>mystarter-spring-boot-starter</code>的包下一个名为<code>spring-configuration-metadata.json</code>中得到答案：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-befa03e6e93fc927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，实际上这些数据来源于KenBingConfig类中的值。不过开发者也可以通过修改<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的对应配置项来覆盖默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kenbing.name=kenbingthoughts</span><br><span class="line">kenbing.website=kenbingthoughts.top</span><br></pre></td></tr></table></figure><p>之后再重新启动一下测试类，可以看到控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,welcome to kenbingthoughts.top,i am kenbingthoughts</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇通过对场景启动器的深度分析，然后学习了自定义场景启动器的步骤，最后在此基础上自定义了一个自己的场景启动器。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/AfotfXlVT2HE4Q8jmkkK4A">图文并茂，Spring Boot Starter 万字详解！还有谁不会？</a>，<a href="https://blog.csdn.net/qq_45383769/article/details/119088191">@Conditional注解常规使用方法</a>，感谢大佬的解惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们对SpringBoot的自动装配原理有了一个较为深刻的研究，那么接下来我们就分析一下其中的场景启动器（starte</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊SpringBoot的自动装配原理</title>
    <link href="http://envyzhan.asia/2022/04/10/7-talk-about-the-automatic-assembly-principle-of-springboot/"/>
    <id>http://envyzhan.asia/2022/04/10/7-talk-about-the-automatic-assembly-principle-of-springboot/</id>
    <published>2022-04-10T09:55:30.000Z</published>
    <updated>2022-09-12T08:13:31.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在重构一个日志模块，需要将其从项目中抽离出来，于是考虑将其做成一个starter便于后续使用。本篇就来聊聊SpringBoot的自动装配原理，只有了解原理才知道如何将自己的项目制作为starter。</p><h1 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h1><p>当你新建一个SpringBoot项目的时候，项目入口类中自动会添加<code>@SpringBootApplication</code>，那么问题来了，这个<code>@SpringBootApplication</code>注解的作用是什么呢，查看一下该注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里注解上面除了几个常用的注解外，还有三个特别的注解：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>首先看一下<code>@SpringBootConfiguration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解上面除了元注解外，只有一个<code>@Configuration</code>注解，也就是说这个注解其实就相当于<code>@Configuration</code>注解，即标识此类为配置类，同时不仅可以注册一些额外的Bean对象，还可以导入一些额外的配置。</p><p>既然看到这里，那就再看一下<code>@Configuration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = Component.class</span><br><span class="line">    )</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@Configuration</code>注解其核心就是<code>@Component</code>注解，这说明Spring配置类其实也是Spring容器管理的对象。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>再来看一下<code>@EnableAutoConfiguration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解用于开启自动配置功能，它其实也是一个组合注解，除了元注解外还有<code>@AutoConfigurationPackage</code>和<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解。</p><h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><p>首先分析<code>@AutoConfigurationPackage</code>注解，它表示让包中的类及子包中的类能够被自动扫描到Spring容器中。查看一下该注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解中除了元注解外，还是用<code>@Import</code>注解导入了Registrar这个字节码类，看一下这个Registrar对象的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现它其实是<code>AutoConfigurationPackages</code>这个抽象类中的静态内部类，里面有两个方法：<code>registerBeanDefinitions</code>和<code>determineImports</code>。<code>registerBeanDefinitions</code>方法用于获取扫描的包路径并将其注册到能被Spring容器扫描的包中，通过Debug可以看到这个<code>(new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()</code>对象其实就是项目入口类所在的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-42c8ee310097dd4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>那么问题来了，传入的metadata是什么呢？可以发现它就是被<code>@SpringBootApplication</code>注解所修饰的类，即项目的入口类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-95cdb3ee8c1647da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说将被<code>@SpringBootApplication</code>注解所修饰的类（项目入口类）所在的包及子包下的所有类都扫描加载到Spring容器中。这也从另一个侧面反映了项目结构，项目入口类必须放在项目的最外层目录中。</p><h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h5><p>再来分析<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解，我们知道<code>@Import</code>注解的作用就是导入一些其他的类到Spring容器中，这里导入了<code>AutoConfigurationImportSelector</code>这个字节码对象，它是一个选择器。首先看一下这个对象的继承关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2e0db9f5d8bc103a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到<code>AutoConfigurationImportSelector</code>实现了<code>DeferredImportSelector</code>接口，而<code>DeferredImportSelector</code>接口又是实现了<code>ImportSelector</code>接口，查看一下这个<code>ImportSelector</code>接口的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ImportSelector &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    default Predicate&lt;String&gt; getExclusionFilter() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它只有两个方法，其中<code>selectImports</code>用于将所有需要导入的类以全路径方式返回，形成一个字符串数组，之后这些类就会被添加到Spring容器中。可以查看该方法的具体实现逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader)</code> 方法来将对象的加载器导入其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123;</span><br><span class="line">    return loadMetadata(classLoader, &quot;META-INF/spring-autoconfigure-metadata.properties&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它实际上调用的是<code>loadMetadata</code>方法，传入的路径是<code>META-INF/spring-autoconfigure-metadata.properties</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(path) : ClassLoader.getSystemResources(path);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">        while(urls.hasMoreElements()) &#123;</span><br><span class="line">            properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource((URL)urls.nextElement())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return loadMetadata(properties);</span><br><span class="line">    &#125; catch (IOException var4) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析可以看到它首先判断<code>classLoader</code>是否为空，如果不为空则通过调用<code>classLoader.getResources(path)</code>方法从path路径中获取信息，而这个path就是之前传入的<code>META-INF/spring-autoconfigure-metadata.properties</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e92b20b25d40c7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过定位到<code>spring-autoconfigure-metadata.properties</code>文件，可以看到其实就是加载这个文件中内容到Spring容器，而这些都是对应组件的自动配置类。有了这些自动配置类，开发者就不再需要手动编写配置类并注入Spring容器中了。</p><p>接着回到<code>selectImports</code>方法，然后执行的是如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br></pre></td></tr></table></figure><p>可以看到它调用的是<code>AutoConfigurationImportSelector#getAutoConfigurationEntry()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return EMPTY_ENTRY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = this.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = this.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取自动配置的入口，其实就是获取到<code>spring-autoconfigure-metadata.properties</code>文件中被加载到Spring容器的自动配置类。该方法内部调用了<code>getCandidateConfigurations()</code>方法来获取系统中已经加载好的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，系统中已经加载好的类是哪些类呢？可以看到它内部其实调用的是<code>loadFactoryNames()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">            LinkedMultiValueMap result = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            while(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = new UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    int var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它会从<code>META-INF/spring.factories</code>中获取资源，然后通过<code>PropertiesLoaderUtils.loadProperties()</code>方法来加载资源：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ee6824fbfed2777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说SpringBoot会在启动的时候，从类路径下的<code>META-INF/spring.factories</code>文件中获取EnableAutoConfiguration设置的值（而这些设置的值都是以AutoConfiguration结尾，即自动配置类）并导入到Spring容器中，自动配置类会帮助我们进行自动配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a8fead716b6b91f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>接着我们再来看一下<code>@ComponentScan</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到这个注解用于扫描包，然后将其放入Spring容器中。</p><h3 id="小结-SpringBootApplication"><a href="#小结-SpringBootApplication" class="headerlink" title="小结@SpringBootApplication"></a>小结@SpringBootApplication</h3><p>接下来我们总结一下<code>@SpringBootApplication</code>注解，该注解用于扫描项目入口类所在的包或者子包内的类，并将其导入Spring容器中，同时加载<code>META-INF/spring.factories</code>文件中的自动配置类到Spring容器中。</p><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>接下来我们再来看项目入口类的main方法，里面其实调用的是run方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(TestApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">    return run(new Class[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下实际上它所调用的run方法的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    //定义一个计时器</span><br><span class="line">    StopWatch stopWatch = new StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = null;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();</span><br><span class="line">    this.configureHeadlessProperty();</span><br><span class="line">    //获取监听器</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line"></span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);</span><br><span class="line">        //创建应用上下文</span><br><span class="line">        context = this.createApplicationContext();</span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        //预刷新上下文</span><br><span class="line">        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        //刷新上下文</span><br><span class="line">        this.refreshContext(context);</span><br><span class="line">        //刷新之后的上下文</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        this.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; catch (Throwable var10) &#123;</span><br><span class="line">        this.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        throw new IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">        //返回上下文</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var9) &#123;</span><br><span class="line">        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们比较关注的是<code>refreshContext</code>这个用于刷新上下文的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">    this.refresh(context);</span><br><span class="line">    if (this.registerShutdownHook) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125; catch (AccessControlException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下这个refresh方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void refresh(ApplicationContext applicationContext) &#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext)applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下这个refresh方法，其实际源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 准备刷新此上下文</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">// 告诉子类刷新内部的bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">// 准备此上下文中使用的bean工厂</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 允许在此上下文子类中对bean工厂进行后处理</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">// 调用在上下文中注册为bean的工厂处理器</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 注册拦截bean创建的bean处理器</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 为此上下文初始化消息源</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">// 为此上下文初始化事件多播器。</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">// 初始化特定上下文子类中的其他特殊bean。</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">// 检查监听器bean并注册它们</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">               // 实例化所有剩余的（非惰性初始化）单例</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">// 最后一步：发布相应的事件</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁已经创建的单例以避免占用资源</span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line">// 重置“活动”标志</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">// 将异常传播给调用者</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finally &#123;</span><br><span class="line">// 重置 Spring 核心中的常见自省缓存，因为我们可能不再需要单例 bean 的元数据......</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这其实就是一个Spring加载Bean的过程。里面有一个用于初始化特定上下文子类中的其他特殊bean的onRefresh方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   protected void onRefresh() throws BeansException &#123;</span><br><span class="line">// For subclasses: do nothing by default.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法居然没有实现，因此可以看其实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void onRefresh() &#123;</span><br><span class="line">    super.onRefresh();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.createWebServer();</span><br><span class="line">    &#125; catch (Throwable var2) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;Unable to start reactive web server&quot;, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面调用了<code>createWebServer()</code>方法，用于创建Web服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void createWebServer() &#123;</span><br><span class="line">    ReactiveWebServerApplicationContext.ServerManager serverManager = this.serverManager;</span><br><span class="line">    if (serverManager == null) &#123;</span><br><span class="line">        String webServerFactoryBeanName = this.getWebServerFactoryBeanName();</span><br><span class="line">        ReactiveWebServerFactory webServerFactory = this.getWebServerFactory(webServerFactoryBeanName);</span><br><span class="line">        boolean lazyInit = this.getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit();</span><br><span class="line">        this.serverManager = ReactiveWebServerApplicationContext.ServerManager.get(webServerFactory, lazyInit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面调用了<code>getWebServerFactory()</code>方法用于创建Web容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected ReactiveWebServerFactory getWebServerFactory(String factoryBeanName) &#123;</span><br><span class="line">    return (ReactiveWebServerFactory)this.getBeanFactory().getBean(factoryBeanName, ReactiveWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回了一个<code>ReactiveWebServerFactory</code>对象，其实这是一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ReactiveWebServerFactory &#123;</span><br><span class="line">    WebServer getWebServer(HttpHandler httpHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以设计为接口，那是因为Web容器有很多种，常用的有Tomcat、Netty、Jetty和Undertow：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f6b70724c385866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>以<code>TomcatReactiveWebServerFactory</code>这一实现类为例，其<code>getWebServer</code>方法的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public WebServer getWebServer(HttpHandler httpHandler) &#123;</span><br><span class="line">    if (this.disableMBeanRegistry) &#123;</span><br><span class="line">        Registry.disableRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tomcat tomcat = new Tomcat();</span><br><span class="line">    File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(&quot;tomcat&quot;);</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    Connector connector = new Connector(this.protocol);</span><br><span class="line">    connector.setThrowOnFailure(true);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    this.customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(false);</span><br><span class="line">    this.configureEngine(tomcat.getEngine());</span><br><span class="line">    Iterator var5 = this.additionalTomcatConnectors.iterator();</span><br><span class="line"></span><br><span class="line">    while(var5.hasNext()) &#123;</span><br><span class="line">        Connector additionalConnector = (Connector)var5.next();</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler);</span><br><span class="line">    this.prepareContext(tomcat.getHost(), servlet);</span><br><span class="line">    return this.getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是创建一个内置的Tomcat容器，然后返回，所以开发者在将项目打包成jar包以后，不需要自己再手动启动Tomcat容器。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过阅读源码对SpringBoot的自动装配原理有了一个较为深刻的理解，后续就可以在此基础上自定义自己的启动器（starter）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在重构一个日志模块，需要将其从项目中抽离出来，于是考虑将其做成一个starter便于后续使用。本篇就来聊聊SpringB</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自定义参数解析器</title>
    <link href="http://envyzhan.asia/2022/03/30/6-springboot-custom-parameter-parser/"/>
    <id>http://envyzhan.asia/2022/03/30/6-springboot-custom-parameter-parser/</id>
    <published>2022-03-30T09:55:30.000Z</published>
    <updated>2022-09-12T08:11:19.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今天我们来聊一聊SpringBoot中的参数解析器，这在某些场景下非常有用。一般来说，在一个Web请求里面参数要么是放在请求地址，要么就是放在请求体里面，极个别的会放在请求头中。</p><p>如果请求参数放在请求地址中，那么通常会采用<code>@RequestParam</code>/<code>@PathVariable</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果请求参数放在请求体里面，那么通常会采用<code>@RequestBody</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果请求参数放在请求头里面，那么通常会采用<code>@RequestHeader</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getHeader(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果参数是JSON形式的，那么会从输入流中获取并解析成JSON字符串，再通过JSON工具转化为POJO对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));</span><br><span class="line">String json = reader.readLine();</span><br><span class="line">reader.close();</span><br><span class="line">User user = new ObjectMapper().readValue(json, User.class);</span><br></pre></td></tr></table></figure><p>无论参数是key-value键值对，还是JSON形式数据，以上几种方式基本上涵盖了日常开发的所有需求。</p><p>现在我们以下面的接口为例，来深度分析SpringMVC如何从请求中获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(String username)&#123;</span><br><span class="line">        return &quot;I am&quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问这个username参数肯定是从HttpServletRequest中获取的，那么它是如何获取的呢？</p><h1 id="方法参数解析器"><a href="#方法参数解析器" class="headerlink" title="方法参数解析器"></a>方法参数解析器</h1><h3 id="HandlerMethodArgumentResolver接口"><a href="#HandlerMethodArgumentResolver接口" class="headerlink" title="HandlerMethodArgumentResolver接口"></a>HandlerMethodArgumentResolver接口</h3><p>我们知道在SpringBoot中与Web相关的配置信息都在<code>WebMvcConfigurer</code>接口中，可以看到该接口中有一个名为<code>addArgumentResolvers</code>的默认方法，用于添加参数解析器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以看到<code>HandlerMethodArgumentResolver</code>这个其实就是具体的一些参数解析器，实际上它是一个接口。我们来看<code>HandlerMethodArgumentResolver</code>这一接口，该接口用于解析方法中的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerMethodArgumentResolver &#123;</span><br><span class="line">    boolean supportsParameter(MethodParameter parameter);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>HandlerMethodArgumentResolver</code>接口中就两个方法，其中<code>supportsParameter()</code>方法表示是否启用该参数解析器，true表示启用，false表示不启用；<code>resolveArgument()</code>方法是具体的解析过程，即从HttpServletRequest中取出参数的过程，该方法的返回值就是接口中参数的值。所以如果开发者想自定义参数解析器，只需实现该接口并重写其中的两个方法。</p><p>由于SpringBoot采用约定大于配置这一规则，因此建议<code>HandlerMethodArgumentResolver</code>接口的实现类命名规则为“解析器对应的注解名称”+“<code>MethodArgumentResolver</code>”。</p><p>将下来我们分析几个常用的<code>HandlerMethodArgumentResolver</code>接口实现类，了解它们对于提升技能有非常大的帮助。</p><h3 id="RequestParamMethodArgumentResolver类"><a href="#RequestParamMethodArgumentResolver类" class="headerlink" title="RequestParamMethodArgumentResolver类"></a>RequestParamMethodArgumentResolver类</h3><p>通过前面的分析，可以得到这个解析器所对应的注解名称为RequestParam，因此首先我们看一下这个注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RequestParam &#123;</span><br><span class="line">    @AliasFor(&quot;name&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean required() default true;</span><br><span class="line"></span><br><span class="line">    String defaultValue() default &quot;\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>@RequestParam</code>注解有四个属性，其中name和value互为各自的别名，required表示参数是否必须传，默认是必须；defaultValue则是参数的默认值。</p><p>接着查看一下这个RequestParamMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveName</code>方法，注意它的<code>resolveArgument</code>方法名称发生了变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">        if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">            return requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        parameter = parameter.nestedIfOptional();</span><br><span class="line">        if (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.useDefaultResolution ? BeanUtils.isSimpleProperty(parameter.getNestedParameterType()) : false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123;</span><br><span class="line">    HttpServletRequest servletRequest = (HttpServletRequest)request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">    Object arg;</span><br><span class="line">    if (servletRequest != null) &#123;</span><br><span class="line">        arg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line">        if (arg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line">            return arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg = null;</span><br><span class="line">    MultipartRequest multipartRequest = (MultipartRequest)request.getNativeRequest(MultipartRequest.class);</span><br><span class="line">    if (multipartRequest != null) &#123;</span><br><span class="line">        List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line">        if (!files.isEmpty()) &#123;</span><br><span class="line">            arg = files.size() == 1 ? files.get(0) : files;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (arg == null) &#123;</span><br><span class="line">        String[] paramValues = request.getParameterValues(name);</span><br><span class="line">        if (paramValues != null) &#123;</span><br><span class="line">            arg = paramValues.length == 1 ? paramValues[0] : paramValues;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，如果使用了<code>@RequestParam</code>注解且不是Map类型，或者是Map类型同时传入了name属性，又或者是没有使用<code>@RequestParam</code>和<code>@RequestPart</code>注解且这个参数有多个组成，或者使用默认的解析器且参数的嵌套是简单类型，则使用该参数解析器；<br>（2）<code>resolveName()</code>方法，首先获取<code>HttpServletRequest</code>对象，如果该对象存在，则解析请求中的多个参数并返回这些参数的值；如果该对象不存在，但是<code>MultipartRequest</code>存在，那么从这个<code>MultipartRequest</code>中通过参数的名称来得到这些参数值，如果参数值存在，那么返回参数值的信息。如果参数值不存在，那么从请求中根据参数名称来得到参数值，如果参数值存在，那么返回参数值的信息。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@RequestParam(&quot;username&quot;) String username)&#123;</span><br><span class="line">        return &quot;I am &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestParamMapMethodArgumentResolver类"><a href="#RequestParamMapMethodArgumentResolver类" class="headerlink" title="RequestParamMapMethodArgumentResolver类"></a>RequestParamMapMethodArgumentResolver类</h3><p>这个方法参数解析器所对应的注解名称同样也是RequestParam，接着查看一下这个RequestParamMapMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveArgument</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">    return requestParam != null &amp;&amp; Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp; !StringUtils.hasText(requestParam.name());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">    ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);</span><br><span class="line">    Class valueType;</span><br><span class="line">    HttpServletRequest servletRequest;</span><br><span class="line">    Collection parts;</span><br><span class="line">    Iterator var10;</span><br><span class="line">    Part part;</span><br><span class="line">    Map parameterMap;</span><br><span class="line">    MultipartRequest multipartRequest;</span><br><span class="line">    if (!MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) &#123;</span><br><span class="line">        valueType = resolvableType.asMap().getGeneric(new int[]&#123;1&#125;).resolve();</span><br><span class="line">        if (valueType == MultipartFile.class) &#123;</span><br><span class="line">            multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line">            return multipartRequest != null ? multipartRequest.getFileMap() : new LinkedHashMap(0);</span><br><span class="line">        &#125; else if (valueType == Part.class) &#123;</span><br><span class="line">            servletRequest = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">            if (servletRequest != null &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">                parts = servletRequest.getParts();</span><br><span class="line">                LinkedHashMap&lt;String, Part&gt; result = CollectionUtils.newLinkedHashMap(parts.size());</span><br><span class="line">                var10 = parts.iterator();</span><br><span class="line"></span><br><span class="line">                while(var10.hasNext()) &#123;</span><br><span class="line">                    part = (Part)var10.next();</span><br><span class="line">                    if (!result.containsKey(part.getName())) &#123;</span><br><span class="line">                        result.put(part.getName(), part);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new LinkedHashMap(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parameterMap = webRequest.getParameterMap();</span><br><span class="line">            Map&lt;String, String&gt; result = CollectionUtils.newLinkedHashMap(parameterMap.size());</span><br><span class="line">            parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">                if (values.length &gt; 0) &#123;</span><br><span class="line">                    result.put(key, values[0]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        valueType = resolvableType.as(MultiValueMap.class).getGeneric(new int[]&#123;1&#125;).resolve();</span><br><span class="line">        if (valueType == MultipartFile.class) &#123;</span><br><span class="line">            multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line">            return multipartRequest != null ? multipartRequest.getMultiFileMap() : new LinkedMultiValueMap(0);</span><br><span class="line">        &#125; else if (valueType != Part.class) &#123;</span><br><span class="line">            parameterMap = webRequest.getParameterMap();</span><br><span class="line">            MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap(parameterMap.size());</span><br><span class="line">            parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">                String[] var3 = values;</span><br><span class="line">                int var4 = values.length;</span><br><span class="line"></span><br><span class="line">                for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                    String value = var3[var5];</span><br><span class="line">                    result.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            servletRequest = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">            if (servletRequest != null &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">                parts = servletRequest.getParts();</span><br><span class="line">                LinkedMultiValueMap&lt;String, Part&gt; result = new LinkedMultiValueMap(parts.size());</span><br><span class="line">                var10 = parts.iterator();</span><br><span class="line"></span><br><span class="line">                while(var10.hasNext()) &#123;</span><br><span class="line">                    part = (Part)var10.next();</span><br><span class="line">                    result.add(part.getName(), part);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new LinkedMultiValueMap(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，如果使用了<code>@RequestParam</code>注解且参数是Map类型，同时<code>@RequestParam</code>注解中没有设置name属性，那么就可以使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，总的来说分为两种情况，一种是MultiValueMap，另一种则是其他的Map。对于MultiValueMap来说，如果它是MultipartFile或者Part类型，那么就可以处理文件上传；如果是其他的则是普通的请求参数。如果是普通的Map，那么就直接从原始请求中获取请求参数，并将这些参数放到一个LinkedMultiValueMap中并返回。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/user&quot;)</span><br><span class="line">    public void user(@RequestParam MultiValueMap map)&#123;</span><br><span class="line">        System.out.println(map.get(&quot;username&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrincipalMethodArgumentResolver类"><a href="#PrincipalMethodArgumentResolver类" class="headerlink" title="PrincipalMethodArgumentResolver类"></a>PrincipalMethodArgumentResolver类</h3><p>查看一下<code>PrincipalMethodArgumentResolver</code>类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    return Principal.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Current request is not of type HttpServletRequest: &quot; + webRequest);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Principal principal = request.getUserPrincipal();</span><br><span class="line">        if (principal != null &amp;&amp; !parameter.getParameterType().isInstance(principal)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Current user principal is not of type [&quot; + parameter.getParameterType().getName() + &quot;]: &quot; + principal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return principal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，用于判断参数类型是否为Principal这一类型，如果是则使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，首先从原始请求中获取<code>HttpServletRequest</code>对象，如果该对象不存在则抛出异常；如果存在则从请求中获取Principal对象并返回。这个Principal对象里面包含登录的用户名称。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(Principal principal)&#123;</span><br><span class="line">        return &quot;My name is &quot; + principal.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PathVariableMethodArgumentResolver类"><a href="#PathVariableMethodArgumentResolver类" class="headerlink" title="PathVariableMethodArgumentResolver类"></a>PathVariableMethodArgumentResolver类</h3><p>通过前面的分析，可以得到这个解析器所对应的注解名称为PathVariable，因此首先我们看一下这个注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface PathVariable &#123;</span><br><span class="line">    @AliasFor(&quot;name&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean required() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>@PathVariable</code>注解有三个属性，其中name和value互为各自的别名，required表示参数是否必须传，默认是必须。</p><p>接着查看一下这个PathVariableMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveName</code>方法，注意它的resolveArgument方法名称发生了变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    if (!parameter.hasParameterAnnotation(PathVariable.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        PathVariable pathVariable = (PathVariable)parameter.getParameterAnnotation(PathVariable.class);</span><br><span class="line">        return pathVariable != null &amp;&amp; StringUtils.hasText(pathVariable.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123;</span><br><span class="line">    Map&lt;String, String&gt; uriTemplateVars = (Map)request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, 0);</span><br><span class="line">    return uriTemplateVars != null ? uriTemplateVars.get(name) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，用于判断如果参数上使用了<code>@PathVariable</code>注解，并且参数的类型不是Map及其子类，则使用该参数解析器。或者是Map类型，则当<code>@PathVariable</code>注解中的value属性有值时，才使用该参数解析器；<br>（2）<code>resolveName()</code>方法，用于从请求中获取uriTemplateVars，如果uriTemplateVars不为空，则从uriTemplateVars根据名称来获取值并返回。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user/&#123;username&#125;&quot;)</span><br><span class="line">    public String user(@PathVariable(&quot;username&quot;) String username)&#123;</span><br><span class="line">        return &quot;My name is &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>假设如下接口中，我们需要获取用户传入的用户名，此时就可以使用自定义参数解析器这一方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@CurrentUserName String username)&#123;</span><br><span class="line">        return &quot;I am&quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即在方法中通过使用<code>@CurrentUserName</code>注解从HttpServletRequest中获取当前传入的用户名。要实现这个功能，步骤如下所示：</p><p>第一步，创建一个名为<code>method-resolve</code>的SpringBoot项目，然后添加<code>spring web</code>和<code>spring test</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>第二步，新建一个名为<code>CurrentUserName</code>的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CurrentUserName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建一个名为<code>CurrentUserNameHandlerMethodArgumentResolver</code>的类，注意它需要实现<code>HandlerMethodArgumentResolver</code>接口并重写其中的上述两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentUserNameHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">        return parameter.getParameterType().isAssignableFrom(String.class) &amp;&amp; parameter.hasParameterAnnotation(CurrentUserName.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        return request.getParameter(parameter.getParameterName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，判断当前参数类型是否为String且在参数上使用了<code>@CurrentUserName</code>注解，这有这样才使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，用于返回接口中参数的值，这里直接调用<code>request.getParameter()</code>方法传入参数名称进而得到参数的值。</p><p>第四步，注册自定义参数解析器。定义一个名为<code>WebConfig</code>的类，注意这个类需要实现<code>WebMvcConfigurer</code>接口，并重写其中的<code>addArgumentResolvers</code>默认方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;</span><br><span class="line">        resolvers.add(new CurrentUserNameHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，新建接口类。定义一个名为<code>UserController</code>的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@CurrentUserName String username)&#123;</span><br><span class="line">        return &quot;I am &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，启动项目，访问<code>http://localhost:8080/user?username=melody</code>链接，可以看到页面显示如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am melody</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了如何在SpringBoot中通过自定义类实现<code>HandlerMethodArgumentResolver</code>接口，并重写其中的<code>supportsParameter()</code>和<code>resolveArgument()</code>方法来实现自定义参数解析器，同时也剖析了一些常用的参数注解以及背后的原理，最后通过实战学习了如何通过自定义一个注解来实现参数解析器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;今天我们来聊一聊SpringBoot中的参数解析器，这在某些场景下非常有用。一般来说，在一个Web请求里面参数要么是放在请求</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>一个注解配合Redis实现接口限流</title>
    <link href="http://envyzhan.asia/2022/03/24/5-an-annotation-cooperates-with-redis-to-realize-interface-current-limition/"/>
    <id>http://envyzhan.asia/2022/03/24/5-an-annotation-cooperates-with-redis-to-realize-interface-current-limition/</id>
    <published>2022-03-24T09:55:30.000Z</published>
    <updated>2022-09-12T08:09:24.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近发现线上发送验证码的接口被莫名刷了，1天就把上周刚充值的1万条用完了，我内心其实是崩溃的，于是决定对该接口实现限流，这里选择使用拦截器配合Redis来实现。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>limit-redis</code>的SpringBoot项目，然后在POM文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，修改<code>application.yml</code>配置文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password: 1234</span><br><span class="line">    database: 1</span><br></pre></td></tr></table></figure><h3 id="重写RedisTempplate的序列化"><a href="#重写RedisTempplate的序列化" class="headerlink" title="重写RedisTempplate的序列化"></a>重写RedisTempplate的序列化</h3><p>第三步，重写RedisTempplate的序列化逻辑。一般来说我们更倾向于在SpringBoot中使用 Spring Data Redis来操作Redis，但是随着而来的则是它的序列化问题，默认使用的是<code>JdkSerializationRedisSerializer</code>，采用的是二进制方式，且会自动的给存入的key和value添加一些前缀，导致实际情况与开发者预想的不一致。针对这种情况我们可以使用<code>Jackson2JsonRedisSerializer</code>这一序列化方式，不建议使用<code>StringRedisTemplate</code>来替代<code>RedisTemplate</code>，因为它提供的数据类型和操作都有限，无法满足日常需要。</p><p>定义一个名为RedisConfig的类，该类用于重写RedisTempplate的序列化逻辑，使用<code>Jackson2JsonRedisSerializer</code>取代默认的<code>JdkSerializationRedisSerializer</code>，这样利于后续开发和使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义限流注解"><a href="#自定义限流注解" class="headerlink" title="自定义限流注解"></a>自定义限流注解</h3><p>第四步，自定义限流注解。我们要求这个限流分为两种，一种是针对某一个接口的全局限流，另一种是针对IP地址的限流：<br>（1）针对当前某一接口的全局限流。举个例子，<code>/test</code>接口可以在1分钟内访问60次；<br>（2）针对IP地址的限流。举个例子，<code>192.168.56.1</code>这一IP地址可以在1分钟内访问60次；<br>针对上述情况，可以创建一个枚举类<code>LimitType</code>，用于记录限流的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 限流类型</span><br><span class="line"> */</span><br><span class="line">public enum LimitType &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认类型：全局限流</span><br><span class="line">     */</span><br><span class="line">    DEFAULT,</span><br><span class="line">    /**</span><br><span class="line">     * 根据请求IP地址限流</span><br><span class="line">     */</span><br><span class="line">    IP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着自定义一个限流注解<code>RateLimiter</code>，里面设置限流key，注意这个key仅仅是一个前缀，后续我们会拼接其他的变量组成完整的key，进而存入Redis中。完整key的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:IP地址-注解所添加方法所在的类的名称-注解所添加方法的名称</span><br></pre></td></tr></table></figure><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:192.168.30.10-com.melody.limitredis.controller.RateLimiterController-test</span><br></pre></td></tr></table></figure><p>time则是限流的时间，单位为秒；count则是限流的次数，默认100次；limitType则是限流的类型，默认为全局限流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RateLimiter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 限流Key</span><br><span class="line">     */</span><br><span class="line">    String key()default &quot;rate_limit:&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流时间，单位秒</span><br><span class="line">     */</span><br><span class="line">    int time()default 60;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流次数，默认100次</span><br><span class="line">     */</span><br><span class="line">    int count()default 100;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流类型，默认全局限流</span><br><span class="line">     */</span><br><span class="line">    LimitType limitType()default LimitType.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样后续我们需要对某个接口进行限流，只需在该接口上添加<code>@RateLimiter</code>注解，并设置上述对应的参数即可，总的来说还是比较简单的。</p><p>第五步，编写Lua脚本。我们知道Redis的单个操作是具备原子性的，而多个操作就无法保证，但是我们可以借助于Lua脚本来实现。一般来说调用Lua脚本有两种方式：<br>（1）在Redis服务端定义Lua脚本，然后计算出一个hash值，接着在Java代码中通过这个hash值来确定需要执行的Lua脚本；<br>（2）在Java代码中将Lua脚本定义好，然后将其发送到Redis服务端，进而去执行。<br>笔者比较倾向于第二种方式，因此可以先在客户端定义好Lua脚本，然后通过Spring Data Redis提供的<code>redisTemplate.execute()</code>方法，传入脚本实例和对应的参数就可以执行对应的Lua脚本了。</p><p>在项目的resources目录下新建一个名为lua的目录，并在该lua目录下新建一个名为<code>limit.lua</code>的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]</span><br><span class="line">local count = tonumber(ARGV[1])</span><br><span class="line">local time = tonumber(ARGV[2])</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, key)</span><br><span class="line">if current and tonumber(current) &gt; count then</span><br><span class="line">    return tonumber(current)</span><br><span class="line">end</span><br><span class="line">current = redis.call(&#x27;incr&#x27;, key)</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&#x27;expire&#x27;, key, time)</span><br><span class="line">end</span><br><span class="line">return tonumber(current)</span><br></pre></td></tr></table></figure><p>这个KEYS和ARGV就是用户后续在执行该脚本时传入来的参数，tonumber方法用于将字符串转成数字，<code>redis.call()</code>方法通过传入方法名称和参数，进而实现调用不同方法的逻辑。上述脚本所要表达的含义如下：<br>（a）获取用户传递进来的key，限流次数count和限流时间time；<br>（b）调用<code>get(key)</code>方法来获取当前key的值，即当前接口在当前时间内已经访问的次数；<br>（c）如果该接口是第一次访问，那么（b）得到的结果将是nil，否则得到的是一个数字。如果是数字那么我们将判断它和限流次数count的大小，如果该数字大于count，则说明已经超过最大访问次数，需要限流了，可以直接返回当前请求的次数；<br>（d）如果得到的结果是nil，则说明是第一次访问该接口，那么给当前的key进行自增加1，并设置一个过期时间；<br>（e）最后只需将自增后的值返回即可。</p><p>第六步，在RedisConfig类中定义一个Bean来加载这个Lua脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultRedisScript&lt;Long&gt; limitScript() &#123;</span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">    redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;lua/limit.lua&quot;)));</span><br><span class="line">    redisScript.setResultType(Long.class);</span><br><span class="line">    return redisScript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Lua脚本的存放位置和名称需要与开发者实际存放的位置相匹配，否则后续无法成功调用该脚本。</p><h3 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h3><p>其实拦截请求可以有不同的实现思路，可以用拦截器或者AOP，考虑到拦截器也是AOP思想的体现，因此这里就直接使用AOP来实现。</p><p>第七步，自定义切面类<code>RateLimiterAspect</code>，该类用于拦截所有添加了<code>@RateLimiter</code>注解的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class RateLimiterAspect &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RateLimiterAspect.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisScript&lt;Long&gt; limitScript;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;@annotation(rateLimiter)&quot;)</span><br><span class="line">    public void before(JoinPoint point, RateLimiter rateLimiter)&#123;</span><br><span class="line">        int time = rateLimiter.time();</span><br><span class="line">        int count = rateLimiter.count();</span><br><span class="line"></span><br><span class="line">        String combineKey = getCombineKey(rateLimiter,point);</span><br><span class="line">        List&lt;Object&gt; keys = Collections.singletonList(combineKey);</span><br><span class="line">        try&#123;</span><br><span class="line">            Long number = redisTemplate.execute(limitScript, keys, count, time);</span><br><span class="line">            if(number == null || number.intValue() &gt; count)&#123;</span><br><span class="line">                throw new BizException(&quot;请求过于频繁，请稍后重试&quot;,500);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(&quot;当前请求次数&#x27;&#123;&#125;&#x27;,限定次数&#x27;&#123;&#125;&#x27;&quot;, number.intValue(), count);</span><br><span class="line">        &#125;catch (BizException e)&#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;服务器限流异常，请稍候再试&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getCombineKey(RateLimiter rateLimiter, JoinPoint point) &#123;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer(rateLimiter.key());</span><br><span class="line">        //IP限制</span><br><span class="line">        if(rateLimiter.limitType() == LimitType.IP)&#123;</span><br><span class="line">            stringBuffer.append(IpUtils.getRequestIp(((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest())).append(&quot;-&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Class&lt;?&gt; targetClass = method.getDeclaringClass();</span><br><span class="line">        stringBuffer.append(targetClass.getName()).append(&quot;-&quot;).append(method.getName());</span><br><span class="line">        logger.info(&quot;&#123;&#125;&quot;,stringBuffer.toString());</span><br><span class="line">        return stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们使用了前置通知，并在前置通知中对请求进行了处理，逻辑如下：<br>（1）获取注解中的time、count 、key和limitType这四个属性；<br>（2）调用<code>getCombineKey()</code>方法来获取一个完整的限流Key，先判断是否包含IP，如果有IP就将IP添加到里面，否则就不添加，最终完整的限流Key格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:IP地址-注解所添加方法所在的类的名称-注解所添加方法的名称</span><br></pre></td></tr></table></figure><p>（3）将限流Key放入一个集合中，因为此处我们调用的<code>redisTemplate.execute()</code>的完整方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args);</span><br></pre></td></tr></table></figure><p>里面的keys就是一个集合，所以此处就生成了一个单例模式的集合。其实这个也对应于之前我们在Lua脚本中定义的参数，即上述方法中的第二个参数keys就是脚本中的KEYS，可变长度就是脚本中的ARGV，注意值下标从1开始计数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]</span><br><span class="line">local count = tonumber(ARGV[1])</span><br><span class="line">local time = tonumber(ARGV[2])</span><br></pre></td></tr></table></figure><p>（4）之后就是将执行Lua脚本之后的返回值与限流值count进行比较，如果值大于count则说明超出最大访问次数，应当限流，此时抛出一个异常，这里我们自定义了一个异常BizException。</p><p>第八步，定义一个用于获取用户IP地址信息的工具类<code>IpUtils</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class IpUtils &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取请求真实IP地址</span><br><span class="line">     */</span><br><span class="line">    public static String getRequestIp(HttpServletRequest request) &#123;</span><br><span class="line">        //通过HTTP代理服务器转发时添加</span><br><span class="line">        String ipAddress = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getRemoteAddr();</span><br><span class="line">            // 从本地访问时根据网卡取本机配置的IP</span><br><span class="line">            if (ipAddress.equals(&quot;127.0.0.1&quot;) || ipAddress.equals(&quot;0:0:0:0:0:0:0:1&quot;)) &#123;</span><br><span class="line">                InetAddress inetAddress = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    inetAddress = InetAddress.getLocalHost();</span><br><span class="line">                &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ipAddress = inetAddress.getHostAddress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过多个代理转发的情况，第一个IP为客户端真实IP，多个IP会按照&#x27;,&#x27;分割</span><br><span class="line">        if (ipAddress != null &amp;&amp; ipAddress.length() &gt; 15) &#123;</span><br><span class="line">            if (ipAddress.indexOf(&quot;,&quot;) &gt; 0) &#123;</span><br><span class="line">                ipAddress = ipAddress.substring(0, ipAddress.indexOf(&quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，这里只是获取了用户的IP地址，之后可以向一些网站发起请求，得到这些IP的归属地，这里笔者就不展示了。</p><h3 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h3><p>第九步，定义一个异常BizException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BizException extends RuntimeException&#123;</span><br><span class="line">    private int code;</span><br><span class="line"></span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(int status) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, int code)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十步，针对该自定义异常，定义一个全局异常处理类<code>GlobalExceptionHandler</code>，用于处理这个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(BizException.class)</span><br><span class="line">    public Map&lt;String,Object&gt; handler(BizException e)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;message&quot;,e.getMessage());</span><br><span class="line">        map.put(&quot;code&quot;,e.getCode());</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义测试接口"><a href="#定义测试接口" class="headerlink" title="定义测试接口"></a>定义测试接口</h3><p>第十一步，新建接口测试类<code>RateLimiterController</code>，然后在里面定义一个接口，并在该接口上添加自定义的<code>@RateLimiter</code>注解，用于测试我们的限流效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RateLimiterController &#123;</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    @RateLimiter(time = 2,count = 5,limitType = LimitType.IP)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test &gt;&gt;&gt;&quot; +new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>第十二步，启动项目，访问<code>http://localhost:8080/test</code>，可以看到页面显示信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &gt;&gt;&gt;2021-05-17 13:57:57</span><br></pre></td></tr></table></figure><p>但是当用户访问较为频繁的时候，页面会给出相应的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 500,</span><br><span class="line">    message: &quot;请求过于频繁，请稍后重试&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时查看IDEA的控制台，可以看到也输出了相应的日志信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6a6ffd8f0dae24b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇基于AOP思想并配合Redis实现了接口的限流功能，在项目中实际上也有提供基于拦截器的实现，这一点需要的小伙伴可以自取。本篇实现的接口限流其实非常简陋，而我们经常使用的微服务组件Sentinel则是比较完备的限流工具，因此后续有更细粒度的限流需求可以参考Sentinel的限流逻辑进行实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近发现线上发送验证码的接口被莫名刷了，1天就把上周刚充值的1万条用完了，我内心其实是崩溃的，于是决定对该接口实现限流，这里</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>可视化多数据源动态切换</title>
    <link href="http://envyzhan.asia/2022/03/20/4-dynamic-switching-of-visual-multiple-data-sources/"/>
    <id>http://envyzhan.asia/2022/03/20/4-dynamic-switching-of-visual-multiple-data-sources/</id>
    <published>2022-03-20T09:55:30.000Z</published>
    <updated>2022-09-12T08:07:26.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中我们希望实现多数据源的动态切换，而这一点我们在前面一篇文章中就已经进行了实现，但是对于业务人员来说，更多的则是希望可以通过可视化界面的方式来自己决定使用哪个数据源，进而获取对应的数据。</p><h1 id="几个思考"><a href="#几个思考" class="headerlink" title="几个思考"></a>几个思考</h1><p>前面我们多次提到<code>AbstractRoutingDataSource</code>抽象类定义了抽象的<code>determineCurrentLookupKey</code>方法，子类只需实现此方法，就可以通过一个Key从Map中获取对应的数据源实例，并执行对应的数据库操作。查看一下之前我们的<code>dynamic-multiple-ds</code>项目，本篇将在此基础上进行实现。由于我们将数据源名称存在<code>DynamicMultipleDataSourceContextHolder</code>这一ThreadLocal中，因此只需修改该变量的值就能实现这个目的。</p><p>也就是说首先我们要定义一个方法用于传入新的数据源名称，然后我们可以将这个数据源名称放在Session、Redis或者数据库中，最后在修改<code>DynamicMultipleDataSourceContextHolder</code>的时候从里面取出数据并更新ThreadLocal的值即可。</p><p>其次，用户通过页面切换的数据源应该是全局的还是局部的呢？这个应该根据实际的业务来确定，此处假设用户通过页面切换的数据源是全局的，因此后续我们在定义切面的时候不再通过注解方式进行拦截，而是直接拦截所有的业务处理类。还有如果某个拦截的类里面部分方法上，也设置了之前定义的<code>@MyDataSource</code>注解，那么此时应当以哪个为准？这个也是需要根据实际业务来确定，此处假设后者优先级高于前者，即如果某个类既被全局拦截，又添加了<code>@MyDataSource</code>注解，那么最终还是以<code>@MyDataSource</code>注解指定的数据源名称为准。</p><p>再次，我们需要提供一个界面以供用户自行切换数据源，然后展示切换数据源后的数据。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>第一步，新建Book实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer price;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    //getter、setter和toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，修改BookMapper接口的代码为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    @Select(&quot;select count(*) from book&quot;)</span><br><span class="line">    Integer number();</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from book&quot;)</span><br><span class="line">    List&lt;Book&gt; getAllBooks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，修改BookService类的代码为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">       return bookMapper.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，由于我们是将用户传入的数据源名称存在Session中，因此先定义一个Session中的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipleDataSourceProvider &#123;</span><br><span class="line">    String DEFAULT_DATASOURCE = &quot;master&quot;;</span><br><span class="line"></span><br><span class="line">    //作为Session的存储key</span><br><span class="line">    String DS_SESSION_KEY = &quot;ds_session_key&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, DataSource&gt; loadDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，我们可以将之前<code>MyDataSourceAspect</code>这一切面类中获取<code>MyDataSource</code>注解的逻辑抽离出来，以便后续可以重复调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyDataSourceAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;</span><br><span class="line">    +&quot;||@within(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;)</span><br><span class="line">    public void myDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;myDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)throws Throwable &#123;</span><br><span class="line">        MyDataSource myDataSource = getMyDataSource(point);</span><br><span class="line">        if(Objects.nonNull(myDataSource))&#123;</span><br><span class="line">            //myDataSource存在则获取并将其存入DynamicMultipleDataSourceContextHolder中</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.setDataSourceName(myDataSource.dataSourceName());</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDataSource getMyDataSource(ProceedingJoinPoint point)&#123;</span><br><span class="line">        //获取方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        //查找方法上的注解</span><br><span class="line">        MyDataSource myDataSource = AnnotationUtils.findAnnotation(signature.getMethod(), MyDataSource.class);</span><br><span class="line">        if(myDataSource==null)&#123;</span><br><span class="line">            myDataSource = AnnotationUtils.findAnnotation(signature.getDeclaringType(), MyDataSource.class);</span><br><span class="line">        &#125;</span><br><span class="line">        return myDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，定义一个用于拦截所有业务方法的全局切面类<code>GlobalDataSourceAspect</code>，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class GlobalDataSourceAspect &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private HttpSession session;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拦截service包下面的所有类的所有方法</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(* com.melody.dynamicmultipleds.service.*.*(..))&quot;)</span><br><span class="line">    public void globalDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;globalDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)&#123;</span><br><span class="line">        String dataSourceName = (String)session.getAttribute(MultipleDataSourceProvider.DS_SESSION_KEY);</span><br><span class="line">        DynamicMultipleDataSourceContextHolder.setDataSourceName(dataSourceName);</span><br><span class="line">        try &#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            //清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第七步，定义一个名为<code>DataSourceController</code>的类，在里面提供两个方法，一个用于修改数据源名称，另一个用于查询所有的books信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DataSourceController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(DataSourceController.class);</span><br><span class="line">    /**</span><br><span class="line">     * 修改数据源名称</span><br><span class="line">     * @param dsName</span><br><span class="line">     * @param session</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/dsName&quot;)</span><br><span class="line">    public void updateDataSourceName(String dsName, HttpSession session)&#123;</span><br><span class="line">        session.setAttribute(MultipleDataSourceProvider.DS_SESSION_KEY,dsName);</span><br><span class="line">        logger.info(&quot;数据源切换为&#123;&#125;&quot;,dsName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/books&quot;)</span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">        return bookService.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，在<code>resources/static</code>目录下新建一个名为<code>jquery-3.6.0.js</code>的js文件，里面的内容可以从 <a href="http://code.jquery.com/jquery-3.6.0.js">这里</a> 获取。接着在该目录下定义一个名为index.html的页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;多数据源可视化切换&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;jquery-3.6.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    请选择使用的数据源：</span><br><span class="line">    &lt;select name=&quot;&quot; id=&quot;&quot; onchange=&quot;dsChange(this.options[this.options.selectedIndex].value)&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;请选择&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;master&quot;&gt;master&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;slave&quot;&gt;slave&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;result&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button onclick=&quot;loadData()&quot;&gt;加载数据&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function loadData() &#123;</span><br><span class="line">        $.get(&quot;/books&quot;,function (data) &#123;</span><br><span class="line">            $(&quot;#result&quot;).html(JSON.stringify(data));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    function dsChange(value) &#123;</span><br><span class="line">        $.post(&quot;/dsName&quot;,&#123;</span><br><span class="line">            dsName: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>前端页面的代码也较为简单，即让用户手动选择数据源，然后点击下方的加载数据按钮，即可通过新的数据源来加载数据。实际上选择数据源的时候就是请求了<code>/dsName</code>这一API；而加载数据则是请求了<code>/books</code>这一API。</p><p>第九步，测试。启动项目，访问<code>http://localhost:8080/index.html</code>页面，选择“master”，可以看到控制台也输出对应信息了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-99deaadfd20a7b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击加载数据按钮，可以看到首页已经将master这一数据源数据查询出来了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea9f77904c0d0607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e3f789e4a191d9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们再选择“slave”，可以看到控制台也输出对应信息了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c64f95ce113230e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1a4df20c856fa200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第十步，确定全局拦截和注解拦截业务顺序。由于前面说过，如果某个类既被全局拦截，又添加了<code>@MyDataSource</code>注解，那么最终还是以<code>@MyDataSource</code>注解指定的数据源名称为准。也就是说全局拦截先执行，<code>@MyDataSource</code>注解后执行才能达到既定目的，而配置Bean的顺序可以使用<code>@Order</code>注解来实现，其中<code>@Order</code>注解中设置的数字越小表示优先级越高，越先执行。所以反映到<code>@Order</code>注解上面，要想实现既定目标，那么全局拦截切面类上的<code>@Order</code>注解中设置的数字就要小于<code>@MyDataSource</code>注解所定义切面上的<code>@Order</code>注解中设置的数字值。</p><p>可以将全局拦截类<code>GlobalDataSourceAspect</code>上的<code>@Order</code>注解值设置为1；<code>@MyDataSource</code>注解所对应的切面类<code>MyDataSourceAspect</code>上的<code>@Order</code>注解值设置为2，这样就可以让<code>@MyDataSource</code>注解的优先级高于全局。然后在BookService类中的getAllBooks方法中添加<code>@MyDataSource</code>注解，指定数据源为master：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;master&quot;)</span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">       return bookMapper.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启项目，可以发现此时无论用户如何切换数据源，最终用户调用的都是master这一数据源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中我们希望实现多数据源的动态切换，而这一点我们在前面一篇文章中就已经进行了实现，但是对于业务人员来说，更多的则是希</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>多数据源动态切换</title>
    <link href="http://envyzhan.asia/2022/03/18/3-dynamic-switching-of-multiple-data-sources/"/>
    <id>http://envyzhan.asia/2022/03/18/3-dynamic-switching-of-multiple-data-sources/</id>
    <published>2022-03-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:05:58.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前一篇文章中我们介绍了如何在SpringBoot中整合<code>Jdbc Template</code>、<code>Mybatis</code>和<code>Spring Data JPA</code>的多数据源配置，但是很明显这些思路都是设置多个Dao层，然后手动选择使用的实例，在实际工作中可能会有需要动态切换数据源的情况，因此本篇来学习如何利用AOP来实现多数据源的动态切换功能。</p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p><code>AbstractRoutingDataSource</code>是Spring2.0.1版本引入的一个抽象类，它提供了多数据源的支持能力。<code>AbstractRoutingDataSource</code>抽象类定义了抽象的<code>determineCurrentLookupKey</code>方法，子类只需实现此方法，进而动态确定要使用的数据源。</p><p>查看一下这个<code>AbstractRoutingDataSource</code>抽象类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Object defaultTargetDataSource;</span><br><span class="line">    private boolean lenientFallback = true;</span><br><span class="line">    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource resolvedDefaultDataSource;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    protected DataSource determineTargetDataSource() &#123;</span><br><span class="line">        Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);</span><br><span class="line">        Object lookupKey = this.determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey);</span><br><span class="line">        if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123;</span><br><span class="line">            dataSource = this.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (dataSource == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected abstract Object determineCurrentLookupKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>determineTargetDataSource</code>方法的逻辑是先判断<code>resolvedDataSources</code>属性是否不为空，之后再调用<code>determineCurrentLookupKey</code>方法来获取数据源名称key，并从<code>resolvedDataSources</code>属性中得到对应的DataSource对象。如果找不到DataSource对象或者数据源名称key不存在则使用<code>resolvedDefaultDataSource</code>。</p><p>说白了就是开发者提前准备好多个数据源，然后将其存入一个Map中，Map的Key是对应数据源的名称，而Value则是对应的数据源。接着将Map设置到<code>AbstractRoutingDataSource</code>对象的<code>resolvedDataSources</code>属性中，然后当执行数据库操作的时候就通过一个Key来从Map中获取对应的数据源实例，并执行对应的数据库操作。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>dynamic-multiple-ds</code>的SpringBoot项目，选择<code>spring web</code>、<code>mybatis framework</code>和<code>mysql driver</code>依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-927a0caa070c04b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二步，在POM文件中新增Druid和AOP依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>第三步，修改<code>application.properties</code>配置文件信息，不过由于笔者一般喜欢使用YAML格式的写法，因此<code>application.yml</code>配置文件其实使用更为频繁，因此这里也使用<code>application.yml</code>配置文件。但是后期我们需要动态获取里面的内容，因此可以使用SpringBoot提供的profile机制来加载里面的信息。定义一个名为<code>application-multiple.yml</code>的配置文件，并在里面新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 数据源配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    # 数据源类型</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 自定义数据源</span><br><span class="line">    my-ds:</span><br><span class="line">      # 主数据源，默认为master</span><br><span class="line">      master:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds1?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">      # 从数据源，slave</span><br><span class="line">      slave:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">    # 初始连接数</span><br><span class="line">    initial-size: 5</span><br><span class="line">    # 最小连接池数量</span><br><span class="line">    min-idle: 10</span><br><span class="line">    # 最大连接池数量</span><br><span class="line">    max-active: 20</span><br><span class="line">    # 获取连接等待超时的时间</span><br><span class="line">    max-wait: 60000</span><br><span class="line">    # 检测间隔时间，检测需要关闭的空闲连接，单位毫秒</span><br><span class="line">    time-between-eviction-runs-millis: 60000</span><br><span class="line">    # 一个连接在连接池中最小的生存时间，单位毫秒</span><br><span class="line">    min-evictable-idle-time-millis: 300000</span><br><span class="line">    # 一个连接在连接池中最大的生存时间，单位毫秒</span><br><span class="line">    max-evictable-idle-time-millis: 900000</span><br><span class="line">    # 配置检测连接是否有效</span><br><span class="line">    validation-query: SELECT 1 FROM DUAL</span><br><span class="line">    # 如果为true（默认为false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的</span><br><span class="line">    test-on-borrow: false</span><br><span class="line">    # 连接返回检测</span><br><span class="line">    test-on-return: false</span><br><span class="line">    # 失效连接检测</span><br><span class="line">    test-while-idle: true</span><br><span class="line">    druid:</span><br><span class="line">      web-stat-filter:</span><br><span class="line">        enabled: true</span><br><span class="line">      stat-view-servlet:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 设置白名单，缺省为所有</span><br><span class="line">        allow:</span><br><span class="line">        url-pattern: /druid/*</span><br><span class="line">        # 登录用户名及密码</span><br><span class="line">        login-username: melody</span><br><span class="line">        login-password: melody</span><br><span class="line">      filter:</span><br><span class="line">        # 开启统计功能</span><br><span class="line">        stat:</span><br><span class="line">          enabled: true</span><br><span class="line">          # 开启慢查询功能</span><br><span class="line">          log-slow-sql: true</span><br><span class="line">          slow-sql-millis: 1000</span><br><span class="line">          # 合并多SQL</span><br><span class="line">          merge-sql: true</span><br><span class="line">        # 开启防火墙功能</span><br><span class="line">        wall:</span><br><span class="line">          enabled: true</span><br><span class="line">          config:</span><br><span class="line">            # 允许多语句同时执行</span><br><span class="line">            multi-statement-allow: true</span><br></pre></td></tr></table></figure><p>这里我们提供了两个数据源，一主一备，其实这里就是同一个连接中的不同数据库罢了。同时我们还对Druid连接池工具进行了详细配置，启用了SQL监控和SQL防火墙等功能。</p><p>然后我们需要在<code>application.yml</code>配置文件中启动上述配置文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: multiple</span><br></pre></td></tr></table></figure><h3 id="加载数据源"><a href="#加载数据源" class="headerlink" title="加载数据源"></a>加载数据源</h3><p>第四步，新建一个名为<code>MultipleDSConfiguration</code>类，显然该类是一个配置类，用于将之前定义的<code>application-multiple.yml</code>配置文件内容加载到该类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">public class MultipleDSConfiguration &#123;</span><br><span class="line">    private Map&lt;String,Map&lt;String,String&gt;&gt; myDS;</span><br><span class="line">    private int initialSize;</span><br><span class="line">    private int minIdle;</span><br><span class="line">    private int maxActive;</span><br><span class="line">    private int maxWait;</span><br><span class="line">    private int timeBetweenEvictionRunsMillis;</span><br><span class="line">    private int minEvictableIdleTimeMillis;</span><br><span class="line">    private int maxEvictableIdleTimeMillis;</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    private boolean testOnBorrow;</span><br><span class="line">    private boolean testOnReturn;</span><br><span class="line">    private boolean testWhileIdle;</span><br><span class="line"></span><br><span class="line">    public DruidDataSource dataSource(DruidDataSource druidDataSource)&#123;</span><br><span class="line">        // 初始连接数</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        // 最小连接池数量</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        // 最大连接池数量</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        // 获取连接等待超时的时间</span><br><span class="line">        druidDataSource.setMaxWait(maxWait);</span><br><span class="line">        // 检测间隔时间，检测需要关闭的空闲连接，单位毫秒</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        // 一个连接在连接池中最小的生存时间，单位毫秒</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        // 一个连接在连接池中最大的生存时间，单位毫秒</span><br><span class="line">        druidDataSource.setMaxEvictableIdleTimeMillis(maxEvictableIdleTimeMillis);</span><br><span class="line">        // 配置检测连接是否有效</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        // 如果为true（默认为false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        // 连接返回检测</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        // 失效连接检测</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myDS这个就是我们所定义的Map，我们将定义的多个数据源写入到该Map中。此处还定义了一个名为dataSource的方法，该方法传入一个DruidDataSource对象，其实就是给这个DruidDataSource对象设置属性。</p><p>第五步，加载数据源。有了数据源及配置文件后，接下来我们开始根据配置文件来加载数据源。定义一个名为<code>MultipleDataSourceProvider</code>的接口类，里面定义默认的数据源名称(master)以及加载数据源的抽象方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipleDataSourceProvider &#123;</span><br><span class="line">    String DEFAULT_DATASOURCE = &quot;master&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, DataSource&gt; loadDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们定义一个该接口的实现类<code>YmlMultipleDataSourceProvider</code>，因此它需要重写其中的<code>loadDataSource()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class YmlMultipleDataSourceProvider implements MultipleDataSourceProvider&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MultipleDSConfiguration multipleDSConfiguration;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;String, DataSource&gt; loadDataSource() &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, String&gt;&gt; myDS = multipleDSConfiguration.getMyDS();</span><br><span class="line">        Map&lt;String,DataSource&gt; map = new HashMap&lt;&gt;(myDS.size());</span><br><span class="line">        try&#123;</span><br><span class="line">            for (String key: myDS.keySet())&#123;</span><br><span class="line">                DruidDataSource druidDataSource = (DruidDataSource)DruidDataSourceFactory.createDataSource(myDS.get(key));</span><br><span class="line">                map.put(key,multipleDSConfiguration.dataSource(druidDataSource));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们将之前的MultipleDSConfiguration对象注入进来，然后调用该对象的<code>getMyDS()</code>方法得到我们在<code>application-multiple.ym</code>l配置文件中设置的如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 数据源配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    my-ds:</span><br><span class="line">      # 主数据源，默认为master</span><br><span class="line">      master:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds1?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">      # 从数据源，slave</span><br><span class="line">      slave:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br></pre></td></tr></table></figure><p>接着调用<code>DruidDataSourceFactory.createDataSource()</code>方法传入一个map，这个map中就url、username和password这三个属性，并构建为一个DruidDataSource对象，之后我们调用MultipleDSConfiguration对象的<code>dataSource()</code>方法将之前对连接设置的各种参数对此数据源进行属性设置，最后以key为数据源名称，value为对应数据源将其存入到前面所述的Map中。</p><h3 id="切换数据源"><a href="#切换数据源" class="headerlink" title="切换数据源"></a>切换数据源</h3><p>第五步，切换数据源。对于当前数据库操作应当使用哪个数据源有多种实现方式，需要说明的是当前数据库操作对数据源所做的修改不应该影响到其他的数据库操作，因此可以使用ThreadLocal来实现。将当前数据库操作所使用的数据源存入到ThreadLocal中，这样只有当前线程才能获取到该数据，保证了多线程并发情况下数据的安全性。</p><p>首先定义一个用于操作ThreadLocal的类<code>DynamicMultipleDataSourceContextHolder</code>，它主要用于往ThreadLocal中存入、获取和清除数据，注意我们其实是将数据源的名称存入ThreadLocal里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicMultipleDataSourceContextHolder &#123;</span><br><span class="line">    public static final Logger log = LoggerFactory.getLogger(DynamicMultipleDataSourceContextHolder.class);</span><br><span class="line"></span><br><span class="line">    private String dataSourceName;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;String&gt; CURRENT_DATASOURCE_NAME = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void setDataSourceName(String dataSourceName)&#123;</span><br><span class="line">        log.info(&quot;切换到&#123;&#125;数据源&quot;,dataSourceName);</span><br><span class="line">        CURRENT_DATASOURCE_NAME.set(dataSourceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDataSourceName()&#123;</span><br><span class="line">        return CURRENT_DATASOURCE_NAME.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clearDataSourceName()&#123;</span><br><span class="line">        CURRENT_DATASOURCE_NAME.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，标记数据源。不过现在还有一个问题，就是我们怎么知道当前使用的是哪个数据源呢？因此需要有一个标识来标记当前使用的数据源。最简单的方式就是使用注解来做标记，因此可以定义一个名为<code>MyDataSource</code>的注解，用于标记当前使用的数据源名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 标记使用数据源的名称</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyDataSource &#123;</span><br><span class="line"></span><br><span class="line">    String dataSourceName() default MultipleDataSourceProvider.DEFAULT_DATASOURCE;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;dataSourceName&quot;)</span><br><span class="line">    String value() default MultipleDataSourceProvider.DEFAULT_DATASOURCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们允许这个注解添加在方法、类、接口(包括注解类型) 或enum上，因为只加载方法表示当前方法使用该数据源，而加载类上则表示该类中的所有方法都使用该数据源。还有用户在使用这个注解的时候需要指定一个数据源名称，不指定的话默认为master。</p><p>第七步，解析自定义注解。前面我们自定义了注解来标记所使用的数据源，那么接下来就是通过AOP来解析该自定义注解。新建一个名为<code>MyDataSourceAspect</code>的类，这是一个切面类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Order(1)</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyDataSourceAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;</span><br><span class="line">    +&quot;||@within(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;)</span><br><span class="line">    public void myDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;myDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)throws Throwable &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        MyDataSource myDataSource = AnnotationUtils.findAnnotation(signature.getMethod(), MyDataSource.class);</span><br><span class="line">        if(Objects.nonNull(myDataSource))&#123;</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.setDataSourceName(myDataSource.dataSourceName());</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）myDS方法定义了切入点，这里拦截所有被前面自定义的MyDataSource注解所修饰的方法或者类、接口(包括注解类型) 或enum；<br>（2）此处使用环绕通知，表示方法执行前后都进行通知。先根据切入点得到所有的方法签名，然后使用<code>AnnotationUtils.findAnnotation()</code>方法传入方法名和注解名，找到包含该注解的方法，然后得到得到该注解。注意该注解可能来自方法上，也可能来自类、接口(包括注解类型) 或enum上，不过方法上的优先级高于类上的优先级。之后判断此注解是否存在，如果存在则将该注解中的数据源名称，设置到当前线程的ThreadLocal中；如果注解不存在则直接进行方法的调用，不用设置数据源，而是使用默认的master数据源。最后当方法调用完成后，我们需要将数据源从ThreadLocal中移除。</p><h3 id="动态使用数据源"><a href="#动态使用数据源" class="headerlink" title="动态使用数据源"></a>动态使用数据源</h3><p>第七步，动态使用数据源。在完成上述操作后，接下来就是如何让Spring知道我们使用的是哪个具体数据源，因此就需要继承<code>AbstractRoutingDataSource</code>抽象类并重写其中的<code>determineTargetDataSource()</code>方法。</p><p>定义一个名为<code>DynamicMultipleDataSource</code>的类，来实现上述操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态使用数据源</span><br><span class="line"> */</span><br><span class="line">public class DynamicMultipleDataSource extends AbstractRoutingDataSource &#123;</span><br><span class="line">    //实际数据源提供者</span><br><span class="line">    YmlMultipleDataSourceProvider ymlMultipleDataSourceProvider;</span><br><span class="line"></span><br><span class="line">    public DynamicMultipleDataSource(YmlMultipleDataSourceProvider provider)&#123;</span><br><span class="line">        this.ymlMultipleDataSourceProvider = provider;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(provider.loadDataSource());</span><br><span class="line">        super.setTargetDataSources(targetDataSources);</span><br><span class="line">        super.setDefaultTargetDataSource(provider.loadDataSource().get(MultipleDataSourceProvider.DEFAULT_DATASOURCE));</span><br><span class="line">        super.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">        String dataSourceName = DynamicMultipleDataSourceContextHolder.getDataSourceName();</span><br><span class="line">        return dataSourceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）重写<code>determineCurrentLookupKey</code>方法逻辑，该方法用于根据数据源的名称来决定调用的数据源，如前面定义的master或者slave数据源名称，得到这个数据源名称后就可以从Map中得到对应的数据源实例。<br>（2）给<code>DynamicMultipleDataSource</code>类提供了一个有参的构造方法，该方法传入一个<code>YmlMultipleDataSourceProvider</code>对象，这个是实际数据源的提供者，即所有的数据源都可以从中获取到。<br>（3）在前面分析<code>AbstractRoutingDataSource</code>抽象类源码的时候，可以看到里面有几个非空的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Object defaultTargetDataSource;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>targetDataSources</code>表示所有的数据源，这个我们可以调用<code>YmlMultipleDataSourceProvider.loadDataSource()</code>方法来获取；defaultTargetDataSource则是默认的数据源，这个可以传入master这一数据源名称从前面所说的所有数据源中获取得到，这个master数据源是默认的，也是必须设置的数据源；最后就是调用<code>afterPropertiesSet()</code>来对前面所说的参数进行赋值和校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">    if (this.targetDataSources == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Property &#x27;targetDataSources&#x27; is required&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.resolvedDataSources = new HashMap(this.targetDataSources.size());</span><br><span class="line">        this.targetDataSources.forEach((key, value) -&gt; &#123;</span><br><span class="line">            Object lookupKey = this.resolveSpecifiedLookupKey(key);</span><br><span class="line">            DataSource dataSource = this.resolveSpecifiedDataSource(value);</span><br><span class="line">            this.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">        &#125;);</span><br><span class="line">        if (this.defaultTargetDataSource != null) &#123;</span><br><span class="line">            this.resolvedDefaultDataSource = this.resolveSpecifiedDataSource(this.defaultTargetDataSource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，注解Bean。接下来我们就是将前面定义的<code>DynamicMultipleDataSource</code>对象注入到Spring容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DynamicMultipleDataSourceConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private YmlMultipleDataSourceProvider provider;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicMultipleDataSource dynamicMultipleDataSource()&#123;</span><br><span class="line">        return new DynamicMultipleDataSource(provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><p>第九步，创建对应数据表。在数据库my-ds1和my-ds2中依次创建book数据表，并给前者数据库的数据表中插入1条数据，后者插入2条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `book` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `price` int(11) DEFAULT NULL,</span><br><span class="line">  `description` varchar(500) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>第十步，创建mapper层。这里简单起见没有使用XML文件，直接通过注解方式书写SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    @Select(&quot;select count(*) from book&quot;)</span><br><span class="line">    Integer number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十一步，创建service层。这里我们定义了两个方法，分别调用master和slave这两个数据源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;master&quot;)</span><br><span class="line">    public Integer master()&#123;</span><br><span class="line">        return bookMapper.number();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;slave&quot;)</span><br><span class="line">    public Integer slave()&#123;</span><br><span class="line">        return bookMapper.number();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十二步，创建controller层。这里我们定义了一个方法，用于输出各个数据源中表的记录条数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    public static final Logger log = LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public List&lt;Integer&gt; books()&#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        log.info(&quot;master db numbers is &#123;&#125;&quot;,bookService.master());</span><br><span class="line">        list.add(bookService.master());</span><br><span class="line">        log.info(&quot;slave db numbers is &#123;&#125;&quot;,bookService.slave());</span><br><span class="line">        list.add(bookService.slave());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十三步，启动项目进行测试。打开浏览器，访问<code>http://localhost:8080/book</code>链接，可以看到它显示一个列表<code>[1,2]</code>，而IDEA控制台输出如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-30704bbfc8225d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就实现了多数据源的动态切换这一功能，但是美中不足的是无法通过界面来实时控制，其实只需将注解的值作为参数来传入就可以实现，关于一点会在后面的文章中进行介绍和学习。</p><p>【参考文章】 <a href="https://mp.weixin.qq.com/s/g71F3cnLtD4zqJGFCeJckQ">手把手教你玩多数据源动态切换！</a> ，感谢大佬的指导与解惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前一篇文章中我们介绍了如何在SpringBoot中整合&lt;code&gt;Jdbc Template&lt;/code&gt;、&lt;code&gt;M</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
</feed>
