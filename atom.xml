<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://aigoing.chat/atom.xml" rel="self"/>
  
  <link href="http://aigoing.chat/"/>
  <updated>2025-11-09T03:46:51.559Z</updated>
  <id>http://aigoing.chat/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Milvus简介及安装</title>
    <link href="http://aigoing.chat/2025/05/04/2025-5-Introduction%20to%20Milvus%20and%20Its%20Installation/"/>
    <id>http://aigoing.chat/2025/05/04/2025-5-Introduction%20to%20Milvus%20and%20Its%20Installation/</id>
    <published>2025-05-04T06:01:20.000Z</published>
    <updated>2025-11-09T03:46:51.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Milvus简介"><a href="#Milvus简介" class="headerlink" title="Milvus简介"></a>Milvus简介</h1><h2 id="什么是Milvus"><a href="#什么是Milvus" class="headerlink" title="什么是Milvus"></a>什么是Milvus</h2><p>（1）Milvus是一款云原生向量数据库，它具备高可用、高性能、易拓展的特点，用于海量向量数据的实时召回。</p><p>（2）Milvus基于FAISS、Annoy、HNSW等向量搜索库构建，核心是解决稠密向量相似度检索的问题。</p><p>（3）在向量检索库的基础上，Milvus支持数据分区分片、数据持久化、增量数据摄取、标量向量混合查询、time travel 等功能，同时大幅优化了向量检索的性能，可满足任何向量检索场景的应用需求。</p><p>（4）通常，建议用户使用 Kubernetes 部署 Milvus，以获得最佳可用性和弹性。</p><p><font style="color:rgb(51, 51, 51);">Milvus 采用</font>共享存储架构，<strong>存储计算完全分离</strong>，计算节点支持横向扩展。从架构上来看，Milvus 遵循数据流和控制流分离，整体分为了四个层次，分别为接入层（access layer）、协调服务（coordinator service）、执行节点（worker node）和存储层（storage）。各个层次相互独立，独立扩展和容灾。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762511182931-a6771352-5678-4303-9812-9e15e73655f0.png"></p><h2 id="为什么需要Milvus"><a href="#为什么需要Milvus" class="headerlink" title="为什么需要Milvus"></a>为什么需要Milvus</h2><p>随着互联网不断发展，电子邮件、论文、物联网传感数据、社交媒体照片、蛋白质分子结构等<strong>非结构化数据</strong>已经变得越来越普遍。如果想要使用计算机来处理这些数据，需要使用embedding技术将这些数据转化为向量。随后，Milvus会存储这些向量，并为其建立索引。Milvus 能够根据两个向量之间的距离来分析他们的相关性。如果两个向量十分相似，这说明向量所代表的源数据也十分相似。</p><p>Milvus 向量数据库专为向量查询与检索设计，能够为万亿级向量数据建立索引。Milvus 在底层设计上就是为了处理由各种非结构化数据转换而来的Embedding向量而生。</p><h2 id="为什么使用Milvus"><a href="#为什么使用Milvus" class="headerlink" title="为什么使用Milvus"></a>为什么使用Milvus</h2><p>（1）高性能：性能高超，可对海量数据集进行向量相似度检索；</p><p>（2）高可用、高可靠：Milvus 支持在云上扩展，其容灾能力能够保证服务高可用；</p><p>（3）混合查询：Milvus 支持在向量相似度检索过程中进行标量字段过滤，实现混合查询；</p><p>（4）开发者友好：支持多语言、多工具的 Milvus 生态系统。</p><h1 id="Milvus系统架构"><a href="#Milvus系统架构" class="headerlink" title="Milvus系统架构"></a>Milvus系统架构</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Milvus 2.0 是一款云原生向量数据库，采用存储与计算分离的架构设计，所有组件均为无状态组件，极大地增强了系统弹性和灵活性：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762507905049-b8a65870-541b-4a26-aa2b-f8ed25bcd82e.png"></p><p>整个系统分为四个层次，各个层次相互独立，独立扩展和容灾：</p><p>（1）接入层（Access Layer）：它是系统的门面，由一组无状态的Proxy组成，对外提供用户连接的endpoint，负责验证客户端请求并合并返回结果。</p><p>（2）协调服务（Coordinator Service）：系统的大脑，负责分配任务给执行节点。协调服务共有四种角色，分别为 root coord、data coord、query coord 和 index coord。</p><p>（3）执行节点（Worker Node）：系统的四肢，负责完成协调服务下发的指令和proxy发起的数据操作语言（DML）命令。执行节点分为三种角色，分别为data node、query node和index node。</p><p>（4） 存储服务 （Storage）： 系统的骨骼，负责Milvus数据的持久化，分为元数据存储（meta store）、消息存储（log broker）和对象存储（object storage）三个部分。</p><h2 id="接入层（Access-Layer）"><a href="#接入层（Access-Layer）" class="headerlink" title="接入层（Access Layer）"></a>接入层（Access Layer）</h2><p>（1）接入层由一组无状态 proxy 组成，是整个系统的门面，对外提供用户连接的 endpoint。接入层负责验证客户端请求并减少返回结果；</p><p>（2）Proxy本身是无状态的，一般通过负载均衡组件（Nginx、Kubernetes Ingress、NodePort、LVS）对外提供统一的访问地址并提供服务。</p><p>（3） 由于Milvus采用大规模并行处理（MPP）架构，proxy会先对执行节点返回的中间结果进行全局聚合和后处理后，再返回至客户端。</p><h2 id="协调服务（Coordinator-Service）"><a href="#协调服务（Coordinator-Service）" class="headerlink" title="协调服务（Coordinator Service）"></a>协调服务（Coordinator Service）</h2><p>（1）协调服务是系统的大脑，负责向执行节点分配任务。它承担的任务包括集群拓扑节点管理、负载均衡、时间戳生成、数据声明和数据管理等。</p><p>（2）协调服务共有四种角色：</p><ul><li>Root coordinator（root coord）：负责处理数据定义语言（DDL）和数据控制语言（DCL）请求。比如，创建或删除collection、partition、index等，同时负责维护中心授时服务TSO和时间窗口的推进。</li><li>Query coordinator (query coord）：负责管理query node的拓扑结构和负载均衡以及从增长的 segment 移交切换到密封的 segment。</li><li>Data coordinator (data coord）：负责管理data node的拓扑结构，维护数据的元信息以及触发 flush、compact 等后台数据操作。</li><li>Index coordinator (index coord）：负责管理index node的拓扑结构，构建索引和维护索引元信息。</li></ul><h2 id="执行节点（Worker-Node）"><a href="#执行节点（Worker-Node）" class="headerlink" title="执行节点（Worker Node）"></a>执行节点（Worker Node）</h2><p>（1）执行节点是系统的四肢，负责完成协调服务下发的指令和 proxy 发起的数据操作语言（DML）命令。</p><p>（2）由于采取了存储计算分离，执行节点是无状态的，可以配合 Kubernetes 快速实现扩缩容和故障恢复</p><p>（3）执行节点分为三种角色：</p><ul><li>Query node： Query node 通过订阅消息存储（log broker）获取增量日志数据并转化为 growing segment，基于对象存储加载历史数据，提供标量 + 向量的混合查询和搜索功能。</li><li>Data node：Data node 通过订阅消息存储获取增量日志数据，处理更改请求，并将日志数据打包存储在对象存储上实现日志快照持久化。</li><li>Index node：Index node 负责执行索引构建任务。Index node 不需要常驻于内存，可以通过 serverless 的模式实现。</li></ul><h2 id="存储服务-（Storage）"><a href="#存储服务-（Storage）" class="headerlink" title="存储服务 （Storage）"></a>存储服务 （Storage）</h2><p>存储服务是系统的骨骼，负责 Milvus 数据的持久化，分为元数据存储（meta store）、对象存储（object storage）和消息存储（log broker）三个部分。</p><h3 id="元数据存储（meta-store）"><a href="#元数据存储（meta-store）" class="headerlink" title="元数据存储（meta store）"></a>元数据存储（meta store）</h3><p>负责存储元信息的快照，如集合 schema 信息、节点状态信息、消息消费的 checkpoint 等。元信息存储需要极高的可用性、强一致和事务支持，因此etcd是这个场景下的不二选择。除此之外，etcd还承担了服务注册和健康检查的职责。</p><h3 id="对象存储（object-storage）"><a href="#对象存储（object-storage）" class="headerlink" title="对象存储（object storage）"></a>对象存储（object storage）</h3><p>负责存储日志的快照文件、标量 / 向量索引文件以及查询的中间处理结果。Milvus 采用MinIO作为对象存储，另外也支持部署于AWS S3和Azure Blob这两大最广泛使用的低成本存储。但是，由于对象存储访问延迟较高，且需要按照查询计费，因此Milvus未来计划支持基于内存或 SSD 的缓存池，通过冷热分离的方式提升性能以降低成本。</p><h3 id="消息存储（log-broker）"><a href="#消息存储（log-broker）" class="headerlink" title="消息存储（log broker）"></a>消息存储（log broker）</h3><p>消息存储是一套支持回放的发布订阅系统，用于持久化流式写入的数据，以及可靠的异步执行查询、事件通知和结果返回。执行节点宕机恢复时，通过回放消息存储保证增量数据的完整性。</p><p>目前，分布式版Milvus依赖Pulsar作为消息存储，单机版Milvus依赖RocksDB作为消息存储。消息存储也可以替换为Kafka、Pravega等流式存储。整个Milvus围绕日志为核心来设计，遵循<strong>日志即数据</strong>的准则，因此在 2.0 版本中没有维护物理上的表，而是通过日志持久化和日志快照来保证数据的可靠性。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762508954322-a30f956d-f741-48a3-ab4a-255ed97feee9.png"></p><p>日志系统作为系统的主干，承担了数据持久化和解耦的作用。通过日志的发布订阅机制，Milvus将系统的读、写组件解耦。一个极致简化的模型如上图所示，整个系统主要由两个角色构成，分别是消息存储（log broker）（负责维护”日志序列 “）与“日志订阅者”。其中的“日志序列” 记录了所有改变库表状态的操作，“日志订阅者”通过订阅日志序列更新本地数据，以只读副本的方式提供服务。 发布订阅机制还为系统在变更数据捕获（CDC）和全面的分布式部署方面的可扩展性提供了空间。</p><h1 id="Milvus主要的组件"><a href="#Milvus主要的组件" class="headerlink" title="Milvus主要的组件"></a>Milvus主要的组件</h1><p>Milvus支持两种部署模式，单机模式（standalone）和分布式模式（cluster）。两种模式具备完全相同的能力，用户可根据数据规模、访问量等因素选择适合自己的模式。Standalone模式部署的Milvus暂时不支持在线升级为cluster模式。</p><h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>单机版的Milvus主要有三个组件，分别是Milvus、etcd和MinIO：</p><ul><li>Milvus负责提供系统的核心功能；</li><li>etcd是元数据引擎，用于管理Milvus内部组件的元数据访问和存储，例如：proxy、index node等；</li><li>MinIO是存储引擎，负责维护Milvus的数据持久化。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762509223944-66e7b2fa-cb29-4916-af07-2ed18325376d.png"></p><h2 id="分布式模式"><a href="#分布式模式" class="headerlink" title="分布式模式"></a>分布式模式</h2><p>（1）分布式版的Milvus主要有八个微服务组件和三个第三方依赖组成，每个微服务组件可使用 Kubernetes 独立部署。</p><p>（2）八个微服务组件分别是：Root coord、Proxy、Query coord、Query node、Index coord、 Index node、Data coord和Data node。</p><p>（3）三个第三方依赖，分别是etcd、MinIO和Pulsar：</p><ul><li>etcd 负责存储集群中各组件的元数据信息；</li><li>MinIO 负责处理集群中大型文件的数据持久化，如索引文件和全二进制日志文件；</li><li>Pulsar 负责管理近期更改操作的日志，输出流式日志及提供日志订阅服务。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762509488543-8dd69fa0-db59-4513-bedb-c4a857f4c463.png"></p><h1 id="Milvus的应用场景"><a href="#Milvus的应用场景" class="headerlink" title="Milvus的应用场景"></a>Milvus的应用场景</h1><p>开发者可以使用Milvus搭建符合自己场景需求的向量相似度检索系统。Milvus的使用场景如下：</p><p>（1） 图片检索系统：以图搜图，从海量数据库中即时返回与上传图片最相似的图片。</p><p>（2）视频检索系统：将视频关键帧转化为向量并插入 Milvus，便可检索相似视频，或进行实时视频推荐。</p><p>（3）音频检索系统：快速检索海量演讲、音乐、音效等音频数据，并返回相似音频。</p><p>（4） 分子式检索系统：超高速检索相似化学分子结构、超结构、子结构。</p><p>（5） 推荐系统：根据用户行为及需求推荐相关信息或商品。</p><p>（6）智能问答机器人：交互式智能问答机器人可自动为用户答疑解惑。</p><p>（7）DNA序列分类系统：通过对比相似 DNA 序列，仅需几毫秒便可精确对基因进行分类。</p><p>（8） 文本搜索引擎：帮助用户从文本数据库中通过关键词搜索所需信息。</p><h1 id="Milvus支持的搜索类型"><a href="#Milvus支持的搜索类型" class="headerlink" title="Milvus支持的搜索类型"></a>Milvus支持的搜索类型</h1><p>Milvus支持多种类型的搜索功能，如下：</p><p>（1）ANN搜索：查找最接近查询向量的前K个向量；</p><p>（2）过滤搜索：在指定的过滤条件下执行 ANN 搜索；</p><p>（3）范围搜索：查找查询向量指定半径范围内的向量；</p><p>（4）混合搜索：基于多个向量场进行 ANN 搜索；</p><p>（5）全文搜索：基于 BM25 的全文搜索；</p><p>（6）Rerankers：根据附加标准或辅助算法调整搜索结果顺序，完善初始 ANN 搜索结果；</p><p>（7）获取：根据主键检索数据；</p><p>（8）查询：使用特定表达式检索数据。</p><h1 id="Milvus与Pinecone的对比"><a href="#Milvus与Pinecone的对比" class="headerlink" title="Milvus与Pinecone的对比"></a>Milvus与Pinecone的对比</h1><p>以下是Milvus与Pinecone的整体对比：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762504908085-f70ee99a-35db-4743-a62d-2d5b1251a56b.png"></p><p>虽然两者作为向量数据库功能相似，但是在特定领域的术语不同：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762504927303-2270bdf2-7bf7-441d-b0e7-ec896c969757.png"></p><p>当然两者在能力方面也存在不同：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762505020541-609f12ee-1fa5-4d40-b66e-3f30b11d6261.png"></p><ul><li><strong><font style="color:rgb(0, 0, 0);">部署模式</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus提供多种部署选项，包括本地部署、Docker、Kubernetes on-premises、云SaaS和面向企业的自带云（BYOC），而Pinecone仅限于SaaS部署。</li><li><strong><font style="color:rgb(0, 0, 0);">嵌入功能</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus 支持额外的嵌入库，可直接使用嵌入模型将源数据转换为向量。</li><li><strong><font style="color:rgb(0, 0, 0);">数据类型</font></strong><font style="color:rgb(0, 0, 0);">：</font>与 Pinecone 相比，Milvus 支持更广泛的数据类型，包括数组和 JSON。Pinecone 只支持以字符串、数字、布尔值或字符串列表为值的扁平元数据结构，而 Milvus 可以在一个 JSON 字段内处理任何 JSON 对象，包括嵌套结构。Pinecone 限制每个向量的元数据大小为 40KB。</li><li><strong><font style="color:rgb(0, 0, 0);">度量和索引类型</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus 支持多种度量和索引类型，以适应各种使用情况，而 Pinecone 的选择较为有限。虽然在 Milvus 中必须为向量建立索引，但也提供了 AUTO_INDEX 选项来简化配置过程。</li><li><strong><font style="color:rgb(0, 0, 0);">Schema 设计</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus 为模式设计提供了灵活的<code>create_collection</code> 模式，包括快速设置动态模式，以获得类似 Pinecone 的无模式体验，以及自定义设置预定义模式字段和索引，类似关系数据库管理系统（RDBMS）。</li><li><strong><font style="color:rgb(0, 0, 0);">多向量字段</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus 支持在单个 Collections 中存储多个向量字段，这些字段可以是稀疏的，也可以是密集的，维度也可能不同。Pinecone 不提供类似功能。</li><li><strong><font style="color:rgb(0, 0, 0);">工具</font></strong><font style="color:rgb(0, 0, 0);">：</font>Milvus 为数据库管理和利用提供了更广泛的工具选择，如 Attu、Birdwatcher、Backup、CLI、CDC 以及 Spark 和 Kafka 连接器。</li></ul><h1 id="Milvus基本概念"><a href="#Milvus基本概念" class="headerlink" title="Milvus基本概念"></a>Milvus基本概念</h1><h2 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h2><p>（1）非结构化数据指的是数据结构不规则，没有统一的预定义数据模型，不方便用数据库二维逻辑表来表现的数据。</p><p>（2）非结构化数据包括图片、视频、音频、自然语言等，占所有数据总量的 80%。</p><p>（3）非结构化数据的处理可以通过各种人工智能（AI）或机器学习（ML）模型转化为向量数据后进行处理。</p><h2 id="特征向量"><a href="#特征向量" class="headerlink" title="特征向量"></a>特征向量</h2><p>（1）向量又称为embedding vector，是指由embedding技术从离散变量（如图片、视频、音频、自然语言等各种非结构化数据）转变而来的连续向量。</p><p>（2）在数学表示上，向量是一个由浮点数或者二值型数据组成的 n 维数组。</p><p>（3）通过现代的向量转化技术，比如各种人工智能（AI）或者机器学习（ML）模型，可以将非结构化数据抽象为 n 维特征向量空间的向量。这样就可以采用最近邻算法（ANN）计算非结构化数据之间的相似度。</p><h2 id="向量相似度检索"><a href="#向量相似度检索" class="headerlink" title="向量相似度检索"></a>向量相似度检索</h2><p>（1）相似度检索是指将目标对象与数据库中数据进行比对，并召回最相似的结果。同理，向量相似度检索返回的是最相似的向量数据。</p><p>（2）近似最近邻搜索（ANN）算法能够计算向量之间的距离，从而提升向量相似度检索的速度。如果两条向量十分相似，这就意味着他们所代表的源数据也十分相似。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>包含一组 entity，可以等价于关系型数据库系统（RDBMS）中的表。</p><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>（1）包含一组field。field与实际对象相对应。field可以是代表对象属性的结构化数据，也可以是代表对象特征的向量。primary key用于指代一个entity的唯一值。</p><p>（2）开发者可以自定义primary key，否则Milvus将会自动生成primary key。</p><p>（3）请注意，目前Milvus不支持primary key去重，因此有可能在一个collection内出现primary key相同的entity。</p><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>（1）Entity 的组成部分。Field 可以是结构化数据，例如数字和字符串，也可以是向量。</p><p>（2）Milvus 2.0 现已支持标量字段过滤。并且，Milvus 2.0 在一个集合中只支持一个主键字段。</p><h2 id="Milvus与关系数据库对比"><a href="#Milvus与关系数据库对比" class="headerlink" title="Milvus与关系数据库对比"></a>Milvus与关系数据库对比</h2><p>Milvus 与关系型数据库的对应关系如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1762510468244-ec2606d3-96a2-420f-a783-250667713890.png"></p><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a><font style="color:rgb(0, 0, 0);">Partition</font></h2><p>分区（Partition）是集合（Collection）的一个分区。Milvus 支持将收集数据划分为物理存储上的多个部分。这个过程称为分区，每个分区可以包含多个段。</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a><font style="color:rgb(51, 51, 51);">Segment</font></h2><p>Milvus在数据插入时，通过合并数据自动创建的数据文件。一个collection可以包含多个segment。一个segment可以包含多个entity。在搜索中，Milvus会搜索每个segment，并返回合并后的结果。</p><h2 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h2><p>（1）Shard 是指将数据写入操作分散到不同节点上，使 Milvus 能充分利用集群的并行计算能力进行写入。默认情况下，单个 Collection 包含 2 个分片（Shard）。</p><p>（2）目前 Milvus 采用基于<strong>主键哈希</strong>的分片方式，未来将支持随机分片、自定义分片等更加灵活的分片方式。</p><p>（3）<strong>分区的意义在于通过划定分区减少数据读取，而分片的意义在于多台机器上并行写入操作。</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>（1）索引基于原始数据构建，可以提高对 collection 数据搜索的速度。</p><p>（2）Milvus 支持多种索引类型。为提高查询性能，开发者可以为每个向量字段指定一种索引类型。目前，一个向量字段仅支持一种索引类型。切换索引类型时，Milvus 自动删除之前的索引。</p><p>（3）<strong>相似性搜索引擎的工作原理：将输入的对象与数据库中的对象进行比较，找出与输入最相似的对象</strong>。</p><p>（4）索引是有效组织数据的过程，极大地加速了对大型数据集的查询，在相似性搜索的实现中起着重要作用。对一个大规模向量数据集创建索引后，查询可以被路由到最有可能包含与输入查询相似的向量的集群或数据子集。在实践中，这意味着要牺牲一定程度的准确性来加快对真正的大规模向量数据集的查询。</p><h2 id="PChannel"><a href="#PChannel" class="headerlink" title="PChannel"></a>PChannel</h2><p>PChannel 表示物理信道。每个 PChannel 对应一个日志存储主题。默认情况下，将分配一组 256 个 PChannels 来存储记录 Milvus 集群启动时数据插入、删除和更新的日志。</p><h2 id="VChannel"><a href="#VChannel" class="headerlink" title="VChannel"></a>VChannel</h2><p>VChannel 表示逻辑通道。每个集合将分配一组 VChannels，用于记录数据的插入、删除和更新。VChannels 在逻辑上是分开的，但在物理上共享资源。</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>关于Docker的具体安装，这里不详细介绍，只给出docker engine的可用镜像地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;builder&quot;: &#123;</span><br><span class="line">    &quot;gc&quot;: &#123;</span><br><span class="line">      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,</span><br><span class="line">      &quot;enabled&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://ccr.ccs.tencentyun.com&quot;,</span><br><span class="line">    &quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;,</span><br><span class="line">    &quot;https://9cpn8tt6.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;https://mirror.ccs.tencentyun.com&quot;,</span><br><span class="line">    &quot;https://docker.1panel.live&quot;,</span><br><span class="line">    &quot;https://2a6bf1988cb6428c877f723ec7530dbc.mirror.swr.myhuaweicloud.com&quot;,</span><br><span class="line">    &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://dockerhub.icu&quot;,</span><br><span class="line">    &quot;https://docker.registry.cyou&quot;,</span><br><span class="line">    &quot;https://docker-cf.registry.cyou&quot;,</span><br><span class="line">    &quot;https://dockercf.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://docker.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://dockertest.jsdelivr.fyi&quot;,</span><br><span class="line">    &quot;https://mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://docker.nju.edu.cn&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;https://mirror.iscas.ac.cn&quot;,</span><br><span class="line">    &quot;https://docker.rainbond.cc&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="安装Milvus"><a href="#安装Milvus" class="headerlink" title="安装Milvus"></a>安装Milvus</h1><p>点击 <a href="https://github.com/milvus-io/milvus/releases">这里</a> 选择对应的版本，或者直接点击 <a href="https://github.com/milvus-io/milvus/releases/download/v2.6.4/milvus-standalone-docker-compose.yml">链接</a> 下载2.6.4的版本：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761477872496-785f1c4e-234d-479d-978b-a82bfeb00c6e.png"></p><p>下载完成后，修改yaml文件名称为<font style="color:rgb(51, 51, 51);">docker-compose.yml。新建一个目录，名字可以为milvus，然后cmd到该目录中，执行如下命令：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>由于在下载镜像，所以需要一些时间，出现下面的信息，说明下载完成：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761478071707-76d732ed-723c-4754-b9b4-f77201195154.png"></p><p>然后执行如下命令来查看是否启动成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose ps</span><br></pre></td></tr></table></figure><p>三个都是up，则说明启动成功：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761478152304-2ede08c2-93af-4577-85c6-4e41b27f9ca9.png"></p><p>在Docker-DeskTop中也能查看启动情况：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761478226934-28a668d9-97d0-481e-9955-7e81403f8bf8.png"></p><p>这样我们就安装完Milvus，但是这样不直观，需要可视化工具来管理向量，下面就开始安装Attu这一工具。</p><h1 id="安装Attu"><a href="#安装Attu" class="headerlink" title="安装Attu"></a>安装Attu</h1><p>第一步，使用ipconfig命令查看一下当前IP地址：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761478323187-d32f1892-0ec6-4173-8115-ca9c571b341b.png"></p><p>笔者使用的是WLAN，所以只需看这个适配器的IPV4地址，如果你开了虚拟机，那么VMnet1和VMnet8也是不用管的。</p><p>第二步，使用如下命令来安装Attu：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name attu-261 -p 3000:3000 -e MILVUS_URL=192.168.43.212:19530 zilliz/attu:v2.6.1</span><br></pre></td></tr></table></figure><p>其中表示将容器的3000端口转发到宿主机的3000端口，而其中的MILVUS_URL则是之前的本地IP地址，19530是向量数据库的端口，容器名称为attu-261，出现下面的<a href="http://172.17.0.2:3000表示启动成功：">http://172.17.0.2:3000表示启动成功：</a></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761478529707-43185e94-a023-4ec6-ba53-56af5bfe38ee.png"></p><h1 id="访问Attu"><a href="#访问Attu" class="headerlink" title="访问Attu"></a>访问Attu</h1><p>打开浏览器，访问如下地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000</span><br></pre></td></tr></table></figure><p>页面出现如下信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761477785809-5105cb24-3fd1-4109-90b3-615f99bd08da.png"></p><p>点击连接，即可登录到控制台：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1761477790589-0b1768a9-0321-4c4c-a98c-87c77057a98c.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Milvus简介&quot;&gt;&lt;a href=&quot;#Milvus简介&quot; class=&quot;headerlink&quot; title=&quot;Milvus简介&quot;&gt;&lt;/a&gt;Milvus简介&lt;/h1&gt;&lt;h2 id=&quot;什么是Milvus&quot;&gt;&lt;a href=&quot;#什么是Milvus&quot; class=&quot;he</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+MCP实现本地工具调用实战</title>
    <link href="http://aigoing.chat/2025/04/06/2025-4-practical-implementation-of-local-tool-call-using-springboot-MCP/"/>
    <id>http://aigoing.chat/2025/04/06/2025-4-practical-implementation-of-local-tool-call-using-springboot-MCP/</id>
    <published>2025-04-06T10:03:01.000Z</published>
    <updated>2025-06-02T13:53:06.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们学习了MCP以及其中的三个角色，包含客户端、服务端和资源端，对应的解释如下：</p><p>（1）客户端：可理解为是Ai应用层，如聊天对话框。用户输入信息后，由客户端接口接收，再由客户端调用服务端调配资源处理；</p><p>（2）服务端：可理解为注册中心，请注意所有的工具都是注册在服务端；</p><p>（3）资源端：资源端就是大模型解析之后的用户需求的服务，即实际的处理逻辑。资源端可以和服务端部署在一起，也可以单独部署。</p><h1 id="资源端"><a href="#资源端" class="headerlink" title="资源端"></a>资源端</h1><p>第一步，新建一个名为ai-mcp-server的SpringBoot项目，注意SpringBoot版本为3.4.2，JDK版本为17。之后pom.xml文件信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.gutsyzhan&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ai-mcp-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;ai-mcp-server&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;ai-mcp-server&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;17&lt;/java.version&gt;</span><br><span class="line">        &lt;spring-ai.version&gt;1.0.0-M6&lt;/spring-ai.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-mcp-server-webmvc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>第二步，新建一个名为service的包，我们在里面定义两个类，分别用于实现数据采集和数据生成功能。新建一个名为DataAcquisitionService的类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class DataAcquisitionService &#123;</span><br><span class="line">    @Tool(description = &quot;数据采集工具，从一个源头数据源中采集数据到目标数据源&quot;)</span><br><span class="line">    public String acquisition(</span><br><span class="line">            @ToolParam(description = &quot;源头数据源&quot;)String sourceDB,</span><br><span class="line">            @ToolParam(description = &quot;目标数据源&quot;)String targetDB,</span><br><span class="line">            @ToolParam(description = &quot;源头数据表&quot;)String sourceTable,</span><br><span class="line">            @ToolParam(description = &quot;目标数据表&quot;)String targetTable,</span><br><span class="line">            @ToolParam(description = &quot;采集策略&quot;)String type</span><br><span class="line">    )&#123;</span><br><span class="line">        //采集逻辑</span><br><span class="line">        System.out.println(&quot;数据采集信息为：&quot;+&quot;\n,源头数据源=&quot; + sourceDB +</span><br><span class="line">                &quot;\n,目标数据源=&quot;+ targetDB + &quot;\n,源头数据表=&quot; + sourceTable +</span><br><span class="line">                &quot;\n,目标数据表=&quot; + targetTable + &quot;\n,采集策略=&quot; + type);</span><br><span class="line">        return &quot;数据采集成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们模拟数据采集的逻辑，从源头数据源的数据表中，根据指定的策略，将数据采集到目标数据源的表中。接着再新建一个名为DataInterfaceService的类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class DataInterfaceService &#123;</span><br><span class="line">    @Tool(description = &quot;数据服务工具，用于生成一个数据接口&quot;)</span><br><span class="line">    public String produceMsg(</span><br><span class="line">            @ToolParam(description = &quot;服务名称&quot;)String interfaceName,</span><br><span class="line">            @ToolParam(description = &quot;数据源&quot;)String dataSource,</span><br><span class="line">            @ToolParam(description = &quot;查询语句&quot;)String sql,</span><br><span class="line">            @ToolParam(description = &quot;入参&quot;)String inParams,</span><br><span class="line">            @ToolParam(description = &quot;出参&quot;)String outParams</span><br><span class="line">    )&#123;</span><br><span class="line">        //生成逻辑</span><br><span class="line">        System.out.println(&quot;数据生成信息为：&quot;+&quot;\n,服务名称=&quot; + interfaceName +</span><br><span class="line">                &quot;\n,数据源=&quot;+ dataSource + &quot;\n,查询语句=&quot; + sql +</span><br><span class="line">                &quot;\n,入参=&quot; + inParams + &quot;\n,出参=&quot; + outParams);</span><br><span class="line">        return &quot;数据生成成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样这里我们模拟数据生成的逻辑，定义一个服务名称，根据传入的参数和查询语句，从源数据源中查询得到出参数据。</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>这里我们将服务端和资源端写在一个项目中，在applicaiton.yml配置文件中新增如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8009</span><br><span class="line"># 服务端定义</span><br><span class="line">spring:</span><br><span class="line">  ai:</span><br><span class="line">    mcp:</span><br><span class="line">      server:</span><br><span class="line">        name: ai-mcp-server</span><br><span class="line">        version: 0.0.1</span><br><span class="line"># 服务方式（同步或者异步）</span><br><span class="line">        type: SYNC</span><br><span class="line"># MCP有两种通讯方式stdio（内部进程通讯）和Server-Sent Events（SSE服务器发送事件）</span><br><span class="line">        stdio: false</span><br><span class="line">        sse-message-endpoint: /mcp/message</span><br><span class="line">        enabled: true</span><br><span class="line"># 变化通知</span><br><span class="line">        resource-change-notification: true</span><br><span class="line">        tool-change-notification: true</span><br><span class="line">        prompt-change-notification: true</span><br></pre></td></tr></table></figure><p>当然，如果使用的是MCP的内部进程通讯方式，需要添加如下两行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.main.banner-mode=off</span><br><span class="line">logging.file.name=D:/logs/server.log</span><br></pre></td></tr></table></figure><p>定义一个名为CustomServer的类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomServer &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ToolCallbackProvider myTools(DataAcquisitionService dataAcquisitionService,</span><br><span class="line">                                        DataInterfaceService dataInterfaceService)&#123;</span><br><span class="line">        return MethodToolCallbackProvider.builder().toolObjects(dataAcquisitionService</span><br><span class="line">        ,dataInterfaceService).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处就是将工具注册进来，方便后续客户端调用。</p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端笔者建议另起一个新的项目来写，第一步，新建一个名为ai-mcp-client的SpringBoot项目，注意SpringBoot版本为3.4.2，JDK版本为17。之后pom.xml文件信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.gutsyzhan&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ai-mcp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;ai-mcp-client&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;ai-mcp-client&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;17&lt;/java.version&gt;</span><br><span class="line">        &lt;spring-ai.version&gt;1.0.0-M6&lt;/spring-ai.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-mcp-client-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-ai.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>第二步，修改application.yml配置文件中的内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: ai-mcp-client</span><br><span class="line">  main:</span><br><span class="line">    web-application-type: none</span><br><span class="line">  ai:</span><br><span class="line">    ollama:</span><br><span class="line">      base-url: http://127.0.0.1:11434</span><br><span class="line">      chat:</span><br><span class="line">        options:</span><br><span class="line">          model: qwen3:1.7b</span><br><span class="line">          temperature: 0.7</span><br><span class="line">    mcp:</span><br><span class="line">      client:</span><br><span class="line">        sse:</span><br><span class="line">          connections:</span><br><span class="line">            server1:</span><br><span class="line">              url: http://127.0.0.1:8009</span><br><span class="line">server:</span><br><span class="line">  port: 8010</span><br><span class="line"># ai.user.input表示用户的需求</span><br><span class="line">ai:</span><br><span class="line">  user:</span><br><span class="line">    input: 第一步，将prod数据源中的t_order表中的数据全量采集到test数据源的t_order表中，第二步再生成一个数据接口，用于获取所有的用户，从prod数据源中查询全量的用户数据，入参为default，出参为用户名和时间</span><br></pre></td></tr></table></figure><p>第三步，新建一个名为client的包，并在里面定义一个名为CustomClient的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomClient &#123;</span><br><span class="line">    @Value(&quot;$&#123;ai.user.input&#125;&quot;)</span><br><span class="line">    private String userInput;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CommandLineRunner solveQuestion(ChatClient.Builder chatBuilder,</span><br><span class="line">                                           ToolCallbackProvider tools,</span><br><span class="line">                                           ConfigurableApplicationContext context)&#123;</span><br><span class="line">        return (args -&gt; &#123;</span><br><span class="line">            ChatClient chatClient = chatBuilder.defaultTools(tools).build();</span><br><span class="line">            System.out.println(&quot;\n&gt;&gt;&gt; 问题为：&quot; + userInput);</span><br><span class="line">            System.out.println(&quot;\n&gt;&gt;&gt; 参考方法为：&quot; + chatClient.prompt(userInput).call().content());</span><br><span class="line">            context.close();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将用户输入的信息直接写在了配置文件中，通过@Value注解进行获取。项目在启动时，会将其传入给服务端，服务端将用户输入和注册的工具列表一起传给大模型。大模型会根据需求来进行工具匹配，匹配到对应工具之后，再看参数是否对应的上，如果对应的上，则执行具体的逻辑，如果匹配不上，则不执行对应逻辑。</p><p>第四步，先启动服务端项目，再启动客户端，可以发现此时客户端输出如下信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748784400499-53f95aa5-f7fe-46de-82a2-65b2293f7cd9.png"></p><p>接着再去看服务端，可以看到客户端也输出如下信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748784375939-34eb7325-6568-4774-9db1-94bd14f50cbd.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过一个实战项目学习了如何使用SpringBoot和MCP实现本地工具调用。请注意，如果开发者存在多个工具进行编排的需求，如何保证工具调用的顺序呢？实际上我们只需在问题描述中，写清楚你每一步需要做什么，然后大模型就会找到对应的工具类，并按照顺序进行调用，所不同的是，这种编排动作是在输入内容中完成的。</p><p>看到这里你可能会有疑问，MCP方式和注入Dify配置工作流这种方式有什么区别？我们知道MCP它是大模型上下文协议，提供了一种大模型调用本地工具，使用本地文件的一种规范，开发者可以使用这种方式将本地逻辑发布为工具，以满足用户对需求不明的诉求，如果大模型找不到满足要求的工具，则会给出一个合适的回复，这样用户也能接受。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们学习了MCP以及其中的三个角色，包含客户端、服务端和资源端，对应的解释如下：&lt;/p&gt;
&lt;p&gt;（1）客户端：可理解为是</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊最近很火的MCP协议</title>
    <link href="http://aigoing.chat/2025/03/01/2025-3-let&#39;s-talk-about-the-recently-popular-MCP-protocol/"/>
    <id>http://aigoing.chat/2025/03/01/2025-3-let&#39;s-talk-about-the-recently-popular-MCP-protocol/</id>
    <published>2025-03-01T11:05:08.000Z</published>
    <updated>2025-06-02T13:50:06.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>笔者最近在用Dify调用工具，但是发现效果非常不好，而且内部都是封装好的，不知道它是如何调用工具的。而现在公司恰好有些需求是要求让大模型直接调用本地文件，目前只能将文件上传上去，但是大模型的数据通常都是截止到某个时间点的，即训练的数据集始终是落后且固定的，无法实时获取数据。</p><p>当然我们可以使用联网搜索，也可以使用知识库，接口等方式将自己的数据上传给大模型，但是感觉使用起来还是差点意思，无法做到架构的统一化。鉴于此，MCP协议诞生了。</p><h1 id="什么是MCP"><a href="#什么是MCP" class="headerlink" title="什么是MCP"></a>什么是MCP</h1><p><a href="https://modelcontextprotocol.io/">MCP</a>全称（Model Context Protocol），即模型上下文协议，是美国一家Ai初创公司Anthropic于2024年11月推出的一种开放协议，旨在标准化大模型（LLM）与外部数据源、工具的交互方式。Anthropic<font style="color:rgb(63, 63, 63);">也是大语言模型Claude的母公司。</font></p><p><font style="color:rgb(63, 63, 63);"></font></p><p><font style="color:rgb(63, 63, 63);">MCP的主要目的在于解决当前AI模型因数据孤岛限制而无法充分发挥潜力的难题，MCP可以使AI应用能够在安全控制下，访问及操作本地和远程数据，为AI应用提供了连接万物的接口。</font></p><p><font style="color:rgb(63, 63, 63);"></font></p><p><font style="color:rgb(63, 63, 63);">即MCP可直接在AI与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过MCP服务器和MCP客户端，开发者只需遵守这套协议，就能实现“万物互联”。有了MCP，可以和数据和文件系统、开发工具、Web和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，大模型+MCP+生态工具的价值将变得不可估量。</font></p><p><font style="color:rgb(63, 63, 63);">举个例子，现在有一个图书管理系统，当你使用MCP进行改造后，不论是ChatGPT还是Claude，都能使用同一套指令实现图书的增删改查，而不用为每个Ai单独开发对应的接口。</font></p><h1 id="MCP与Function-Calling的对比"><a href="#MCP与Function-Calling的对比" class="headerlink" title="MCP与Function Calling的对比"></a><font style="color:rgb(63, 63, 63);">MCP与Function Calling的对比</font></h1><p>我们知道，<font style="color:rgb(63, 63, 63);">Function Calling是AI模型调用函数的机制，而MCP是一个标准协议，它使AI模型与API无缝交互。AI Agent是一个自主运行的智能系统，利用Function Callling和MCP来分析和执行任务，实现特定目标。</font></p><p>下面这张图便是MCP与<font style="color:rgb(63, 63, 63);">Function Calling的对比：</font></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748836799555-0d6fb5f9-1e23-4010-aa6a-58898b182383.png"></p><h1 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h1><p>前<font style="color:rgb(63, 63, 63);">MCP通过标准化的数据访问接口，减少了与数据直接接触，降低了数据泄露风险，使AI应用能够在安全控制下，访问及操作本地和远程数据，为AI应用提供了连接万物的接口。</font></p><p><font style="color:rgb(63, 63, 63);"></font></p><p>实际上，MCP服务器内置了安全机制，确保只有经过验证的请求才能访问特定资源，相当于又加了一把安全锁。且MCP还支持多种加密算法，以确保数据在传输过程中的安全性。</p><h1 id="MCP的核心原理"><a href="#MCP的核心原理" class="headerlink" title="MCP的核心原理"></a>MCP的核心原理</h1><p>MCP协议采用了独特的架构设计，将大模型与资源之间的通信划分为三个部分，即客户端、服务端和资源端。</p><p>客户端负责将请求发送给MCP服务器，而服务器则将这些请求转发给对应的资源端。这种分层设计使得MCP协议能够很好的实现权限控制，确保只有经过授权的用户才能访问特定的资源。</p><h2 id="MCP的基本工作流程"><a href="#MCP的基本工作流程" class="headerlink" title="MCP的基本工作流程"></a>MCP的基本工作流程</h2><p>MCP的基本工作流程如下：</p><p>（1）<strong>初始化连接请求</strong>：客户端向服务器发送连接请求，建立通信通道；</p><p>（2）<strong>发送请求</strong>：客户端根据需求来构建请求信息，并发送给服务器；</p><p>（3）<strong>处理请求</strong>：服务器在接收到请求之后，解析请求内容，并执行对应的操作，如查询数据库，读取文件等；</p><p>（4）<strong>返回结果</strong>：服务器将处理结果封装为响应消息，发送给客户端；</p><p>（5）<strong>断开连接</strong>：任务完成后，客户端可以主动关闭连接或者等待服务器超时关闭。</p><p>上述流程对应的示意图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748852069115-ad037623-c85e-4f35-8f3b-d69761e677c0.png"></p><h2 id="MCP客户端工作流程"><a href="#MCP客户端工作流程" class="headerlink" title="MCP客户端工作流程"></a>MCP客户端工作流程</h2><p>下面是MCP客户端的工作流程，如下所示：</p><p>（1）MCP客户端首先从MCP服务器获取可用的工具列表；</p><p>（2）将用户的查询连同工具描述，通过Function Calling一起发送给LLM大模型；</p><p>（3）LLM大模型根据需求来决定是否使用工具以及使用哪些工具；</p><p>（4）如果需要使用工具，MCP客户端会通过MCP服务器执行对应的工具调用；</p><p>（5）工具调用的结果会发送给LLM大模型；</p><p>（6）最后将响应展示给用户。</p><h2 id="MCP服务器主要作用"><a href="#MCP服务器主要作用" class="headerlink" title="MCP服务器主要作用"></a>MCP服务器主要作用</h2><p>下面是MCP服务器提供的主要作用，如下所示：</p><p>（1）资源：类似文件的数据，可被客户端读取，如API响应或者文件内容；</p><p>（2）工具：可以被LLM调用的函数，注意这些需要得到用户的准许；</p><p>（3）提示：预先编写的模板，以帮助用户完成特定的任务。</p><p>这些作用使得MCP服务器为Ai应用提供丰富的上下文信息和操作能力，<font style="color:rgb(63, 63, 63);">从而增强LLM的实用性和灵活性。</font></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font style="color:rgb(63, 63, 63);">小结</font></h1><p>本篇我们学习了MCP以及其中的三个角色，包含客户端、服务端和资源端，对应的解释如下：</p><p><font style="color:rgb(63, 63, 63);">（1）客户端：可理解为是Ai应用层，如聊天对话框。用户输入信息后，由客户端接口接收，再由客户端调用服务端调配资源处理；</font></p><p><font style="color:rgb(63, 63, 63);">（2）服务端：可理解为注册中心，请注意所有的工具都是注册在服务端；</font></p><p><font style="color:rgb(63, 63, 63);">（3）资源端：资源端就是大模型解析之后的用户需求的服务，即实际的处理逻辑。资源端可以和服务端部署在一起，也可以单独部署。</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;笔者最近在用Dify调用工具，但是发现效果非常不好，而且内部都是封装好的，不知道它是如何调用工具的。而现在公司恰好有些需求是</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>如何在本地搭建LLM并使用</title>
    <link href="http://aigoing.chat/2025/02/23/2025-2-how-to-set-up-LLM-locally-and-use-it/"/>
    <id>http://aigoing.chat/2025/02/23/2025-2-how-to-set-up-LLM-locally-and-use-it/</id>
    <published>2025-02-23T09:03:01.000Z</published>
    <updated>2025-06-02T13:38:45.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习如何在Windows上安装属于开发者自己的大模型，主要以Ollama为例进行介绍。<font style="color:rgb(31, 28, 28);">Ollama 是一款优秀的开源工具，让开发者可以在本地轻松运行和管理各种大型语言模型（LLMs）。</font></p><h1 id="Ollama介绍"><a href="#Ollama介绍" class="headerlink" title="Ollama介绍"></a><font style="color:rgb(31, 28, 28);">Ollama介绍</font></h1><p><font style="color:rgb(31, 28, 28);">Ollama 是一个简化大型语言模型（LLM）部署和使用的工具。它具有以下特点：</font></p><ul><li><strong><font style="color:rgb(31, 28, 28);">本地运行：</font></strong><font style="color:rgb(31, 28, 28);"> 模型完全在您的本地计算机上运行，无需联网，保护您的隐私和数据安全。</font></li><li><strong><font style="color:rgb(31, 28, 28);">简单易用：</font></strong><font style="color:rgb(31, 28, 28);"> 通过简单的命令行指令，即可下载、运行和管理各种 LLM。</font></li><li><strong><font style="color:rgb(31, 28, 28);">模型丰富：</font></strong><font style="color:rgb(31, 28, 28);"> 支持 Llama 2、Deepseek、Mistral、Gemma 等多种流行的开源模型。</font></li><li><strong><font style="color:rgb(31, 28, 28);">跨平台：</font></strong><font style="color:rgb(31, 28, 28);"> 支持 macOS、Windows 和 Linux 系统。</font></li><li><strong><font style="color:rgb(31, 28, 28);">开放API</font></strong><font style="color:rgb(31, 28, 28);">：支持与OpenAI兼容的接口，可以和其他工具集成。</font></li></ul><h1 id="安装Ollama"><a href="#安装Ollama" class="headerlink" title="安装Ollama"></a>安装Ollama</h1><h2 id="Windows平台安装"><a href="#Windows平台安装" class="headerlink" title="Windows平台安装"></a>Windows平台安装</h2><p>点击 <a href="https://ollama.com/download/windows">Ollama官网</a>，选择合适的版本：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748754290798-f9444014-1e84-4005-8c5d-7a97561bf78a.png"></p><p>之后笔者将其下载到F盘，但是笔者希望将Ollama安装到E盘的指定目录下，此时可以是以如下方式进行安装目录自定义：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748754358509-03341080-ad1f-420e-b985-26629358fa81.png"></p><p>执行该命令，之后就会将Ollama安装到自定义目录下。</p><h2 id="MacOS平台安装"><a href="#MacOS平台安装" class="headerlink" title="MacOS平台安装"></a>MacOS平台安装</h2><p>点击 <a href="https://ollama.com/download/windows">Ollama官网</a>，选择合适的版本：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748754550878-4814adc7-2fbb-4642-923c-c240b14ad66d.png"></p><p>当然也可以到它们对应的github网站上获取：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748754653227-1ce7bc13-d216-4393-a2d6-6cccab154e22.png"></p><h2 id="Linux平台安装"><a href="#Linux平台安装" class="headerlink" title="Linux平台安装"></a>Linux平台安装</h2><p>点击 <a href="https://ollama.com/download/windows">Ollama官网</a>，选择合适的版本：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748754696620-4c655491-2ad5-4dbf-90fa-7eb0f46da0de.png"></p><p>可以看到这里没有提供直接的下载地址，而是使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br></pre></td></tr></table></figure><p>实际上就是下载并执行，不过由于网络波动，笔者还是建议先下载该脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget  https://ollama.com/install.sh</span><br></pre></td></tr></table></figure><p>之后修改Ollama的安装目录，安装成功后查看一下版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Application\ollama&gt;ollama -v</span><br><span class="line">ollama version is 0.9.0</span><br></pre></td></tr></table></figure><h1 id="安装对应模型"><a href="#安装对应模型" class="headerlink" title="安装对应模型"></a>安装对应模型</h1><h2 id="自定义模型安装路径"><a href="#自定义模型安装路径" class="headerlink" title="自定义模型安装路径"></a>自定义模型安装路径</h2><p>首先，停止运行Ollama，接着打开系统环境变量，在里面新增一个名为OLLAMA_MODELS的变量名，值为笔者打算存放模型的路径E:\OllamaModels\models，完整参数如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748759155519-289c1d6d-6020-43f4-8712-e6c330d6d02d.png"></p><p>之后需要重新启动Ollama，这样才能保证自定义路径已经生效。</p><h2 id="安装对应模型-1"><a href="#安装对应模型-1" class="headerlink" title="安装对应模型"></a>安装对应模型</h2><p>点击Ollama官网中的Models模块，可以看到这里面列举了很多常用的模型：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748756777532-ab60fb01-2f9e-4101-96e7-30d2ed0aa90e.png"></p><p>笔者这里选择deepseek-r1模型，同时选择了deepseek-r1:1.5b这一分支：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748756799935-9be8fd81-822a-497a-ba05-ba451c65c3fa.png"></p><p>之后在控制台执行如下命令来运行对应模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ollama run deepseek-r1:1.5b</span><br></pre></td></tr></table></figure><p>安装成功后，出现Send a message则表明已经安装成功：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748757570697-633a9788-ce57-4cc1-87eb-4a696983ad6f.png"></p><p>此时可以进入到之前自定义的模型存储路径：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748762695789-9f93cd40-c719-4155-9072-f12b1f343153.png"></p><p>也可以使用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\Application\Ollama&gt;ollama list</span><br><span class="line">NAME                ID              SIZE      MODIFIED</span><br><span class="line">deepseek-r1:1.5b    e0979632db5a    1.1 GB    29 minutes ago</span><br><span class="line">qwen3:1.7b          8f68893c685c    1.4 GB    47 minutes ago</span><br></pre></td></tr></table></figure><p>可以看到这里展示了笔者已经安装成功的2个模型。</p><h1 id="可视化调用"><a href="#可视化调用" class="headerlink" title="可视化调用"></a>可视化调用</h1><p>尽管模型启动后，可以使用终端进行交互，但是界面不美观，而且不易于管理，因此笔者建议使用可视化工具进行调用，这里选择CheeryStudio。</p><h2 id="为什么选择CheeryStudio"><a href="#为什么选择CheeryStudio" class="headerlink" title="为什么选择CheeryStudio"></a>为什么选择CheeryStudio</h2><p>之所以选择使用CheeryStudio中使用Ollama，是因为它具有如下四个特点：</p><ul><li><strong><font style="color:rgb(31, 28, 28);">无需云服务：</font></strong><font style="color:rgb(31, 28, 28);"> 不再受限于云端 API 的配额和费用，尽情体验本地 LLM 的强大功能。</font></li><li><strong><font style="color:rgb(31, 28, 28);">数据隐私：</font></strong><font style="color:rgb(31, 28, 28);"> 您的所有对话数据都保留在本地，无需担心隐私泄露。</font></li><li><strong><font style="color:rgb(31, 28, 28);">离线可用：</font></strong><font style="color:rgb(31, 28, 28);"> 即使在没有网络连接的情况下，也能继续与 LLM 进行交互。</font></li><li><strong><font style="color:rgb(31, 28, 28);">定制化：</font></strong><font style="color:rgb(31, 28, 28);"> 可以根据您的需求，选择和配置最适合您的 LLM</font></li></ul><h2 id="CheeryStudio的安装"><a href="#CheeryStudio的安装" class="headerlink" title="CheeryStudio的安装"></a>CheeryStudio的安装</h2><p>点击 <a href="https://www.cherry-ai.com/download">cherry官网</a>，选择对应的版本进行下载：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748763120280-d3f33eb7-6e99-477e-b702-5cc0f0b9829d.png"></p><p>请注意，在使用CheeryStudio与Ollama模型交互期间，需要保证Ollama处于运行状态。</p><h2 id="配置Ollama模型"><a href="#配置Ollama模型" class="headerlink" title="配置Ollama模型"></a>配置Ollama模型</h2><p>第一步，运行Ollama模型，然后打开CheeryStudio。</p><p>第二步，打开CheeryStudio中的设置，在设置页面选择模型服务，然后点击列表中的Ollama：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748763502435-557260cc-6d32-4732-ae5b-2182c2ff1133.png"></p><p>第三步，配置Ollama服务商。<font style="color:rgb(31, 28, 28);">在服务商列表中找到刚刚添加的 Ollama，并进行详细配置：</font></p><ol><li><strong><font style="color:rgb(31, 28, 28);">启用状态：</font></strong><ul><li><font style="color:rgb(31, 28, 28);">确保 Ollama 服务商最右侧的开关已打开，表示已启用。</font></li></ul></li><li><strong><font style="color:rgb(31, 28, 28);">API 密钥：</font></strong><ul><li><font style="color:rgb(31, 28, 28);">Ollama 默认</font><strong><font style="color:rgb(31, 28, 28);">不需要</font></strong><font style="color:rgb(31, 28, 28);"> API 密钥。您可以将此字段留空，或者填写任意内容。</font></li></ul></li><li><strong><font style="color:rgb(31, 28, 28);">API 地址：</font></strong></li></ol><p><font style="color:rgb(31, 28, 28);">填写 Ollama 提供的本地 API 地址。通常情况下，地址为：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:11434/</span><br></pre></td></tr></table></figure><p><font style="color:rgb(31, 28, 28);">如果修改了端口，请自行更改。</font></p><ol start="4"><li><strong><font style="color:rgb(31, 28, 28);">模型管理：</font></strong><ul><li><font style="color:rgb(31, 28, 28);">点击“+ 添加”按钮，手动添加您在 Ollama 中已经下载的模型名称。</font></li><li><font style="color:rgb(31, 28, 28);">比如您已经通过</font><code>&lt;font style=&quot;color:rgb(31, 28, 28);&quot;&gt;ollama run llama3.2&lt;/font&gt;</code><font style="color:rgb(31, 28, 28);">下载了</font><code>&lt;font style=&quot;color:rgb(31, 28, 28);&quot;&gt;llama3.2&lt;/font&gt;</code><font style="color:rgb(31, 28, 28);">模型, 那么此处可以填入</font><code>&lt;font style=&quot;color:rgb(31, 28, 28);&quot;&gt;llama3.2&lt;/font&gt;</code></li><li><font style="color:rgb(31, 28, 28);">点击“管理”按钮，可以对已添加的模型进行编辑或删除。</font></li></ul></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748763716251-3e9e3913-d5fe-4e99-9315-fdadd0570c9b.png"></p><p>第四步，使用大模型。上述配置完成后，回到<font style="color:rgb(31, 28, 28);">CherryStudio的聊天界面中，选择Ollama服务商和您已下载的模型，开始与本地 LLM 进行对话：</font></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748763790250-f05096bd-ab50-42d8-9881-91429a579425.png"></p><p>这样我们就实现了在本地部署LLM大模型，同时通过可视化界面与大模型进行交互。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习如何在Windows上安装属于开发者自己的大模型，主要以Ollama为例进行介绍。&lt;font style=&quot;col</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊常用的3种实时技术</title>
    <link href="http://aigoing.chat/2025/01/11/2025-1-let&#39;s-talk-about-three-commonly-used-real-time-technologies/"/>
    <id>http://aigoing.chat/2025/01/11/2025-1-let&#39;s-talk-about-three-commonly-used-real-time-technologies/</id>
    <published>2025-01-11T10:03:01.000Z</published>
    <updated>2025-06-02T13:32:51.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我们知道，早期网站只展示静态内容，但是现在我们更希望实时更新、即时聊天、通知推送和动态仪表盘等功能，因此就有必要学习目前常用的3种实时技术了。</p><p>常用的有SSE、WebSocket和Long Polling这三种，下面将分别进行介绍：</p><p>（1）SSE（Server-Send Events）：轻量级单向数据流；</p><p>（2）WebSocket：全双工双向通信；</p><p>（3）Long Polling（长轮询）：传统过渡方案。</p><p>假设现在我们有如下三个业务场景，它们都需要实现数据实时更新：</p><ul><li>股票交易仪表盘；</li><li>即时聊天平台；</li><li>实时新闻推送。</li></ul><p>面对这些需求，我们该如何选择合适的方案呢？接下来我们将从实战、架构、性能和扩展性角度来进行分析。</p><h1 id="Long-Polling（长轮询）"><a href="#Long-Polling（长轮询）" class="headerlink" title="Long Polling（长轮询）"></a>Long Polling（长轮询）</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>长轮询的原理就是客户端持续地询问服务器，有点类似于吃饭排队时，站在店门口，每隔几分钟询问是否轮到你吃饭了么，可见效率非常低下。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>（1）实现简单，标准的REST；（2）兼容性最好。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>（1）高延迟；（2）浪费大量资源，存在大量的空请求；（3）扩展性差。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>当系统无法使用WebSocket或者SSE，且需要支持对老旧浏览器或者代理时使用，一般在大型企业的遗留系统中使用。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/longpoll&quot;)</span><br><span class="line">public class LongPollingController &#123;</span><br><span class="line">    //使用队列存储待推送的消息</span><br><span class="line">    private static final BlockingQueue&lt;String&gt; messageQueue = </span><br><span class="line">                                                         new LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 长轮询端点</span><br><span class="line">      * @param timeout 超时时间（毫秒）</span><br><span class="line">     * @return 消息内容或者超时时间</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/poll&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; longPoll(</span><br><span class="line">            @RequestParam(defaultValue = &quot;30000&quot;)long timeout</span><br><span class="line">    )&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //等待消息,最多等待指定的超时时间</span><br><span class="line">            String message = messageQueue.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            if(!StringUtils.isEmpty(message))&#123;</span><br><span class="line">                return ResponseEntity.ok(message);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //超时返回空响应</span><br><span class="line">                return ResponseEntity.ok(&quot;timeout&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">                    .body(&quot;服务器内部发生错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送消息</span><br><span class="line">     * @param message 待发送的消息</span><br><span class="line">     * @return 发送结果</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/send&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; sendMessage(@RequestBody String message)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            messageQueue.offer(message);</span><br><span class="line">            return ResponseEntity.ok(&quot;消息发送成功&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">                    .body(&quot;消息发送失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;长轮询(LongPolling)消息推送&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;长轮询(LongPolling)消息推送&lt;/h1&gt;</span><br><span class="line">&lt;div id=&quot;messages&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class LongPollingClient&#123;</span><br><span class="line">        constructor() &#123;</span><br><span class="line">            this.isPolling = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 开始长轮询</span><br><span class="line">         */</span><br><span class="line">        startPolling()&#123;</span><br><span class="line">            if(this.isPolling)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            this.isPolling = true;</span><br><span class="line">            this.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 停止长轮询</span><br><span class="line">         */</span><br><span class="line">        stopPolling()&#123;</span><br><span class="line">            this.isPolling = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 执行轮询请求</span><br><span class="line">         */</span><br><span class="line">        async poll()&#123;</span><br><span class="line">            while (this.isPolling)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    const response = await fetch(&#x27;http://127.0.0.1:8080/api/longpoll/poll?timeout=30000&#x27;);</span><br><span class="line">                    const message = await response.text();</span><br><span class="line">                    if(message &amp;&amp; message !== &#x27;timeout&#x27;)&#123;</span><br><span class="line">                        console.log(&quot;收到消息：&quot;,message);</span><br><span class="line">                        this.handleMessage(message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;catch (error)&#123;</span><br><span class="line">                    console.error(&quot;轮询错误：&quot;,error);</span><br><span class="line">                    //发生错误时，等待一段时间后重试</span><br><span class="line">                    await this.sleep(5000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 处理接收到的消息</span><br><span class="line">         */</span><br><span class="line">        handleMessage(message)&#123;</span><br><span class="line">            //将消息显示在页面上</span><br><span class="line">            document.getElementById(&#x27;messages&#x27;).innerHTML += &#x27;&lt;div&gt;&#x27; + message +&#x27;&lt;/div&gt;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 延迟函数</span><br><span class="line">         */</span><br><span class="line">        sleep(ms)&#123;</span><br><span class="line">            return new Promise(resolve =&gt; setTimeout(resolve,ms));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //客户端调用</span><br><span class="line">    const client = new LongPollingClient();</span><br><span class="line">    client.startPolling();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>先运行后端项目，再打开前端页面，之后打开Postman，我们发起一个请求：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748863973489-ad638e4a-49f8-42b6-b113-89f193259a3a.png"></p><p>可以看到已经显示消息发送成功，接着我们查看一下前端页面，可以看到页面已经出现了对应信息：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748864051203-2272b3fa-7140-4fd2-b383-dae4ad9fca0d.png"></p><h1 id="SSE（Server-Send-Events）"><a href="#SSE（Server-Send-Events）" class="headerlink" title="SSE（Server-Send Events）"></a>SSE（Server-Send Events）</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>SSE的原理如下，即当客户端建立连接后，“持续监听中…..”，之后服务器随时推送消息，不断的消息发送给前端，双方一直保持连接。<strong>请注意，SSE仅支持服务器到客户端的单向通信，比较适合实时数据流。</strong></p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>（1）轻量（基于HTTP /1.1）；（2）兼容大多数代理；（3）自动重连机制。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>（1）单向通信；（2）部分环境支持有限；（3）控制粒度较粗。</p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>当需要简单高效的服务器到客户端更新，如<font style="color:rgb(63, 63, 63);">股票行情、实时比分、状态仪表盘、监控系统等。</font></p><h2 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h2><h3 id="后端代码-1"><a href="#后端代码-1" class="headerlink" title="后端代码"></a>后端代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/sse&quot;)</span><br><span class="line">public class SSEController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建SSE连接端点</span><br><span class="line">     * @return SseEmitter对象，用于发送服务器推送事件</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/connect&quot;)</span><br><span class="line">    public SseEmitter connect()&#123;</span><br><span class="line">        // 创建SseEmitter对象，设置超时时间为30分钟</span><br><span class="line">        SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);</span><br><span class="line">        try&#123;</span><br><span class="line">            //发送连接成功消息</span><br><span class="line">            emitter.send(SseEmitter.event()</span><br><span class="line">                    .name(&quot;connect&quot;)</span><br><span class="line">                    .data(&quot;SSE连接建立成功&quot;));</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            emitter.completeWithError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        //模拟定时推送消息</span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);</span><br><span class="line">        executor.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                //每5秒推送一下当前时间</span><br><span class="line">                emitter.send(SseEmitter.event()</span><br><span class="line">                        .name(&quot;message&quot;)</span><br><span class="line">                        .data(&quot;当前数字为：&quot; + LocalDateTime.now()));</span><br><span class="line">            &#125;catch (IOException e)&#123;</span><br><span class="line">                emitter.complete();</span><br><span class="line">                executor.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,0,5, TimeUnit.SECONDS);</span><br><span class="line">        return emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端代码-1"><a href="#前端代码-1" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;SSE消息推送&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;SSE消息推送&lt;/h1&gt;</span><br><span class="line">&lt;div id=&quot;messages&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建EventSource对象连接SSE端点</span><br><span class="line">    const eventSource = new EventSource(&quot;http://127.0.0.1:8080/api/sse/connect&quot;);</span><br><span class="line">    //监听连接事件</span><br><span class="line">    eventSource.addEventListener(&#x27;connect&#x27;,function (event)&#123;</span><br><span class="line">        console.log(&#x27;连接状态：&#x27;,event.data);</span><br><span class="line">    &#125;);</span><br><span class="line">    //监听消息事件</span><br><span class="line">    eventSource.addEventListener(&#x27;message&#x27;,function (event)&#123;</span><br><span class="line">        console.log(&#x27;收到消息：&#x27;,event.data);</span><br><span class="line">        //将消息显示在页面上</span><br><span class="line">        document.getElementById(&#x27;messages&#x27;).innerHTML += &#x27;&lt;div&gt;&#x27; + event.data +&#x27;&lt;/div&gt;&#x27;;</span><br><span class="line">    &#125;);</span><br><span class="line">    //监听错误事件</span><br><span class="line">    eventSource.onerror = function (event) &#123;</span><br><span class="line">        console.error(&#x27;SSE连接错误：&#x27;,event);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p>先运行后端项目，再打开前端页面，可以看到页面每隔5秒钟显示当前时间：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748864484753-11519e37-c823-4e2f-9429-697244398310.png"></p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>WebSocket的原理就是建立双向通道，实现实时对话，类似于对讲机的全双工通信模式。</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>（1）双向通信；（2）低延迟；（3）可通过消息中间件扩展。</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>（1）代理兼容性差；（2）扩展复杂度高；（3）需要维持长连接。</p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于聊天室、游戏、协作应用等需要实现双向交互的场景。</p><h2 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h2><h3 id="后端代码-2"><a href="#后端代码-2" class="headerlink" title="后端代码"></a>后端代码</h3><p>其中的MyWebSocketHandler类代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyWebSocketHandler extends TextWebSocketHandler &#123;</span><br><span class="line">    //存储所有活跃的WebSocket会话</span><br><span class="line">    private static final Set&lt;WebSocketSession&gt; sessions = Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 建立连接后调用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(&quot;WebSocket连接建立：&quot; + session.getId());</span><br><span class="line">        //向新连接的客户端发送欢迎消息</span><br><span class="line">        session.sendMessage(new TextMessage(&quot;欢迎使用WebSocket！&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 收到客户端发来的消息时调用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">        String payload = message.getPayload();</span><br><span class="line">        System.out.println(&quot;收到消息，消息内容为：&quot; + payload);</span><br><span class="line"></span><br><span class="line">        //广播消息给所有连接的客户端</span><br><span class="line">        broadcastMessage(&quot;服务器回复的消息为：&quot; + payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 连接关闭后调用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(&quot;WebSocket连接关闭：&quot; + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 广播消息给所有连接的客户端</span><br><span class="line">     */</span><br><span class="line">    private static void broadcastMessage(String message)&#123;</span><br><span class="line">        synchronized (sessions)&#123;</span><br><span class="line">            sessions.removeIf(session -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(session.isOpen())&#123;</span><br><span class="line">                        session.sendMessage(new TextMessage(message));</span><br><span class="line">                        //保留该会话</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    System.err.println(&quot;消息发送失败：&quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                //移除无效会话</span><br><span class="line">                return true;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个MyWebSocketHandler类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        //注册websocket处理器，并允许跨域访问</span><br><span class="line">        registry.addHandler(new MyWebSocketHandler(),&quot;/websocket&quot;)</span><br><span class="line">                .setAllowedOrigins(&quot;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端代码-2"><a href="#前端代码-2" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;WebSocket消息推送&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;WebSocket消息推送&lt;/h1&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeholder=&quot;请输入需要发送的消息...&quot;&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot; onclick=&quot;messageSend()&quot; &gt;提交&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;messages&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建WebSocket连接</span><br><span class="line">    const socket = new WebSocket(&quot;ws://127.0.0.1:8080/websocket&quot;);</span><br><span class="line">    //连接打开时的处理逻辑</span><br><span class="line">    socket.onopen = function (event) &#123;</span><br><span class="line">        console.log(&quot;WebSocket连接已经建立&quot;);</span><br><span class="line">        //发送消息给服务端</span><br><span class="line">        socket.send(&quot;测试一下WebSocket！&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line">    //客户端接收到消息时的处理逻辑</span><br><span class="line">    socket.onmessage = function (event) &#123;</span><br><span class="line">        console.log(&quot;收到消息：&quot; + event.data);</span><br><span class="line">        //将消息显示在页面上</span><br><span class="line">        document.getElementById(&#x27;messages&#x27;).innerHTML += &#x27;&lt;div&gt;&#x27; + event.data +&#x27;&lt;/div&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //连接关闭时调用</span><br><span class="line">    socket.onclose = function (event) &#123;</span><br><span class="line">        console.log(&quot;WebSocket连接已关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //错误处理逻辑</span><br><span class="line">    socket.onerror = function (error) &#123;</span><br><span class="line">        console.error(&quot;WebSocket错误：&quot; + error);</span><br><span class="line">    &#125;</span><br><span class="line">    //界面发送消息的逻辑</span><br><span class="line">    function messageSend() &#123;</span><br><span class="line">        const input = document.getElementById(&#x27;messageInput&#x27;);</span><br><span class="line">        if(socket.readyState === WebSocket.OPEN)&#123;</span><br><span class="line">            socket.send(input.value);</span><br><span class="line">            input.value = &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><p>先运行后端项目，再打开前端页面，可以看到初始界面如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748864928738-970ba5b3-c73d-4888-ae85-49ac430b3e88.png"></p><p>之后我们尝试在输入框内输入“测试一下WebSocket”：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748864961420-e3a961c7-2b03-4a1e-b6df-a9ce1ae7bb13.png"></p><p>然后点击提交按钮，可以看到界面信息如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748864979893-3b9b38f0-e027-4bd8-ab05-8a9732333c96.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过前面的分析，我们就可以对上述三个场景需要的方案进行选项了：</p><ul><li>股票交易仪表盘：SSE</li><li>即时聊天平台：WebSocket</li><li>实时新闻推送(历史遗留系统)：Long Polling</li></ul><p>当然技术选型需要因地制宜，结合实际情况和场景来选择合适的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;我们知道，早期网站只展示静态内容，但是现在我们更希望实时更新、即时聊天、通知推送和动态仪表盘等功能，因此就有必要学习目前常用</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL同步ES的6种方式</title>
    <link href="http://aigoing.chat/2024/12/21/2024-11-6-ways-to-synchronize-es-with-mysql/"/>
    <id>http://aigoing.chat/2024/12/21/2024-11-6-ways-to-synchronize-es-with-mysql/</id>
    <published>2024-12-21T10:23:04.000Z</published>
    <updated>2025-06-02T13:19:54.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我们知道，在分布式系统日益发展的今天，<font style="color:rgb(63, 63, 63);">MySQL与Elasticsearch的协同已成为解决高并发查询与复杂检索的标配组合。但是，如何实现两者间数据的高效同步，已成为架构设计中不可忽视的问题。笔者结合实际工作经验和一些参考文章，给出常用的6种可行的同步方式，以供在后续架构设计中作参考。</font></p><h1 id="小批量数据同步方式"><a href="#小批量数据同步方式" class="headerlink" title="小批量数据同步方式"></a><font style="color:rgb(63, 63, 63);">小批量数据同步方式</font></h1><h2 id="同步双写"><a href="#同步双写" class="headerlink" title="同步双写"></a><font style="color:rgb(63, 63, 63);">同步双写</font></h2><p>【适用场景】对数据实时性要求较高，且业务逻辑较为简单的场景，如支付记录同步等。</p><p>【实现方式】在代码中同时写入MySQL和ES。</p><p>【示例代码】以下是同步双写的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Transactional  </span><br><span class="line">public void createRecord(TRecord trecord) &#123;  </span><br><span class="line">    // 写入MySQL  </span><br><span class="line">    trecordMapper.insert(trecord);  </span><br><span class="line">    // 同步写入ES  </span><br><span class="line">    IndexRequest request = new IndexRequest(&quot;records&quot;)  </span><br><span class="line">        .id(trecord.getId())  </span><br><span class="line">        .source(JSON.toJSONString(trecord), XContentType.JSON);  </span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【缺点】</p><p>（1）代码侵入：需要在所有涉及写入操作的地方都添加ES写入逻辑；</p><p>（2）性能降低：双写会导致事务时间变长，降低TPS；</p><p>（3）数据一致性难以得到保证：<font style="color:rgb(63, 63, 63);">如果ES写入失败，而MySQL写入成功，需要引入补偿机制。</font></p><h2 id="异步双写"><a href="#异步双写" class="headerlink" title="异步双写"></a><font style="color:rgb(63, 63, 63);">异步双写</font></h2><p>【适用场景】对数据实时性要求不高，且业务逻辑较为简单的场景，如订单创建成功后状态修改，以供用户查询等。</p><p>【实现方式】使用MQ来进行解耦和实现异步双写。</p><p>【示意流程】以下是异步双写的流程：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748308847462-1f11a8d8-7262-4039-96a6-918164ee5a0c.png"></p><p>【示例代码】以下是异步双写的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//生产者(业务服务)</span><br><span class="line">public void updateOrder(Order order) &#123;  </span><br><span class="line">    orderMapper.update(order);  </span><br><span class="line">    kafkaTemplate.send(&quot;order-update&quot;, order.getId());  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//消费者(消费服务)</span><br><span class="line">@KafkaListener(topics = &quot;order-update&quot;)  </span><br><span class="line">public void syncToES(String orderId) &#123;  </span><br><span class="line">    Order order = orderMapper.selectById(orderId);  </span><br><span class="line">    esClient.index(order);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】</p><p>（1）大幅提升吞吐量：通过MQ实现削峰填谷；</p><p>（2）故障隔离：ES宕机不影响业务正常进行</p><p>【缺点】</p><p>（1）存在消息堆积：突发流量可能会导致消费延迟；</p><p>（2）消费顺序难以保证：必须通过分区来保证同一分区数据消费的顺序性。</p><h2 id="Canal监听Binlog日志"><a href="#Canal监听Binlog日志" class="headerlink" title="Canal监听Binlog日志"></a>Canal监听Binlog日志</h2><p>【适用场景】对数据实时性要求较高，且业务逻辑较为复杂的场景，如商品上架后实时搜索等。</p><p>【实现方式】使用MQ + Canal + ES来实现。</p><p>【示意流程】以下是Canal监听Binlog日志的流程：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748311466891-3581176a-f774-4034-a6cc-d5a6c597e8f0.png"></p><p>在Canal中有一些关键配置，这个用于配置MySQL地址以及mq的主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># canal.properties  </span><br><span class="line">canal.instance.master.address=127.0.0.1:3306  </span><br><span class="line">canal.mq.topic=canal.es.sync</span><br></pre></td></tr></table></figure><p>【注意事项】</p><p>（1）需要实现幂等消费：可通过id等唯一键来实现；</p><p>（2）可能存在数据漂移：需要<font style="color:rgb(63, 63, 63);">处理DDL变更（开发者可通过Schema Registry来管理映射）。</font></p><h2 id="Logstash定时拉取"><a href="#Logstash定时拉取" class="headerlink" title="Logstash定时拉取"></a><font style="color:rgb(63, 63, 63);">Logstash定时拉取</font></h2><p>【适用场景】对数据实时性要求不高，延迟较高，如用户行为T+1分析等。</p><p>【示例配置】以下是Logstash定时拉取的示例配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    jdbc_driver=&gt;&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_url=&gt;&quot;jdbc:mysql://127.0.0.1:3306/user_log_db&quot;</span><br><span class="line">    schedule=&gt;&quot;*/5 * * * *&quot;# 每5分钟执行  </span><br><span class="line">    statement=&gt;&quot;SELECT * FROM user_log WHERE create_time &gt; :sql_last_value&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts=&gt;[&quot;es-host:9200&quot;]</span><br><span class="line">    index=&gt;&quot;user_logs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优点】</p><p>（1）代码零入侵：代码零入侵，非常适合历史数据的迁移；</p><p>（2）配置灵活：可通过配置文件来指定配置参数。</p><p>【缺点】</p><p>（1）分钟级别延迟：无法实现实时搜索；</p><p>（2）全表扫码压力大：数据同步是全量的，需要优化<font style="color:rgb(63, 63, 63);">增量字段索引</font>。</p><h1 id="大数据量同步方式"><a href="#大数据量同步方式" class="headerlink" title="大数据量同步方式"></a>大数据量同步方式</h1><h2 id="DataX批量同步"><a href="#DataX批量同步" class="headerlink" title="DataX批量同步"></a>DataX批量同步</h2><p>【适用场景】将历史数据从MySQL迁移至ES中，大数据同步优先考虑此种方式。</p><p>【示例配置】以下是DataX批量同步数据的示例配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">&quot;job&quot;:&#123;</span><br><span class="line">    &quot;content&quot;:[&#123;</span><br><span class="line">      &quot;reader&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;mysqlreader&quot;,</span><br><span class="line">        &quot;parameter&quot;:&#123;&quot;splitPk&quot;:&quot;id&quot;,&quot;querySql&quot;:&quot;SELECT * FROM orders&quot;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;writer&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&quot;elasticsearchwriter&quot;,</span><br><span class="line">        &quot;parameter&quot;:&#123;&quot;endpoint&quot;:&quot;http://es-host:9200&quot;,&quot;index&quot;:&quot;orders&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【调优配置】</p><p>（1）<font style="color:rgb(63, 63, 63);">调整Channel数：为提升并发，需要调整Channel数，建议与分片数对齐；</font></p><p><font style="color:rgb(63, 63, 63);">（2）使用limit：为避免发生OOM，需要使用limit关键字进行分页处理。</font></p><h2 id="Flink流处理"><a href="#Flink流处理" class="headerlink" title="Flink流处理"></a><font style="color:rgb(63, 63, 63);">Flink流处理</font></h2><p>【适用场景】对于<font style="color:rgb(63, 63, 63);">复杂的ETL场景，或者</font>商品价格或者数量发生变化时，需要<font style="color:rgb(63, 63, 63);">关联用户画像，计算实时推荐评分时，推荐使用该方式</font>。</p><p>【示例配置】以下是Flink流处理的示例配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">env.addSource(new CanalSource())  </span><br><span class="line">   .map(record -&gt; parseToPriceEvent(record))  </span><br><span class="line">   .keyBy(event -&gt; event.getProductId())  </span><br><span class="line">   .connect(userProfileBroadcastStream)  </span><br><span class="line">   .process(new PriceRecommendationProcess())  </span><br><span class="line">   .addSink(new ElasticsearchSink());</span><br></pre></td></tr></table></figure><p>【调优配置】</p><p>（1）<font style="color:rgb(63, 63, 63);">状态管理：通过WaterMark机制，精准处理乱序事件；</font></p><p><font style="color:rgb(63, 63, 63);">（2）维表关联：通过Broadcast State实现实时画像关联。</font></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><font style="color:rgb(63, 63, 63);">小结</font></h1><p>下面通过一张表来展示上述6种方式的区别，后续在架构设计和开发过程中可以根据各种方式的特点来选择合适的方式：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748313159832-ed4e3299-6e3e-4f37-9b7c-ce73f4a08897.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;我们知道，在分布式系统日益发展的今天，&lt;font style=&quot;color:rgb(63, 63, 63);&quot;&gt;MySQL与</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SQL调优常用的10种方式</title>
    <link href="http://aigoing.chat/2024/11/09/2024-12-10-common-ways-to-optimize-sql/"/>
    <id>http://aigoing.chat/2024/11/09/2024-12-10-common-ways-to-optimize-sql/</id>
    <published>2024-11-09T07:23:04.000Z</published>
    <updated>2025-06-02T13:19:38.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇是笔者在实际工作中总结的10种常用的SQL调优方式，这里进行总结和分享。</p><h1 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h1><h2 id="避免使用select"><a href="#避免使用select" class="headerlink" title="避免使用select *"></a>避免使用select *</h2><p><font style="color:rgb(74, 74, 74);">很多时候为了方便写sql语句，都喜欢直接使用</font><font style="color:#000000;">select *</font><font style="color:rgb(74, 74, 74);">，一次性查出表中所有列的数据，如下所示：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id=1;</span><br></pre></td></tr></table></figure><p><font style="color:rgb(74, 74, 74);">而在实际业务场景中，可能只需要两三列，多查了很多数据，又不用，白白浪费了数据库资源。此外多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。</font></p><p><font style="color:rgb(74, 74, 74);"></font></p><p><font style="color:rgb(74, 74, 74);">最重要的是select *不会走覆盖索引，会出现大量的回表操作，而从导致查询sql的性能很低。此时我们应当根据实际情况，只查询要使用的列，多余的列不需要查询：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age from user where id=1;</span><br></pre></td></tr></table></figure><h2 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a><font style="color:rgb(74, 74, 74);">小表驱动大表</font></h2><p>所谓的<font style="color:rgb(74, 74, 74);">小表驱动大表，即使用小表的数据集来驱动大表的数据集。</font></p><p><font style="color:rgb(74, 74, 74);"></font></p><p><font style="color:rgb(74, 74, 74);">举个例子，现在工单表有1000万数据，而用户表只有10万条，要查询所有有效用户最近一次处理的工单明显。可以使用in关键字，对应语句如下：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from t_order</span><br><span class="line">where user_id in (</span><br><span class="line">    select id </span><br><span class="line">    from t_user </span><br><span class="line">    where status=1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>或者使用exists关键字，<font style="color:rgb(74, 74, 74);">对应语句如下：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from t_order</span><br><span class="line">where exists (</span><br><span class="line">    select 1 </span><br><span class="line">    from t_user </span><br><span class="line">    where t_order.user_id = t_user.id </span><br><span class="line">    and t_user.status=1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><font style="color:#000000;">不过笔者更建议使用in关键字去实现，因为如果SQL语句中包含了in关键字，则它会优先执行in里面的子查询语句，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询的话，速度会更快。</font></p><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">当然，如果SQL语句中包含了exists关键字，那么它优先执行exists左边的语句（即主查询语句），然后把它作为条件，去跟右边的语句匹配。如果匹配得上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。</font></p><p><font style="color:rgb(74, 74, 74);"></font></p><p><font style="color:#000000;">在上面的例子中，工单表有1000万数据，而用户表只有10万条，因此工单表是大表，而用户表则是小表。如果工单表在左边，那使用in关键字性能更好。总结一下原则：</font></p><p><font style="color:#000000;">（1）in适用于左边大表，右边小表;</font></p><p><font style="color:#000000;">（2）exists</font><font style="color:#000000;"> 适用于左边小表，右边大表。</font></p><p><font style="color:#000000;">不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。</font></p><h2 id="多用limit"><a href="#多用limit" class="headerlink" title="多用limit"></a><font style="color:#000000;">多用limit</font></h2><p>有时候我们只是想查询第一条数据，如id为1的用户他处理的第一个工单的时间，有些人可能会这样书写SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select order_id, deal_time </span><br><span class="line">from t_order </span><br><span class="line">where user_id=1</span><br><span class="line">order by deal_time asc;</span><br></pre></td></tr></table></figure><p>先<font style="color:rgb(74, 74, 74);">根据用户id查询工单，之后按照处理时间顺序排序，接着在得到的工单集合中，获取第一个元素的数据，即首单的数据，就能获取首个工单的处理时间：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TOrder&gt; list = orderMapper.getOrderList();</span><br><span class="line">TOrder order = list.get(0);</span><br></pre></td></tr></table></figure><p>这种做法在功能实现上没有任何问题，但是<font style="color:rgb(74, 74, 74);">它的效率不高，需要先查询出所有数据，太浪费资源了。实际上我们只需使用limit 1语句，直接返回一条数据即可：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select order_id, deal_time </span><br><span class="line">from t_order </span><br><span class="line">where user_id=1</span><br><span class="line">order by deal_time asc</span><br><span class="line">limit 1;</span><br></pre></td></tr></table></figure><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>当我们有一批数据现在经过处理后，需要插入到数据库，此时该怎样操作呢？有些人会遍历列表，然后单独插入每一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(Order order: list)&#123;</span><br><span class="line">   orderMapper.insert(order):</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;insert&gt;</span><br><span class="line">  insert into order(id,code,user_id) </span><br><span class="line">  values(10001,&#x27;12312&#x27;,1);</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>毫无疑问，这种<font style="color:rgb(74, 74, 74);">操作需要多次请求数据库，才能完成这批数据的插入操作。实际上我们在代码中，每次远程请求数据库，都会消耗一定的性能。因此非常不建议使用这种方式，应该采用批量插入方式：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">orderMapper.insertBatch(orderListinsert into order(id,code,user_id) ):</span><br><span class="line"></span><br><span class="line">values(10001,&#x27;12312&#x27;,1),(10002,&#x27;12313&#x27;,2),(10003,&#x27;12314&#x27;,3);</span><br></pre></td></tr></table></figure><p><font style="color:rgb(74, 74, 74);">这样只需远程请求一次数据库，即可批量插入数据。但是一次批量操作的数据不能太多，如果数据太多也会导致数据库响应缓慢，建议数据量控制在500条左右，多于500条，建议采用多线程分批次处理。</font></p><h2 id="增量查询"><a href="#增量查询" class="headerlink" title="增量查询"></a><font style="color:rgb(74, 74, 74);">增量查询</font></h2><p><font style="color:rgb(74, 74, 74);">有时候，我们需要通过远程接口来查询数据，然后将其同步到另一个数据库，此时最简单的SQL就是全量查询：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from t_user;</span><br></pre></td></tr></table></figure><p>这种做法虽然简单粗暴，但是如果数据过多，那么势必会影响性能。此时，可以考虑使用id和时间升序来进行控制，<font style="color:rgb(74, 74, 74);">每次只同步一批数据，如500条，之后记下同步数据的最大id和时间：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from t_user </span><br><span class="line">where id &gt; #&#123;lastId&#125; </span><br><span class="line">      and create_time &gt;= #&#123;lastCreateTime&#125; </span><br><span class="line">limit 500;</span><br></pre></td></tr></table></figure><p><font style="color:rgb(74, 74, 74);">每次同步完成之后，保存该500条数据中最大的id和时间，给同步下一批数据的时候用。通过这种增量查询的方式，能够极大提升单次查询的效率。</font></p><h2 id="高效分页"><a href="#高效分页" class="headerlink" title="高效分页"></a>高效分页</h2><p>一般来说，在进行列表查询时，为避免一次性返回太多数据，我们都会对查询接口进行分页处理。通常是配合limit关键字来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">id,order_name</span><br><span class="line">from t_order</span><br><span class="line">limit 1,10</span><br></pre></td></tr></table></figure><p><font style="color:rgb(74, 74, 74);">如果表中数据量不大，用limit关键字做分页，这是允许的。但如果表中数据量很大，再使用它就会出现较为严重的性能问题。举个例子，现在分页变成如下：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">id,order_name</span><br><span class="line">from t_order</span><br><span class="line">limit 1000000,10</span><br></pre></td></tr></table></figure><p>此时<font style="color:rgb(74, 74, 74);">数据库会查询1000010条数据，然后丢弃前面的1000000条，只查后面的10条数据，毫无疑问这种方式是很浪费资源的。如果id是自增且连续的，那么我们可以先找到上次分页的最大id，然后利用id来进行过滤：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">id,order_name</span><br><span class="line">from t_order</span><br><span class="line">where id &gt; 1000000</span><br><span class="line">limit 10</span><br></pre></td></tr></table></figure><p>当然了，也可以使用between关键字来优化查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">id,order_name</span><br><span class="line">from t_order</span><br><span class="line">where id between 1000000 and 1000010</span><br></pre></td></tr></table></figure><p>请注意，<font style="color:rgb(74, 74, 74);">between关键字需要在唯一索引上进行分页，不然会出现每页大小不一致的问题。</font></p><h2 id="连接查询替代子查询"><a href="#连接查询替代子查询" class="headerlink" title="连接查询替代子查询"></a>连接查询替代子查询</h2><p><font style="color:#000000;">当我们需要从多张表中查询数据时，会有两种查询方式：子查询和连接查询。以前面的例子为例，进行说明。下面是一个子查询的例子，子查询通过in关键字实现，一个查询语句的条件落在另一个查询语句的查询结果中。程序会先运行嵌套在最内层的语句，然后运行外层的语句。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from t_order</span><br><span class="line">where user_id in (</span><br><span class="line">    select id </span><br><span class="line">    from t_user </span><br><span class="line">    where status=1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果涉及的表数量不多，那可以使用。我们知道MySQL在使用子查询时，先创建临时表，等<font style="color:rgb(74, 74, 74);">查询完成后，再删除这些临时表，所以存在一定的性能消耗。此时推荐使用连接查询：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select o.* </span><br><span class="line">from t_order o</span><br><span class="line">inner join t_user u on o.user_id = u.id</span><br><span class="line">where u.status=1</span><br></pre></td></tr></table></figure><h2 id="选择合适的字段类型"><a href="#选择合适的字段类型" class="headerlink" title="选择合适的字段类型"></a>选择合适的字段类型</h2><p><font style="color:#000000;">char</font><font style="color:rgb(74, 74, 74);">表示固定字符串类型，该类型字段存储空间是固定的，因</font><font style="color:#000000;">此会浪费存储空间，而</font><font style="color:#000000;">varchar</font><font style="color:#000000;">表示变长</font><font style="color:rgb(74, 74, 74);">字符串类型，该类型的字段存储空间会根据实际数据的长度进行调整，不会浪费存储空间。</font></p><p><font style="color:rgb(74, 74, 74);"></font></p><p><font style="color:rgb(74, 74, 74);">对于长度固定的字段，如用户手机号，一般都是11位，因此可定义成char类型，长度是11字节。对于不固定的字段，如公司名，定义成char类型就不行了。</font></p><p><font style="color:rgb(74, 74, 74);">在定义字段类型时，可以考虑遵循如下原则：</font></p><p><font style="color:rgb(1, 1, 1);">（1）优先使用数字类型，能不用字符串就不用，因为字符的处理往往比数字要慢；</font></p><p><font style="color:rgb(1, 1, 1);">（2）尽量使用小的类型，如使用bit存储布尔值，tinyint存储枚举值；</font></p><p><font style="color:rgb(1, 1, 1);">（3）长度固定的字符串字段，使用char类型；</font></p><p><font style="color:rgb(1, 1, 1);">（4）长度可变的字符串字段，使用varchar类型；</font></p><p><font style="color:rgb(1, 1, 1);">（5）金额字段用decimal，这样可以避免精度丢失问题。</font></p><h2 id="提升group-by效率"><a href="#提升group-by效率" class="headerlink" title="提升group by效率"></a>提升group by效率</h2><p>group by字段使用非常频繁，通常用在去重和分组的时候，一般会配合having字段使用，用于实现<font style="color:rgb(74, 74, 74);">分组后再根据条件过滤数据。</font></p><p>举个例子，我们需要统计用户id不大于100的用户，他们各自完成的工单数量，可以使用如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  user_id,</span><br><span class="line">  count(1) </span><br><span class="line">from t_order</span><br><span class="line">group by user_id</span><br><span class="line">having user_id &lt;= 100;</span><br></pre></td></tr></table></figure><p>不推荐使用这种方式，它是先将所有的用户id和工单数进行了统计，之后再过滤用户id大于100的用户。分组其实是一个非常耗时的操作，我们完全可以先过滤之后再分组的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  user_id,</span><br><span class="line">  count(1) </span><br><span class="line">from t_order</span><br><span class="line">where user_id &lt;= 100</span><br><span class="line">group by user_id;</span><br></pre></td></tr></table></figure><p>这样就极大的减少了需要分组的数据，当然这里只是介绍一种思路，还有其他的方式。</p><h2 id="join表不要太多"><a href="#join表不要太多" class="headerlink" title="join表不要太多"></a>join表不要太多</h2><p><font style="color:rgb(74, 74, 74);">笔者建议，join表的数量不要超过3个，一旦超过会出现严重的性能问题：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  a.name,</span><br><span class="line">  b.name,</span><br><span class="line">  c.name,</span><br><span class="line">  d.name,</span><br><span class="line">  e.name,</span><br><span class="line">  f.name</span><br><span class="line">from a </span><br><span class="line">left join b on a.id = b.a_id</span><br><span class="line">left join c on c.b_id = b.id</span><br><span class="line">left join d on d.c_id = c.id</span><br><span class="line">left join e on e.d_id = d.id</span><br><span class="line">left join f on f.e_id = e.id</span><br></pre></td></tr></table></figure><p>join太多的话，MySQL在选择索引时，很容易选错索引，而且如果没有命中，那么会分别从两个表中读取一行数据两两进行对比，这样复杂度就是N^2了。</p><p>一般三个表合适，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">  a.name,</span><br><span class="line">  b.name,</span><br><span class="line">  c.name,</span><br><span class="line">  a_d_name,</span><br><span class="line">  b_e_name,</span><br><span class="line">  c_f_name</span><br><span class="line">from a </span><br><span class="line">left join b on a.id = b.a_id</span><br><span class="line">left join c on c.b_id = b.id</span><br></pre></td></tr></table></figure><p><font style="color:#000000;">当然</font>在实际开发过程中，某些数据就得通过查询另外几张表中才能获取到，此时可以在a、b、c表中通过添加冗余的字段来实现，如在表a中添加a_d_name，表b中添加b_e_name，表c中添加c_f_name字段，来保存需要查询的数据。所以说，适当的冗余实际上会加快系统的访问速度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上10种SQL优化方式是笔者的工作总结，在实际开发过程中得到了很好的验证，提升了开发效率和查询速度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇是笔者在实际工作中总结的10种常用的SQL调优方式，这里进行总结和分享。&lt;/p&gt;
&lt;h1 id=&quot;常用方式&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>多租户架构设计与实践</title>
    <link href="http://aigoing.chat/2024/04/27/2024-6-mult-tenant-architecture-design-and-practice/"/>
    <id>http://aigoing.chat/2024/04/27/2024-6-mult-tenant-architecture-design-and-practice/</id>
    <published>2024-04-27T11:55:30.000Z</published>
    <updated>2024-05-23T12:40:14.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇是笔者一年来对智能照明SaaS平台多租户改造升级的一些实践与体会，这些内容在技术分享会上已做了介绍，下面是一些重要的概念和思想。</p><h1 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h1><h2 id="多租户简介"><a href="#多租户简介" class="headerlink" title="多租户简介"></a>多租户简介</h2><p>多租户技术，它是一种软件架构技术，用于实现多用户环境下，共用相同的系统或者程序，并确保各个用户间数据的安全隔离。即一个单独的实例，可以为多个组织提供服务。</p><h2 id="SaaS多租户"><a href="#SaaS多租户" class="headerlink" title="SaaS多租户"></a>SaaS多租户</h2><p>（1）SaaS是Software-as-a-Service的缩写，意为软件即服务，即通过网络提供软件服务。<br>（2）SaaS平台供应商将应用部署到自己的服务器上，客户可根据实际需要，通过互联网向厂商订购所需的应用软件服务，按照订购的服务多少及时间长短向厂商支付费用，并通过互联网获得SaaS平台供应商提供的服务。<br>（3）SaaS服务基于一套标准的软件系统为成百上千个不同的客户（又称为租户）提供服务。这要求SaaS服务能够支持不同租户间的数据和配置隔离，同时支持对界面、业务逻辑、数据结构等方面的个性化需求开发。<br>（4）由于SaaS同时支持多个租户，而每个租户又有很多用户，因此对支撑软件的基础设施平台的性能、稳定性和扩展性有很高的要求。<br>（5）多租户是SaaS领域特有的产物。对于SaaS服务供应商来说，构建SaaS提醒需要完成两部分工作，即上层服务和底层多租户系统。</p><h2 id="SaaS多租户优点"><a href="#SaaS多租户优点" class="headerlink" title="SaaS多租户优点"></a>SaaS多租户优点</h2><p>（1）开发和运维成本低。<br>（2）按需付费，节约成本。<br>（3）故障排查更及时。</p><h2 id="多租户模型"><a href="#多租户模型" class="headerlink" title="多租户模型"></a>多租户模型</h2><p>下面是多租户模型的示意图：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716343320591-ed0a0107-0c09-4b6e-b894-5ca09f65783e.png#averageHue=%23f7f2ef&clientId=ue64ccb44-95d4-4&from=paste&height=243&id=u3ed7fa52&originHeight=401&originWidth=1111&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=108721&status=done&style=none&taskId=u9cf08bd6-5eb7-437c-98b3-162c547eeea&title=&width=673.333294415717" alt="image.png"><br>可以看到该模型主要涉及到九类：<br>（1）租户。指一个企业或者个人客户，租户间数据与行为完全隔离，上下级的租户之间通过授权实现数据共享。注意，每个租户只能操作归属于自己租户的数据。<br>（2）组织。如果租户是一个企业客户，那么通常就会有自己的组织架构。<br>（3）用户。指某个租户下具体的使用者，即具有用户名、密码、邮箱等账号的自然人。<br>（4）角色。用户操作权限的集合。<br>（5）员工。组织内的某位员工。<br>（6）解决方案。为解决客户的某类业务问题，SaaS供应商一般会将产品和服务组合在一起，为客户提供整体的打包方案。<br>（7）产品能力。帮助客户实现场景解决方案闭环的能力。<br>（8）资源域。用于运行1个或者多个产品应用的一套云资源环境。<br>（9）云资源。SaaS产品一般部署在各种云上面，由各种云平台提供计算、存储、网络等资源。</p><h1 id="SaaS多租户数据隔离"><a href="#SaaS多租户数据隔离" class="headerlink" title="SaaS多租户数据隔离"></a>SaaS多租户数据隔离</h1><p>多租户对于用户来说，最重要的一点在于数据隔离。绝对不允许出现A公司用户登录系统看到了B公司的数据，因此多租户的数据库设计方案具有很高的挑战。</p><p>目前主流的SaaS多租户数据库设计方案分为三种，即为每个租户提供独立的数据库、独立的数据表、按照字段区分租户，每种方案都有其适用场景。</p><h2 id="一个租户一个数据库"><a href="#一个租户一个数据库" class="headerlink" title="一个租户一个数据库"></a>一个租户一个数据库</h2><p>一个租户对应一个数据库，意味着SaaS系统需要连接多个数据库，这种方案有点类似于分库分表。好处是数据隔离级别高、安全性好，毕竟一个租户一个数据库，但缺点就是资源利用率不高，维护成本也高。</p><h2 id="一个租户一个数据表"><a href="#一个租户一个数据表" class="headerlink" title="一个租户一个数据表"></a>一个租户一个数据表</h2><p>一个租户对应一个数据表，这就意味着所有租户共用一个数据库，只是每个租户在数据库系统中拥有一个独立的数据表。</p><h2 id="按租户id字段隔离租户"><a href="#按租户id字段隔离租户" class="headerlink" title="按租户id字段隔离租户"></a>按租户id字段隔离租户</h2><p>这是三种方案中最简单的数据隔离方式，即在每张表中都添加一个字段(tenant_id)，用于标识数据归属于哪个租户。之后在对数据进行操作时，都需要将该字段作为过滤条件。由于所有租户的数据都存放在同一张表中，因此数据隔离性是最差的，很容易出现把数据弄错的情况。</p><h2 id="三种数据隔离架构设计对比"><a href="#三种数据隔离架构设计对比" class="headerlink" title="三种数据隔离架构设计对比"></a>三种数据隔离架构设计对比</h2><p>下面是三种数据隔离架构的对比：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716345338895-3ec98c21-d704-42c6-ada1-46bfc6050ac6.png#averageHue=%23f2f1f0&clientId=ue64ccb44-95d4-4&from=paste&height=284&id=ucf64086b&originHeight=468&originWidth=1015&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=55552&status=done&style=none&taskId=ue18df12a-52cf-4e88-a923-4549a6db3a3&title=&width=615.1514795967172" alt="image.png"><br>结合公司现状，最终决定采用按照租户id字段隔离租户这一架构，这种方式能降低服务器成本，但也提高了开发难度，有利有弊。</p><h1 id="基于Mybatis实现多租户"><a href="#基于Mybatis实现多租户" class="headerlink" title="基于Mybatis实现多租户"></a>基于Mybatis实现多租户</h1><p>由于本公司目前使用的ORM框架为Mybatis，因此决定在此基础上配合拦截器实现多租户。</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>最简单的方式就是在SQL语句执行前，拦截原始语句，然后在语句后面添加where tenant_id = tenantID，当然了实际情况并不是所有的表中都包含tenant_id字段，因此并不能全部都加上这个字段，这里为了演示，就不考虑这个问题。那么问题来了，如何拦截原始SQL语句呢？可以使用Mybatis提供的拦截器来实现。</p><p>点击 <a href="https://mybatis.org/mybatis-3/zh_CN/configuration.html#plugins">这里</a> 阅读Mybatis的插件文档，实际上它就是一个拦截器：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716365108772-df8fab1f-be6e-4948-812f-811385af1499.png#averageHue=%23f9f9f9&clientId=ua1b4368c-a858-4&from=paste&height=317&id=u8d64bc02&originHeight=523&originWidth=1305&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=76608&status=done&style=none&taskId=uc16d7d54-dc36-4055-93dd-23c0d69a9eb&title=&width=790.9090451957792" alt="image.png"><br>要想使用Mybatis提供的插件，只需实现Interceptor接口，并指定想要拦截的方法签名即可。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed);</li><li>ParameterHandler (getParameterObject, setParameters);</li><li>ResultSetHandler (handleResultSets, handleOutputParameters);</li><li>StatementHandler (prepare, parameterize, batch, update, query).</li></ul><p>Mybatis的插件使用起来非常简单，只需如下三步：<br>（1）实现Interceptor接口；<br>（2）指定想要拦截的方法签名；<br>（3）注册这个插件。</p><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>第一步，新建一个名为interceptor-mybatis的SpringBoot项目，然后在POM文件中引入redis、mysql和web依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--添加mybatis依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--添加数据库驱动依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--添加数据库连接池依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>第二步，在<code>application.yml</code>配置文件中新增redis和mysql配置信息及项目运行端口信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/many_tenant?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    database: 2</span><br><span class="line">    port: 6379</span><br><span class="line">    password:</span><br><span class="line">    timeout: 5000</span><br><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.gutsyzhan.interceptormybatis.mapper: debug</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br></pre></td></tr></table></figure><h3 id="创建Redis工具类"><a href="#创建Redis工具类" class="headerlink" title="创建Redis工具类"></a>创建Redis工具类</h3><p>第三步，新建utils包，并在utils包内新建一个名为RedisUtil的工具类，该类用于封装对Redis的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisUtils &#123;</span><br><span class="line">    public static final String TENANT_ID_KEY = &quot;tenant_id&quot;;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    public boolean setExpire(Object value, Long expireTime)&#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        try&#123;</span><br><span class="line">            redisTemplate.opsForValue().set(TENANT_ID_KEY, value, expireTime, TimeUnit.SECONDS);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Object o = redisTemplate.opsForValue().get(TENANT_ID_KEY);</span><br><span class="line">            if(o == null)&#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return o.toString();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建Bean工具类"><a href="#创建Bean工具类" class="headerlink" title="创建Bean工具类"></a>创建Bean工具类</h3><p>第四步，在utils包内新建一个名为BeanUtils的工具类，该类用于获取Spring容器中的Bean对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BeanUtils implements BeanFactoryAware &#123;</span><br><span class="line">    private static BeanFactory beanFactory;</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        BeanUtils.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getBean(String beanName)&#123;</span><br><span class="line">        return beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T getBean(Class&lt;? extends T&gt; clazz)&#123;</span><br><span class="line">        return beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建拦截器类"><a href="#创建拦截器类" class="headerlink" title="创建拦截器类"></a>创建拦截器类</h3><p>第五步，新建interceptor包，并在interceptor包内新建一个名为TenantInterceptor的拦截器类，该类用于拦截原始SQL语句并对SQL语句进行拼接操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">                RowBounds.class, ResultHandler.class &#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class TenantInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0];</span><br><span class="line">        Object parameter = invocation.getArgs()[1];</span><br><span class="line">        BoundSql boundSql = mappedStatement.getBoundSql(parameter);</span><br><span class="line"></span><br><span class="line">        //获取原始的SQL语句</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        // 获取当前租户标识，可以从 ThreadLocal、Spring Security 等获取</span><br><span class="line">        String tenantId = BeanUtils.getBean(RedisUtils.class).get();</span><br><span class="line">        //拼接新的SQL语句</span><br><span class="line">        String newSql = sql + &quot; where tenant_id = &#x27;&quot; + tenantId + &quot;&#x27;&quot;;</span><br><span class="line">        //将修改后的SQL语句重新添加到BoundSql中</span><br><span class="line">        BoundSql newBoundSql = new BoundSql(mappedStatement.getConfiguration(), newSql,</span><br><span class="line">                boundSql.getParameterMappings(), parameter);</span><br><span class="line">        //将新的BoundSql对象设置到MappedStatement对象中</span><br><span class="line">        MappedStatement newMappedStatement = copyFromMappedStatement(mappedStatement, new BoundSqlSqlSource(newBoundSql));</span><br><span class="line">        //更新参数列表</span><br><span class="line">        invocation.getArgs()[0] = newMappedStatement;</span><br><span class="line">        //调用原始的方法，执行SQL语句</span><br><span class="line">        return invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object plugin(Object target) &#123;</span><br><span class="line">        return Plugin.wrap(target, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        //可以在这里设置一些属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private MappedStatement copyFromMappedStatement(MappedStatement ms, SqlSource newSqlSource) &#123;</span><br><span class="line">        MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource, ms.getSqlCommandType());</span><br><span class="line">        builder.resource(ms.getResource());</span><br><span class="line">        builder.fetchSize(ms.getFetchSize());</span><br><span class="line">        builder.statementType(ms.getStatementType());</span><br><span class="line">        builder.keyGenerator(ms.getKeyGenerator());</span><br><span class="line">        builder.keyProperty(ms.getKeyProperties() == null ? null : ms.getKeyProperties()[0]);</span><br><span class="line">        builder.timeout(ms.getTimeout());</span><br><span class="line">        builder.parameterMap(ms.getParameterMap());</span><br><span class="line">        builder.resultMaps(ms.getResultMaps());</span><br><span class="line">        builder.resultSetType(ms.getResultSetType());</span><br><span class="line">        builder.cache(ms.getCache());</span><br><span class="line">        builder.flushCacheRequired(ms.isFlushCacheRequired());</span><br><span class="line">        builder.useCache(ms.isUseCache());</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class BoundSqlSqlSource implements SqlSource &#123;</span><br><span class="line">        BoundSql boundSql;</span><br><span class="line">        public BoundSqlSqlSource(BoundSql boundSql) &#123;</span><br><span class="line">            this.boundSql = boundSql;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public BoundSql getBoundSql(Object parameterObject) &#123;</span><br><span class="line">            return boundSql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册拦截器对象"><a href="#注册拦截器对象" class="headerlink" title="注册拦截器对象"></a>注册拦截器对象</h3><p>第六步，新建config包，并在config包内新建一个名为MybatisConfig的配置类，这个配置类需要注册前面定义的拦截器对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ConfigurationCustomizer mybatisConfigurationCustomizer()&#123;</span><br><span class="line">        return configuration -&gt; &#123;</span><br><span class="line">            //创建并添加拦截器到配置中</span><br><span class="line">            configuration.addInterceptor(new TenantInterceptor());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写Redis序列化"><a href="#重写Redis序列化" class="headerlink" title="重写Redis序列化"></a>重写Redis序列化</h3><p>第七步，在config包内新建一个名为RedisConfig的配置类，这个配置类需要定义一个redisTemplate方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = new ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新建数据库和表"><a href="#新建数据库和表" class="headerlink" title="新建数据库和表"></a>新建数据库和表</h3><p>第八步，创建名为many_tenant的数据库，并在里面执行如下建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `book` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `name` varchar(128) DEFAULT NULL COMMENT &#x27;名称&#x27;,</span><br><span class="line">  `author` varchar(64) DEFAULT NULL COMMENT &#x27;作者&#x27;,</span><br><span class="line">  `tenant_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;租户id&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line">INSERT INTO `book` VALUES (2, &#x27;西游记&#x27;, &#x27;吴承恩&#x27;, &#x27;zh001&#x27;);</span><br><span class="line">INSERT INTO `book` VALUES (4, &#x27;三国演义&#x27;, &#x27;罗贯中&#x27;, &#x27;zh002&#x27;);</span><br><span class="line">INSERT INTO `book` VALUES (5, &#x27;水浒传&#x27;, &#x27;施耐庵&#x27;, &#x27;zh003&#x27;);</span><br><span class="line">INSERT INTO `book` VALUES (6, &#x27;红楼梦&#x27;, &#x27;曹雪芹&#x27;, &#x27;zh004&#x27;);</span><br></pre></td></tr></table></figure><p>可以看到这个tenant_id就是我们定义的租户字段，用于表示用户的租户信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716366446975-58d396ad-292e-4762-9ece-8a035d33d827.png#averageHue=%23e9e7e5&clientId=ua1b4368c-a858-4&from=paste&height=89&id=u4ddf7ddb&originHeight=147&originWidth=437&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=9401&status=done&style=none&taskId=u3a3df959-85d9-4687-94c4-2bfca647329&title=&width=264.84846954065557" alt="image.png"></p><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><p>第九步，新建一个名为entity的包，并在该包下创建一个名为Book的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    private String tenantId;</span><br><span class="line">    //getter、setter和toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据库访问层"><a href="#创建数据库访问层" class="headerlink" title="创建数据库访问层"></a>创建数据库访问层</h3><p>第十步，新建一个名为mapper的包，并在该包下创建一个名为BookMapper的java类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    List&lt;Book&gt; getAllBooks();</span><br><span class="line"></span><br><span class="line">    void update(String author);</span><br><span class="line"></span><br><span class="line">    void delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在该包内定义一个同名的xml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.gutsyzhan.interceptormybatis.mapper.BookMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getAllBooks&quot; resultType=&quot;com.gutsyzhan.interceptormybatis.entity.Book&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">            id as id,</span><br><span class="line">            name as name,</span><br><span class="line">            author as author,</span><br><span class="line">            tenant_id as tenantId</span><br><span class="line">        from book</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;update id=&quot;update&quot;&gt;</span><br><span class="line">        update book</span><br><span class="line">        set author = #&#123;author&#125;</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    &lt;delete id=&quot;delete&quot;&gt;</span><br><span class="line">        delete from book</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="配置pom-xml文件"><a href="#配置pom-xml文件" class="headerlink" title="配置pom.xml文件"></a><strong>配置pom.xml文件</strong></h3><p>第十一步，配置pom文件。由于我们将mapper类和xml文件放在同一个包内，且不在resources目录下，此时运行项目肯定会抛出mapper文件找不到的异常，因为Maven运行时会忽略包内的xml文件，因此需要在pom.xml文件中重新指明资源文件的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!--使用mybatis时需要手动指明xml的位置--&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="创建控制层"><a href="#创建控制层" class="headerlink" title="创建控制层"></a>创建控制层</h3><p>第十二步，新建一个名为controller的包，并在该包下创建一个名为BookController的java类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private RedisUtils redisUtils;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public String list()&#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookMapper.getAllBooks();</span><br><span class="line">        return &quot;【bookList】&gt;&gt;&gt;&gt;&gt;&gt;&quot;+ bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/get&quot;)</span><br><span class="line">    public String get()&#123;</span><br><span class="line">        String tenantId = redisUtils.get();</span><br><span class="line">        return &quot;现在的租户id为：&quot; + tenantId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/set&quot;)</span><br><span class="line">    public String set(@RequestParam(&quot;tenantId&quot;)String tenantId)&#123;</span><br><span class="line">        String oldTenantId = redisUtils.get();</span><br><span class="line">        redisUtils.setExpire(tenantId,100L);</span><br><span class="line">        return &quot;之前的租户id为：&quot; + oldTenantId + &quot;；现在的租户id为：&quot; + tenantId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/update&quot;)</span><br><span class="line">    public String update()&#123;</span><br><span class="line">        bookMapper.update(&quot;张三&quot;);</span><br><span class="line">        return &quot;数据修改成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/delete&quot;)</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        bookMapper.delete();</span><br><span class="line">        return &quot;数据删除成功&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>第十三步，运行项目，在浏览器地址栏中输入<code>http://localhost:8081/set?tenantId=zh001</code>，可以看到当前租户id如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716383726007-f0e6d719-ef3a-4350-ad72-676365b94ad2.png#averageHue=%23e3bf83&clientId=u6c08ef22-c982-4&from=paste&height=66&id=u3e539131&originHeight=66&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6649&status=done&style=none&taskId=u869c0ee6-e468-4dab-b3f3-023bd935fcf&title=&width=379" alt="image.png"><br>（1）查询操作。接着我们访问list接口，页面返回结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367092500-a2c61bff-a38d-4b36-8032-05bcb6e37b6c.png#averageHue=%23d5b179&clientId=ua1b4368c-a858-4&from=paste&height=96&id=u68d4c4ba&originHeight=158&originWidth=1016&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=17475&status=done&style=none&taskId=u6abb1f21-a2c9-4c74-bfe5-581e6a03930&title=&width=615.7575401677484" alt="image.png"><br>查看一下控制台，可以看到输出如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367174447-8523c337-387d-4ff7-810d-a8d8cbb42a03.png#averageHue=%232e2d2d&clientId=ua1b4368c-a858-4&from=paste&height=123&id=ue884dd1f&originHeight=203&originWidth=1726&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=27792&status=done&style=none&taskId=u655bbc29-c282-4402-9111-9316b7dd65b&title=&width=1046.0605455999348" alt="image.png"><br>可以看到我们的xml文件中是没有传入tenantId这一条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  id as id,</span><br><span class="line">  name as name,</span><br><span class="line">  author as author,</span><br><span class="line">  tenant_id as tenantId</span><br><span class="line">from book</span><br></pre></td></tr></table></figure><p>但是代码在执行过程中被拦截了，然后拼接上了tenantId这个过滤条件。<br>（2）修改操作。接着我们再来访问update接口，页面返回如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367624922-3f8c77a2-521b-4aee-bc67-86016783d4c9.png#averageHue=%23f9f9f8&clientId=ua1b4368c-a858-4&from=paste&height=99&id=u31e1cf60&originHeight=163&originWidth=538&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=9734&status=done&style=none&taskId=uc9ecfacf-d734-4b9b-9664-3f52afe54a3&title=&width=326.0605872148117" alt="image.png"><br>再来看一下控制台，可以看到输出如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367664105-73095b45-d3de-49f6-b191-f580be9dcb1d.png#averageHue=%232f2f2e&clientId=ua1b4368c-a858-4&from=paste&height=75&id=ubc30e7db&originHeight=124&originWidth=965&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=15431&status=done&style=none&taskId=ued69708d-8e41-411e-a17b-0d3e1b48341&title=&width=584.8484510451548" alt="image.png"><br>而我们的xml文件中也没有传入tenantId这一条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update book</span><br><span class="line">set author = #&#123;author&#125;</span><br></pre></td></tr></table></figure><p>（3）删除操作。接着我们再来访问delete接口，页面返回如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367873289-8ca3c29f-9a05-49a4-aa9a-13cff965fc79.png#averageHue=%23f9f8f7&clientId=ua1b4368c-a858-4&from=paste&height=102&id=u76bb390f&originHeight=168&originWidth=464&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=9332&status=done&style=none&taskId=u11007082-7154-4c5e-bb2a-13e51a45cb3&title=&width=281.21210495849925" alt="image.png"><br>再来看一下控制台，可以看到输出如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716367890674-c5e6eb52-7f4e-4c0d-babc-21292a08797a.png#averageHue=%23302f2e&clientId=ua1b4368c-a858-4&from=paste&height=68&id=ucd61859c&originHeight=113&originWidth=827&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=12016&status=done&style=none&taskId=u0d407619-4889-4141-bf09-e85c0039003&title=&width=501.21209224284246" alt="image.png"><br>而我们的xml文件中也没有传入tenantId这一条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from book</span><br></pre></td></tr></table></figure><p>由于新增操作使用post方式，且不需要添加where tenant_id这一过滤条件，因此笔者这里就不再演示。<br>（4）切换租户ID。接着我们再来访问set接口，将租户ID切换为zh002，此时页面返回如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716383814976-a8b6d72c-cdd7-4419-929c-139efcdb8b01.png#averageHue=%23e3bd80&clientId=u6c08ef22-c982-4&from=paste&height=62&id=u5734ac48&originHeight=62&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6972&status=done&style=none&taskId=ub8f35c89-45f0-45e7-a9e2-95b49661bf6&title=&width=379" alt="image.png"><br>为确保租户ID已经正确切换，此时我们再次访问get接口，页面返回如下信息：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716383871633-1ea411f5-ae13-4ba6-b334-cbe61aa6e58a.png#averageHue=%23e0b87b&clientId=u6c08ef22-c982-4&from=paste&height=61&id=u68473603&originHeight=61&originWidth=268&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4990&status=done&style=none&taskId=u4cd08b47-3a05-4324-9a78-fc635dcd9b3&title=&width=268" alt="image.png"><br>（5）查询操作。接着我们访问list接口，页面返回结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716384879658-034ee9f4-5c26-4f51-a51e-aa6b705f74db.png#averageHue=%23edd08c&clientId=u6c08ef22-c982-4&from=paste&height=65&id=ud1bce57d&originHeight=65&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7462&status=done&style=none&taskId=ue102cc31-ddda-4238-b6a1-fe679e465ba&title=&width=670" alt="image.png"></p><h1 id="案例原理分析"><a href="#案例原理分析" class="headerlink" title="案例原理分析"></a>案例原理分析</h1><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>首先我们定义了一个名为TenantInterceptor的类，它需要实现Interceptor接口，并实现其中的intercept、plugin和setProperties方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(</span><br><span class="line">        @Signature(type = Executor.class,method = &quot;query&quot;,args = &#123;MappedStatement.class,Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;)</span><br><span class="line">)</span><br><span class="line">public class TenantInterceptor implements Interceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        //TODO 拦截方法前处理</span><br><span class="line">        //执行被代理方法</span><br><span class="line">        Object obj = invocation.proceed();</span><br><span class="line">        //TODO 拦截方法后处理</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intercepts注解的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Intercepts &#123;</span><br><span class="line">    Signature[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它里面可以配置多个Signature注解，Signature注解的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;&#125;)</span><br><span class="line">public @interface Signature &#123;</span><br><span class="line">    Class&lt;?&gt; type();</span><br><span class="line">    String method();</span><br><span class="line">    Class&lt;?&gt;[] args();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解的属性解释如下：<br>（1）type：用于指定拦截的类型；<br>（2）method：用于指定拦截的方法；<br>（3）args：用于指定拦截的方法参数。<br>通过上面这三个属性，就能完全确定一个方法。我们在TenantInterceptor类中配置了两个拦截器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">                RowBounds.class, ResultHandler.class &#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>分别拦截了Executor类中的query和update方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int update(MappedStatement ms, Object obj) throws SQLException;</span><br><span class="line"></span><br><span class="line">&lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object obj, RowBounds rb, ResultHandler rh);</span><br></pre></td></tr></table></figure><p>也就是会代理他们，会进入到TenantInterceptor#intercept()方法中。</p><h2 id="拦截类型"><a href="#拦截类型" class="headerlink" title="拦截类型"></a>拦截类型</h2><p>Mybatis中可被拦截的类有四种，按照拦截的先后顺序如下所示：<br>（1）Executor：拦截执行器的方法，用于进行增删改查操作。<br>（2）ParameterHandler：拦截参数的处理，用于处理SQL语句中的参数对象。<br>（3）ResultHandler：拦截结果集的处理，用于处理SQL语句的返回结果。<br>（4）StatementHandler：拦截SQL语句构建的处理，也就是数据库的处理对象，用于执行SQL语句。<br>这些拦截类中可以被拦截的方法如下所示：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些地方包含了sql执行的全部过程，这些方法也可以从拦截类型类中进行查阅。对应到Signature注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;&#125;)</span><br><span class="line">public @interface Signature &#123;</span><br><span class="line">    Class&lt;?&gt; type();</span><br><span class="line"></span><br><span class="line">    String method();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] args();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就能知道type字段存放是的Class对象，即前面提到的四大类型。method字段存放的是class对象的具体方法。args字段存放的是具体方法的参数。实际上看到这里，你应该就能联想到反射相关的内容了。</p><h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>在案例中我们是需要对查询、修改和删除操作自动添加where条件，因此使用Executor对象就能满足我们的要求，即type字段可以设置为Executor.class。method字段应该存放方法名称，查阅Executor类的源码：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716442428521-e74a4ba1-6770-4e2f-9e54-da32c9f749c0.png#averageHue=%232d2c2c&clientId=ua81fce80-3bb9-4&from=paste&height=499&id=u9776dcf7&originHeight=823&originWidth=1037&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=93069&status=done&style=none&taskId=ud020293a-3f65-49ee-ab82-b10011c1c37&title=&width=628.4848121594047" alt="image.png"><br>你会发现其中只有query和update方法，并没有delete方法。实际上我们可以认为delete也是一种update，从SqlSession接口中查阅一下源码，可以发现delete确实是一种update：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int delete(String statement) &#123;</span><br><span class="line">    return this.update(statement, (Object)null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上不仅仅是delete，插入使用的insert方法其实也是一种update方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int insert(String statement, Object parameter) &#123;</span><br><span class="line">    </span><br><span class="line">    return this.update(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此method字段就只需填写query和query，而args字段存放的就是方法入参。那么这样完整的配置参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">                RowBounds.class, ResultHandler.class &#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们其实就对自定义插件的工作原理有了一个较为清晰的理解，但是对于Mybatis插件的源码阅读才刚刚开始。</p><h1 id="Mybatis插件源码"><a href="#Mybatis插件源码" class="headerlink" title="Mybatis插件源码"></a>Mybatis插件源码</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>先来阅读Mybatis源码中plugin包里面的类，可以看到目录结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716444959209-cb21626e-0e65-4fb8-a7c5-e79fee064f33.png#averageHue=%23514c42&clientId=ua81fce80-3bb9-4&from=paste&height=239&id=u270e500a&originHeight=359&originWidth=380&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=19033&status=done&style=none&taskId=u68351bf3-4af1-4b55-a06a-8b98ba9f803&title=&width=253.33333333333334" alt="image.png"></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在前面我们说过，Mybatis插件的原理是动态代理加上责任链模式。在Java中，JDK动态代理是通过实现InvocationHandler接口来实现的。查阅一下Plugin这个类的源码：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716443359400-42c92f23-134f-4058-9610-1970c5fe855a.png#averageHue=%232c2c2b&clientId=ua81fce80-3bb9-4&from=paste&height=513&id=u32e35bd0&originHeight=846&originWidth=1549&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=227100&status=done&style=none&taskId=u01f6f4c4-115d-413e-955c-b0be91bb6a6&title=&width=938.7878245274038" alt="image.png"><br>可以看到这个类确实是实现了InvocationHandler接口，因此它采用了JDK动态代理。接着这个类里面定义了三个属性，分别为target（目标对象）、interceptor（拦截器）和signatureMap（签名map）。</p><p>再来看一下wrap方法，可以看到它其实就是判断是否需要生成Plugin代理对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Object wrap(Object target, Interceptor interceptor) &#123;</span><br><span class="line">    //解析当前inteceptor上所有配置的Inteceptors注解，并获取配置的拦截方法</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    //如果拦截器配置的拦截方法与当前target中存在的方法匹配的上，那么当前对象需要被代理</span><br><span class="line">    return interfaces.length &gt; 0 ? Proxy.newProxyInstance(type.getClassLoader(), </span><br><span class="line">    interfaces, new Plugin(target, interceptor, signatureMap)) </span><br><span class="line">    : target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而invoke方法的源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//动态代理方法被调用时返回</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Set&lt;Method&gt; methods = (Set)this.signatureMap.get(method.getDeclaringClass());</span><br><span class="line">        return methods != null &amp;&amp; methods.contains(method) ? </span><br><span class="line">        this.interceptor.intercept(new Invocation(this.target, method, args)) </span><br><span class="line">        : method.invoke(this.target, args);</span><br><span class="line">    &#125; catch (Exception var5) &#123;</span><br><span class="line">        throw ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是判断当前方法是否需要被拦截，如果需要被拦截，则使用代理对象并执行拦截逻辑，否则执行正常的逻辑。接下来我们通过debug代码，来看一下上面invoke方法的执行过程，尤其是if方法的判断逻辑：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716444722326-f709c332-7ded-4401-b512-5958c6dc8954.png#averageHue=%233b403c&clientId=ua81fce80-3bb9-4&from=paste&height=549&id=u6e2b6e68&originHeight=824&originWidth=1740&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=932765&status=done&style=none&taskId=ufede9fd2-8329-46ee-b027-1ec5a46ebfb&title=&width=1160" alt="image.png"><br>可以看到methods集合中存放的则是Mybatis支持的拦截方法，而method则是开发者配置的需要拦截的方法，注意这个方法名也需要在前面提到的拦截类中存在才行。</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>接下来查阅其中的InterceptorChain类的源码，可以看到里面定义了一个interceptors属性，里面存放了拦截器对象：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716445667882-489e3098-33f3-40d7-80f3-13b75d0baceb.png#averageHue=%232c2b2b&clientId=ua81fce80-3bb9-4&from=paste&height=595&id=u40f65600&originHeight=892&originWidth=1588&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=104787&status=done&style=none&taskId=ufb245309-4357-40be-8a0a-e0aefcf028f&title=&width=1058.6666666666667" alt="image.png"><br>接下来我们查看一下pluginAll方法的调用地方，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716445369195-87472843-72b5-4ade-a1b5-00be81b6728a.png#averageHue=%23494b42&clientId=ua81fce80-3bb9-4&from=paste&height=215&id=u2d8e2081&originHeight=323&originWidth=1374&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=485266&status=done&style=none&taskId=udd25270c-4bd1-4779-8611-8c75312f558&title=&width=916" alt="image.png"><br>可以看到就是前面介绍的Executor、ParameterHandler 、ResultSetHandler 和StatementHandler这四大对象来调用它，即插件只作用于这四大对象。完整的调用地方，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716445510535-2e8dda77-817f-46e7-a2f2-488c7fbb60fa.png#averageHue=%233f3b33&clientId=ua81fce80-3bb9-4&from=paste&height=619&id=u55e72e3e&originHeight=929&originWidth=2144&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=1156113&status=done&style=none&taskId=u9d6344cf-cd0b-40ab-9ae6-11c300c5ac9&title=&width=1429.3333333333333" alt="image.png"><br>现在就有一个问题了，插件是在什么时候被加载的呢？这就要阅读前面提到的InterceptorChain类的源码了。完整的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class InterceptorChain &#123;</span><br><span class="line">    //保存所有的拦截器配置</span><br><span class="line">    private final List&lt;Interceptor&gt; interceptors = new ArrayList();</span><br><span class="line"></span><br><span class="line">    public InterceptorChain() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建executor或者handler时调用</span><br><span class="line">    public Object pluginAll(Object target) &#123;</span><br><span class="line">        Interceptor interceptor;</span><br><span class="line">        //验证所有的inteceptor和当前要创建的对象是否匹配</span><br><span class="line">        for(Iterator var2 = this.interceptors.iterator(); </span><br><span class="line">            var2.hasNext(); t</span><br><span class="line">            arget = interceptor.plugin(target)</span><br><span class="line">            ) </span><br><span class="line">          &#123;</span><br><span class="line">            interceptor = (Interceptor)var2.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析plugins配置时调用</span><br><span class="line">    public void addInterceptor(Interceptor interceptor) &#123;</span><br><span class="line">        this.interceptors.add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Interceptor&gt; getInterceptors() &#123;</span><br><span class="line">        return Collections.unmodifiableList(this.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它定义了一个interceptors属性，这个属性被final修改，也就是说它本身不能被修改，但是里面的内容是可以被修改的。而getInterceptors方法则让interceptors属性不可以被修改，因此要想修改这个interceptors属性，必须使用addInterceptor方法，这样可以保证集合的修改是可被控制的。</p><p>看到这里，我们就知道了，要想知道插件什么时候被加载的，只需知道哪里调用了addInterceptor方法。通过分析，可以看到只有下面两个地方调用了addInterceptor方法：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716445964433-21365ad7-5f0c-472d-9e9b-760506db6ec9.png#averageHue=%23475255&clientId=ua81fce80-3bb9-4&from=paste&height=128&id=u4fc25e43&originHeight=192&originWidth=736&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=200644&status=done&style=none&taskId=ua23ad255-4211-45f9-89fe-a115906cd12&title=&width=490.6666666666667" alt="image.png"><br>一个是XMLConfigBuilder，另一个则是SqlSessionFactoryBean。当我们使用xml配置文件这一方式来配置插件相关内容时，对应的XML配置内容可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin inreceptor=&quot;org.mybatis.example.ExamplePlugin&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>之后MyBatis就会对此标签进行解析：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716446369857-81b10fc2-3b14-48ff-9137-cad3661d60ec.png#averageHue=%233a3a32&clientId=ua81fce80-3bb9-4&from=paste&height=501&id=ucb10010b&originHeight=752&originWidth=1244&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=727947&status=done&style=none&taskId=u4bf12d06-8b6e-4876-9f59-3bcaa20b9e2&title=&width=829.3333333333334" alt="image.png"><br>在解析到plugins标签时，就会进入到pluginElement方法中，然后在此方法中调用addInterceptor方法：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716446435386-a7eb0a6d-8c19-45eb-adb5-06360c75becc.png#averageHue=%233d3932&clientId=ua81fce80-3bb9-4&from=paste&height=261&id=u05327d28&originHeight=392&originWidth=1300&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=361607&status=done&style=none&taskId=u1703053b-a270-4c69-a80d-db470799e41&title=&width=866.6666666666666" alt="image.png"><br>由于前面我们使用的都是注解方式，并没有采用XML配置文件的方式，因此接下来着重分析SqlSessionFactoryBean。通过分析，我们发现MybatisAutoConfiguration类的构造方法中初始化了interceptors：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public MybatisAutoConfiguration(MybatisProperties properties, </span><br><span class="line">    ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, </span><br><span class="line">    ResourceLoader resourceLoader, </span><br><span class="line">    ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, </span><br><span class="line">    ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">        this.interceptors = (Interceptor[])interceptorsProvider.getIfAvailable();</span><br><span class="line">        this.resourceLoader = resourceLoader;</span><br><span class="line">        this.databaseIdProvider = (DatabaseIdProvider)databaseIdProvider.getIfAvailable();</span><br><span class="line">        this.configurationCustomizers = (List)configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是调用了interceptorsProvider对象的getIfAvailable()方法，该方法的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T getIfAvailable() throws BeansException;</span><br></pre></td></tr></table></figure><p>可以看到该方法的实现有四个类：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716448385951-dcb4714e-fa61-464f-9eb6-517c093f9d42.png#averageHue=%23989c89&clientId=ua81fce80-3bb9-4&from=paste&height=199&id=udfe1560c&originHeight=328&originWidth=1488&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=70143&status=done&style=none&taskId=u12a3d01d-2f94-48f3-ad6e-c5fa0ffef8a&title=&width=901.8181296944977" alt="image.png"><br>接着我们查看一下MybatisAutoConfiguration#sqlSessionFactory()方法，可以看到上面添加了一个@ConditionalOnMissingBean注解，表示只有当项目中没有自定义SqlSessionFactory对象时，才会注入此对象，这样才会真的注册插件：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/12555354/1716448819730-0f4544ca-32c4-446f-8144-45e14d1a1adb.png#averageHue=%232d2c2b&clientId=ua81fce80-3bb9-4&from=paste&height=556&id=u44e8878a&originHeight=917&originWidth=987&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=123504&status=done&style=none&taskId=u68ec78f0-81ab-4ce2-816a-e090efcbe54&title=&width=598.1817836078422" alt="image.png"><br>注意后面那一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">    factory.setPlugins(this.interceptors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只有interceptors不为空的时候，才会调用factory.setPlugins(this.interceptors)来注册插件。看到这里我们就知道了插件的三种配置方式，现总结如下：<br>（1）XML文件配置方式；<br>（2）如果没有自定义SqlSessionFactory对象，那么直接使用@Bean注解，直接注入拦截器即可；<br>（3）如果自定义了SqlSessionFactory对象，那么需要在自定义的地方手动调用factory.setPlugins()方法来注册插件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）Mybatis在执行语句时，会通过Configuration对象来创建对应的Executor或者Handler；<br>（2）创建完成后，会调用InterceptorChain#pluginAll()方法来判断该方法是否配置对应的拦截器，判断依据是通过配置的@Inteceptors注解中的方法签名，来判断当前target是否存在。如果需要则创建一个代理对象，否则返回原对象；<br>（3）代理对象在执行被拦截的方法时，首先调用Plugin#invoke()方法，来触发对应拦截器的intercept方法，而这个intercept方法就是开发者定义拦截器需要实现的方法，可以在该方法中书写对应的业务逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇是笔者一年来对智能照明SaaS平台多租户改造升级的一些实践与体会，这些内容在技术分享会上已做了介绍，下面是一些重要的概念</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>详解MySQL中的JSON数据类型</title>
    <link href="http://aigoing.chat/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/"/>
    <id>http://aigoing.chat/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/</id>
    <published>2024-03-23T10:55:30.000Z</published>
    <updated>2024-05-22T14:17:58.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习MySQL中的JSON数据类型，这在某些场景下比text类型好用很多。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 是 JavaScript Object Notation（JavaScript 对象表示法）的缩写，是一个轻量级的，基于文本的，跨语言的数据交换格式，易于阅读和编写。</p><h1 id="JSON基本数据类型"><a href="#JSON基本数据类型" class="headerlink" title="JSON基本数据类型"></a>JSON基本数据类型</h1><p>JSON 的基本数据类型如下：<br>（1）数值：十进制数，前面不能有0，可以为负数或小数，也可以为 e 或 E 表示的指数。<br>（2）字符串：字符串必须用双引号括起来。<br>（3）布尔值：true，false。<br>（4）数组：一个由零或多个值组成的有序序列。每个值可以为任意类型。数组使用方括号[] 括起来，元素之间用逗号,分隔。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, &quot;abc&quot;, null, false, &quot;10:29:06.000000&quot;, &#123;&quot;id&quot;: 2&#125;]</span><br></pre></td></tr></table></figure><p>（5）对象：一个由零或者多个键值对组成的无序集合。其中键必须是字符串，值可以为任意类型。对象使用花括号{}括起来，键值对之间使用逗号,分隔，键与值之间用冒号:分隔。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;db&quot;: [&quot;mysql&quot;, &quot;oracle&quot;], &quot;id&quot;: 666, &quot;info&quot;: &#123;&quot;age&quot;: 26&#125;&#125;</span><br></pre></td></tr></table></figure><p>（6）空值：null。</p><h1 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h1><p>这里创建一个名为tb_json的表，对应的SQL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json(t1 json);</span><br></pre></td></tr></table></figure><h3 id="直接插入JSON数组"><a href="#直接插入JSON数组" class="headerlink" title="直接插入JSON数组"></a>直接插入JSON数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_json values(&#x27;[1, &quot;test&quot;, null, false, &quot;09:10:11.000000&quot;]&#x27;);</span><br></pre></td></tr></table></figure><h3 id="直接插入JSON对象"><a href="#直接插入JSON对象" class="headerlink" title="直接插入JSON对象"></a>直接插入JSON对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_json values(&#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 20&#125;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="使用-JSON-ARRAY-构造JSON数组"><a href="#使用-JSON-ARRAY-构造JSON数组" class="headerlink" title="使用 JSON_ARRAY 构造JSON数组"></a>使用 JSON_ARRAY 构造JSON数组</h3><p>JSON_ARRAY(val1,val2,val3…)，用于构造JSON数组。该方法可接受0个或者多个值的列表，并返回一个包含这些值的 JSON 数组，开发者可利用该函数实现将List数组存储到数据库中。<br>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692323865019-d5f7f950-36d1-4a4a-9879-43de8b0a73fe.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=143&id=uc7885295&originHeight=214&originWidth=971&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20331&status=done&style=none&taskId=uf77f11f7-6fd3-422b-9706-cbd542abdc3&title=&width=647.3333333333334" alt="image.png"></p><h3 id="使用-JSON-OBJECT-构造JSON对象"><a href="#使用-JSON-OBJECT-构造JSON对象" class="headerlink" title="使用 JSON_OBJECT 构造JSON对象"></a>使用 JSON_OBJECT 构造JSON对象</h3><p>JSON_OBJECT(key1,val1,key2,val2…)，用于构造JSON对象。该方法可接受0个或者多个键值对列表，并返回一个包含这些对的 JSON 对象，利用该方法开发者可以很容易的创建一个json对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_object(&#x27;id&#x27;, 2, &#x27;name&#x27;, &#x27;zhangsan&#x27;, &#x27;age&#x27;, 20);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692323945023-ebbe05f4-c185-4ba2-87a9-a0c6b5281fa4.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=139&id=uc29a17c9&originHeight=208&originWidth=931&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19228&status=done&style=none&taskId=u66f32ec4-b814-4c78-a38a-0933d423930&title=&width=620.6666666666666" alt="image.png"></p><h3 id="使用-JSON-QUOTE-将JSON转为字符串"><a href="#使用-JSON-QUOTE-将JSON转为字符串" class="headerlink" title="使用 JSON_QUOTE 将JSON转为字符串"></a>使用 JSON_QUOTE 将JSON转为字符串</h3><p>JSON_QUOTE(json_val)，用于将JSON转为字符串。通常用于生成有效的 JSON 字符串文字以包含在 JSON 文档中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_quote(&#x27;[123456]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692324112765-535db8bd-9255-49f7-b01b-f7074b845084.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=136&id=u1316e3ef&originHeight=204&originWidth=535&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13485&status=done&style=none&taskId=ue8a1af62-5b68-4596-b55c-85d30465da2&title=&width=356.6666666666667" alt="image.png"></p><h3 id="JSON对象注意点"><a href="#JSON对象注意点" class="headerlink" title="JSON对象注意点"></a>JSON对象注意点</h3><p>对于 JSON 对象来说，KEY 名不能重复，具体的需要结合 MySQL 版本来进行说明。<br>（1）如果插入的值中存在重复 KEY，在 MySQL 8.0.3 之前，遵循 first duplicate key wins 原则，会保留第一个 KEY，后面的将被丢弃掉。<br>（2）而从 MySQL 8.0.3 开始，遵循的是 last duplicate key wins 原则，只会保留最后一个 KEY。</p><p>【MySQL 5.7.32】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30);</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| &#123;&quot;key1&quot;: 10, &quot;key2&quot;: 20&#125;                   |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>【MySQL 8.0.27】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30);</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| &#123;&quot;key1&quot;: 30, &quot;key2&quot;: 20&#125;                   |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h1><h3 id="JSON-CONTAINS"><a href="#JSON-CONTAINS" class="headerlink" title="JSON_CONTAINS"></a><strong>JSON_CONTAINS</strong></h3><p>JSON_CONTAINS(json_doc, val[, path])，用于查询JSON格式数据中是否包含指定对象，如果包含则返回1，否则返回0。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692324751008-59d14e7f-1dc9-4cf5-88f0-0203c3c30142.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=298&id=u619d238a&originHeight=447&originWidth=812&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=31042&status=done&style=none&taskId=u732492bb-16ac-4750-b3ee-ab31eccfc8c&title=&width=541.3333333333334" alt="image.png"></p><h3 id="JSON-CONTAINS-PATH"><a href="#JSON-CONTAINS-PATH" class="headerlink" title="JSON_CONTAINS_PATH"></a><strong>JSON_CONTAINS_PATH</strong></h3><p>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] …)，用于查询JSON格式数据中是否存在指定类型的key，如果包含则返回1，否则返回0。</p><p>如果有参数为NULL，那么返回NULL。请注意one_or_all的值只能为”one”或”all”，one表示只要有一个存在即可，all表示所有的都存在才行。</p><p>使用如下命令来创建一个测试表并插入一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json2(t2 json);</span><br><span class="line">insert into tb_json2 values(&#x27;&#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125;&#x27;), (&#x27;&#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>接着我们尝试使用 JSON_CONTAINS_PATH 来查询t2中是否包含 ename 这个key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_contains_path(t2,&#x27;one&#x27;,&#x27;$.ename&#x27;) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692328836836-4d124f59-66cc-4e1f-83d5-644231021b67.png#averageHue=%23161616&clientId=u35032c6b-3321-4&from=paste&height=163&id=ucde6db02&originHeight=244&originWidth=954&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18508&status=done&style=none&taskId=u928297c5-b4ba-49a5-b93b-dccd83ac56e&title=&width=636" alt="image.png"></p><h3 id="JSON-EXTRACT"><a href="#JSON-EXTRACT" class="headerlink" title="JSON_EXTRACT"></a><strong>JSON_EXTRACT</strong></h3><p>JSON_EXTRACT(json_doc, path[, path] …)，用于从JSON中抽取指定数据。其中，json_doc 是 JSON 文档，path 是路径。该函数会从 JSON 文档提取指定路径（path）的元素。如果指定 path 不存在，会返回 NULL。注意，可指定多个 path，那么匹配到的多个值会以数组形式返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(t2,&#x27;$.ename&#x27;) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692335483883-266ba718-d5f1-449c-880c-e657a7390271.png#averageHue=%23161616&clientId=u35032c6b-3321-4&from=paste&height=163&id=u5d4861cf&originHeight=244&originWidth=779&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17082&status=done&style=none&taskId=u30678b04-0466-4dac-b1d0-256db851153&title=&width=519.3333333333334" alt="image.png"></p><h5 id="JSON-EXTRACT在数组中的使用"><a href="#JSON-EXTRACT在数组中的使用" class="headerlink" title="JSON_EXTRACT在数组中的使用"></a>JSON_EXTRACT在数组中的使用</h5><p>我们知道数组的路径是通过下标来表示的，而且第一个元素的下标是 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336159121-97956765-5ee3-4f46-8d6b-a33f80ee6c57.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u79c6d2c7&originHeight=217&originWidth=873&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17385&status=done&style=none&taskId=ubb7dd4dc-9a2f-4d11-b4f9-2c2b41c335b&title=&width=582" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0]&#x27;,&#x27;$[1]&#x27;,&#x27;$[2][2]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336245648-ff3ac220-a33d-4741-81df-675f0c9a0702.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=139&id=ue8cf8993&originHeight=209&originWidth=1105&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20751&status=done&style=none&taskId=u89932fad-0271-47ea-9cbe-15cd5223abf&title=&width=736.6666666666666" alt="image.png"><br>当然，我么还可以使用 [M to N] 来获取数组的子集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0 to 1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336338518-c85f36ce-c7be-4ef7-bcab-4cbb88615fb5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u1b1ae785&originHeight=217&originWidth=939&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18789&status=done&style=none&taskId=u430ea725-9423-462f-ac36-2eca7a23b04&title=&width=626" alt="image.png"><br>也可以使用last来代表最后一个元素的下标，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[last-1 to last]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336438352-8dfe5df4-a373-48c6-88a6-47aa02ddb166.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=142&id=u2a40a4cb&originHeight=213&originWidth=1048&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20758&status=done&style=none&taskId=ue930ae36-b5ad-4732-add4-d2afca58a4d&title=&width=698.6666666666666" alt="image.png"><br>也可通过 [*] 来获取数组中的所有元素，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[*]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336508314-bbad0f73-17b5-4ead-872d-8a1df1925ff1.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=138&id=ub2e34c6e&originHeight=207&originWidth=870&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18366&status=done&style=none&taskId=u8dbaf399-be64-4316-8dc8-b04f9026b06&title=&width=580" alt="image.png"></p><h5 id="JSON-EXTRACT在对象中的使用"><a href="#JSON-EXTRACT在对象中的使用" class="headerlink" title="JSON_EXTRACT在对象中的使用"></a>JSON_EXTRACT在对象中的使用</h5><p>我们知道对象的路径是通过 KEY 来表示的。首先往数据表中定义一个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @j=&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;a c&quot;: 4&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>之后我们尝试从中获取key为a的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.a&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337859006-9525f7d2-6430-473a-9e97-c30c19668265.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=u774ec65e&originHeight=218&originWidth=544&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12281&status=done&style=none&taskId=u934f6a6f-b9d0-4d5b-addb-66a848662ba&title=&width=362.6666666666667" alt="image.png"><br>再来获取key为b，且数组下标为1的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.b[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337920555-f1011e67-eccd-44e1-bb48-5830f590bd86.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=143&id=u1437f46e&originHeight=215&originWidth=586&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13456&status=done&style=none&taskId=u0f7de5ae-5bdf-41fe-9b15-42054956a27&title=&width=390.6666666666667" alt="image.png"><br>请注意，如果 KEY 在路径表达式中不合法（如存在空格），那么在引用这个 KEY 时，需用双引号括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.&quot;a c&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337980197-7b761f25-cf46-4163-a751-bba4224964a2.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=ue5f56c5b&originHeight=212&originWidth=603&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12972&status=done&style=none&taskId=u811d815d-996d-4866-9d0e-74308b1f4e5&title=&width=402" alt="image.png"><br>此外，开发者还可以通过 .*  来获取对象中的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;a c&quot;: 4&#125;&#x27;, &#x27;$.*&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338068263-9462510c-4dc7-419a-8fd9-a9f6049fce2d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=138&id=u45698e38&originHeight=207&originWidth=981&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18850&status=done&style=none&taskId=u9deda8f5-500c-489b-9f2a-9ff1148387a&title=&width=654" alt="image.png"><br>再来看一个通配符的情况，可以看到这里的 $**.b 会匹配 $.a.b 和 $.c.b 这两种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;&#123;&quot;a&quot;: &#123;&quot;b&quot;: 1&#125;, &quot;c&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;, &#x27;$**.b&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338196223-306ca6cf-215a-433c-b515-bb7a3d8571ae.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=139&id=ud287d3a1&originHeight=209&originWidth=986&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18072&status=done&style=none&taskId=u1ae788a8-6843-4d6b-8da0-35caac860c5&title=&width=657.3333333333334" alt="image.png"></p><h3 id="column-gt-path"><a href="#column-gt-path" class="headerlink" title="column-&gt;path"></a><strong>column-&gt;path</strong></h3><p>column-&gt;path 以及后面提到的 column-&gt;&gt;path，它们都是语法糖，在实际使用的时候都会转化为 JSON_EXTRACT。</p><p>column-&gt;path 等同于 JSON_EXTRACT(column, path) ，注意里面只能指定一个path。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json2(t2 json);</span><br><span class="line">insert into tb_json2 values(&#x27;&#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125;&#x27;), (&#x27;&#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>查看一下t2以及其中ename的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2 ,t2 -&gt; &#x27;$.ename&#x27; from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338461799-f5f7e715-f449-41f9-a3a8-c9eccd9fad4b.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=161&id=ub813f5c9&originHeight=241&originWidth=780&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19917&status=done&style=none&taskId=uc3e58f9f-6cd8-41a7-9bfd-6a557e7b2f5&title=&width=520" alt="image.png"><br>查看一下empno为1001的用户的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_json2 where t2 -&gt; &#x27;$.empno&#x27; = 1001;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338620358-aa7093c9-bd6b-45ee-8e35-8afb2bfc967f.png#averageHue=%23171717&clientId=u35032c6b-3321-4&from=paste&height=140&id=ue7c5d3b1&originHeight=210&originWidth=840&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15629&status=done&style=none&taskId=ufba36d5e-ee32-48fc-a112-6603aaf672f&title=&width=560" alt="image.png"></p><h3 id="column-gt-gt-path"><a href="#column-gt-gt-path" class="headerlink" title="column-&gt;&gt;path"></a><strong>column-&gt;&gt;path</strong></h3><p>和 column-&gt;path 类似，只不过它返回的是字符串，请注意，下面三者是等价的：</p><ul><li><p>JSON_UNQUOTE( JSON_EXTRACT(column, path) )</p></li><li><p>JSON_UNQUOTE(column -&gt; path)</p></li><li><p>column-&gt;&gt;path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2-&gt;&#x27;$.ename&#x27;,json_extract(t2, &quot;$.ename&quot;),json_unquote(t2-&gt;&#x27;$.ename&#x27;),t2-&gt;&gt;&#x27;$.ename&#x27; from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338778806-d962b960-eb1d-4f5f-854c-8669a8bc54e0.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=160&id=u4c428175&originHeight=240&originWidth=1593&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=29171&status=done&style=none&taskId=uf2a40b73-9949-4f36-9580-31e6e4a888d&title=&width=1062" alt="image.png"></p><h3 id="JSON-SEARCH"><a href="#JSON-SEARCH" class="headerlink" title="JSON_SEARCH"></a><strong>JSON_SEARCH</strong></h3><p>JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] …])，该方法用于返回某个字符串（search_str）在 JSON 文档中的位置。其中：</p></li><li><p>one_or_all：匹配的次数，one 是只匹配一次，all 是匹配所有。如果匹配到多个，结果会以数组的形式返回。</p></li><li><p>search_str：子串，支持模糊匹配：% 和 _ 。</p></li><li><p>escape_char：转义符，如果该参数不填或为 NULL，则取默认转义符 \ 。</p></li><li><p>path：查找路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;one&#x27;, &#x27;abc&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341861120-d716b263-cb2b-4515-8e41-e31721a9bc49.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=ud46d07b1&originHeight=217&originWidth=1392&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23747&status=done&style=none&taskId=u2255355c-2d5f-4eb3-aa0f-f1408b100c4&title=&width=928" alt="image.png"><br>再来将one修改为all试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;abc&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341911889-e7dc5f0c-15bb-461d-94f0-d9ecb28cc535.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=137&id=u87572faf&originHeight=206&originWidth=1374&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24124&status=done&style=none&taskId=u3464de8a-ebcb-4a68-a581-5157f7a1990&title=&width=916" alt="image.png"><br>再来尝试寻找一个不存在的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;ddd&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341970434-83060a2a-6905-47ce-af86-96958ffbf5f5.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=137&id=u53518f7b&originHeight=205&originWidth=1393&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23127&status=done&style=none&taskId=u95d6906e-6c7f-49be-87d1-c123ef8dc08&title=&width=928.6666666666666" alt="image.png"><br>再来看一个例子，这里我们设置转义符为NULL，查找路径path指定为$[1]，此时代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;%b%&#x27;, NULL, &#x27;$[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342393098-3c0cdff1-55bd-4b3b-a751-313d540ee4f2.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u2022898b&originHeight=207&originWidth=1580&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27519&status=done&style=none&taskId=u83f164a3-6f9f-4ab2-b483-b11f53eea69&title=&width=1053.3333333333333" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;%b%&#x27;, NULL, &#x27;$[3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342525743-3296886e-cb83-4539-9b75-ccbded7e5f0d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=147&id=ue7824b1d&originHeight=220&originWidth=1580&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28290&status=done&style=none&taskId=ua7d08ff6-56d4-4b48-aef7-d549eba5f1b&title=&width=1053.3333333333333" alt="image.png"></p><h3 id="JSON-KEYS"><a href="#JSON-KEYS" class="headerlink" title="JSON_KEYS"></a><strong>JSON_KEYS</strong></h3><p>JSON_KEYS(json_doc[, path])，用于返回 JSON 文档最外层的 key，如果指定了 path，那么返回该 path 对应元素最外层的 key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_keys(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 6&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342653491-9ab83fff-8f45-4944-bcbe-cb7b58a5b24d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=143&id=ubc107274&originHeight=214&originWidth=730&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14997&status=done&style=none&taskId=u408aefbe-cefb-4ab9-894f-8d554189414&title=&width=486.6666666666667" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_keys(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 6&#125;&#125;&#x27;, &#x27;$.b&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342719716-7b89e4e2-3ddd-449c-9dc3-22a82880da55.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=u146bd41d&originHeight=212&originWidth=822&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16105&status=done&style=none&taskId=u93190263-d3ea-40a1-a300-f5e76967cb8&title=&width=548" alt="image.png"></p><h3 id="JSON-VALUE"><a href="#JSON-VALUE" class="headerlink" title="JSON_VALUE"></a><strong>JSON_VALUE</strong></h3><p>JSON_VALUE(json_doc, path)，它是MySQL 8.0.21 版本引入的，用于从 JSON 文档提取指定路径（path）的元素。该函数的完整语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JSON_VALUE(json_doc, path [RETURNING type] [on_empty] [on_error])</span><br><span class="line"></span><br><span class="line">on_empty:</span><br><span class="line">    &#123;NULL | ERROR | DEFAULT value&#125; ON EMPTY</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line">    &#123;NULL | ERROR | DEFAULT value&#125; ON ERROR</span><br></pre></td></tr></table></figure><p>上述命令中各参数的含义如下：</p></li><li><p>RETURNING type：返回值的类型，不指定，则默认是 VARCHAR(512)。不指定字符集，则默认是 utf8mb4，且区分大小写。</p></li><li><p>on_empty：如果指定路径没有值，会触发 on_empty 子句， 默认是返回 NULL，也可指定 ERROR 抛出错误，或者通过 DEFAULT value 返回默认值。</p></li><li><p>on_error：三种情况下会触发 on_error 子句：从数组或对象中提取元素时，会解析到多个值；类型转换错误，比如将 “abc” 转换为 unsigned 类型；值被 truncate 了。默认是返回 NULL。</p></li></ul><p>看一个简单的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;26&quot;&#125;&#x27;, &#x27;$.name&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342932116-e1e94e9b-79dd-4d2b-8508-5bba057532b9.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u5e6d6dd6&originHeight=208&originWidth=1020&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19010&status=done&style=none&taskId=ue0d11c29-862f-4b70-9b35-5a4d7e1857b&title=&width=680" alt="image.png"><br>再来看一个指定RETURNING type的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.weight&#x27; returning decimal(5,2)) as weight;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343141729-9bc7ba22-e87c-4274-bcad-87a6cac11125.png#averageHue=%23121212&clientId=u35032c6b-3321-4&from=paste&height=142&id=u16894e28&originHeight=213&originWidth=1610&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21501&status=done&style=none&taskId=ue6552d18-130c-4e91-bf70-9b3b1356c1e&title=&width=1073.3333333333333" alt="image.png"><br>再看一个指定on_empty的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.weight1&#x27; error on empty);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343271714-6ec28591-b059-49d2-b0a1-c0d6339abb7f.png#averageHue=%23252525&clientId=u35032c6b-3321-4&from=paste&height=40&id=ueff83c5d&originHeight=60&originWidth=1375&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15339&status=done&style=none&taskId=u11f5e095-a924-433c-a7d8-4db39802a01&title=&width=916.6666666666666" alt="image.png"><br>再看一个指定on_error的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;[1, 2, 3, 4]&#x27;, &#x27;$[1 to 2]&#x27; error on error);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343361168-b9e05a72-b9b1-427a-96be-7accd256e46b.png#averageHue=%23222222&clientId=u35032c6b-3321-4&from=paste&height=43&id=u2f0227d3&originHeight=65&originWidth=1244&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13959&status=done&style=none&taskId=u02e84174-e4a0-4504-afc8-8cb0de77247&title=&width=829.3333333333334" alt="image.png"><br>再来看一个指定on_error的例子，是因为类型转换错误而导致的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.name&#x27; returning unsigned error on error) as weight;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343669694-1ad8d804-d809-444c-8c84-15f4262182c2.png#averageHue=%23212121&clientId=u35032c6b-3321-4&from=paste&height=42&id=u8fdbd69c&originHeight=63&originWidth=1737&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16681&status=done&style=none&taskId=u7fe53ace-5727-471a-b05a-93394623a05&title=&width=1158" alt="image.png"></p><h3 id="MEMBER-OF"><a href="#MEMBER-OF" class="headerlink" title="MEMBER OF"></a><strong>MEMBER OF</strong></h3><p>value MEMBER OF(json_array)，用于判断 value 是否是 JSON 数组的一个元素，如果是，则返回 1；否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 18 member of(&#x27;[23, &quot;ad&quot;, 18, &quot;abc&quot;, 16]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343800781-34296a34-bd93-40f5-bd27-6cf2b7786564.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=uf820cc5e&originHeight=204&originWidth=797&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15655&status=done&style=none&taskId=u3779c79b-92b6-4436-8236-1699ad9437f&title=&width=531.3333333333334" alt="image.png"><br>再来看一个vaue为JOSN数组时的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cast(&#x27;[1,2]&#x27; as json) member of(&#x27;[[1,2],[3,4]]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343881895-3b094579-b587-45ab-917f-2fa16ae68fa2.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=ufb8790b6&originHeight=204&originWidth=892&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16893&status=done&style=none&taskId=ue9c282b4-f0c5-48f8-a486-17525c5a69c&title=&width=594.6666666666666" alt="image.png"></p><h3 id="JSON-OVERLAPS"><a href="#JSON-OVERLAPS" class="headerlink" title="JSON_OVERLAPS"></a><strong>JSON_OVERLAPS</strong></h3><p>JSON_OVERLAPS(json_doc1, json_doc2)，它是 MySQL 8.0.17版本 引入的，用于比较两个 JSON 文档是否有相同的键值对或数组元素，如果有，则返回 1，否则返回0。如果两个参数都是标量，那么判断这两个标量是否相等。<br>首先看一下两个JOSN数组是否有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;[1,3,5,7,9]&#x27;, &#x27;[3,5,7]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344368505-f4c3da2a-1efa-4aa8-8e31-b0e54fb6efbb.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=u63eac0f4&originHeight=217&originWidth=767&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15320&status=done&style=none&taskId=u59e43344-67e9-4cf2-802f-477a57c5f6f&title=&width=511.3333333333333" alt="image.png"><br>看一个两个JOSN数组中没有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;[1,3,5,7,9]&#x27;, &#x27;[2,4,6]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344424376-067ba9a5-01ff-4696-84f6-bdec4c25e6a5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=137&id=u527f7731&originHeight=205&originWidth=770&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16100&status=done&style=none&taskId=udb995371-c541-4421-bd45-704784ca120&title=&width=513.3333333333334" alt="image.png"><br>再来看一个两个JOSN对象是否有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;, &#x27;&#123;&quot;c&quot;:3,&quot;d&quot;:4,&quot;b&quot;:2&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344554055-aaaefc2a-4ce9-4656-99a9-1f43bc945baf.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=138&id=u81d5d322&originHeight=207&originWidth=966&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17667&status=done&style=none&taskId=u6780bf9a-3e37-4709-9f80-90369473175&title=&width=644" alt="image.png"><br>再来一个比较简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;1&#x27;, &#x27;1&#x27;),json_overlaps(&#x27;1&#x27;, &#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345248986-faa90e61-16d1-4765-97c7-5fd3aec3bedf.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u19436e90&originHeight=207&originWidth=878&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15372&status=done&style=none&taskId=u04a463bd-dfde-4082-9bbe-b991d1eb358&title=&width=585.3333333333334" alt="image.png"><br>自 MySQL 8.0.17版本开始，InnoDB 支持多值索引，可用在 JSON 数组中。当开发者使用 JSON_CONTAINS、MEMBER OF、JSON_OVERLAPS 进行数组相关的操作时，可使用多值索引来加快查询。</p><h1 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h1><h3 id="JSON-INSERT"><a href="#JSON-INSERT" class="headerlink" title="JSON_INSERT"></a><strong>JSON_INSERT</strong></h3><p>JSON_INSERT(json_doc, path, val[, path, val] …)，该方法用于插入新值，注意仅当指定位置或指定 KEY 的值不存在时，才执行插入操作。此外，如果指定的 path 是数组下标，且 json_doc 不是数组，那么该函数首先会将 json_doc 转化为数组，然后再插入新值。</p><p>下面通过几个案例来学习如何使用JSON_INSERT这个函数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;1&#x27;,&#x27;$[0]&#x27;,&quot;6&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339122210-55f80d8b-9e54-4d0b-8e12-1d79f00da72a.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u99cad776&originHeight=208&originWidth=600&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13009&status=done&style=none&taskId=u94f90d9a-5be0-4efb-8304-79904ec6fad&title=&width=400" alt="image.png"><br>接着我们通过path指定数组下标为1，此时执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;1&#x27;,&#x27;$[1]&#x27;,&quot;6&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339185145-9f6b08a0-597f-40cd-898e-ddb1b6f22aef.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=143&id=ue9314c1c&originHeight=215&originWidth=608&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13529&status=done&style=none&taskId=ueabaaaf9-791c-4965-8bad-9088559f2a9&title=&width=405.3333333333333" alt="image.png"><br>再来看一个数组的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&#x27;,&#x27;$[3]&#x27;,&quot;8&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339271760-2f0a20be-a20b-4157-88c1-bd61ee36620c.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=139&id=u91178613&originHeight=209&originWidth=770&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16341&status=done&style=none&taskId=u633bdb45-7c4e-4a26-a2e4-016cc6991c5&title=&width=513.3333333333334" alt="image.png"><br>再来看一下比较综合的案例，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;, &#x27;$.a&#x27;, 6, &#x27;$.d&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339388328-693d7407-0425-4a3a-9025-3e8ae3360060.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=142&id=u7cb77c1b&originHeight=213&originWidth=1215&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24629&status=done&style=none&taskId=u247c84fe-d8e0-497f-8beb-c9628744014&title=&width=810" alt="image.png"></p><h3 id="JSON-SET"><a href="#JSON-SET" class="headerlink" title="JSON_SET"></a><strong>JSON_SET</strong></h3><p>JSON_SET(json_doc, path, val[, path, val] …)，该方法用于插入新值，并替换已经存在的值。也就是说，如果指定位置或指定 KEY 的值不存在，那么将执行插入操作；如果存在，则执行更新操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_set(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;, 8, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339568779-34be3fd8-e4ed-4d7c-b725-eabc180eb90f.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u4c57a675&originHeight=218&originWidth=1212&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24840&status=done&style=none&taskId=u400a4f06-e0e4-404a-9d56-b076f100089&title=&width=808" alt="image.png"></p><h3 id="JSON-REPLACE"><a href="#JSON-REPLACE" class="headerlink" title="JSON_REPLACE"></a><strong>JSON_REPLACE</strong></h3><p>JSON_REPLACE(json_doc, path, val[, path, val] …)，该方法用于替换已经存在的值，如果该值不存在那么不会进行替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_replace(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;, 6, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339733503-924ed095-bccf-4557-9ab7-df4e268b2d28.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=139&id=ud7187169&originHeight=209&originWidth=1275&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24113&status=done&style=none&taskId=ufef2c797-2f54-4cf1-bafb-090d6a9cacf&title=&width=850" alt="image.png"></p><h3 id="JSON-ARRAY-APPEND"><a href="#JSON-ARRAY-APPEND" class="headerlink" title="JSON_ARRAY_APPEND"></a><strong>JSON_ARRAY_APPEND</strong></h3><p>JSON_ARRAY_APPEND(json_doc, path, val[, path, val] …)，用于向数组的指定位置追加元素，请注意，如果指定的 path 不存在，那么将不会添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[0]&#x27;, 1);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345664066-ac5a7a83-406a-44c1-a559-7f5637d884b1.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=142&id=u5a937e88&originHeight=213&originWidth=979&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19658&status=done&style=none&taskId=uab0421bb-3f3a-439e-a710-f111f85e77e&title=&width=652.6666666666666" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[1][0]&#x27;, 2);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345710645-3568c0c7-19cf-465d-bcfb-473ea3bb41f5.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=140&id=u27f0a147&originHeight=210&originWidth=1011&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20280&status=done&style=none&taskId=u6d880c30-e69b-4cc4-9fda-3629d50301f&title=&width=674" alt="image.png"><br>现在我们尝试修改一个不存在的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[3]&#x27;, 3);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345746637-12505391-8bb7-41c2-8993-4d6098d21d9d.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=137&id=ub88f6388&originHeight=206&originWidth=978&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18946&status=done&style=none&taskId=u64c21c13-ed75-4b12-905d-d7208b0470c&title=&width=652" alt="image.png"><br>前面提到的都是JSON数组，接下来我们看一下JSON对象，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: 4&#125;&#x27;, &#x27;$.b&#x27;, &#x27;x&#x27;, &#x27;$&#x27;, &#x27;z&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346023296-dd896e22-0100-427e-ab8f-3c767fd47fa5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u13ad2a4a&originHeight=207&originWidth=1234&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23876&status=done&style=none&taskId=u0ed68f36-0614-4206-bcf6-34600a16527&title=&width=822.6666666666666" alt="image.png"></p><h3 id="JSON-ARRAY-INSERT"><a href="#JSON-ARRAY-INSERT" class="headerlink" title="JSON_ARRAY_INSERT"></a><strong>JSON_ARRAY_INSERT</strong></h3><p>JSON_ARRAY_INSERT(json_doc, path, val[, path, val] …)，用于向数组的指定位置插入元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[0]&#x27;, 1);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346205592-a066b414-9425-4c56-93a2-0ebe9f59f641.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u078d1649&originHeight=208&originWidth=1058&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21498&status=done&style=none&taskId=ubed87693-0a5e-44c3-8e49-22d2dcb6da6&title=&width=705.3333333333334" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[1]&#x27;, cast(&#x27;[1,2,3]&#x27; as json));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346311046-86b0334a-0ccc-417b-a3b2-939294be46c3.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u632adfca&originHeight=209&originWidth=1370&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26359&status=done&style=none&taskId=u25b793a8-c0a1-482c-ab1c-06057d7a8ae&title=&width=913.3333333333334" alt="image.png"><br>接下来我们尝试往数组中不存在的索引位置处插入一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[8]&#x27;, 2);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346416270-1026a48d-0248-4e89-bd30-716523dd20e6.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=135&id=u14e9c78b&originHeight=203&originWidth=1042&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21352&status=done&style=none&taskId=u7c933517-d0e9-4a6b-91e3-a697237429b&title=&width=694.6666666666666" alt="image.png"><br>可以看到此时即使用户传入的下标超出了数组的索引，但是依旧能插入元素，只是在数组末尾进行了插入。</p><h3 id="JSON-MERGE-PATCH"><a href="#JSON-MERGE-PATCH" class="headerlink" title="JSON_MERGE_PATCH"></a><strong>JSON_MERGE_PATCH</strong></h3><p>JSON_MERGE_PATCH(json_doc, json_doc[, json_doc] …)，它是MySQL 8.0.3版本 引入的，用于合并多个 JSON 文档。合并规则如下：<br>（1）如果两个文档不全是 JSON 对象，那么合并后的结果是第二个文档。<br>（2）如果两个文档都是 JSON 对象，且不存在同名 KEY，那么合并后的文档包括两个文档的所有元素；如果存在同名 KEY，那么第二个文档的值会覆盖第一个。<br>首先看第一点，这里我们尝试合并两个JSON数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;[1, 2]&#x27;, &#x27;[3, 4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346915784-8081947d-9f96-44f3-a024-aac1b2fca1ee.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=ucd346278&originHeight=218&originWidth=721&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15479&status=done&style=none&taskId=ufd3bdab3-0bcf-417f-86de-b35fd358231&title=&width=480.6666666666667" alt="image.png"><br>接着我们尝试将一个JOSN数组和一个JSON对象进行合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;[1, 2]&#x27;, &#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347000216-9177fb63-ae94-4b23-9456-d898049713a0.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=141&id=u1c60e98f&originHeight=212&originWidth=924&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19436&status=done&style=none&taskId=u7ce1ab6c-55ce-4ff4-b608-2c2962f6a67&title=&width=616" alt="image.png"><br>然后我们尝试合并两个JSON对象，这两个JSON对象不存在同名的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;, &#x27;&#123;&quot;b&quot;: 2&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347172411-a430c420-4f6a-4af6-bab0-d183adbf9025.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=144&id=ud130e65f&originHeight=216&originWidth=784&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16907&status=done&style=none&taskId=u09b8fa88-3b67-4bbc-95fb-904d2cab7e6&title=&width=522.6666666666666" alt="image.png"><br>接着我们尝试合并两个JSON对象，注意这两个JSON对象存在同名的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;:2 &#125;&#x27;,&#x27;&#123; &quot;a&quot;: 3, &quot;c&quot;:4 &#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347291515-bf8293d3-6fa6-4ec2-946e-68d02fc10df9.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=140&id=u962229bf&originHeight=210&originWidth=1019&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19831&status=done&style=none&taskId=u18d35517-21ed-4957-b83d-2c4103baf6c&title=&width=679.3333333333334" alt="image.png"><br>请注意，如果第二个文档中存在 null 值，那么文档合并后不会输出对应的 KEY，这一点需要引起注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&#x27;, &#x27;&#123;&quot;a&quot;:3, &quot;b&quot;:null&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347411910-197ae876-b9d8-4d33-9ab3-6e3ce60030ac.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=u6affd741&originHeight=204&originWidth=993&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18930&status=done&style=none&taskId=uc6ec4f57-ff87-4541-94aa-f7963cefe6e&title=&width=662" alt="image.png"></p><h3 id="JSON-MERGE-PRESERVE"><a href="#JSON-MERGE-PRESERVE" class="headerlink" title="JSON_MERGE_PRESERVE"></a><strong>JSON_MERGE_PRESERVE</strong></h3><p>JSON_MERGE_PRESERVE(json_doc, json_doc[, json_doc] …)，它是自MySQL 8.0.3版本 引入的，用于代替 JSON_MERGE。它也是用来合并文档，但合并规则与 JSON_MERGE_PATCH 有所不同，具体如下：<br>（1）两个文档中，只要有一个文档是数组，那么就会将另一个文档合并到该数组中；<br>（2）两个文档都是 JSON 对象，如果存在同名 KEY ，那么第二个文档并不会覆盖第一个，而是会将值 append 到第一个文档中。<br>先看第一点，如下所示的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;1&#x27;,&#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347913733-162e1c2b-f622-44bb-b289-1d86b05b85d7.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=137&id=u16b8f1bd&originHeight=206&originWidth=598&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12633&status=done&style=none&taskId=ue20702ff-23e6-4297-84b6-60ca46ead5b&title=&width=398.6666666666667" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;[1, 2]&#x27;, &#x27;[3, 4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347981109-eb6e32c1-217e-4ae5-be76-348631bb5dd6.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=140&id=u4055182c&originHeight=210&originWidth=767&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15682&status=done&style=none&taskId=u32a06f02-60d5-45ee-8f00-be81d3adbc2&title=&width=511.3333333333333" alt="image.png"><br>再来看一个例子，这个例子看起来更清晰一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;[1, 2]&#x27;, &#x27;&#123;&quot;a&quot;: 1234&#125;&#x27;), json_merge_preserve(&#x27;&#123;&quot;a&quot;: 1234&#125;&#x27;, &#x27;[3,4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348086960-605750c4-30b2-4f13-8766-6ef3f2c35cc4.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=141&id=u5385a835&originHeight=212&originWidth=1466&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26424&status=done&style=none&taskId=u37dd13b5-2f65-4bce-96c6-c072d25920f&title=&width=977.3333333333334" alt="image.png"><br>再来看一个比较复杂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;, &#x27;&#123;&quot;b&quot;: 2&#125;&#x27;), json_merge_preserve(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;:2 &#125;&#x27;,&#x27;&#123; &quot;a&quot;: 3, &quot;c&quot;:4 &#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348180174-8c4d57d2-168c-4b06-880b-ee75aba068eb.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=ub0e52592&originHeight=208&originWidth=1690&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28264&status=done&style=none&taskId=uebc5b683-cecf-4c16-94f9-0d40d6b1721&title=&width=1126.6666666666667" alt="image.png"></p><h3 id="JSON-MERGE"><a href="#JSON-MERGE" class="headerlink" title="JSON_MERGE"></a>JSON_MERGE</h3><p>JSON_MERGE(json_doc, json_doc[, json_doc] …)，与 JSON_MERGE_PRESERVE 作用一样，不过自 MySQL 8.0.3版本开始就不建议使用，后续会移除。</p><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><h3 id="JSON-REMOVE"><a href="#JSON-REMOVE" class="headerlink" title="JSON_REMOVE"></a><strong>JSON_REMOVE</strong></h3><p>JSON_REMOVE(json_doc, path[, path] …)，该方法用于删除 JSON 文档中指定位置的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339891455-9e6363ee-6f39-4e07-84c4-5dbf32dc2d1e.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=u7b55d02b&originHeight=212&originWidth=879&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18186&status=done&style=none&taskId=ufc22c531-d718-4d42-a319-e41dff9d945&title=&width=586" alt="image.png"><br>再来一个删除数组中指定位置元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;, &quot;e&quot;]&#x27;, &#x27;$[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692340892323-9c8f16ee-5215-4d60-a05d-39382bdc91d9.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=144&id=ua9df5050&originHeight=216&originWidth=925&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17855&status=done&style=none&taskId=ub723ef8a-5c3c-4413-b340-6e17a53ad68&title=&width=616.6666666666666" alt="image.png"><br>再来看一个同时删除对象和数组中指定位置元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;, &quot;e&quot;]&#x27;, &#x27;$[1]&#x27;, &#x27;$[2]&#x27;);</span><br></pre></td></tr></table></figure><p>请注意，这里指定删除两个位置的元素，相对应的元素索引是在前面操作后结果的基础上，不是在原始JSON文档的索引基础上进行的操作，执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341094925-8e223504-4cf3-41bc-87ec-53edc5930227.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=143&id=u46442776&originHeight=214&originWidth=1043&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19062&status=done&style=none&taskId=u95170264-b078-475d-bda7-092e74dac8d&title=&width=695.3333333333334" alt="image.png"></p><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><h3 id="JSON-QUOTE"><a href="#JSON-QUOTE" class="headerlink" title="JSON_QUOTE"></a><strong>JSON_QUOTE</strong></h3><p>JSON_QUOTE(string)，用于生成有效的 JSON 字符串，主要是对一些特殊字符（如双引号）进行转义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_quote(&#x27;null&#x27;), json_quote(&#x27;&quot;null&quot;&#x27;), json_quote(&#x27;[1, 2, 3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348491206-41c5a161-c952-41ac-9543-149116ff719b.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=147&id=ucdfe8513&originHeight=220&originWidth=1146&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20698&status=done&style=none&taskId=ud060081b-d772-4027-9e8e-020df6427a5&title=&width=764" alt="image.png"><br>当然了，还可以通过 CAST(value AS JSON) 来进行类型转换。</p><h3 id="JSON-UNQUOTE"><a href="#JSON-UNQUOTE" class="headerlink" title="JSON_UNQUOTE"></a><strong>JSON_UNQUOTE</strong></h3><p>JSON_UNQUOTE(json_val)，用于将 JSON 转义成字符串输出。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2-&gt;&#x27;$.ename&#x27;,json_unquote(t2-&gt;&#x27;$.ename&#x27;),json_valid(t2-&gt;&#x27;$.ename&#x27;),json_valid(json_unquote(t2-&gt;&#x27;$.ename&#x27;)) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692580154218-0c05e45a-e405-414e-b5dc-adf85c065372.png#averageHue=%23171717&clientId=u79b58c88-76cc-4&from=paste&height=179&id=u49e085e0&originHeight=268&originWidth=1917&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34153&status=done&style=none&taskId=u9a5d7783-b124-483c-8da6-170a57df4c6&title=&width=1278" alt="image.png"><br>从执行结果中看，没使用 JSON_UNQUOTE 函数，那么字符串会用双引号引起来。而加了 JSON_UNQUOTE 函数，字符串就没有用双引号括起来。但本质上，前者是 JSON 中的 STRING 类型，后者是 MySQL 中的字符类型，这一点可通过 JSON_VALID 函数来进行判断。</p><h3 id="JSON-OBJECTAGG"><a href="#JSON-OBJECTAGG" class="headerlink" title="JSON_OBJECTAGG"></a><strong>JSON_OBJECTAGG</strong></h3><p>JSON_OBJECTAGG(key, value)方法，用于取表中的两列作为参数，其中第一列是 key，第二列是 value，并以JSON 对象进行返回。举个例子，如下所示的数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_json2;</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| t2                               | name | age  |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| &#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125; | jack |   20 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125; | mark |   19 |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试使用 json_objectagg() 方法，将name和age组成一个JOSN对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_objectagg(name, age) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692580712946-dad69137-51f5-4750-af3a-1f48721b11ab.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=135&id=uab645cb8&originHeight=202&originWidth=758&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15891&status=done&style=none&taskId=u0488156a-6350-4f3d-bcfa-554115d7b0c&title=&width=505.3333333333333" alt="image.png"></p><h3 id="JSON-ARRAYAGG"><a href="#JSON-ARRAYAGG" class="headerlink" title="JSON_ARRAYAGG"></a><strong>JSON_ARRAYAGG</strong></h3><p>JSON_ARRAYAGG(col_or_expr)方法，用于将列的值聚合成 JSON 数组，请注意 JSON 数组中元素的顺序是随机的。</p><p>举个例子，如下所示的数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_json2;</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| t2                               | name | age  |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| &#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125; | jack |   20 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125; | mark |   19 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1003, &quot;ename&quot;: &quot;book&quot;&#125; | book |   22 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1004, &quot;ename&quot;: &quot;yook&quot;&#125; | yook |   25 |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试使用 json_arrayagg() 方法，将 age 列的值聚合为一个JOSN数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name ,json_arrayagg(age) from tb_json2 group by name;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581144794-0614391d-0c27-41ee-b353-2639be0236fb.png#averageHue=%23151515&clientId=u79b58c88-76cc-4&from=paste&height=196&id=u43f1cbe2&originHeight=294&originWidth=950&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23359&status=done&style=none&taskId=uc273fecd-8264-4127-9495-e1a975cfd10&title=&width=633.3333333333334" alt="image.png"></p><h3 id="JSON-PRETTY"><a href="#JSON-PRETTY" class="headerlink" title="JSON_PRETTY"></a><strong>JSON_PRETTY</strong></h3><p>JSON_PRETTY(json_val)方法，用于格式化 JSON 。首先看一个格式化JSON数组的例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_pretty(&#x27;[1,2,3,4,5]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581319413-3e864613-ad61-4bf2-b207-6dfed6848002.png#averageHue=%23131313&clientId=u79b58c88-76cc-4&from=paste&height=258&id=u438e3226&originHeight=387&originWidth=590&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17421&status=done&style=none&taskId=ud6780927-47eb-4432-b831-4a9282de08d&title=&width=393.3333333333333" alt="image.png"><br>再来看一个格式化JSON对象的例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_pretty(&#x27;&#123;&quot;a&quot;: 1,&quot;b&quot;: 2,&quot;c&quot;:3&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581447956-d48747ff-3c44-400e-a55d-4aebec4ea710.png#averageHue=%23141414&clientId=u79b58c88-76cc-4&from=paste&height=216&id=u38f102fb&originHeight=324&originWidth=728&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19288&status=done&style=none&taskId=u108cffc0-dc1e-4148-a601-b9811d8be31&title=&width=485.3333333333333" alt="image.png"></p><h3 id="JSON-STORAGE-FREE"><a href="#JSON-STORAGE-FREE" class="headerlink" title="JSON_STORAGE_FREE"></a><strong>JSON_STORAGE_FREE</strong></h3><p>JSON_STORAGE_FREE(json_val)，该方法是MySQL 8.0 新增的，与 Partial Updates 有关，用于计算 JSON 文档在进行部分更新后的剩余空间。</p><h3 id="JSON-STORAGE-SIZE"><a href="#JSON-STORAGE-SIZE" class="headerlink" title="JSON_STORAGE_SIZE"></a><strong>JSON_STORAGE_SIZE</strong></h3><p>JSON_STORAGE_SIZE(json_val)，该方法是MySQL 5.7.22 引入的，用于计算 JSON 文档的空间使用情况。</p><h3 id="JSON-DEPTH"><a href="#JSON-DEPTH" class="headerlink" title="JSON_DEPTH"></a><strong>JSON_DEPTH</strong></h3><p>JSON_DEPTH(json_doc)，该方法用于返回 JSON 文档的最大深度。请注意，对于空数组，空对象，标量值，其深度为 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_depth(&#x27;&#123;&#125;&#x27;), json_depth(&#x27;[1,2,3]&#x27;), josn_depth(&#x27;[1,&#123;&quot;a&quot;: 2&#125;]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581778951-609ae0fa-06f0-4d37-ad2f-d9534580475e.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u2dd097f6&originHeight=206&originWidth=1153&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20263&status=done&style=none&taskId=u960b7de1-3af1-4792-aea2-edd1a2e59ac&title=&width=768.6666666666666" alt="image.png"></p><h3 id="JSON-LENGTH"><a href="#JSON-LENGTH" class="headerlink" title="JSON_LENGTH"></a><strong>JSON_LENGTH</strong></h3><p>JSON_LENGTH(json_doc[, path])，该方法用于返回 JSON 文档的长度，计算规则如下：<br>（1）如果是标量值，其长度为 1；<br>（2）如果是数组，其长度为数组元素的个数；<br>（3）如果是对象，其长度为对象元素的个数；<br>（4）不包括嵌套数据和嵌套对象的长度。<br>接下来我们通过案例来演示上述计算规则的使用。首先是标量值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&quot;abcd&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582089291-856a250e-8cf2-4f35-aa3d-8c8a27fbb0b7.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=139&id=ud0068afe&originHeight=208&originWidth=512&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11277&status=done&style=none&taskId=ub493d140-26c1-4a2f-b897-1b27d658102&title=&width=341.3333333333333" alt="image.png"><br>看一个纯数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;[1,2,3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582523263-931e5d62-b255-4c1c-9441-ea64ce2f95e1.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=142&id=u77670965&originHeight=213&originWidth=535&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12025&status=done&style=none&taskId=u2d820909-c2e6-4ac1-b3e9-1b8152155b7&title=&width=356.6666666666667" alt="image.png"><br>看一个纯对象的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;sex&quot;: &quot;female&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582620978-a7359073-5592-4f8f-870a-1c0f12bff045.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=141&id=ua9c62b1b&originHeight=212&originWidth=951&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17321&status=done&style=none&taskId=u6fb56b42-42a7-40af-8fe8-ed3fa24d1b1&title=&width=634" alt="image.png"><br>来看一个数组和对象混用的例子，注意它不包括嵌套数据和嵌套对象的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;[1,2,3,&#123;&quot;name&quot;: &quot;wanger&quot;, &quot;sex&quot;: &quot;male&quot;&#125;]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582768400-9e6cf437-78a9-47d2-bee2-d0d983dedf8c.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=135&id=u1a127da5&originHeight=203&originWidth=994&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18743&status=done&style=none&taskId=u25969ded-4f3f-492d-8b1f-79cab3ac7f3&title=&width=662.6666666666666" alt="image.png"><br>再看一个对象和对象混用的例子，注意它同样不包括嵌套数据和嵌套对象的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;hobby&quot;:&#123;&quot;language&quot;: &quot;english&quot;,&quot;boll&quot;:&quot;footboll&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582951088-fbf5ec4b-ef9a-4522-9cbc-64e6b482fc1e.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=144&id=ud744c117&originHeight=216&originWidth=1391&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24111&status=done&style=none&taskId=u762334fe-06e8-4935-8e0e-7aa8385af2e&title=&width=927.3333333333334" alt="image.png"><br>我们尝试输出hobby这个对象的长度，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;hobby&quot;:&#123;&quot;language&quot;: &quot;english&quot;,&quot;boll&quot;:&quot;footboll&quot;&#125;&#125;&#x27;,&#x27;$.hobby&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583139153-0023cd5f-8a9b-4743-82a9-d5b4098b389c.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u07999bba&originHeight=206&originWidth=1539&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25966&status=done&style=none&taskId=u994018e9-6c7e-4402-98b2-7c162ee44c9&title=&width=1026" alt="image.png"></p><h3 id="JSON-TYPE"><a href="#JSON-TYPE" class="headerlink" title="JSON_TYPE"></a><strong>JSON_TYPE</strong></h3><p>JSON_TYPE(json_val)，该方法用于返回 JSON 值的类型。首先看一个JSON整型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(&#x27;12345&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583417931-9854fce7-049b-48e7-a4c9-159660635190.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=142&id=u8e6c7f99&originHeight=213&originWidth=489&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11986&status=done&style=none&taskId=u4ffe10ba-d1e2-4150-b220-326548a7fe1&title=&width=326" alt="image.png"><br>再看一个JSON字符串类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(&#x27;&quot;abcd&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583545781-30ae4848-5860-4f9a-bb7e-89d8c46b8c55.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=139&id=u89b81e93&originHeight=209&originWidth=473&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11577&status=done&style=none&taskId=u9bd95972-1d0d-49d0-8e32-0db106491b8&title=&width=315.3333333333333" alt="image.png"><br>再看一个JOSN时间类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(cast(now() as json));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583596058-972bc826-7790-455f-9735-84e8c3ae5aa7.png#averageHue=%231b1b1b&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u3cf30eb9&originHeight=205&originWidth=642&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13849&status=done&style=none&taskId=u779c3404-fb0d-4a31-a878-2e0b7f2c2da&title=&width=428" alt="image.png"><br>再看一个JOSN数组类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(json_extract(&#x27;&#123;&quot;a&quot;: [1234, false, &quot;1234&quot;]&#125;&#x27;, &#x27;$.a&#x27;));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583671242-fedddf22-f1ce-4b3d-9839-51562a7071cd.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=135&id=u3d156918&originHeight=203&originWidth=1082&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20518&status=done&style=none&taskId=u1f588aac-0fe9-4d6c-8150-53ab496abb9&title=&width=721.3333333333334" alt="image.png"></p><h3 id="JSON-VALID"><a href="#JSON-VALID" class="headerlink" title="JSON_VALID"></a><strong>JSON_VALID</strong></h3><p>JSON_VALID(val)，该方法用于判断给定值是否为有效的 JSON 文档。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_valid(&#x27;hello&#x27;), json_valid(&#x27;&quot;hello&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583793642-42a978b7-6514-4144-bb82-fad5e573ba70.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=140&id=u0353df04&originHeight=210&originWidth=813&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14873&status=done&style=none&taskId=u904b1330-310c-4334-9d45-ea18aeb79fa&title=&width=542" alt="image.png"></p><h3 id="JSON-TABLE"><a href="#JSON-TABLE" class="headerlink" title="JSON_TABLE"></a><strong>JSON_TABLE</strong></h3><p>JSON_TABLE(expr, path COLUMNS (column_list) [AS] alias)，该方法用于从 JSON 文档中提取数据并以表格形式返回。</p><p>该方法的完整语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JSON_TABLE(</span><br><span class="line">    expr,</span><br><span class="line">    path COLUMNS (column_list)</span><br><span class="line">)   [AS] alias</span><br><span class="line"></span><br><span class="line">column_list:</span><br><span class="line">    column[, column][, ...]</span><br><span class="line"></span><br><span class="line">column:</span><br><span class="line">    name FOR ORDINALITY</span><br><span class="line">    |  name type PATH string_path [on_empty] [on_error]</span><br><span class="line">    |  name type EXISTS PATH string_path</span><br><span class="line">    |  NESTED [PATH] path COLUMNS (column_list)</span><br><span class="line"></span><br><span class="line">on_empty:</span><br><span class="line">    &#123;NULL | DEFAULT json_string | ERROR&#125; ON EMPTY</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line">    &#123;NULL | DEFAULT json_string | ERROR&#125; ON ERROR</span><br></pre></td></tr></table></figure><p>解释一下上述各个参数的含义：</p><ul><li>expr：可返回 JSON 文档的表达式。它可以是一个标量（ JSON 文档 ），列名或者一个函数调用（ JSON_EXTRACT(t1.json_data,’$.post.comments’) ）。</li><li>path：JSON 的路径表达式。</li><li>column：列的类型，支持以下四种类型：<ul><li>name FOR ORDINALITY：序号。name 是列名。</li><li>name type PATH string_path [on_empty] [on_error]：提取指定路径（ string_path ）的元素。name 是列名，type 是 MySQL 中的数据类型。</li><li>name type EXISTS PATH string_path：指定路径（ string_path ）的元素是否存在。</li><li>NESTED [PATH] path COLUMNS (column_list)：将嵌套对象或数组与来自父对象或数组的 JSON 值扁平化为一行输出。</li></ul></li></ul><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">json_table (</span><br><span class="line">&#x27;[&#123;&quot;x&quot;:2, &quot;y&quot;:&quot;8&quot;, &quot;z&quot;:9, &quot;b&quot;:[1,2,3]&#125;, &#123;&quot;x&quot;:&quot;3&quot;, &quot;y&quot;:&quot;7&quot;&#125;, &#123;&quot;x&quot;:&quot;4&quot;, &quot;y&quot;:6, &quot;z&quot;:10&#125;]&#x27;,</span><br><span class="line">&quot;$[*]&quot; COLUMNS (</span><br><span class="line">id FOR ordinality,</span><br><span class="line">xval VARCHAR ( 100 ) path &quot;$.x&quot;,</span><br><span class="line">yval VARCHAR ( 100 ) path &quot;$.y&quot;,</span><br><span class="line">z_exist INT EXISTS path &quot;$.z&quot;,</span><br><span class="line">nested path &#x27;$.b[*]&#x27; COLUMNS ( b INT PATH &#x27;$&#x27; ) </span><br><span class="line">) </span><br><span class="line">) AS t;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692584362428-64ceaaaa-d934-4c64-9517-e692107eb301.png#averageHue=%23121212&clientId=u79b58c88-76cc-4&from=paste&height=430&id=u04282bb6&originHeight=645&originWidth=1401&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=63070&status=done&style=none&taskId=u758fe789-a9e1-466e-809e-117c6f21e29&title=&width=934" alt="image.png"></p><h3 id="JSON-SCHEMA-VALID"><a href="#JSON-SCHEMA-VALID" class="headerlink" title="JSON_SCHEMA_VALID"></a><strong>JSON_SCHEMA_VALID</strong></h3><p>JSON_SCHEMA_VALID(schema,document)，该方法用于判断 document （ JSON 文档 ）是否满足 schema （ JSON 对象）定义的规范要求。完整的规范要求可参考 <a href="https://json-schema.org/specification-links.html#draft-4">Draft 4 of the JSON Schema specification</a>。如果不满足，可通过 JSON_SCHEMA_VALIDATION_REPORT() 方法来获取具体的原因。</p><p>举个例子，如下所示的 schema 信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set @schema = &#x27;&#123;</span><br><span class="line">   &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">   &quot;properties&quot;: &#123;</span><br><span class="line">     &quot;latitude&quot;: &#123;</span><br><span class="line">       &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">       &quot;minimum&quot;: -90,</span><br><span class="line">       &quot;maximum&quot;: 90</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;longitude&quot;: &#123;</span><br><span class="line">       &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">       &quot;minimum&quot;: -180,</span><br><span class="line">       &quot;maximum&quot;: 180</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;required&quot;: [&quot;latitude&quot;, &quot;longitude&quot;]</span><br><span class="line">&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>从 schema 中可以看出如下信息：<br>（1）document 必须是 JSON 对象；<br>（2）JSON 对象必须有 latitude 和 longitude 这两个属性；<br>（3）latitude 和 longitude 必须是数值类型，且两者的大小分别在 -90 ～ 90，-180 ～ 180 之间。<br>那么接下来我们就通过定义一个document，并通过 json_schema_valid() 方法来验证document 是否满足 schema 定义的规范要求，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @schema = &#x27;&#123;</span><br><span class="line">    &#x27;&gt;    &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">    &#x27;&gt;    &quot;properties&quot;: &#123;</span><br><span class="line">    &#x27;&gt;      &quot;latitude&quot;: &#123;</span><br><span class="line">    &#x27;&gt;        &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">    &#x27;&gt;        &quot;minimum&quot;: -90,</span><br><span class="line">    &#x27;&gt;        &quot;maximum&quot;: 90</span><br><span class="line">    &#x27;&gt;      &#125;,</span><br><span class="line">    &#x27;&gt;      &quot;longitude&quot;: &#123;</span><br><span class="line">    &#x27;&gt;        &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">    &#x27;&gt;        &quot;minimum&quot;: -180,</span><br><span class="line">    &#x27;&gt;        &quot;maximum&quot;: 180</span><br><span class="line">    &#x27;&gt;      &#125;</span><br><span class="line">    &#x27;&gt;    &#125;,</span><br><span class="line">    &#x27;&gt;    &quot;required&quot;: [&quot;latitude&quot;, &quot;longitude&quot;]</span><br><span class="line">    &#x27;&gt; &#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 63.564456,&quot;longitude&quot;: 10.237812&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     1 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从上面执行结果中可以看出，验证是通过的。接下来我们尝试定义一个 document ，它只传入latitude这一个参数，可以看到验证是不通过的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 63.564456&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     0 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试输出一下错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_pretty(json_schema_validation_report(@schema, @document))\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">json_pretty(json_schema_validation_report(@schema, @document)): &#123;</span><br><span class="line">  &quot;valid&quot;: false,</span><br><span class="line">  &quot;reason&quot;: &quot;The JSON document location &#x27;#&#x27; failed requirement &#x27;required&#x27; at JSON Schema location &#x27;#&#x27;&quot;,</span><br><span class="line">  &quot;schema-location&quot;: &quot;#&quot;,</span><br><span class="line">  &quot;document-location&quot;: &quot;#&quot;,</span><br><span class="line">  &quot;schema-failed-keyword&quot;: &quot;required&quot;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>可以看到这里的原因就是缺少longitude参数，那么接下来我们尝试传入longitude参数，但是取值我们又取错误的值，然后再来测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 96, &quot;longitude&quot;: 0&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     0 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_pretty(json_schema_validation_report(@schema, @document))\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">json_pretty(json_schema_validation_report(@schema, @document)): &#123;</span><br><span class="line">  &quot;valid&quot;: false,</span><br><span class="line">  &quot;reason&quot;: &quot;The JSON document location &#x27;#/latitude&#x27; failed requirement &#x27;maximum&#x27; at JSON Schema location &#x27;#/properties/latitude&#x27;&quot;,</span><br><span class="line">  &quot;schema-location&quot;: &quot;#/properties/latitude&quot;,</span><br><span class="line">  &quot;document-location&quot;: &quot;#/latitude&quot;,</span><br><span class="line">  &quot;schema-failed-keyword&quot;: &quot;maximum&quot;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>从执行结果中也可以看到，验证不通过的原因就是取值超出了属性的可允许取值范围。</p><h1 id="对JSON字段创建索引"><a href="#对JSON字段创建索引" class="headerlink" title="对JSON字段创建索引"></a>对JSON字段创建索引</h1><p>实际上，和 TEXT，BLOB 字段一样，JSON 字段是不允许直接创建索引的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table tb_json3(t1 json, index(t1));</span><br><span class="line">ERROR 3152 (42000): JSON column &#x27;t1&#x27; supports indexing only via generated columns on a specified JSON path.</span><br></pre></td></tr></table></figure><p>实际上即使支持直接创建索引，其意义也不大，一般来说我们都是基于文档中的元素进行查询，很少会基于整个  JSON 文档。如果需要对文档中的元素进行查询，那么就需要使用到 MySQL 5.7 引入的虚拟列及函数索引。</p><p>如下所示，我们新建一个数据表tb_json3，其中t1类型为JOSN，然后t2是虚拟列，之后使用 index (t2) 来对虚拟列t2添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json3(t1 json, t2 varchar(100) as (JSON_UNQUOTE(t1 -&gt; &#x27;$.name&#x27;)), index (t2));</span><br></pre></td></tr></table></figure><p>之后我们往该数据表中插入5条测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_json3 ( t1 )</span><br><span class="line">VALUES</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;lisi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;wanger&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;mazi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 5, &quot;name&quot;: &quot;zhangsanfeng&quot;&#125;&#x27; )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>可以看到此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586568144-6ceee757-ef57-4520-923a-b774bdf73ca7.png#averageHue=%23daad66&clientId=u79b58c88-76cc-4&from=paste&height=115&id=u196a299b&originHeight=173&originWidth=1084&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14014&status=done&style=none&taskId=u9a802a78-9b6b-4522-a919-61d52151d63&title=&width=722.6666666666666" alt="image.png"><br>接下来我们尝试查询姓名为lisi的用户，首先使用虚拟列来进行查询，查看一下执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_json3 where t2 = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure><p>执行一下该执行计划，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586726584-a95d611a-543d-4dfc-8863-c36f0f992862.png#averageHue=%23e7e5e4&clientId=u79b58c88-76cc-4&from=paste&height=43&id=u11f04775&originHeight=65&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11212&status=done&style=none&taskId=u78c47c55-e77d-4210-ab41-3294ed8cc5a&title=&width=948.6666666666666" alt="image.png"><br>接着我们尝试使用文档中的元素来查询，同样也是先看一下执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_json3 where t1 -&gt; &#x27;$.name&#x27; = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure><p>执行一下该执行计划，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586726584-a95d611a-543d-4dfc-8863-c36f0f992862.png#averageHue=%23e7e5e4&from=url&id=I8nlI&originHeight=65&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title="><br>从上述输出结果中可以看到，无论是使用虚拟列，还是文档中的元素来进行查询，它们都会用到索引。<strong>请注意，在创建虚拟列时，需要使用 JSON_UNQUOTE方法，来将 t1 -&gt; “$.name” 的返回值转换为字符串。</strong></p><h1 id="将存储-JSON-字符串的字符字段升级为-JSON-字段"><a href="#将存储-JSON-字符串的字符字段升级为-JSON-字段" class="headerlink" title="将存储 JSON 字符串的字符字段升级为 JSON 字段"></a>将存储 JSON 字符串的字符字段升级为 JSON 字段</h1><p>在 MySQL 支持 JSON 类型之前，对于 JSON 文档，一般是以字符串的形式存储在字符类型中（VARCHAR 或 TEXT）。</p><p>现在问题来了，在 JSON 类型出来后，如何将这些字符字段升级为 JSON 字段呢？为了学习的需要，这里先构建测试表和数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table tb_json4 (id int auto_increment primary key, t1 text);</span><br><span class="line"></span><br><span class="line">insert into tb_json4 (t1) values (&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;a&quot;&#125;&#x27;),</span><br><span class="line">(&#x27;&#123;&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;b&quot;&#125;&#x27;), </span><br><span class="line">(&#x27;&#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;c&quot;&#125;&#x27;), </span><br><span class="line">(&#x27;&#123;&quot;id&quot;, &quot;name&quot;: &quot;d&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>注意，第4条记录的json数据是有问题的，不符合JSON格式的要求，这里先不管，后面会进行修改，此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587376783-6e20adef-3bb1-4d15-b01a-e02d22ca5a9a.png#averageHue=%23d7aa63&clientId=u79b58c88-76cc-4&from=paste&height=97&id=uf90650c6&originHeight=146&originWidth=326&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6336&status=done&style=none&taskId=udba0c808-d0fa-433b-adf7-387d82d0bdb&title=&width=217.33333333333334" alt="image.png"><br>接着，修改t1字段的类型。如果我们直接使用 DDL语句来修改字段的数据类型，那么它会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb_json4 modify t1 json;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587501344-bcad7f89-50b3-4131-9929-3e0700dab460.png#averageHue=%231e1e1e&clientId=u79b58c88-76cc-4&from=paste&height=42&id=u64da4e51&originHeight=63&originWidth=1967&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17188&status=done&style=none&taskId=u4ed803c8-7e60-4186-b984-e193fa36e23&title=&width=1311.3333333333333" alt="image.png"><br>所以我们需要另一种方式来修改t1字段的类型，对应的修改步骤如下所示：<br>第一步，使用 json_valid 方法找出不满足 JSON 格式要求的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_json4 where json_valid(t1) = 0;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587645354-6af19a3f-6c69-4a18-ac1a-c827fbd33aa8.png#averageHue=%23171717&clientId=u79b58c88-76cc-4&from=paste&height=137&id=ubf6140ce&originHeight=206&originWidth=777&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14531&status=done&style=none&taskId=ud2e56a09-ca4d-478e-99e9-f4a593191be&title=&width=518" alt="image.png"><br>第二步，处理不满足 JSON 格式要求的文档。接着我们就需要使用DDL语句来修改不满足JSON格式要求的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json4 set t1 = &#x27;&#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;d&quot;&#125;&#x27; where id = 4;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587815313-7c36a49c-e1a8-4a53-b08d-130c0c96a059.png#averageHue=%231e1e1e&clientId=u79b58c88-76cc-4&from=paste&height=82&id=u261c52d8&originHeight=123&originWidth=1017&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19320&status=done&style=none&taskId=u56267011-364f-4215-af6b-e16644b4c03&title=&width=678" alt="image.png"><br>第三步，将 TEXT 字段修改为 JSON 字段。现在我们再次检查是否存在不符合JSON格式要求的文档，执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587923081-d20ed51b-2aee-459c-b1a3-4a2d49658bed.png#averageHue=%231f1f1f&clientId=u79b58c88-76cc-4&from=paste&height=40&id=uc5c9ea84&originHeight=60&originWidth=777&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7690&status=done&style=none&taskId=u783248f9-4b9c-40b9-9df3-986aee622db&title=&width=518" alt="image.png"><br>之后我们就可以修改t1字段的类型了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb_json4 modify t1 json;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587999908-c26ec33d-e133-4f1f-98f0-876163a4fea0.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=339&id=u4df7d335&originHeight=509&originWidth=609&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=36418&status=done&style=none&taskId=u6db2b8fe-bc98-4a7b-bcfd-1e46fe377c9&title=&width=406" alt="image.png"></p><h1 id="使用JSON时的注意事项"><a href="#使用JSON时的注意事项" class="headerlink" title="使用JSON时的注意事项"></a>使用JSON时的注意事项</h1><p>在使用JSON类型时，有如下四个注意事项：<br>（1）在 MySQL 8.0.13 之前，不允许对 BLOB，TEXT，GEOMETRY，JSON 字段设置默认值。而从 MySQL 8.0.13 开始，取则消了这个限制。</p><p>请注意，在设置默认值时，默认值需要由小括号 () 括起来，否则会抛出 JSON 字段不允许设置默认值的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table tb_json5(t1 json not null default &#x27;&#x27;);</span><br><span class="line">ERROR 1101 (42000): BLOB, TEXT, GEOMETRY or JSON column &#x27;t1&#x27; can&#x27;t have a default value</span><br><span class="line"></span><br><span class="line">mysql&gt; create table tb_json5(t1 json not null default (&#x27;&#x27;));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>（2）不允许直接给JSON类型字段创建索引，但可创建函数索引；<br>（3）JSON 列的最大大小和 LONGBLOB（LONGTEXT）一样，都是 4G；<br>（4）插入时，单个文档的大小受到 max_allowed_packet 的限制，该参数最大是 1G。</p><h1 id="Partial-Updates"><a href="#Partial-Updates" class="headerlink" title="Partial Updates"></a>Partial Updates</h1><p>在 MySQL 5.7 中，对于JSON 文档进行更新的策略：先删除旧的文档，再插入新的文档。这种方式效率非常低下，即使这个修改很微小，只涉及几个字节，也会替换掉整个文档。<br>在<br>而在 MySQL 8.0 中，针对 JSON 文档，引入了一项新的特性—Partial Updates（部分更新），它支持 JSON 文档的原地更新。得益于这个特性，JSON 文档的处理性能得到了极大提升。</p><p>如下所示，我们新建一个数据表tb_json6，其中id类型为int，而t1为JSON类型，对应的建表语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json6(id int auto_increment primary key, t1 json);</span><br></pre></td></tr></table></figure><p>之后我们往该数据表中插入5条测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_json6 ( t1 )</span><br><span class="line">VALUES</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;lisi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;wanger&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;mazi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 5, &quot;name&quot;: &quot;zhangsanfeng&quot;&#125;&#x27; )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>可以看到此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692595548155-e6c04598-f311-499a-8073-4a05ca661ec2.png#averageHue=%23f6f4f2&clientId=u79b58c88-76cc-4&from=paste&height=118&id=ua6bae6d6&originHeight=177&originWidth=514&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=10416&status=done&style=none&taskId=u0f4fbdf9-5944-433a-8658-64ecd90c435&title=&width=342.6666666666667" alt="image.png"></p><h3 id="使用-Partial-Updates-的条件"><a href="#使用-Partial-Updates-的条件" class="headerlink" title="使用 Partial Updates 的条件"></a>使用 Partial Updates 的条件</h3><p>（1）被更新的列是 JSON 类型。<br>（2）使用 JSON_SET，JSON_REPLACE，JSON_REMOVE 这三个函数进行 UPDATE 操作。举个例子，如下所示更新语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_remove(t1,&#x27;$.id&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692595783650-78015db6-687d-493f-a857-7ac5ee0182b8.png#averageHue=%231c1c1c&clientId=u79b58c88-76cc-4&from=paste&height=221&id=u50e44b81&originHeight=331&originWidth=603&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24384&status=done&style=none&taskId=uced3a7b2-50e6-496e-832e-9c09a060b8e&title=&width=402" alt="image.png"><br>请注意，如果开发者不使用上述三个函数赋值，而采用手动显式赋值，那么就不会进行部分更新。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;a&quot;&#125;&#x27; where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693187345536-3898cb52-bcd3-46e7-b015-3475f744fcf8.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=220&id=ub19d4dd9&originHeight=330&originWidth=613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24316&status=done&style=none&taskId=u13a560a3-1218-4ef4-9d54-9671b05989e&title=&width=408.6666666666667" alt="image.png"><br>实际上此时它并不是进行部分更新，而是先删除旧的记录，然后再插入了新的记录，这个操作在数据量大的情况下会影响系统性能。<br>（3）输入列和目标列必须是同一列，否则也不会进行部分更新。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t1,&#x27;$.id&#x27;,10) where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693187681967-fbcbc51c-0afc-499d-b53c-7ed1e836e29e.png#averageHue=%231c1c1c&clientId=u6cd2691a-9d9f-4&from=paste&height=218&id=u97dbb472&originHeight=327&originWidth=604&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24488&status=done&style=none&taskId=udd608f00-5d62-4dd6-8eb0-0405b331a41&title=&width=402.6666666666667" alt="image.png"><br>如果我们使用的是下面的语句，那么就不是部分更新了，这里的t2列实际上是不存在的，这里只是为了演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t2,&#x27;$.id&#x27;,10) where id=1;</span><br></pre></td></tr></table></figure><p>（4）变更前后，JSON 文档的空间使用不会增加。举个例子，首先我们查看一下id为1的记录所占用的空间大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188017872-df1d0bdf-471c-4706-8932-87dfb3aaf074.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=135&id=u778fcb6c&originHeight=203&originWidth=1193&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22083&status=done&style=none&taskId=u1ac1389d-05aa-4d6e-838f-c9881e988e0&title=&width=795.3333333333334" alt="image.png"><br>接着我们尝试修改id为1的记录，将id为1的记录中的id属性给去除，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_remove(t1,&#x27;$.id&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>之后我们再次执行查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188165598-36f8a9f0-a672-48b1-a46b-6afb491345f0.png#averageHue=%231a1a1a&clientId=u6cd2691a-9d9f-4&from=paste&height=139&id=u9a538d41&originHeight=208&originWidth=1200&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21752&status=done&style=none&taskId=ube40082d-fce0-4b08-bc39-c8c37d8667f&title=&width=800" alt="image.png"><br>接下来我们使用json_set函数来更新JSON文档，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_set(t1,&#x27;$.id&#x27;,10086) where id=1;</span><br></pre></td></tr></table></figure><p>之后我们再次执行查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188346984-51df017f-f4a6-4d74-97b1-ff04666a3c72.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=135&id=u7e7dbc3f&originHeight=203&originWidth=1206&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22636&status=done&style=none&taskId=u752486d4-3892-4759-a7f6-97c54a71714&title=&width=804" alt="image.png"><br>接这我们再次使用json_set函数来更新JSON文档，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_set(t1,&#x27;$.id&#x27;,&#x27;helloworld&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>之后再次执行查询语句，可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188486922-90c1348c-8928-4b2d-939a-cfd8cf0edbc2.png#averageHue=%231a1a1a&clientId=u6cd2691a-9d9f-4&from=paste&height=143&id=u216f73ba&originHeight=215&originWidth=1281&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23839&status=done&style=none&taskId=u760d749e-fcf3-4b22-9f09-462c7bbcf70&title=&width=854" alt="image.png"><br>怎么两次使用json_set函数查询出来的数据有些不一样呢？下面我们将对这些现象进行详细学习。</p><p>在上面的例子中，我们使用了json_storage_size和json_storage_free这两个函数，其中json_storage_size用于获取JSON文档的空间使用情况，而json_storage_free则是用于获取JSON文档在执行原地更新后的空间释放情况。</p><p>从例子中可以看出，我们一共执行了三次更新操作（两次json_set，一次json_remove），其中前两次是原地更新，而第三次不是。那么问题来了，同样使用了json_set方法，为什么第一次是原地更新，而第二次却不是呢？那是因为第一次的json_set复用了json_remove释放的空间，而第二次的json_set执行的是更新操作，且 ‘helloworld’ 比 10086 需要更多的存储空间，因此两次查询获取到的空间使用情况就不一样了。</p><h3 id="如何在-binlog-中开启-Partial-Updates"><a href="#如何在-binlog-中开启-Partial-Updates" class="headerlink" title="如何在 binlog 中开启 Partial Updates"></a>如何在 binlog 中开启 Partial Updates</h3><p>Partial Updates 不仅适用于存储引擎层，还可用于主从复制。主从复制场景下，开启 Partial Updates，只需将binlog_row_value_options参数设置为 PARTIAL_JSON，注意这个参数默认为空。</p><p>下面我们将通过一个案例来学习，同一个 UPDATE 操作，在开启和不开启 Partial Updates情况下，在 binlog 中的记录有什么区别。</p><p>这是UPDATE操作所使用的语句，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t1,&#x27;$.id&#x27;,10) where id = 1;</span><br></pre></td></tr></table></figure><p>以下是未开启Partial Updates时的binlog记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### UPDATE `slowtech`.`tb_json6`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br><span class="line">### SET</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: 10, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>下面是开启了Partial Updates时的binlog记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### UPDATE `slowtech`.`tb_json6`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br><span class="line">### SET</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=JSON_REPLACE(@2, &#x27;$.id&#x27;, 10)</span><br></pre></td></tr></table></figure><p>通过对上述两条binlog记录的对比，可以看出在不开启Partial Updates时，无论是修改前的镜像（before_image）还是修改后的镜像（after_image），记录的都是完整文档。而开启Partial Updates后，对于修改后的镜像，记录的是命令，而不是完整文档，这样可节省近一半的空间。</p><p>开发者在将 binlog_row_value_options 参数设置为 PARTIAL_JSON 后，对于可使用 Partial Updates 的操作，在 binlog 中，不再通过 ROWS_EVENT 来记录，而是新增了一个 PARTIAL_UPDATE_ROWS_EVENT 的事件类型。</p><p><strong>请注意，binlog 中使用 Partial Updates，只需满足存储引擎层使用 Partial Updates 的前三个条件，无需考虑变更前后，JSON 文档的空间使用是否会增加。</strong></p><h3 id="关于-Partial-Updates-的性能测试"><a href="#关于-Partial-Updates-的性能测试" class="headerlink" title="关于 Partial Updates 的性能测试"></a>关于 Partial Updates 的性能测试</h3><p>首先我们构造数据表和数据，假设tb_json7表一共有 16 个文档，每个文档近 10 MB，对应SQL语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json7(id int auto_increment primary key,</span><br><span class="line">               t1 json,</span><br><span class="line">               name varchar(100) as (t1-&gt;&gt;&#x27;$.name&#x27;),</span><br><span class="line">               age int as (t1-&gt;&#x27;$.age&#x27;));</span><br><span class="line"></span><br><span class="line">insert into tb_json7(t1) values</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Joe&#x27;, &#x27;age&#x27;, 24,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;x&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Sue&#x27;, &#x27;age&#x27;, 32,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;y&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Pete&#x27;, &#x27;age&#x27;, 40,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;z&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Jenny&#x27;, &#x27;age&#x27;, 27,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;w&#x27;, 10 * 1000 * 1000)));</span><br><span class="line"></span><br><span class="line">insert into tb_json7(t1) select t1 from tb_json7;</span><br><span class="line">insert into tb_json7(t1) select t1 from tb_json7;</span><br></pre></td></tr></table></figure><p>接着我们尝试测试如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json7 set t1 = json_set(t1, &#x27;$.age&#x27;, age + 1);</span><br></pre></td></tr></table></figure><p>然后在如下四种场景进行执行，并统计对应的执行时间：<br>（1）MySQL 5.7.36；<br>（2）MySQL 8.0.27<br>（3）MySQL 8.0.27，binlog_row_value_options=PARTIAL_JSON<br>（4）MySQL 8.0.27，binlog_row_value_options=PARTIAL_JSON + binlog_row_image=MINIMAL<br>这里我们选择分别执行 10 次，然后去掉最大值和最小值，最后求平均值，得到的结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693190440934-bb38d69a-8d19-4405-b483-7942d9cc96c3.png#averageHue=%2312133a&clientId=u6cd2691a-9d9f-4&from=paste&height=499&id=u2f8c004e&originHeight=749&originWidth=965&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54229&status=done&style=none&taskId=u98fb6391-a999-4738-b96c-69cb585187a&title=&width=643.3333333333334" alt="image.png"><br>请注意，这里我们以 MySQL 5.7.36 的查询时间作为基准：<br>（1）MySQL 8.0 只开启存储引擎层的 Partial Updates，查询时间比 MySQL 5.7 快 1.94 倍。<br>（2）MySQL 8.0 同时开启存储引擎层和 binlog 中的 Partial Updates，查询时间比 MySQL 5.7 快 4.87 倍。<br>（3）如果在 （2）的基础上，同时将 binlog_row_image 设置为 MINIMAL，查询时间更是比 MySQL 5.7 快 102.22 倍。<br>当然，在生产环境，我们一般很少将 binlog_row_image 设置为 MINIMAL。但即便如此，<strong>只开启存储引擎层和 binlog 中的 Partial Updates，查询时间也比 MySQL 5.7 快 4.87 倍，这样看性能提升还是比较明显</strong>。</p><p>参考文章：</p><ol><li><a href="https://zh.wikipedia.org/wiki/JSON">JSON官网</a>；</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html">The JSON Data Type</a>；</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/json-functions.html">JSON Functions</a>；</li><li><a href="https://dev.mysql.com/blog-archive/upgrading-json-data-stored-in-text-columns/">Upgrading JSON data stored in TEXT columns</a>；</li><li><a href="https://dev.mysql.com/blog-archive/indexing-json-documents-via-virtual-columns/">Indexing JSON documents via Virtual Columns</a>；</li><li><a href="https://dev.mysql.com/blog-archive/partial-update-of-json-values/">Partial update of JSON values</a>；</li><li><a href="https://dev.mysql.com/blog-archive/mysql-8-0-innodb-introduces-lob-index-for-faster-updates/">MySQL 8.0: InnoDB Introduces LOB Index For Faster Updates</a>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习MySQL中的JSON数据类型，这在某些场景下比text类型好用很多。&lt;/p&gt;
&lt;h1 id=&quot;JSON&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="mysql" scheme="http://aigoing.chat/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://aigoing.chat/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊六种常用的属性配置读取方式</title>
    <link href="http://aigoing.chat/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/"/>
    <id>http://aigoing.chat/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/</id>
    <published>2024-03-02T02:55:30.000Z</published>
    <updated>2024-05-22T14:01:34.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力有极大帮助。使用的SpringBoot版本为 2.7.11 。</p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><h3 id="Environment简介"><a href="#Environment简介" class="headerlink" title="Environment简介"></a>Environment简介</h3><p>Environment 是 SpringBoot 的核心环境配置接口，它提供了很多方法用于访问应用程序属性，包括系统属性、操作系统环境变量、命令行参数和应用程序配置文件中定义的属性等。源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Environment extends PropertyResolver &#123;</span><br><span class="line">    String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line">    String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean acceptsProfiles(String... profiles);</span><br><span class="line"></span><br><span class="line">    boolean acceptsProfiles(Profiles profiles);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface PropertyResolver &#123;</span><br><span class="line">    boolean containsProperty(String key);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getProperty(String key);</span><br><span class="line"></span><br><span class="line">    String getProperty(String key, String defaultValue);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);</span><br><span class="line"></span><br><span class="line">    String getRequiredProperty(String key) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    String resolvePlaceholders(String text);</span><br><span class="line"></span><br><span class="line">    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个接口继承自 PropertyResolver 接口，PropertyResolver接口中定义了很多获取属性的方法，因此Environment这个接口才具备上述能力。</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>接下来我们通过分析SpringBoot项目在启动时，对配置进行初始化这一过程来深度了解Environment接口的作用。</p><p>我们知道SpringBoot项目在启动时会调用 SpringApplication.run() 方法，而这个方法内部会调用prepareEnvironment()方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690263104622-84102549-40ba-4876-920a-7b58a03d6e1c.png#averageHue=%232d2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=431&id=u75ec017d&originHeight=646&originWidth=1656&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=143909&status=done&style=none&taskId=u7a493edc-491f-4fda-a61b-147fec114a9&title=&width=1104" alt="image.png"><br>查看一下这个prepareEnvironment()方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123;</span><br><span class="line">    /** </span><br><span class="line">    * 1、创建ConfigurableEnvironment对象：调用getOrCreateEnvironment()方法获取或创建ConfigurableEnvironment对象，</span><br><span class="line">    * 该对象用于存储环境参数。如果已经存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的。</span><br><span class="line">    */</span><br><span class="line">    ConfigurableEnvironment environment = this.getOrCreateEnvironment();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 2、解析并加载用户指定的配置文件，将其作为 PropertySource 添加到环境对象中。该方法默认会解析application.properties和application.yml文件，并将其添加到ConfigurableEnvironment对象中。</span><br><span class="line">    * PropertySource或PropertySourcesPlaceholderConfigurer加载应用程序的定制化配置。</span><br><span class="line">    */</span><br><span class="line">    this.configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"></span><br><span class="line">    // 3、加载所有的系统属性，并将它们添加到ConfigurableEnvironment对象中</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">    // 4、通知监听器环境参数已经准备就绪</span><br><span class="line">    listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    *  5、将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值。</span><br><span class="line">    *  还可以避免用户无意中覆盖了SpringBoot提供的默认属性</span><br><span class="line">    */</span><br><span class="line">    DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">    Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;);</span><br><span class="line">    </span><br><span class="line">    // 6、将SpringBoot应用程序的属性绑定到环境对象上，以便能正确地读取和使用这些配置属性</span><br><span class="line">    this.bindToSpringApplication(environment);</span><br><span class="line"></span><br><span class="line">    // 7、如果没有自定义的环境类型，则使用EnvironmentConverter类型将环境对象转换为标准的环境类型，并添加到ConfigurableEnvironment对象中</span><br><span class="line">    if (!this.isCustomEnvironment) &#123;</span><br><span class="line">        EnvironmentConverter environmentConverter = new EnvironmentConverter(this.getClassLoader());</span><br><span class="line">        environment = environmentConverter.convertEnvironmentIfNecessary(environment, this.deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 8、再次加载系统配置，以防止被其他配置覆盖</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的流程：</p><ul><li>创建 ConfigurableEnvironment 环境对象 ，用于存储环境参数；</li><li>调用 configureEnvironment 方法加载默认的 application.properties 和 application.yml 配置文件，以及用户指定的配置文件，并将其封装为 PropertySource 对象添加到环境对象中；</li><li>ConfigurationPropertySources.attach 方法，用于加载所有的系统属性，并将它们添加到环境对象中；</li><li>listeners.environmentPrepared 方法，用于发送环境参数配置已经准备就绪的监听通知；</li><li>DefaultPropertiesPropertySource.moveToEnd 方法，用于将系统默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就能覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性；</li><li>bindToSpringApplication方法，用于将应用程序的属性绑定到Bean对象上；</li><li>ConfigurationPropertySources.attach方法，用于再次加载系统配置，防止被其他配置覆盖。</li></ul><p>下面是对于上述几个比较重要的方法进行详细介绍，如下所示：<br>（1）getOrCreateEnvironment方法的源码如下所示，可以看到该方法会返回一个ConfigurableEnvironment对象，该对象用于存储环境参数。如果已存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的ConfigurableEnvironment对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">    if (this.environment != null) &#123;</span><br><span class="line">        return this.environment;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ConfigurableEnvironment environment = this.applicationContextFactory.createEnvironment(this.webApplicationType);</span><br><span class="line">        if (environment == null &amp;&amp; this.applicationContextFactory != ApplicationContextFactory.DEFAULT) &#123;</span><br><span class="line">            environment = ApplicationContextFactory.DEFAULT.createEnvironment(this.webApplicationType);</span><br><span class="line">        &#125;</span><br><span class="line">        return (ConfigurableEnvironment)(environment != null ? environment : new ApplicationEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）configureEnvironment方法的源码如下所示，可以看到该方法会解析并加载用户指定的配置文件，并将其作为 PropertySource对象添加到环境对象中。configureEnvironment方法默认会解析<code>application.properties</code>和 <code>application.yml</code>文件，并将其添加到ConfigurableEnvironment对象中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    if (this.addConversionService) &#123;</span><br><span class="line">        environment.setConversionService(new ApplicationConversionService());</span><br><span class="line">    &#125;</span><br><span class="line">    this.configurePropertySources(environment, args);</span><br><span class="line">    this.configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">    if (!CollectionUtils.isEmpty(this.defaultProperties)) &#123;</span><br><span class="line">        DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">        String name = &quot;commandLineArgs&quot;;</span><br><span class="line">        if (sources.contains(name)) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">            CompositePropertySource composite = new CompositePropertySource(name);</span><br><span class="line">            composite.addPropertySource(new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));</span><br><span class="line">            composite.addPropertySource(source);</span><br><span class="line">            sources.replace(name, composite);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sources.addFirst(new SimpleCommandLinePropertySource(args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）DefaultPropertiesPropertySource.moveToEnd方法的源码如下所示，该方法会将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void moveToEnd(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    moveToEnd(environment.getPropertySources());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void moveToEnd(MutablePropertySources propertySources) &#123;</span><br><span class="line">    PropertySource&lt;?&gt; propertySource = propertySources.remove(&quot;defaultProperties&quot;);</span><br><span class="line">    if (propertySource != null) &#123;</span><br><span class="line">        propertySources.addLast(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析，我们知道各种配置属性最终都会被封装为一个个PropertySource对象，查看一下该对象的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class PropertySource&lt;T&gt; &#123;</span><br><span class="line">    protected final String name; // 属性名称</span><br><span class="line">    protected final T source; // 属性值（一个泛型，比如Map，Property）</span><br><span class="line">    public String getName();  // 获取属性的名字  </span><br><span class="line">    public T getSource(); // 获取属性值  </span><br><span class="line">    public boolean containsProperty(String name);  //是否包含某个属性  </span><br><span class="line">    public abstract Object getProperty(String name);   //根据属性名获取到对应属性  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>PropertySource这个抽象类有很多实现类，分别用于管理应用程序的配置属性。不同的PropertySource实现类，可从不同的来源来获取配置属性，如文件、环境变量、命令行参数等。下面是涉及到的一些常用实现类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690266427489-901c66fd-ae05-4be0-8446-4b82669ac20e.png#averageHue=%233c4145&clientId=uc1ab0a73-0559-4&from=paste&id=u8f832076&originHeight=379&originWidth=832&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ueb409361-f04f-483d-835d-b678c9df9e8&title="><br>简单解释一下上述涉及到的实现类的作用：</p><ul><li>MapPropertySource，用于将Map键值对转换为PropertySource对象；</li><li>PropertiesPropertySource，用于将Properties对象中的配置属性转换为PropertySource对象；</li><li>ResourcePropertySource，用于从文件系统或classpath中加载配置属性，并封装为PropertySource对象；</li><li>ServletConfigPropertySource，用于从Servlet配置中读取配置属性，并封装为PropertySource对象；</li><li>ServletContextPropertySource，用于从Servlet上下文中读取配置属性，并封装为PropertySource对象；</li><li>StubPropertySource，这是一个空的实现类，它的作用仅仅是给CompositePropertySource类作为默认的父级属性源，以避免空指针异常；</li><li>CompositePropertySource:，这是一个复合型的实现类，内部维护了PropertySource集合队列，可以将多个PropertySource对象进行合并；</li><li>SystemEnvironmentPropertySource，用于从操作系统环境变量中读取配置属性，并将其封装为PropertySource对象。</li></ul><p>上面各类配置初始化生成的PropertySource对象都会被维护到集合队列中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;PropertySource&lt;?&gt;&gt;()</span><br></pre></td></tr></table></figure><p>配置初始化完成后，应用程序上下文 AbstractApplicationContext 会加载配置，这样程序在运行时就可以随时获取到配置信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267487883-5dff1184-08f9-4a80-9b3f-d28624f7e167.png#averageHue=%232e2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=215&id=ua6decfd6&originHeight=323&originWidth=1499&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=74002&status=done&style=none&taskId=uc533859b-abb4-4348-835a-14896e389f8&title=&width=999.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267606290-b594f371-57d1-4970-945e-7127f376aa94.png#averageHue=%232d2d2c&clientId=uc1ab0a73-0559-4&from=paste&height=275&id=u6860fe12&originHeight=412&originWidth=1493&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79537&status=done&style=none&taskId=u15367136-7c78-4064-9a23-0b41a49b8be&title=&width=995.3333333333334" alt="image.png"></p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>前面我们已经学习了加载配置的整个流程，那么读取配置就是从维护的 PropertySource 队列中根据name获取对应的source对象了。</p><p>一般而言，我们会使用Environment接口对象提供的方法来获取配置信息，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = environment.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在前面阅读源码的时候，我们知道这个Environment接口继承PropertyResolver接口，PropertyResolver是获取配置的关键接口，其内部提供了操作PropertySource 队列的方法，查看一下这个接口的继承依赖关系：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690268378231-d67e5d69-866c-4f3f-9483-b43466a7574a.png#averageHue=%233b4043&clientId=uc1ab0a73-0559-4&from=paste&id=ud889ead3&originHeight=499&originWidth=481&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u149749e3-d686-4d31-bb47-aa567992a31&title="><br>因此，我们也可以直接使用PropertyResolver接口中的方法来获取对应的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PropertyResolver propertyResolver;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = propertyResolver.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Value注解"><a href="#Value注解" class="headerlink" title="Value注解"></a>Value注解</h1><p>@Value注解，是 Spring 框架提供的用于获取注入配置属性值的注解，可用在类的成员变量、方法参数和构造函数参数上。</p><p>我们知道，在应用程序启动时，使用@Value注解修饰的Bean会被实例化并加入到 PropertySourcesPlaceholderConfigurer 的后置处理器集合中。当后置处理器开始执行时，它会读取Bean中所有被 @Value 注解所修饰的值，并通过反射将解析后的属性值，赋值给被@Value 注解修饰成员变量、方法参数和构造函数参数。<br><strong>请注意，在使用 @Value 注解时，需要确保注入的属性值已被加载到 Spring 容器中，否则会导致注入失败。</strong></p><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在项目的 src/main/resources 目录下新建 application.yml 配置文件，并往其中添加如下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quick:</span><br><span class="line">  use: true</span><br></pre></td></tr></table></figure><p>对应的测试代码如下，只需变量上加 @Value(“${quick.use}”)注解，那么@Value 注解便会自动将配置文件中的quick.use 属性值注入到 isQuickUsed 字段中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管@Value注解使用起来很方便，但是也存在一些需要注意的地方，下面介绍几个比较容易出错的地方。</p><h3 id="缺失配置"><a href="#缺失配置" class="headerlink" title="缺失配置"></a>缺失配置</h3><p>如果开发者在代码中引用变量，但是在配置文件中为进行配置，此时就会出现如下的错误信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690332916832-6ed72f81-8422-46b6-9bba-465e81400431.png#averageHue=%23353332&clientId=uf1677bb8-9339-4&from=paste&height=115&id=u94f4bf5a&originHeight=172&originWidth=1508&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50792&status=done&style=none&taskId=u9a1f075f-d556-42e9-b1e5-73bceb87bef&title=&width=1005.3333333333334" alt="image.png"><br>为了避免此类错误导致服务无法正常启动，我们可以在引用变量的同时，给它赋一个默认值，这样即使未在配置文件中赋值，程序也是可以正常启动的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use:true&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量赋值"><a href="#静态变量赋值" class="headerlink" title="静态变量赋值"></a>静态变量赋值</h3><p><strong>请注意，将 @Value 注解添加到静态变量上，这样是无法获取静态变量的属性值。</strong>我们知道，静态变量属于类，不属于某个对象，而 Spring是基于对象的属性进行依赖注入，且类在应用启动时，静态变量就被初始化，此时 Bean还未被实例化，因此无法通过 @Value 注解来注入属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private static String isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：null</span><br></pre></td></tr></table></figure><p>尽管 @Value 注解无法直接作用在静态变量上，但是开发者可通过获取已有 Bean实例化后的属性值，并将其赋值给静态变量进而实现给静态变量赋值这一目的。</p><p>上述过程对应的具体操作如下：<br>（1）通过 @Value 注解将属性值注入到普通 Bean中；<br>（2）获取该 Bean对应的属性值；<br>（3）将其赋值给静态变量；<br>（4）在静态变量中使用该属性值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private void setIsQuickUsed(String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><p>当然了也可以在构造方法中设置isUsed变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    StaticVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量赋值"><a href="#常量赋值" class="headerlink" title="常量赋值"></a>常量赋值</h3><p>**请注意，将 @Value 注解添加到常量上，这样是无法获取常量的属性值。 **我们知道，被final修饰的变量在使用前必须赋值，且一旦赋值便不能修改。final修饰的变量可以在定义时、构造方法中或者静态代码中进行赋值，这里只讨论final变量在静态代码块中赋值的情况。前面说过， @Value 注解是在 Bean 实例化后才进行属性注入，因此无法在构造方法中初始化 final 变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class FinalVarTest &#123;</span><br><span class="line">    private final String isUsed;</span><br><span class="line">    </span><br><span class="line">    FinalVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isUsed的值为：&#123;&#125;&quot;, isUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><h3 id="非Spring容器管理的Bean中使用"><a href="#非Spring容器管理的Bean中使用" class="headerlink" title="非Spring容器管理的Bean中使用"></a>非Spring容器管理的Bean中使用</h3><p>在Spring中，只有被 @Component、@Service、@Controller、@Repository 或 @Configuration 等注解标识的类，才会被Spring容器所管理，在这些类中使用 @Value注解才会生效。而对于普通的POJO类，无法使用 @Value注解进行属性注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class NoBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就无法获取配置文件中 quick.use 配置项的值。</p><h3 id="引入方式不对"><a href="#引入方式不对" class="headerlink" title="引入方式不对"></a>引入方式不对</h3><p>当我们需要使用某个Spring容器管理的对象时，需要使用依赖注入的方式，不能通过new关键字来创建实例。</p><h1 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="ConfigurationProperties注解"></a>ConfigurationProperties注解</h1><p>@ConfigurationProperties 注解是 SpringBoot 提供的一种更优雅的方式，来读取配置文件中的属性值。通过自动绑定和类型转换等机制，可将指定前缀的属性集合自动绑定到一个Bean对象上。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>前面在分析 SpringBoot 项目的启动流程中，我们发现这个 prepareEnvironment() 方法中调用了一个非常重要的方法 bindToSpringApplication(environment)，该方法的作用是将配置文件中的属性值绑定到被 @ConfigurationProperties 注解标记的 Bean对象中。不过此时这些对象还没有被 Spring 容器管理，因此无法完成属性的自动注入。</p><p>那么问题来了，这些 Bean 对象是在何时被注册到 Spring 容器中呢？这就涉及到了 ConfigurationPropertiesBindingPostProcessor 类，它是 Bean 后置处理器，负责扫描容器中所有被 @ConfigurationProperties 注解所标记的 Bean对象。如果找到了，则使用 Binder 组件将外部属性的值绑定到它们身上，从而实现自动注入：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356409937-9f0d2bef-a612-44cc-ad54-42932a4ed8ec.png#averageHue=%232e2d2c&clientId=u313a9f9a-5626-4&from=paste&height=317&id=u91100481&originHeight=475&originWidth=1747&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=130729&status=done&style=none&taskId=u762011e4-80bd-44f6-8896-e1a2ff1566f&title=&width=1164.6666666666667" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void bindToSpringApplication(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));</span><br><span class="line">    &#125; catch (Exception var3) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356666349-e4c62109-418c-494a-bc4d-db0061d5f5d9.png#averageHue=%232f2c2b&clientId=u313a9f9a-5626-4&from=paste&id=u6206cbe3&originHeight=462&originWidth=1074&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u93c04198-1bbe-4818-8efc-5a02a4fe59a&title="></p><ul><li>bindToSpringApplication方法，主要将属性值绑定到 Bean 对象中；</li><li>ConfigurationPropertiesBindingPostProcessor类，主要负责在Spring容器启动时，将被注解标记的 Bean 对象注册到容器中，并完成后续的属性注入操作。<h3 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在application.yml配置文件中新增如下配置信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config:</span><br><span class="line">  custom:</span><br><span class="line">    prop1: prop1</span><br><span class="line">    prop2: prop2</span><br></pre></td></tr></table></figure>第二步，定义一个名为 UsePropertiesConfig 的类，该类用于承载所有前缀为 config.custom 的配置属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;config.custom&quot;)</span><br><span class="line">public class UsePropertiesConfig &#123;</span><br><span class="line">    private String prop1;</span><br><span class="line">    private String prop2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将UsePropertiesConfig类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UsePropertiesConfig usePropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;prop1 is :&#123;&#125;&quot;, usePropertiesConfig.getProp1());</span><br><span class="line">        log.info(&quot;prop2 is :&#123;&#125;&quot;, usePropertiesConfig.getProp2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：prop1和prop2</span><br></pre></td></tr></table></figure><h1 id="PropertySources-注解"><a href="#PropertySources-注解" class="headerlink" title="PropertySources 注解"></a>PropertySources 注解</h1>一般来说，系统默认提供的名为 application.yml 或者 application.properties 配置文件能满足绝大多数业务场景，但是在某些场景下我们还是希望自定义配置文件名称及内容。请注意，与默认的配置文件所不同的是，用户自定义的配置文件无法被应用自动加载，需要开发者手动加载。<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3>@PropertySources 注解的实现原理比较简单，如下所示：<br>（1）应用程序启动时，扫描所有被@PropertySources 注解修饰的类，并获取到注解中指定自定义配置文件的路径；<br>（2）将指定路径下的配置文件内容加载到 Environment 中，这样就可通过 @Value 注解或 Environment.getProperty() 方法来获取其中定义的属性值。<h3 id="示例使用-1"><a href="#示例使用-1" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在 src/main/resources 目录下定义一个名为 customProperties.properties 的自定义配置类，里面的配置项如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom.sex=male</span><br><span class="line">custom.address=shanghai</span><br></pre></td></tr></table></figure>第二步，在需要使用自定义配置文件的类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开。这里定义一个名为 CustomPropertiesConfig 的类，里面的代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customProperties.properties&quot;,encoding = &quot;utf-8&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class CustomPropertiesConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.address&#125;&quot;)</span><br><span class="line">    private String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将CustomPropertiesConfig 类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private CustomPropertiesConfig customPropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, customPropertiesConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.address is: &#123;&#125;&quot;, customPropertiesConfig.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h3 id="支持YML格式"><a href="#支持YML格式" class="headerlink" title="支持YML格式"></a>支持YML格式</h3>查看一下这个 @PropertySource 注解的源码，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(PropertySources.class)</span><br><span class="line">public @interface PropertySource &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    boolean ignoreResourceNotFound() default false;</span><br><span class="line"></span><br><span class="line">    String encoding() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到这里的 factory 属性，默认使用的是 PropertySourceFactory 类，而这个类是一个接口，查看一下该接口的源码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PropertySourceFactory &#123;</span><br><span class="line">    PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>里面只有一个 createPropertySource 方法，该方法会返回一个 PropertySource 对象，这个PropertySourceFactory 接口只有一个默认的实现类 DefaultPropertySourceFactory ，该实现类的源码如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultPropertySourceFactory implements PropertySourceFactory &#123;</span><br><span class="line">    public DefaultPropertySourceFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        return name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>也就是说它只能加载 .properties 结尾的配置文件，无法加载 yml 格式结尾的文件。如果我们需要加载 yml 格式的配置文件，那么需要自定义 PropertySourceFactory 接口实现类。</li></ul><p>第一步，在 src/main/resources 目录下定义一个名为 customYaml.yml 的自定义配置类，里面的配置项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  sex: male</span><br><span class="line">  city: shanghai</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 YamlPropertySourceFactory 的类，该类需要实现 PropertySourceFactory 接口并重写其中的 createPropertySource 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class YamlPropertySourceFactory  implements PropertySourceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();</span><br><span class="line">        factoryBean.setResources(resource.getResource());</span><br><span class="line"></span><br><span class="line">        Properties properties = factoryBean.getObject();</span><br><span class="line">        return new PropertiesPropertySource(resource.getResource().getFilename(), properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个名为 UseYamlConfig 的配置类，并在该类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customYaml.yml&quot;, encoding = &quot;utf-8&quot;, factory = YamlPropertySourceFactory.class)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class UseYamlConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.city&#125;&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个名为 UseYamlConfigTest 的类，该类会使用到前面的配置项，因此需要将UseYamlConfig 类进行注入并使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UseYamlConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UseYamlConfig useYamlConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, useYamlConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.city is: &#123;&#125;&quot;, useYamlConfig.getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h1 id="YamlPropertiesFactoryBean-加载-YAML-文件"><a href="#YamlPropertiesFactoryBean-加载-YAML-文件" class="headerlink" title="YamlPropertiesFactoryBean 加载 YAML 文件"></a>YamlPropertiesFactoryBean 加载 YAML 文件</h1><p>我们还可以使用 YamlPropertiesFactoryBean 这个类将 YAML 配置文件中的属性值注入到 Bean 中，具体操作如下：<br>第一步，定义一个名为 customBeanYaml.yml 的配置文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  email: qq@qq.com</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 CustomYamlPropertiesFactoryBeanConfig 的类，里面定义一个名为 yamlConfigurer 的方法，该方法需要返回一个 PropertySourcesPlaceholderConfigurer 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomYamlPropertiesFactoryBeanConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public static PropertySourcesPlaceholderConfigurer yamlConfigurer() &#123;</span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean();</span><br><span class="line">        yaml.setResources(new ClassPathResource(&quot;customBeanYaml.yml&quot;));</span><br><span class="line">        configurer.setProperties(Objects.requireNonNull(yaml.getObject()));</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个测试方法，开发者可通过 @Value 注解或 Environment.getProperty() 方法来获取配置文件中定义的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@Slf4j</span><br><span class="line">public class YamlPropertiesFactoryBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.email&#125;&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.email is: &#123;&#125;&quot;, email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义读取"><a href="#自定义读取" class="headerlink" title="自定义读取"></a>自定义读取</h1><p>如果开发者觉得上述读取方式不够优雅，自己想造轮子，此时可以直接注入 PropertySources 对象，来获取所有属性的配置队列，之后就可以按照要求进行实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CustomTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void customTest() &#123;</span><br><span class="line">        for (PropertySource&lt;?&gt; propertySource : propertySources) &#123;</span><br><span class="line">            log.info(&quot;自定义方式，来实现配置获取逻辑，属性名称为：&#123;&#125; ,属性源为：&#123;&#125;&quot;, propertySource.getName(), propertySource.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例使用"><a href="#案例使用" class="headerlink" title="案例使用"></a>案例使用</h1><p>接下来通过一个例子来灵活学习如何获取指定配置文件中的属性值，步骤如下所示：<br>第一步，定义一个名为PropertiesLoader的类，我们定义 loadProperties 方法用于读取指定配置文件中的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesLoader &#123;</span><br><span class="line">    private static final Logger logger = Logger.getLogger(PropertiesLoader.class.getName());</span><br><span class="line"></span><br><span class="line">    private PropertiesLoader() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Properties loadProperties(String location) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        logger.info(&quot;Loading properties file from path:&quot; + location);</span><br><span class="line">        InputStreamReader in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new InputStreamReader(PropertiesLoader.class.getClassLoader().getResourceAsStream(location), &quot;UTF-8&quot;);</span><br><span class="line">            props.load(in);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.log(Level.WARNING, &quot;error close inputstream&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步，定义一个方法用于获取配置文件中指定名称的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesTest &#123;</span><br><span class="line">    public static void init(String location)&#123;</span><br><span class="line">        Properties properties = PropertiesLoader.loadProperties(location);</span><br><span class="line">        String userName = properties.getProperty(&quot;user.name&quot;);</span><br><span class="line">        String userSex = properties.getProperty(&quot;user.sex&quot;);</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">        System.out.println(userSex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String location = &quot;user.properties&quot;;</span><br><span class="line">        init(location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个 user.properties 文件是定义在项目resources目录下的文件。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的学习，我们知道可通过 @Value 注解、Environment 类、@ConfigurationProperties 注解和@PropertySource 注解等方式来获取配置信息。<br>其中，@Value 注解适用于单个值的注入，其他几种方式适用于多个配置的批量注入，而且不同方式在效率、灵活性、易用性等方面存在差异，在选择的时候需要多方面进行考虑。</p><p>这里笔者结合实际的工作体会，给出一些比较有参考意义的建议：如果重视代码的可读性和可维护性，可选择 @ConfigurationProperties 注解；如果更注重运行效率，可选择使用 Environment 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊九种常用的分布式ID生成方案</title>
    <link href="http://aigoing.chat/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/"/>
    <id>http://aigoing.chat/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/</id>
    <published>2024-02-03T06:55:27.000Z</published>
    <updated>2024-05-22T14:13:22.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习9种常用的分布式ID生成方案，掌握这些对于提升自身能力有极大帮助。</p><h1 id="为什么使用分布式ID"><a href="#为什么使用分布式ID" class="headerlink" title="为什么使用分布式ID"></a>为什么使用分布式ID</h1><h3 id="分布式ID的定义"><a href="#分布式ID的定义" class="headerlink" title="分布式ID的定义"></a>分布式ID的定义</h3><p>这里以MySQL数据库为例进行说明，当我们的业务数据量不大时，单库单表完全可以支撑现有业务，数据再大一点时，使用MySQL主从同步、读写分离模式也能应付。但是当数据日益增长，达到亿级别的时候，就需要对数据库进行分库分表操作，而分库分表后需要有一个唯一的ID来标识每条数据，显然数据库的自增ID无法满足需求，那么这个 全局唯一ID 就叫 分布式ID 。</p><h3 id="分布式ID满足的条件"><a href="#分布式ID满足的条件" class="headerlink" title="分布式ID满足的条件"></a>分布式ID满足的条件</h3><p>一般来说，分布式ID需要满足如下五个要求：</p><ul><li>全局唯一：必须保证ID是全局性唯一；</li><li>高性能：高可用低延时，ID生成响应快，否则会成为业务瓶颈；</li><li>高可用：100%可用无法做到，但是要无限接近于100%的可用；</li><li>好接入：秉承拿来即用的设计原则，在系统设计和实现上要尽可能的简单；</li><li>趋势递增：最好有趋势递增，不过要结合实际业务进行分析。<h1 id="分布式ID的生成方式"><a href="#分布式ID的生成方式" class="headerlink" title="分布式ID的生成方式"></a>分布式ID的生成方式</h1>分布式ID的生成方式有很多种，此处列举常用的9种方式，如下所示：<br>（1）UUID；<br>（2）数据库自增ID；<br>（3）数据库多主模式；<br>（4）号段模式；<br>（5）Redis；<br>（6）SnowFlake（雪花算法）；<br>（7）Uidgenerator （百度）；<br>（8）TinyID（滴滴）；<br>（9）Leaf（美团）。<br>本篇文章将学习以上9种分布式ID的生成方式，并学习其原理和优缺点，以便在实际开发过程中能有针对性的进行选择使用。<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3>由于笔者使用的是Java语言，而Java自带了一个能生成全球唯一ID的UUID类，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行上述方法，输出结果为：15751784476b47719021f39dffe49003。实际上生成的UUID可以作为分布式ID，但是并不建议使用它。因为生成的UUID体现不出业务的含义，而且对于数据库而言，UUID的长度过长且是字符串，存储和查询性能较差。</li></ul><p><strong>优点：</strong></p><ul><li>生成逻辑简单，一行代码搞定；</li><li>本地生成无网络消耗且具有唯一性。</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性；</li><li>无法体现具体的业务含义；</li><li>长度过长且是字符串，存储和查询性能较差。<h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3>这里以MySQL数据库为例进行说明，可以使用MySQL的 auto_increment 自增ID来充当分布式ID。</li></ul><p>举个例子，下面是一个表，使用它的自增主键ID作为分布式ID，对应的建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sequence_id (</span><br><span class="line">    id bigint(20) unsigned NOT NULL auto_increment, </span><br><span class="line">    value char(10) NOT NULL default &#x27;&#x27;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into sequence_id(value) VALUES (&#x27;zhangsan&#x27;);</span><br></pre></td></tr></table></figure><p>当我们需要一个ID时，只需往该表中插入一条记录，即可返回该记录的主键ID，不过这种方式仅适用于并发量不大的情况，在分布式系统中不建议使用。</p><p><strong>优点：</strong></p><ul><li>实现简单且ID单调自增；</li><li>采用数值类型，因此查询速度快。</li></ul><p><strong>缺点：</strong></p><ul><li>数据库存在宕机故障，无法抗住高并发场景。<h3 id="数据库集群模式"><a href="#数据库集群模式" class="headerlink" title="数据库集群模式"></a>数据库集群模式</h3>既然单点数据库方式存在高并发问题，那么我们可对上述方式进优化，采用主从模式集群模式。考虑到单主节点挂掉，无法高可用，那么可采用双主模式集群，即两个Mysql实例都能单独生成自增ID。</li></ul><p>不过这里还有一个问题，就是两个MySQL实例的自增ID都从1开始，肯定会生成重复的ID，此时可以考虑错开设置起始值以及采用自增步长。</p><p>举个例子，假设这里有两个MySQL实例，接下来我们尝试对其做如下配置：<br>（1）MySQL_1的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>（2）MySQL_2的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>通过上面的配置，那么这两个MySQL实例的自增ID分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL_1：1、3、5、7、9 </span><br><span class="line">MySQL_2：2、4、6、8、10</span><br></pre></td></tr></table></figure><p>当然了，如果使用此集群后，性能还是不佳，无法扛住高并发，可考虑对MySQL集群进行扩容处理，即增加节点，不过这个操作比较复杂：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690164636483-e2181405-a519-4d02-9d00-6903f7d780c4.png#averageHue=%23f7f7f7&clientId=u9118ed87-b2b2-4&from=paste&height=328&id=u1e2bb6fe&originHeight=492&originWidth=868&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=53668&status=done&style=none&taskId=ub42491d9-4df1-4c25-b728-6289992fe1d&title=&width=578.6666666666666" alt="image.png"><br>可以看到，由于上述数据库集群支持水平扩展，因此有利于解决数据库单点压力的问题，同时为了ID生成特性，需要将自增步长按照机器数量来设置。</p><p>这个操作其实比较复杂，我们仅仅是往集群中添加了一个实例，就需要对上述三个实例的起始值和步长都进行调整，将第三台机器的ID起始值调整为比现有最大自增ID的值都大，而且必须在前面两台机器还没有增长到第三台机器的起始ID值时才能操作，否则自增ID就重复了，这是非常严重的问题，必要时还可能需要停机修改。</p><p><strong>优点：</strong></p><ul><li>解决数据库的单节点宕机故障。</li></ul><p><strong>缺点：</strong></p><ul><li>水平扩容较为复杂，且实际上单个数据库压力还是很大，依旧无法满足高并发场景。<h3 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h3>数据库号段模式是当前分布式ID生成器的主流实现方式之一，号段模式可以这样理解：首先从数据库批量获取自增ID，然后每次从数据库取出一个号段范围，如 (1,1000] 代表1000个ID，接着某一业务微服务将本号段生成1~1000的自增ID并加载到内存中。对应的表结构如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  max_id bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  step int(20) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  biz_type    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,</span><br><span class="line">  version int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) </span><br></pre></td></tr></table></figure>简单解释一下上述字段的含义：<br>（1）max_id ，表示当前可用的最大id；<br>（2）step，表示号段的步长；<br>（3）biz_type，表示不同的业务类型；<br>（4）version ，一个乐观锁，注意每次对数据进行更新操作，都需要更新version字段，保证并发时数据的正确性。</li></ul><p>下面是一条示例，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690167055037-a72e14a2-75b8-4399-98d4-7492bc839947.png#averageHue=%23f1f1f0&clientId=u9118ed87-b2b2-4&from=paste&height=88&id=u44200825&originHeight=132&originWidth=979&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13288&status=done&style=none&taskId=ub2437283-bcf0-4a63-ad5f-3354d5632bd&title=&width=652.6666666666666" alt="image.png"><br>后续等这批号段ID用完了，可再次向数据库申请新号段，只需对 max_id 字段做一次 update 操作，执行如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update id_generator</span><br><span class="line">set max_id = max_id + step, version = version + 1</span><br><span class="line">where biz_type = #&#123;bizType&#125;</span><br><span class="line">and max_id = #&#123;maxId&#125;</span><br><span class="line">and version = #&#123;version&#125;</span><br></pre></td></tr></table></figure><p>上述语句执行成功，则说明新号段获取成功，此时新的号段范围为 (max_id , max_id +step] 。考虑到多个业务可能同时操作，因此引入版本号 version 字段，采用乐观锁方式更新。</p><p><strong>优点：</strong></p><ul><li>不强依赖数据库，且不会频繁的访问数据库，对数据库的压力很小。</li></ul><p><strong>缺点：</strong></p><ul><li>当存在多个业务，且业务使用频率差距较大时，会造成有些业务号段不够用，有些使用率不高的情况。<h3 id="Redis模式"><a href="#Redis模式" class="headerlink" title="Redis模式"></a>Redis模式</h3>Redis提供了incr命令，因此通过该命令也可以实现分布式ID的生成功能。举个例子，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set sequence_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr sequence_id      // 增加1，并返回递增后的数值</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>请注意，在使用Redis实现时需要考虑Redis的持久化问题。我们知道Redis有两种持久化方式：RDB和AOF。下面说一下这两种情况分别可能存在的问题：<br>（1）RDB方式是定时生成一个快照，进而进行持久化。这样就有一个问题，假如连续自增的Redis没及时进行持久化就挂掉了，那么重启后就会出现ID重复的情况。<br>（2）AOF方式是针对每条写命令进行持久化，这样即使Redis挂掉也不会出现ID重复的情况。但是这样会有一个情况，由于incr命令的特殊性，它会导致Redis重启恢复数据的时间较长。</li></ul><p><strong>优点：</strong></p><ul><li>实现简单，不依赖与数据库，可实现高可用。</li></ul><p><strong>缺点：</strong></p><ul><li>RDB方式可能出现ID重复、AOF方式会导致Redis重启恢复数据的时间较长。<h3 id="雪花算法（Snowflake）模式"><a href="#雪花算法（Snowflake）模式" class="headerlink" title="雪花算法（Snowflake）模式"></a>雪花算法（Snowflake）模式</h3>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，各大公司在此基础上开发出了各具特色的分布式ID生成器。下图是雪花算法生成的Long类型ID的组成结构示意图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690168415774-0d50e86a-e68e-4081-a32e-40fd60fb8c49.png#averageHue=%23f7f7f7&clientId=u9118ed87-b2b2-4&from=paste&height=194&id=u5879679a&originHeight=291&originWidth=966&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=89402&status=done&style=none&taskId=u6f5f18d0-f175-4c54-8726-bf6f92f7188&title=&width=644" alt="image.png"><br>Snowflake 生成的是一个Long类型的ID，而一个Long类型占8个字节，每个字节又占8比特，即一个Long类型占64 个比特。</li></ul><p>该Long类型的ID由64个比特组成，结构如下：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特）。</p><ul><li>第一个bit位（1bit）：Java中Long的最高位是符号位，代表正负，其中正数是0，负数是1，一般生成ID都为正数，所以默认是0。</li><li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，这样可使产生的ID从更小的值开始。41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年。</li><li>工作机器id（10bit）：也被叫做 workId ，这个可灵活配置，一般是机器ID+数据中心ID组成。</li><li>序列号部分（12bit）：自增值支持同一毫秒时间内，同一个节点可生成4096个ID。</li></ul><p>根据雪花算法的逻辑，开发者只需使用Java语言将其实现出来，并封装为一个工具方法，然后在各个业务系统中直接使用该工具方法来获取分布式ID，此时只需保证每个业务都有自己的工作机器id，不需要单独搭建一个获取分布式ID的系统。</p><p>下面是使用Java实现的雪花算法代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span><br><span class="line"> *</span><br><span class="line"> * https://github.com/beyondfengyu/SnowFlake</span><br><span class="line"> */</span><br><span class="line">public class SnowFlakeShortUrl &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     */</span><br><span class="line">    private final static long START_TIMESTAMP = 1480166465631L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     */</span><br><span class="line">    //序列号占用的位数</span><br><span class="line">    private final static long SEQUENCE_BIT = 12;</span><br><span class="line">    //数据中心占用的位数</span><br><span class="line">    private final static long DATA_CENTER_BIT = 5;</span><br><span class="line">    //机器标识占用的位数</span><br><span class="line">    private final static long MACHINE_BIT = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     */</span><br><span class="line">    //序列号的最大值</span><br><span class="line">    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    //数据中心的最大值</span><br><span class="line">    private final static long MAX_DATA_CENTER_NUM = -1L ^ (-1L &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line">    //机器标识的最大值</span><br><span class="line">    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     */</span><br><span class="line">    //机器标识向左的位移</span><br><span class="line">    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    //数据中心向左的位移</span><br><span class="line">    private final static long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    //时间戳向左的位移</span><br><span class="line">    private final static long TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    //数据中心</span><br><span class="line">    private long dataCenterId;</span><br><span class="line">    //机器标识</span><br><span class="line">    private long machineId;</span><br><span class="line">    //序列号</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line">    //上一次时间戳</span><br><span class="line">    private long lastTimeStamp = -1L;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill = getNewTimeStamp();</span><br><span class="line">        while (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewTimeStamp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span><br><span class="line">     *</span><br><span class="line">     * @param dataCenterId 数据中心ID</span><br><span class="line">     * @param machineId    机器标志ID</span><br><span class="line">     */</span><br><span class="line">    public SnowFlakeShortUrl(long dataCenterId, long machineId) &#123;</span><br><span class="line">        if (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.dataCenterId = dataCenterId;</span><br><span class="line">        this.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成下一个ID</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currTimeStamp = getNewTimeStamp();</span><br><span class="line">        if (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            //相同毫秒内，序列号自增</span><br><span class="line">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line">            //同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence == 0L) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //不同毫秒内，序列号置为0</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        return (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT //时间戳部分</span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       //数据中心部分</span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             //机器标识部分</span><br><span class="line">                | sequence;                             //序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = new SnowFlakeShortUrl(2, 3);</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; (1 &lt;&lt; 4); i++) &#123;</span><br><span class="line">            //10进制</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Uidgenerator-（百度）"><a href="#Uidgenerator-（百度）" class="headerlink" title="Uidgenerator （百度）"></a>Uidgenerator （百度）</h3><p>uid-generator 是百度基于 Snowflake 算法实现的，项目 <a href="https://github.com/baidu/uid-generator">GitHub地址</a> 。与原始的 snowflake 算法不同，uid-generator 支持 自定义时间戳、工作机器ID 和 序列号 等各部分的位数，且 uid-generator 中采用用户自定义 workId 的生成策略。</p><p>uid-generator 需要与数据库配合来使用，数据库中需要新建一个名为 WORKER_NODE 的表。当系统启动时，会往数据库表中插入一条数据，插入成功后会返回自增的ID，该ID就是该机器的 workId 数据。workId 由host和port组成。</p><p>请注意，uid-generator ID的组成结构与原始的Snowflake 算法生成的ID不同，uid-generator ID的workId占用22个bit位，而时间占用28个bit位，序列化占用13个bit位，还有它的时间单位是秒，不是毫秒。同时workId 也不一样，且同一应用每次重启就会消费一个 workId 。关于 Uidgenerator中文说明文档可以点击  <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">GitHub地址</a> 进行阅读。</p><h3 id="TinyID（滴滴）"><a href="#TinyID（滴滴）" class="headerlink" title="TinyID（滴滴）"></a>TinyID（滴滴）</h3><p>TinyID是滴滴基于号段模式原理开发的，项目 <a href="https://github.com/didi/tinyid">GitHub地址</a> 。每个服务获取一个号段，如（1000,2000]、（2000,3000]、（3000,4000]，之后各服务使用号段进行业务调用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690178105351-301f57f8-0659-4b4d-9ed7-df6c05cf4bd7.png#averageHue=%23fdf7f6&clientId=u9118ed87-b2b2-4&from=paste&height=430&id=u465c57f9&originHeight=645&originWidth=990&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=78683&status=done&style=none&taskId=ubcb7a563-6b5c-49f7-b692-986d1f1a0dd&title=&width=660" alt="image.png"><br>Tinyid 提供两种方式来进行接入：http 和 tinyid-client，下面将分别进行学习。</p><h5 id="http方式接入"><a href="#http方式接入" class="headerlink" title="http方式接入"></a>http方式接入</h5><p>第一步，使用如下命令来下载tinyid的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/didi/tinyid.git</span><br></pre></td></tr></table></figure><p>第二步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info`</span><br><span class="line">(</span><br><span class="line">    `id`          bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">    `biz_type`    varchar(63) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务类型，唯一&#x27;,</span><br><span class="line">    `begin_id`    bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;,</span><br><span class="line">    `max_id`      bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">    `step`        int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;步长&#x27;,</span><br><span class="line">    `delta`       int(11) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;每次id增量&#x27;,</span><br><span class="line">    `remainder`   int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;余数&#x27;,</span><br><span class="line">    `create_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    `version`     bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;版本号&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `uniq_biz_type` (`biz_type`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;id信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    `token`       varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;token&#x27;,</span><br><span class="line">    `biz_type`    varchar(63)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;此token可访问的业务类型标识&#x27;,</span><br><span class="line">    `remark`      varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;备注&#x27;,</span><br><span class="line">    `create_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;token信息表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (1, &#x27;test&#x27;, 1, 1, 100000, 1, 0, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-22 23:19:27&#x27;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (2, &#x27;test_odd&#x27;, 1, 1, 100000, 2, 1, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-23 00:39:24&#x27;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (1, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (2, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test_odd&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br></pre></td></tr></table></figure><p>第三步，配置tinyid-server项目offline包下的application.properties配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8086</span><br><span class="line">datasource.tinyid.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">datasource.tinyid.primary.username=root</span><br><span class="line">datasource.tinyid.primary.password=root</span><br></pre></td></tr></table></figure><p>注意笔者使用的MySQL版本为8系列。<br>第四步，启动tinyid-server项目，开始进行测试。访问如下链接，来获取单个的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8086/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c</span><br></pre></td></tr></table></figure><p>返回结果为：2。</p><p>如果要批量获取ID，可使用如下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8086/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=3</span><br></pre></td></tr></table></figure><p>返回结果为：3,4,5。</p><h5 id="Java客户端方式接入"><a href="#Java客户端方式接入" class="headerlink" title="Java客户端方式接入"></a>Java客户端方式接入</h5><p>第一步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info`</span><br><span class="line">(</span><br><span class="line">    `id`          bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">    `biz_type`    varchar(63) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务类型，唯一&#x27;,</span><br><span class="line">    `begin_id`    bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;,</span><br><span class="line">    `max_id`      bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">    `step`        int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;步长&#x27;,</span><br><span class="line">    `delta`       int(11) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;每次id增量&#x27;,</span><br><span class="line">    `remainder`   int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;余数&#x27;,</span><br><span class="line">    `create_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    `version`     bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;版本号&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `uniq_biz_type` (`biz_type`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;id信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    `token`       varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;token&#x27;,</span><br><span class="line">    `biz_type`    varchar(63)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;此token可访问的业务类型标识&#x27;,</span><br><span class="line">    `remark`      varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;备注&#x27;,</span><br><span class="line">    `create_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;token信息表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (1, &#x27;test&#x27;, 1, 1, 100000, 1, 0, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-22 23:19:27&#x27;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (2, &#x27;test_odd&#x27;, 1, 1, 100000, 2, 1, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-23 00:39:24&#x27;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (1, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (2, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test_odd&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br></pre></td></tr></table></figure><p>第二步，配置tinyid-server项目offline包下的application.properties配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8086</span><br><span class="line">datasource.tinyid.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">datasource.tinyid.primary.username=root</span><br><span class="line">datasource.tinyid.primary.password=root</span><br></pre></td></tr></table></figure><p>第三步，创建一个项目，然后在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tinyid-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;tinyid.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第四步，通过阅读源码可知，需要新建一个名为 tinyid_client.properties 的配置文件，然后往里面新增如下配置信息，后面两个配置项可以不配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tinyid.token=0f673adf80504e2eaa552f5d791b644c</span><br><span class="line">tinyid.server=localhost:8086</span><br><span class="line">tinyid.readTimeout=</span><br><span class="line">tinyid.connectTimeout=</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690182879239-8e2508f5-336a-4b0d-9941-58dc08760f91.png#averageHue=%232e2d2c&clientId=u9118ed87-b2b2-4&from=paste&height=557&id=u5dd24467&originHeight=835&originWidth=1633&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=209149&status=done&style=none&taskId=u6d8beecc-8ae6-4b45-9627-e3e8da23e29&title=&width=1088.6666666666667" alt="image.png"><br>第五步，启动项目，开始进行测试。通过对源码分析，可以看到实际上我们只需通过 TinyId 这个工具类提供的方法就能获取到生成的ID：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690183637784-6e650e9d-b140-4e74-9312-aa4746b7abc1.png#averageHue=%232c2c2b&clientId=u9118ed87-b2b2-4&from=paste&height=555&id=u1a7e9957&originHeight=833&originWidth=1057&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=111228&status=done&style=none&taskId=u877e574a-a5f2-4431-81fd-067db899c65&title=&width=704.6666666666666" alt="image.png"><br>如果你想获取单个的ID，可调用TinyId的 nextId(String bizType) 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyId.nextId(&quot;test&quot;);</span><br></pre></td></tr></table></figure><p>返回结果为：2。</p><p>如果想要批量获取ID，可调用TinyId的 nextId(String bizType, Integer batchSize) 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyId.nextId(&quot;test&quot;,3);</span><br></pre></td></tr></table></figure><p>返回结果为：3,4,5。请注意，上面的bizType和token必须对应起来，否则数据是无法查询出来的。</p><h3 id="Leaf（美团）"><a href="#Leaf（美团）" class="headerlink" title="Leaf（美团）"></a>Leaf（美团）</h3><p>Leaf 由美团开发，同时支持号段模式和 snowflake 算法模式（可切换使用）的分布式ID生成器，项目 <a href="https://github.com/Meituan-Dianping/Leaf">GitHub地址</a> 。</p><h5 id="号段模式接入"><a href="#号段模式接入" class="headerlink" title="号段模式接入"></a>号段模式接入</h5><p>第一步，使用如下命令来下载 Leaf 的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Meituan-Dianping/Leaf</span><br></pre></td></tr></table></figure><p>第二步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `leaf_alloc`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `leaf_alloc` (</span><br><span class="line">  `biz_tag` varchar(128)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务标签，唯一&#x27;,</span><br><span class="line">  `max_id` bigint(20) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(11) NOT NULL COMMENT &#x27;步长&#x27;,</span><br><span class="line">  `description` varchar(256)  DEFAULT NULL COMMENT &#x27;描述信息&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`biz_tag`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;号段分配表&#x27;;</span><br></pre></td></tr></table></figure><p>第三步，修改项目的一些依赖版本，具体如下：<br>（1）mysql-connector-java，由 5.1.38 调整为 8.0.33；<br>（2）druid，由 1.0.18 调整为 1.1.10。<br>第四步，修改 leaf-server 项目中的leaf.properties文件内容，我们这里使用号段模式，配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leaf.name=com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable=true</span><br><span class="line">leaf.jdbc.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">leaf.jdbc.username=root</span><br><span class="line">leaf.jdbc.password=root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable=false</span><br></pre></td></tr></table></figure><p>既然我们这里使用了号段模式，因此需要关闭雪花算法模式。<br>第五步，启动 leaf-server 项目的入口类 LeafServerApplication，即可启动项目。然后往数据表leaf_alloc中插入一条数据，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690248965265-8292884a-33f2-4901-b023-2b3889ec3904.png#averageHue=%23d8ebc6&clientId=u5eb8395b-a42d-4&from=paste&height=37&id=u006e5718&originHeight=55&originWidth=740&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7578&status=done&style=none&taskId=ue44e2073-b1c8-4143-8cfd-a1984b3ccc5&title=&width=493.3333333333333" alt="image.png"><br>接着在浏览器地址栏中访问<code>[http://localhost:8080/api/segment/get/test_order](http://localhost:8080/api/segment/get/test_order)</code>链接，即可获取到生成的ID。<br>实际上，Leaf还提供了一个接口<code>[http://localhost:8080/cache](http://localhost:8080/cache)</code>来监控号段模式，界面如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690249124499-9dadd9d0-2d96-404a-b2ee-59ccf9b12dde.png#averageHue=%23fcfbfb&clientId=u5eb8395b-a42d-4&from=paste&height=81&id=u94200bcf&originHeight=122&originWidth=2123&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16287&status=done&style=none&taskId=ua67244e9-bbf1-45e5-ad65-1ef16e421d9&title=&width=1415.3333333333333" alt="image.png"></p><h5 id="雪花算法模式接入"><a href="#雪花算法模式接入" class="headerlink" title="雪花算法模式接入"></a>雪花算法模式接入</h5><p>Leaf和原始的雪花算法主要区别在 workId 的生成上。我们知道 Leaf 的雪花算法模式依赖ZooKeeper，它的 workId 是基于ZooKeeper的顺序Id来生成的。每个应用在使用 Leaf 的雪花模式接入时，在启动的时候，都会在Zookeeper中生成一个顺序Id，就相当于一台机器对应一个顺序节点，也就是一个workId。</p><p>前面三步和之前的一样，第四步配置信息有点差异，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leaf.segment.enable=false</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable=true</span><br><span class="line">leaf.snowflake.zk.address=127.0.0.1</span><br><span class="line">leaf.snowflake.port=2187</span><br></pre></td></tr></table></figure><p>之后启动 leaf-server 项目的入口类 LeafServerApplication，即可启动项目。然后在浏览器地址栏中访问<code>[http://localhost:8080/api/snowflake/get/test_order](http://localhost:8080/api/segment/get/test_order)</code>链接，即可获取到生成的ID。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习9种常用的分布式ID生成方案，掌握这些对于提升自身能力有极大帮助。&lt;/p&gt;
&lt;h1 id=&quot;为什么使用分布式ID&quot;</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>什么是架构及架构师</title>
    <link href="http://aigoing.chat/2024/01/02/2024-0-what-is-architecture-and-architect/"/>
    <id>http://aigoing.chat/2024/01/02/2024-0-what-is-architecture-and-architect/</id>
    <published>2024-01-02T04:55:20.000Z</published>
    <updated>2025-06-03T14:53:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>2024年笔者正式步入到架构设计的领域，因此有必要记录自己在架构设计方面学习的点滴。由于每个业务系统都要求从业务架构的视角进行代码开发和迭代，因此架构师属性不仅仅是作为架构师所必备的技能，更是作为每个开发者应当具备的属性，这种架构师可称为纵向架构师，而目标在于提高整个团队水平，确定多业务边界的，笔者称之为横向架构师。</p><p><strong>【纵向架构师】</strong>主要考虑业务和系统，做问题和结果的定义，做系统、模块、代码设计；</p><p>【<strong>横向架构师</strong>】解决跨域问题，确定跨团队边界，定义规范、统一语言。定义纵向架构能力基础/标准的成长路径和方法论，让人人都成为架构师。即它的核心过程是探讨如何完成架构设计，如何培养和拥有架构思维。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748419731574-7fd6fe5a-1df2-4443-a2c0-7b2364287d2a.png"></p><h1 id="什么是架构师"><a href="#什么是架构师" class="headerlink" title="什么是架构师"></a>什么是架构师</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>关于架构师的定义，wiki百科是这样定义的：</p><blockquote><p>软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，对外接口方法，创新的设计特性，以及高层事物的对象操作、逻辑和流程。软件架构师与客户商谈概念上的事情，与经理商谈广泛的设计问题，与软件工程师商谈创新的结构特性，与程序员商谈实现技巧，外观和风格。</p></blockquote><p>笔者认为，架构师主要有如下三个职责：</p><p>（1）跟需求方，<strong>提炼</strong>关于项目的概念并和需求方有统一的沟通语言；</p><p>（2）基于利益相关方，<strong>总结关键质量属性</strong>，并给出满足质量属性的软件系统<strong>架构设计；</strong></p><p>（3）与开发工程师，共同进行<strong>软件系统的落地</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748420297717-84e5d831-cbc7-431d-83ef-c0f373e44932.png"></p><p>【注意】这里的质量属性，是指评估系统性能的非功能性需求，如可用性，可扩展性，一致性等。</p><p>其实从上面的图中可以看出，想要成为架构师，需要具备三方面的能力：</p><p>（1）<strong>挖掘/提炼需求描述的能力</strong>。一般来说，客户或者产品对于需求的描述都比较简单，会缺少一些上下文或者产品上认为不重要的部分，此时就需要架构师来拨开云雾，了解需求详情、业务目标，确定不同方的关注点。</p><p>（2）<strong>架构设计能力</strong>。在架构设计方面，有一个非常重要的点就是架构师及团队成员的能力。举个例子，如果我们在选型非关系型数据库的时候，团队成员对Redis非常熟悉，而对MongoDB不太熟悉，那么在选型中会更加青睐于Redis。因为这对于项目的开发，测试和运维成本以及进度风险会更低。与此同时，我们也需要承担这个选型带来的一些缺点。所以架构设计不仅依赖方法论，还依赖于架构师的技术前沿性。</p><p>（3）<strong>代码落地能力</strong>。架构师要能够和开发人员一起，完成代码的落地编写，因此一个好的架构师也是一个优秀的开发者。</p><p>也就是说，架构师是需要在日常工作中，从多个维度去坚持提升，包括但不限于业务抽象能力、代码编写能力、复杂问题解决能力、与人沟通能力、项目管理能力等。</p><h2 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h2><p>之前笔者以为方法论非常虚，没必要去学习，后面随着实际经验的累计，发现“学习方法论 &gt; 实践  &gt; 基于方法论对实践进行反思”这一循环，正是我们自身能力螺旋上升的典型模式。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748422443943-a308c9b2-be0c-4e41-87bf-80bab030c1c4.png"></p><p>举一个笔者印象非常深刻的例子，余弦定理。初看公式的时候，我们会觉得很精妙，之后自己花一定时间去推导出来后，发现太完美了。但是推导它需要花费一定的时间和精力，所以我们都是将该公式铭记于心，然后在解决相关问题时，就直接套用公式，而不是再去重新推导，这其实就是一种方法论，对于架构设计也是如此。</p><h1 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h1><p>架构，是由组成<strong>模块</strong>、特定上下文环境下模块间的<strong>关系</strong>、指导模块和关系发展的<strong>原则</strong>。</p><p>有点类似于编程语言中的基类，越顶层的抽象描述事物的范围越广。对于软件系统架构，我们可以从一个软件系统最终落地结果来看，进而得到软件系统架构关于架构的具体实现。</p><p>它分为系统模块架构、对象架构和数据存储架构这三种，具体如下：</p><p>（1）系统模块架构：</p><ul><li>模块：系统分层模块，应用模块和外部服务模块；</li><li>关系：模块依赖关系，模块数据流转方式；</li><li>原则：模块划分方案。</li></ul><p>（2）对象架构：</p><ul><li>模块：类，包含哪些核心类，类的职责是什么；</li><li>关系：类的继承关系、依赖关系；</li><li>原则：类设计指导思想和关注点。</li></ul><p>（3）数据存储架构：</p><ul><li>模块：数据库和表，有哪些数据库、数据表；</li><li>关系：表的关联关系，不同数据表之间的一对一或者一对多关系；</li><li>原则：数据存储选型/设计方案和关注点，以及设计考虑的核心质量属性。</li></ul><h1 id="架构师要解决的问题"><a href="#架构师要解决的问题" class="headerlink" title="架构师要解决的问题"></a>架构师要解决的问题</h1><p>前面我们提到了软件系统架构的定义，实际上这些就是架构师的职责和要落地的内容。对于业务系统来说，我们的输入往往就是业务需求或者技术需求的描述集合，输出则是软件的系统架构，中间的则是架构师要解决的问题，即如何将业务需求或者技术需求加工成落地的软件系统架构。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748483379942-0ee7960c-10ab-425d-8172-488ff5074275.png"></p><p>实际上我们提到的数据存储架构、对象架构、系统模块架构，这些底层都需要有业务领域模型，这样才能设计出对应的软件系统领域模型。要想得到业务领域模型，我们需要对需求充分了解，充分挖掘，并评估各个利益方关注点的核心质量属性以及业务目标，因此架构师要解决的问题如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748483752331-7bea9418-c300-422a-82da-403a8e1a7129.png"></p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>从上往下看，首先是了解需求，包括利益相关方的业务目标、关键架构需求和用例集。</p><p>利益相关方的业务目标会影响质量属性的优先级和架构的设计选型。而关键架构需求包含四类：</p><p>（1）约束：给定的不可更改的设计决策；</p><p>（2）质量属性：评估系统的非功能性需求，是利益相关方判断软件系统是否好用的一切外部可见特性。如响应耗时，可扩展、可用性、可维护性等，它表征系统在特定环境下的运行情况。通常设计系统时会提高或者拟制一个质量属性，如性能和可读性。因此在模式选择的时候，需要基于质量属性进行抉择。</p><p>（3）影响较大的功能需求：一些需要特别注意的特性和功能；</p><p>（4）其他影响因素：团队成员的经验和擅长。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748485312819-f880a9b6-1e15-42b9-b408-54f517e8f253.png"></p><p>用例集，它是一组相关的成功和失败的场景集合，用于描述参与者如何使用系统来实现目标。举个例子，一个优秀的产品文档，应当无限接近于标准的格式化用例描述集合，它是原始产品方案经过多次沟通得到的标准化语言。一个用例应该要包含参与者（可以是系统或者用户）、前置条件（使用场景）、如何使用系统、经过什么规则、产生什么结果。只有这样的用例集合，才能描述出产品系统的功能全貌。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748485659456-f3791db4-88f5-4e2f-9350-c7f465bc7ed6.png"></p><h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><p>当从业务目标、关键架构需求和用例集将需求描述清楚之后，接下来就可以使用业务模型来描述项目产品。这一层设计的是问题空间中的<strong>领域模型，它是对客观物理世界中概念、规则、关系的分析和描述，与软件系统无关。</strong></p><blockquote><p>这个层次上的实体，我们称之为概念实体，这一部分内容用在需求和业务分析上。讨论业务概念模型时，完全不需要考虑软件的实现，这是一个分析过程，即使不做软件研发，做其他的研发，类似的分析过程也应该有。</p></blockquote><p>实际上，笔者翻阅《实现领域驱动模型》一书，里面对问题空间也做了一个定义，即问题空间是顶级域和其他域的组合，以及域之间的关联关系，即使没有软件的存在，这些域还是存在的，域之间的关系也还是存在的。</p><p>在设计过程，我们需要将<strong>问题空间的领域模型</strong>映射到<strong>解决问题空间</strong>，而《实现领域驱动模型》一书中对<strong>解决问题空间</strong>的定义“一组特定的软件模型，它通过软件的方式来实现解决方案”。实际上，这一组特定的软件模型就是我们要产出的软件系统架构，如系统模块架构、对象架构、存储架构。</p><p>笔者看过一些文章，发现现在很多讲架构的文章，讲的都是这一层的故事，甚至有些只讲了系统模块架构，如MVC架构、六边形架构、洋葱架构和整洁架构等。</p><p>《领域驱动设计，软件核心复杂性应对之道》 一文，则花了大量的篇幅，来介绍实体、值对象、服务、聚合根、工厂、仓库、界限上下文等，这是一套将问题空间领域模型映射到解决空间对象架构的设计模式。</p><h1 id="如何解决架构师要解决的问题"><a href="#如何解决架构师要解决的问题" class="headerlink" title="如何解决架构师要解决的问题"></a>如何解决架构师要解决的问题</h1><h2 id="了解需求"><a href="#了解需求" class="headerlink" title="了解需求"></a>了解需求</h2><p>只有了解需求、了解利益相关方关注点、了解业务目标，我们才能制定对应的设计策略。</p><h2 id="利益相关方关注点"><a href="#利益相关方关注点" class="headerlink" title="利益相关方关注点"></a>利益相关方关注点</h2><p>首先我们需要梳理需求的利益相关方关注点图表，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748486955872-d6c30c82-6f5d-4d3d-bf60-5fdde374e531.png"></p><p>这里我们对利益相关方进行了排序，其中优先级越高的，它的关注点越能影响后续决策。与利益相关方沟通之后，接下来我们要与他们明确业务目标（背景+主体+结果）。业务目标是架构的主要驱动因素，多个利益相关方发生冲突时，要以业务目标为核心进行排序选择。</p><h2 id="关键架构需求"><a href="#关键架构需求" class="headerlink" title="关键架构需求"></a>关键架构需求</h2><p>关键架构需求是指能够显著影响架构中的结构选择的需求，一般为四类：约束、质量属性、影响较大的功能需求和其他影响因素。</p><ul><li><strong>约束</strong>：约束是架构中不能被打破的原则性前提。约束的语法应当是“必须怎样”，而不是“尽量怎样”。由于约束的不可变性，因此我们要尽可能的减少约束性需求。但是新增约束通常会带来架构设计上的便利，加速项目功能上线，只是需要架构师来甄别哪些约束恰当。</li><li><strong>质量属性</strong>：质量属性与功能性需求无关，因此很容易被忽视，但是在进行模式选择和方案设计的时候，通常又要基于质量属性做设计决策。可通过一个质量属性优先级的排名来对利益相关方关注的事项和原始质量属性场景进行提取、分类、完善、排定优先级，并可视化头脑风暴与利益相关方的沟通结果：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748679781758-2e5c390e-8134-41e5-b8a1-dd71a35717e7.png"></p><ul><li><strong>影响较大的功能需求</strong>：需求特别注意的特性和功能。</li><li><strong>其他影响因素</strong>：请注意，这里虽然叫做其他影响因素，但是它对最终架构选型至关重要。架构师和团队的经验极大程度上影响着，我们使用框架和存储选择。</li></ul><h2 id="用例集"><a href="#用例集" class="headerlink" title="用例集"></a>用例集</h2><p>用例集，它是一组相关的成功和失败的场景集合，用于描述参与者如何使用系统来实现目标。单独一个用例，应该要能完整表达一次或者一类业务行为。</p><p>一个用例应该要包含参与者（可以是系统或者用户）、前置条件（使用场景）、如何使用系统、经过什么规则、产生什么结果。只有这样的用例集合，才能描述出产品系统的功能全貌。</p><p>请注意，这里的用例集合通常所说的tc（测试用例）集是不一样的，用例相比tc更强调过程规则，强调对功能的描述，而tc则更多关注的是输入和输出，强调覆盖场景，强调对业务功能、业务模型、技术模型的功能性或者非功能性验证。</p><h1 id="架构描述"><a href="#架构描述" class="headerlink" title="架构描述"></a>架构描述</h1><p>前面提到的业务模型还是软件系统模型，它们对于架构的描述，都不可避免的涉及到通过图来描述全貌。复杂的系统架构，用单一的模型图描述的话，只会非常粗略，因此提出了“视点”这一概念。</p><p><strong>”视点“，即从不同的角度或者专业领域来看待系统的方法。</strong>常用的视点方法论有”C4模型“和”4+1模型“。</p><h2 id="C4模型"><a href="#C4模型" class="headerlink" title="C4模型"></a>C4模型</h2><p>所谓C4模型，实际上就是4个层次，下面分别进行介绍：</p><p>（1）上下文层次（Context）：描述系统与外部实体（如用户、其他系统、软硬件设备等）之间的关系，用于展示系统如何与周围环境交互以及其外部依赖关系。 </p><p>（2）容器层次（Container）：系统内的软件被分解成多个容器，如应用程序、数据库、文件系统等，容器图描述了这些容器之间的关系及它们如何共同工作以实现系统的功能。</p><p>（3）组件层次（Component）：在容器的内部，每个容器被进一步拆分为组件，如类、模块、服务等，组件图描述了组件之间的关系和依赖关系，以及它们如何协同工作。</p><p>（4）代码层次（Code）：这是最低层次，描述了每个组件的内部实现细节，可以是类图、包图等，用于展示组件内的代码结构。</p><h2 id="4-1模型"><a href="#4-1模型" class="headerlink" title="4+1模型"></a>4+1模型</h2><p>所谓4+1模型，实际上就是5个视图，下面分别进行介绍：</p><p>（1）场景视图：从外部视角，描述系统的参与者（用户）与系统功能用例的关系。反映的是系统的最终用户需求和交互设计。 </p><p>（2）逻辑视图：从结构化视角，描述该系统对用户提供的所需功能服务所具备的组件结构和数据结构，以及一些边界约束条件，清晰的描述给用户提供的功能需求服务是如何构建的。描述该系统内部所具备了那些组织结构，以达到实现对外功能。 </p><p>（3）开发视图：从结构化视角和行为视角，去描述实现系统功能的各个组件和模块是如何实现的。</p><p>（4）处理视图：从行为视角，描述系统各个组件和模块是如何进行通信的。</p><p>（5）物理视图：从交互视角，描述系统可以部署到哪些物理环境（如服务器、PC端、移动端等）上和软件环境（如虚拟机、容器、进程等）上。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>下面分别从问题空间和解决方案空间模型出发，来对架构进行描述：</p><p>（1）业务领域模型图：描述需求的分析结果，突出业务领域概念和业务模型关系，统一产品需求方、领域专家、开发人员的概念语言；</p><p>（2）系统模块图：描述系统内的分层模式和模块/领域依赖关系，描述系统间的依赖关系和数据交互方式；</p><p>（3）对象模型图：描述核心类职责，类与类继承关系，类与类的依赖关系；</p><p>（4）数据存储架构图：描述库表结构，分库分表策略，存储选型，以及不同数据表之间的一对多/一对一等依赖关系。</p><p>实际上，这里也是一个视点想要表达的内容，而不是只用一张图来表达内容。我们按需绘制精细视图，用于呈现系统细节，描述某个局部的系统细节。也可以增加质量属性视图，用来表达设计原则，描述对于某个属性质量的设计，如可用性、数据准确性、一致性等。</p><h1 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h1><p><strong>业务模型是问题空间的领域模型</strong>，描述业务和产品，与软件系统无关，具体<strong>描述的是客观物理世界的概念、规则、关系</strong>。</p><p>要想对业务领域建模，首先要对用例进行分析，步骤如下：</p><p>（1）从准确的用例中剥离出名词； </p><p>（2）根据名词梳理领域模型和其属性； </p><p>（3）根据名词的修饰梳理出属性值； </p><p>（4）根据名词的定义完善属性值； </p><p>（5）从用例集合中剥离出动词&amp;形容词； </p><p>（6）根据动词&amp;形容词梳理出领域模型之间的关系。</p><p>但如果只是对用例集进行提取，会遗漏很多隐藏概念。举个例子，关于“一个店铺拥有多个子账户，而每个子账号对店铺的操作权限又不相同”这一描述，我们很容易将操作视作为子账号的一个属性，子账号则挂靠在店铺实体上：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748682904412-dfd1a916-f41e-4544-aaae-ea622a4aa420.png"></p><p>这里例子应该很常见了，一般我们都会将权限单拎出来，作为单独的实体，然后再将权限关联到账号上，这样也方便权限后期的维护和继承：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748682996350-f1cd8336-0d5a-4d42-b21d-66cacf513502.png"></p><p>实际上这里就涉及到了<strong>架构元模型</strong>（<strong>元模型定义了模型中使用的概念和使用规则</strong>）中隐藏概念的建立，从提问开始，建立模型，检验模型，分离概念，如此循环：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748683117273-7be8e082-d3d9-4071-8e13-3c641ba00276.png"></p><p>请注意，业务人员与技术人员之间需要使用统一的、通用的语言，这样才能极大地降低了沟通成本。</p><h1 id="软件系统模型中的系统模块架构"><a href="#软件系统模型中的系统模块架构" class="headerlink" title="软件系统模型中的系统模块架构"></a>软件系统模型中的系统模块架构</h1><p>系统模块架构用于描述<strong>系统内的分层模式和模块/领域依赖关系</strong>，即系统间的<strong>依赖关系和数据交互方式</strong>。</p><p>关于系统内的分层模式和模块/领域的依赖关系方法论，<strong>《</strong>DDD中常提到的应用架构总结（六边形、洋葱、整洁、清晰）<strong>》</strong>一文中介绍的非常详细，这里简单摘录一下。</p><h2 id="传统MVC分层架构"><a href="#传统MVC分层架构" class="headerlink" title="传统MVC分层架构"></a>传统MVC分层架构</h2><p>最开始的传统MVC分层架构，对系统进行了简单分层，描述了从数据层到业务逻辑层，再到数据出口层的关系。由于MVC中，业务逻辑对数据出入口的依赖是确定的，因此如果这个依赖发生变化，那么改动成本非常大，无法突出领域模型的独立性：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748684015997-f75f7d66-342a-4790-9387-9f861dd62949.png"></p><h2 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h2><p>于是六边形架构出现，它将领域层独立出来，不依赖任何确定的外部服务，以端口/适配器的方式定义外部服务交互协议。只要能实现这套交互协议，数据出入口的依赖变化，对领域层是没有侵入的。这里体现的是领域驱动设计的思想，<strong>将领域知识立在最重要的地位</strong>，不为任何模块影响。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748684220250-4ced3a5c-e850-48bc-8ff3-d7a694ef369a.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748684973724-49540428-c6b2-4e8b-92b0-e4e90c949a7a.png"></p><h2 id="清晰架构"><a href="#清晰架构" class="headerlink" title="清晰架构"></a>清晰架构</h2><p>最后是清晰架构，它的最内层是<strong>领域层</strong>，包含领域模型和领域服务，实现相关的领域知识和概念模型。实际上清晰架构中间还存在洋葱架构和整洁架构这两个架构。</p><p>清晰架构向外是<strong>应用服务</strong>，可依赖领域层，做业务用例的编排实现，如操作某个领域服务后，再操作某个实体进行某项行为，最后发送某个领域事件等。和应用服务层同级的，还有<strong>CQRS和事件/消息处理器</strong>，接受不同类型的命令执行类似应用服务的事情。</p><p>以上这些即应用核心，应用核心与外界的交互分为两类：图中的<strong>左半边为主动适配器</strong>，做类似于Controller或是HSF服务的系统最外层请求实现；图中的<strong>右半边为被动适配器</strong>，定义消息出口、数据持久化接口、搜索引擎接口等，由外部具体的基础设施实现。可见，清晰架构属于集前人所长，提供的一份以领域知识为核心的<strong>分层架构指南</strong>：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748685146303-4233e416-1867-4d9e-ad47-206d1d65d951.png"></p><p>除了系统内部的分层结构，我们还需要描述<strong>系统间、应用间的关系</strong>，以及数据流转的方式：</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748685285974-1b90e40d-e4ef-47c9-9fe6-575ea6a8d795.png"></p><h1 id="软件系统模型中的对象架构"><a href="#软件系统模型中的对象架构" class="headerlink" title="软件系统模型中的对象架构"></a>软件系统模型中的对象架构</h1><p>按照前面抽象出来的业务领域模型编写的代码，能够很好的表达设计含义，且模型与实际系统相契合。</p><p>面向对象编程之所以强大，是因为它为架构概念提供了实现方式，能描述现实物理世界中的关系(操作、继承、组合)和模型(定义、属性、职责)。</p><p>《领域驱动设计，软件核心复杂性应对之道》一书中，用了大量的篇幅来讲解如何使用面向对象的思路，来对类的类型进行划分，并将业务模型映射到对象模型中的模式。下面分别介绍实体、值对象、聚合、服务、工厂、仓库和防腐层等7个概念。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>【实体】实体由标识定义，而不依赖它的所有属性和职责，并在整个生命周期中有连续性。说白了，就是一个标识不变的对象。如果某个对象在它自身属性发生变化后，它依旧不变，那么它就是一个实体。举个例子，某条工单，它的处理人和状态发生了变化，但是它的工单编号没有变化，那么这个工单依旧是之前的工单，只是它的一些属性发生了变化。</p><p>我们可以通过这种方式来识别实体，因为在领域中的关键对象，通常并不由它们的属性定义， 而是由可见的/不可见的标识来定义，且有完整的生命周期，在这个周期内它如何变化，它都依然是它。</p><p>通过这种方式识别出实体这种领域关键对象，这也是领域驱动设计和数据驱动设计最大的差别。数据驱动设计是先识别出我们需要哪些数据表，然后将这些数据表映射为对象模型。而领域驱动设计是先通过业务模型识别出实体，再将实体映射为所需要的数据表。</p><p>请注意，实体的标识可以是可见的，也可以是不可见的，因为有很多域内无持久化的系统，在它们的对象模型中，并不存在可见的唯一标识ID。</p><p>对于更加关注”行为”而非”唯一性”的纯计算型应用，笔者这里给出划分实体与值对象的另一种思路，如下所示：</p><p>（1）实体是会对自身属性做出强解释行为的类型；</p><p>（2）值对象是轻属性解释，重属性设计的类型。</p><p>因为对于纯计算型应用而言，业务关注重点是行为，当一个类需要承载复杂的计算逻辑，即对自身属性需要进行强解释行为时，它往往就承载了系统中更重要的职责，能更加凸显领域业务概念。</p><h2 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h2><p>【值对象】值对象用于描述领域的某个方面而本身没有唯一标识的对象。被实例化后用来表示一些设计元素，对于这些设计元素，我们<strong>只关心它们是什么，而不关心它们是谁</strong>。</p><p>举个例子，某条工单的发生地址Address有城市、街道、道路这三个属性，其中的道路从长江路修改到了黄河路，它已经不再是修改前的那个了，因为道路名称已经发生了变化。即它是没有生命周期的，<strong>它的equals方法由它的属性值决定（实体的equals方法由唯一标识决定）</strong>。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>【聚合】聚合是一组实体和值对象的组合，其内部包含一个聚合根，由聚合根关联实体和值对象。</p><p>举个例子，商品、sku、库存三个实体，那么在商品模型中，商品就是聚合根，其内部通过sku_id来关联它的sku，库存id关联商品/sku的库存。聚合将这组关联关系建立，对外提供统一的操作。如果需要删除某个商品，那么这个聚合的内部需要在一个事务(或分布式事务)中，对库存进行清空，对sku进行删除，最终才能对商品进行删除。</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>【服务】有一些对实体/聚合/值对象进行编排操作的概念并不适合被建模为对象，那么它应该被抽象为服务，化作一只上帝之手，做领域对象间流程操作的编排。服务很重要的特征，它的操作应该是无状态的。</p><h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><p>【工厂】当创建一个实体对象或聚合的操作很复杂，甚至有很多领域内部的结构需要暴露时，就可以用工厂进行封装。对于工厂的判断，这里提供一种相对简单粗暴的判断方法，即看这个类的构造方法实现是否复杂，且这些逻辑不应该由这个类实现那么此时就可以使用工厂来构造该对象。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>【仓库】仓库是可持久化的领域对象和真实物理存储操作之间的媒介，随意的数据库查询会破坏领域对象的封装，因此需要抽象出仓库这种类型。仓库用于定义领域对象的获取和持久化方法，具体实现领域层无法感知。</p><p>至于具体用了什么存储，如何写入和查询，是否使用缓存，这些逻辑统一封装在仓库的实现层，对于后续迁移存储、增删缓存，可以做到不入侵业务领域。</p><h2 id="防腐层"><a href="#防腐层" class="headerlink" title="防腐层"></a>防腐层</h2><p>【防腐层】防腐层并不是一个特定的对象类型，而是一种领域模型保护的思路。对于领域外界的变化，我们需要持悲观的态度，因为领域外部的模型不受我们控制，它们的变化轨迹难以捉摸。因此在系统与系统之间，上下文与上下文之间，要有一层放腐层进行领域内外的模型转换。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748687127816-d414b5f6-7854-4195-b9d2-deac90d81e2c.png"></p><h2 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h2><p>有了对象类型的划分之后，接下来将对对象职责进去确定，可以使用GRASP给出的判断标准：</p><p>（1）创建者。</p><blockquote><p>问题：谁负责产生类的实例？</p><p>解决方案：如果符合下面的一个或者多个条件，则可以将创建类A实例的职责分配给类B：</p><p>B包含A </p><p>B聚合A </p><p>B拥有初始化A的数据并在创建类A的实例时将数据传递给类A </p><p>B记录A的实例 </p><p>B频繁使用A </p></blockquote><p>（2）信息专家。</p><blockquote><p>定义：如果某个类拥有完成某个职责所需要的所有信息，那么这个职责就应该分配给这个类来实现。此时，这个类就是相对于这个职责的信息专家。 </p><p>解决方案：将职责分配给拥有履行一个职责所必须信息的类或者域。</p></blockquote><p>（3）低耦合。</p><blockquote><p>问题：怎么样支持低的依赖，减少变更带来的影响，提高重用性？ </p><p>解决方案： </p><p>在类的划分上，尽量创建松耦合的类，修改一个类不会影响其他类。 </p><p>在类的设计上，尽量降低类中成员和方法的访问权限，尽量将类设计为不变类。</p><p>在类的引用上，将一个对象对另一个对象的引用降低到最小。 </p></blockquote><p>（4）高内聚。</p><blockquote><p>问题：如何使得复杂性可控？ </p><p>解决方案：功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。</p></blockquote><p>（5）纯虚构。</p><blockquote><p>当不想破坏高内聚和低耦合的设计原则时，但是有些职责又没地方放，如何处理 </p><p>解决方案：将一组高内聚的职责分配给一个虚构的或者处理方便的类，它并不是问题域的概念，而是虚构的概念，以达到支持高内聚低耦合和重用的目的。 </p></blockquote><p>（6）间接。</p><blockquote><p>问题：如何分配职责，以避免两个事物之间的直接耦合？ </p><p>解决方案：当我们不知道将职责分配给何种模型的时候，可以看看是否可以将职责分配给中介模型。 </p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2025/png/12555354/1748687519466-a8cf8b44-9b21-4f95-a7a3-655d7c32343e.png"></p><h1 id="软件系统模型中的存储架构"><a href="#软件系统模型中的存储架构" class="headerlink" title="软件系统模型中的存储架构"></a>软件系统模型中的存储架构</h1><p>存储架构，用于描述数据库和表结构，包含分库分表策略，存储选型，以及不同数据表之间的一对多/一对一等依赖关系。</p><p>常见的手段有E-R图描述表模型关系，用图例来描述分库分表策略以及存储选型策略。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文学习了架构设计中的一些方法及软件系统模型，对于后续架构设计有很大帮助。由于横向架构师本质上是站在多业务视角上的纵向架构师，单业务领域对它而言其实就是子域，因此没有花篇幅去介绍横向架构师。</p><p>【参考资料】</p><p>（1）<strong>《领域驱动设计，软件核心复杂性应对之道》</strong>，作者：Eric Evans，译者：赵俐 / 盛海艳 / 刘霞，出版社：人民邮电出版社；</p><p>（2）<a href="https://code84.com/730128.html">《DDD中常提到的应用架构总结（六边形、洋葱、整洁、清晰）》</a>;</p><p>（3）<a href="https://mp.weixin.qq.com/s/_sPs0NB4zWef-pW17DKimg">架构之道：人人都是架构师</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;2024年笔者正式步入到架构设计的领域，因此有必要记录自己在架构设计方面学习的点滴。由于每个业务系统都要求从业务架构的视角进</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>巧用分页列表缓存，快速响应用户请求</title>
    <link href="http://aigoing.chat/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/"/>
    <id>http://aigoing.chat/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/</id>
    <published>2023-05-28T08:55:30.000Z</published>
    <updated>2023-06-09T13:52:42.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响应用户的时间，主要用到了分页列表缓存。</p><h1 id="直接缓存分页列表"><a href="#直接缓存分页列表" class="headerlink" title="直接缓存分页列表"></a>直接缓存分页列表</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最简单，也是最能想到的方法就是直接缓存分页列表。举个例子，如下所示，直接将每页的数据以列表形式进行缓存：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-77510826a25930a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    String key = &quot;productPageList:pageNum:&quot; + pageNum+ &quot;pageSize:&quot; + pageSize+  &quot;param:&quot; + param ;</span><br><span class="line">    List&lt;Product&gt; productList = cacheUtil.get(key);</span><br><span class="line">    if(productList != null)return productList;</span><br><span class="line">    productList = queryFromDB(param,pageNum,pageSize);</span><br><span class="line">    if(productList != null) &#123;</span><br><span class="line">         cacheUtil.set(key , productList , Constants.ExpireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方式优点就是操作简单，性能也快，缺点就是缓存的粒度太粗。如果列表中数据发生增删，为了保证数据的一致性，需要修改分页列表缓存。</p><p>当然了，可以有两种方式来解决 ：<br>（1）利用缓存的过期时间来惰性删除，不过这种要求业务能接受；<br>（2）使用Redis提供的<code>keys</code>命令来找到对应的分页缓存，之后执行删除操作。不过<code>keys</code>命令对性能影响很大，会导致 Redis产生较大的延迟，这一点在并发性要求高的业务下是很难满足的 。而且生产环境使用<code>keys</code>命令比较危险，很容易出现问题，因此不推荐使用<code>keys</code>命令。</p><h1 id="先查询对象ID列表，再缓存每个对象"><a href="#先查询对象ID列表，再缓存每个对象" class="headerlink" title="先查询对象ID列表，再缓存每个对象"></a>先查询对象ID列表，再缓存每个对象</h1><p>前面说过直接缓存分页列表，导致缓存粒度较粗，很难保证数据的一致性，因此我们可以尝试细粒度缓存，即先查询对象ID列表，再缓存每个对象。</p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>举个例子，如下所示，首先我们查询分页对象ID列表，然后再缓存每一个对象，后续通过对象ID和缓存的对象来聚合形成列表返回给前端：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-adbcc181311b464e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    //1、构建返回对象</span><br><span class="line">    List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br><span class="line">    //2、从数据库中查询分页ID列表</span><br><span class="line">    List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br><span class="line">    //3、为空则直接返回空列表</span><br><span class="line">    if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">        return new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    //4、批量从缓存中获取缓存对象列表</span><br><span class="line">    Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br><span class="line">    //5、缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来</span><br><span class="line">    List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">    noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">        if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">            noHitpProductIdList.add(productId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //6、将前面没有命中的对象从数据库中查询并添加到缓存中</span><br><span class="line">    List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">    if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">        Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">        .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">        //将没有命中的对象添加到缓存中</span><br><span class="line">        cacheUtil.mset(noHitProductMap);</span><br><span class="line">        //将没有命中的对象添加到聚合Map中</span><br><span class="line">        cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">    &#125;</span><br><span class="line">    //7、组装返回对象</span><br><span class="line">    productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">      Product product = cacheProductMap.get(productId);</span><br><span class="line">      if(product != null)&#123;</span><br><span class="line">        result.add(product);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面简单解释一下上述代码的含义：<br>（1）构建返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br></pre></td></tr></table></figure><p>（2）从数据库中查询分页ID列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br></pre></td></tr></table></figure><p>其实这个就相当于执行如下的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t_product order by id limit (pageNum -1)* size,size;</span><br></pre></td></tr></table></figure><p>（3）为空则直接返回空列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">      return new ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）批量从缓存中获取缓存对象列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br></pre></td></tr></table></figure><p>这里我们采用的是分布式缓存系统Redis，它天然支持批量查询命令，如mget、mset等。<br>（5）缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">        noHitpProductIdList.add(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于缓存中可能出现对象过期或者其他原因，导致缓存没有命中，此时我们需要找到哪些对象是没有命中的。<br>（6）将前面没有命中的对象从数据库中查询并添加到缓存中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">    Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">    .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">    //将没有命中的对象添加到缓存中</span><br><span class="line">    cacheUtil.mset(noHitProductMap);</span><br><span class="line">     //将没有命中的对象添加到聚合Map中</span><br><span class="line">    cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先我们从数据库中批量查询出未命中的对象列表，其实就相当于执行如下SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_product where id in (1,2,3......);</span><br></pre></td></tr></table></figure><p>之后就将命中的对象添加到缓存和聚合Map中。<br>（7）组装返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    Product product = cacheProductMap.get(productId);</span><br><span class="line">    if(product != null)&#123;</span><br><span class="line">      result.add(product);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可以看到此时最坏的情况就是经过两次网络IO，第一次是数据库查询IO，第二次是Redis查询IO，我们就能得到所需要的数据。</p><p>“先查询对象ID列表，再缓存每个对象”这种方案灵活性很高，我们还可以将查询对象ID列表这一操作从数据库中变为从Redis、ElasticSearch等。下图是博客文章的搜索流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69072d5faeed1cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到，此时搜索的分页结果中只包含业务对象 ID ，而对象的详细信息则从缓存和数据库中获取。</p><h1 id="缓存对象ID列表同时缓存每个对象"><a href="#缓存对象ID列表同时缓存每个对象" class="headerlink" title="缓存对象ID列表同时缓存每个对象"></a>缓存对象ID列表同时缓存每个对象</h1><p>记得之前笔者在写一个社交APP的时候，遇到过Feed流的情况，需要以瀑布流的形式展示用户所关注的好友的动态。当时采用了推模式并结合Redis的ZSet数据结构来实现，将每一条动态ID存储在ZSet中，ZSet是一种有序的数据结构，由多个有序的唯一字符串组成，每个字符串都关联一个浮点类型的分数。</p><p>ZSet 使用的是 member -&gt; score 结构 ，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-82a033cd1cb7b693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>member是被排序的标识，也是默认的第二排序维度（ 即score相同时，Redis以member的字典序排列）；而score则是被排序的分值，存储类型是double。</p><p>我们可以使用ZSet来存储动态 ID 列表，其中member是动态编号，score是创建时间，然后通过ZSet 的<code>ZREVRANGE</code>命令就可以实现分页效果，它用于按照成员的分数从大到小返回有序集合中的指定范围的成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>当然了，为了实现分页效果，我们上面的start和stop的取值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int start = (pageNum -1) * pageSize;</span><br><span class="line">int stop = start + pageSize - 1;</span><br></pre></td></tr></table></figure><p>这样通过<code>ZREVRANGE</code>命令，我们就可以查询出动态ID列表了。在获取到动态ID列表之后，我们还需要缓存每个动态对象的信息，这些动态对象包括详情、评论、点赞、转发等内容，这些内容是需要单独做缓存的：</p><table><thead><tr><th align="center">动态信息</th><th align="center">Redis存储方式</th></tr></thead><tbody><tr><td align="center">动态</td><td align="center">使用Hash来存储动态详情</td></tr><tr><td align="center">点赞</td><td align="center">使用ZSET来存储userId，前端显示用户头像，使用String缓存用户信息</td></tr><tr><td align="center">收藏</td><td align="center">使用String来存储userId和FeedId的映射关系</td></tr><tr><td align="center">评论</td><td align="center">使用ZSET来存储commentId，使用String缓存评论详情信息</td></tr></tbody></table><p>当然，无论是查询还是更新缓存，笔者都是建议采用批量操作，这样效率更高。如果缓存对象结构简单，那么可以使用<code>mget</code>、<code>hmget</code>等命令；若结构复杂，可以使用pipleline，Lua脚本等方式。 笔者采用Redis的pipleline来实现批量操作。</p><p>“缓存对象ID列表同时缓存每个对象”这种方案的流程如下所示：<br>（1）使用ZSet来存储动态 ID 列表，并通过传入分页参数和<code>ZREVRANGE</code>命令来动态查询ID列表；<br>（2）通过传递动态ID列表参数，并采用Redis的pipleline功能，从缓存中批量获取动态的详情，评论，点赞，收藏等数据 ，最终组装成所需列表并返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要学习了分页缓存的三种方案，如下所示：<br>（1）直接缓存分页列表；<br>（2）先查询对象ID列表，再缓存每个对象；<br>（3）缓存对象ID列表同时缓存每个对象。<br>这三种方式层层递进，最终采用细粒度控制缓存对象和批量加载缓存对象，进而实现快速响应用户请求这一目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>基于请求参数校验的接口幂等性实现方案</title>
    <link href="http://aigoing.chat/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/"/>
    <id>http://aigoing.chat/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/</id>
    <published>2023-05-10T02:55:30.000Z</published>
    <updated>2023-06-09T13:50:03.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求参数的校验，这种方式在高并发环境下优势更明显。由于请求只有一次，所以不需要从服务端获取令牌。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>基于请求参数校验这一方式原理很简单，如果在某一个时间间隔内，同一个接口接收到的请求参数一样，则说明前后请求是重复的，服务端则拒绝处理后续请求。注意由于前后端通过JOSN格式传递数据，且需要多次重复读取JSON数据，所以前面介绍的文章还是有很大的帮助。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>第一步，新建一个名为<code>repeat-submit</code>的SpringBoot项目，然后在POM文件中引入redis、web和aop依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，在<code>application.yml</code>配置文件中新增redis配置信息及项目运行端口信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    password: root</span><br><span class="line">    database: 4</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>第三步，新建redis包，并在redis包内新建一个名为RedisCache的工具类，该类用于封装对Redis的操作。里面定义了两个方法，即对字符串进行存入和查看这两个操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCacheObject(final String key)&#123;</span><br><span class="line">        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void setCacheObject(final String key, final T value, Integer timeout, TimeUnit timeUnit)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，新建annotation包，并在annotation包内新建一个名为RepeatSubmit的注解，该注解可用在需要实现幂等的接口上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface RepeatSubmit &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 两个请求之间的间隔时间，单位毫秒</span><br><span class="line">     * 小于此间隔认为重复提交</span><br><span class="line">     */</span><br><span class="line">    public int interval() default 5000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重复提交时提示信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String message() default &quot;请勿重复提交，稍后再试&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，新建interceptor包，并在interceptor包内新建一个名为IdempotencyInterceptor的抽象类，这个抽象类通过拦截器来拦截所有被<code>RepeatSubmit</code>注解所修饰的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdempotencyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        if(handler instanceof HandlerMethod)&#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            RepeatSubmit annotation = method.getAnnotation(RepeatSubmit.class);</span><br><span class="line">            if(null != annotation)&#123;</span><br><span class="line">                //重复提交</span><br><span class="line">                if(isRepeatSubmit(request,annotation))&#123;</span><br><span class="line">                    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                    map.put(&quot;status&quot;,500);</span><br><span class="line">                    map.put(&quot;message&quot;,annotation.message());</span><br><span class="line">                    response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">                    response.getWriter().write(new ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，具体判断逻辑由子类确定</span><br><span class="line">     */</span><br><span class="line">    public abstract boolean isRepeatSubmit(HttpServletRequest request,RepeatSubmit repeatSubmit);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它重写了preHandle方法的逻辑，首先判断当前handler是否为HandlerMethod的实例，如果是就强转为Method对象并得到方法上的<code>@RepeatSubmit</code>注解。如果该注解存在，然后调用<code>isRepeatSubmit()</code>方法来判断是否为重复提交，如果是则返回既定的重复提交数据提示。注意，这里我们将<code>isRepeatSubmit()</code>方法设置为抽象方法，目的是针对重复提交的实现逻辑可以有很多种，这里我们采用的是根据“URL地址+请求参数”这一方式来判断。后期开发者可以对此有不同的实现，而不用修改此处的重复提交提示信息。</p><p>第六步，在interceptor包内新建一个名为isRepeatSubmit的类，这个类需要继承前面的IdempotencyInterceptor类并重写其中的isRepeatSubmit方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于请求地址URL+请求参数来判断是否重复提交</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RepeatSubmitInterceptor extends IdempotencyInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    public final String REPEAT_PARAMS = &quot;repeatParams&quot;;</span><br><span class="line">    public final String REPEAT_TIME = &quot;repeatTime&quot;;</span><br><span class="line">    public static final String REPEAT_SUBMIT_KEY = &quot;REPEAT_SUBMIT_KEY&quot;;</span><br><span class="line"></span><br><span class="line">    private String HEADER = &quot;Authorization&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，true则表示重复提交</span><br><span class="line">     * @param request</span><br><span class="line">     * @param repeatSubmit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchcked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRepeatSubmit(HttpServletRequest request, RepeatSubmit repeatSubmit) &#123;</span><br><span class="line">        String nowParams = &quot;&quot;;</span><br><span class="line">        if(request instanceof RepeatableReadRequestWrapper)&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = (RepeatableReadRequestWrapper) request;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = requestWrapper.getReader().readLine();</span><br><span class="line">            &#125;catch (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //body参数为空的话，获取Parameter中的参数</span><br><span class="line">        if(ObjectUtils.isEmpty(nowParams))&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = new ObjectMapper().writeValueAsString(request.getParameterMap());</span><br><span class="line">            &#125;catch (JsonProcessingException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //构建一个存于缓存的nowDataMap对象</span><br><span class="line">        Map&lt;String,Object&gt; nowDataMap = new HashMap&lt;&gt;();</span><br><span class="line">        nowDataMap.put(REPEAT_PARAMS,nowParams);</span><br><span class="line">        nowDataMap.put(REPEAT_TIME,System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        //获取请求地址，作为缓存中的key的一部分</span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        //获取消息头，注意这个值唯一,值不存在则使用请求地址</span><br><span class="line">        String header = request.getHeader(HEADER);</span><br><span class="line">        //构建缓存中的key</span><br><span class="line">        String cacheRepeatKey = REPEAT_SUBMIT_KEY + url + header.replace(&quot;Bearer &quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //查询缓存中是否存在对应的数据</span><br><span class="line">        Object cacheObject = redisCache.getCacheObject(cacheRepeatKey);</span><br><span class="line">        if(null != cacheObject)&#123;</span><br><span class="line">            Map&lt;String, Object&gt; cacheMap = (Map&lt;String, Object&gt;) cacheObject;</span><br><span class="line">            //参数一致且时间小于设定的间隔，则说明此为重复提交</span><br><span class="line">            if(compareParams(nowDataMap,cacheMap) &amp;&amp; compareTime(nowDataMap,cacheMap,repeatSubmit.interval()))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存中没有数据，说明不是重复提交</span><br><span class="line">        redisCache.setCacheObject(cacheRepeatKey,nowDataMap,repeatSubmit.interval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的参数是否一致</span><br><span class="line">     * @param nowDataMap 现在的参数值</span><br><span class="line">     * @param preDataMap 之前的参数值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareParams(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap)&#123;</span><br><span class="line">        String nowParams = (String)nowDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        String preParams = (String)preDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        return nowParams.equals(preParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的时间间隔是否小于RepeatSubmit注解中指定的值</span><br><span class="line">     * @param nowDataMap 现在时间</span><br><span class="line">     * @param preDataMap 之前时间</span><br><span class="line">     * @param interval RepeatSubmit注解中指定的时间间隔</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareTime(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap,int interval)&#123;</span><br><span class="line">        long nowTime = (Long)nowDataMap.get(REPEAT_TIME);</span><br><span class="line">        long preTime = (Long)preDataMap.get(REPEAT_TIME);</span><br><span class="line">        if((nowTime - preTime)&lt; interval)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）首先判断当前请求是否为RepeatableReadRequestWrapper的实例，如果是则说明当前请求参数格式为JSON，此时就会通过解析IO流来读取数据，关于这一部分在之前的《SpringBoot实现JSON数据重复读取》一文中进行了介绍；<br>（2）如果当前请求不是RepeatableReadRequestWrapper的实例，说明不是JSON格式，那么可以从请求参数中获取，即以key-value方式读取数据，并使用<code>objectMapper.writeValueAsString()</code>方法来将其转换成字符串；<br>（3）接下来我们构造一个用于存入Redis的对象，注意这里我们使用Redis的String类型，Value为Map对象，然后Map对象中存有从请求中读取的参数和当前时间；<br>（4）然后我们构造Redis的Key，这个Key的格式为“固定前缀+请求地址URL+请求头的令牌”，其中固定前缀值为<code>REPEAT_SUBMIT_KEY</code>，请求头的令牌需要去除其中的<code>Bearer </code>字符串。请注意，请求令牌此处必须添加，这样可以区分用户；<br>（5）根据Key去Redis中查询是否存在对应的缓存数据，如果存在则去判断参数是否相同以及两次请求的时间间隔是否小于既定时间间隔，如果两者同时满足，则说明前后两次请求为重复请求，并返回true；<br>（6）如果不是（5）中的结果，那么说明请求是第一次过来或者说已经过了既定的时间窗口，服务器都接受并处理请求，此时将得到的请求信息重新添加到Redis中，并返回false。</p><p>第七步，新建config包，并在config包内新建一个名为MyWebMvcConfig的配置类，这个配置类需要实现WebMvcConfigurer接口，并重写其中的addInterceptors方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手动将自定义的RepeatSubmitInterceptor拦截器注册到Spring容器中</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，新建request包，并在request包内新建一个名为RepeatableReadRequestWrapper的类，<br>这个类需要继承HttpServletRequestWrapper类并重写其中的getInputStream和getReader方法，同时重载一下父类ServletRequestWrapper中有HttpServletRequest和HttpServletResponse对象的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义请求包装类</span><br><span class="line"> */</span><br><span class="line">public class RepeatableReadRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private final byte[] bytes;</span><br><span class="line"></span><br><span class="line">    public RepeatableReadRequestWrapper (HttpServletRequest request,HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        bytes = request.getReader().readLine().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() throws IOException &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int available() throws IOException &#123;</span><br><span class="line">                return bytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() throws IOException &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是自定义了一个新的HttpServletRequest类，并重载了一个包含HttpServletRequest和HttpServletResponse对象的构造方法，目的就是修改请求和响应的字符编码格式以及从IO流出读取数据，然后存入一个字节数组中，并通过重写getInputStream和getReader方法分别从字节数组中获取数据并构造IO流进行返回，这样就实现了IO流的多次读取。</p><p>第九步，新建filter包，并在filter包内新建一个名为RepeatRequestFilter的类，这个类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 请求拦截器，只有JSON数据才会使用自定义的RequestWrapper</span><br><span class="line"> */</span><br><span class="line">public class RepeatRequestFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        if(StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE))&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = new RepeatableReadRequestWrapper(request,(HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(requestWrapper,servletResponse);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们重写了doFilter方法，目的就是判断请求的类型，如果请求是HttpServletRequest且请求数据类型为JSON格式才会调用自定义的RepeatableReadRequestWrapper，即将HttpServletRequest替换为RepeatableReadRequestWrapper，走IO流可以多次读取的逻辑，之后让过滤器继续往下执行。</p><p>请注意，过滤器最好不要使用<code>@Component</code>注解交由Spring容器来管理，这样会导致每个接口都会被进行过滤，最好是开发者自己手动注册，并且配置过滤的接口。</p><p>第十步，在之前定义的MyWebMvcConfig类中将这个自定义的RepeatRequestFilter过滤器注册进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手动将自定义的RepeatRequestFilter过滤器注册到Spring容器中</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">FilterRegistrationBean&lt;RepeatRequestFilter&gt; repeatRequestFilterFilterRegistrationBean()&#123;</span><br><span class="line">    FilterRegistrationBean&lt;RepeatRequestFilter&gt; bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new RepeatRequestFilter());</span><br><span class="line">    bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十一步，新建controller包，并在controller包内新建一个名为RepeatSubmitController的类，我们在该类中提供一个名为<code>/repeat</code>的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RepeatSubmitController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RepeatSubmitController.class);</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/repeat&quot;)</span><br><span class="line">    @RepeatSubmit(interval = 2000)</span><br><span class="line">    public String repeat(@RequestBody String message)&#123;</span><br><span class="line">        logger.info(&quot;message is: &#123;&#125;&quot;,message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于需要提交参数因此必须使用POST请求，同时这里设置了重复提交的时间间隔为2秒，即两秒内如有来自同一用户对同一接口多次请求相同参数时，可认为前后请求是重复提交的。</p><p>第十二步，启动项目进行测试。用户构造<code>http://localhost:8888/repeat</code>链接并以JSON形式传递message时，页面第一次会返回获取的message信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e524ea08a42c6655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果两秒内多次请求则会抛出此为重复请求，请稍后重试的提示信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0eb026568eff2fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过判断请求数据格式是否为JOSN形式，如果是则调用增强的HttpServletRequest并从请求中获取请求参数，然后构建Key并从Redis中查询缓存信息，如果缓存中存在则通过请求参数和时间间隔来判断是否为重复提交，如果是则给出相应提示信息并返回false；否则返回认为是非重复提交并返回true，继续后续流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Redis各种数据类型巧用</title>
    <link href="http://aigoing.chat/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/"/>
    <id>http://aigoing.chat/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/</id>
    <published>2023-04-20T02:55:30.000Z</published>
    <updated>2023-06-09T13:17:06.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信息：一个key关联一个数据集合，同时要对集合中的数据进行各种操作，诸如统计、排序等。</p><p>那么本篇笔者将结合工作实际，列举六种典型使用Redis的业务场景，如下所示：<br>（1）判断用户登录状态；（2）统计用户连续签到情况；（3）统计每天新增和第二天用户留存数；（4）统计网站访客量（Unique Visitor，UV）；（5）最新评论列表；（6）积分排行榜。</p><p>一般来说，我们面临的用户数量和访问量都是巨大的，如百万、千万级别用户数量，或者千万甚至亿级别的访问量，因此必须选择能够高效统计大量数据的集合类型。不过在此之前，首先需要了解常用的统计模式，并使用合理的数据类型来解决实际问题。</p><p>这里我们一般会使用如下四种统计类型：二值状态统计、基数统计、排序统计和聚合统计。</p><h1 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h1><h3 id="二值状态统计概念"><a href="#二值状态统计概念" class="headerlink" title="二值状态统计概念"></a>二值状态统计概念</h3><p>二值状态统计，即集合中的元素只有0和1这两种状态，统计对应状态出现的次数。</p><p>举个例子，用户在进行打卡签到的时候，只有签到（1）或未签到（0）这两种；判断用户是否登录，也只有已登录（1）或未登录（0）这两种，它们均合适使用二值状态来进行统计。</p><h3 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h3><p>可以使用BitMap来判断海量用户中某个用户是否登录，它提供了<code>GETBIT</code>、<code>SETBIT</code>等命令，通过一个偏移值offset对bit数组的offset位置的bit位进行读写操作，请注意offset从0开始。</p><p>这样只需使用一个<code>login_status</code>集合来存储用户登录状态，然后将用户ID作为offset，如果用户在线则设置为1，下线则设置为0。后续开发者就可以通过<code>GETBIT</code>来判断对应用户是否在线。</p><p><code>SETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>用于设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。</p><p><code>GETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;key&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><p>用于获取 key 的 value 在 offset 处的 bit 位的值，注意当 key 不存在时，返回 0。</p><p>举个例子，当我们需要判断userId为1001用户的登录情况，此时步骤如下：<br>（1）假定用户已经登录，往<code>login_status</code>集合中userId为1001的bit位处设置值为1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 1</span><br></pre></td></tr></table></figure><p>（2）判断该用户是否登录，返回值为1表示已登录，0表示未登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 1001</span><br></pre></td></tr></table></figure><p>（3）用户进行退出操作，将对应的offset值设置为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 0</span><br></pre></td></tr></table></figure><h3 id="统计用户每个月的签到情况"><a href="#统计用户每个月的签到情况" class="headerlink" title="统计用户每个月的签到情况"></a>统计用户每个月的签到情况</h3><p>在签到统计中，每个用户每天的签到使用1个Bit位表示，那么一年的签到只需365个Bit位。而一个月最多只有31天你，那么最多只要31个Bit位。</p><p>现在有一个需求，统计userId为10010的用户在2021年8月份的签到打卡情况，此时该如何操作呢？可以将key设置为<code>userId:sign:&#123;userId&#125;:&#123;yyyyMM&#125;</code>这一格式，月份每一天的值减去1就可以作为offset，因为offset从0开始。</p><p>第一步，假定userId为1001的用户在2021年8月18号签到打卡了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT userId:sign:1001:202108 17 1</span><br></pre></td></tr></table></figure><p>第二步，判断userId为1001的用户在2021年8月18号是否进行了签到打卡：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT userId:sign:1001:202108 17</span><br></pre></td></tr></table></figure><p>第三步，统计userId为1001的用户在2021年8月的签到打卡次数，可以使用<code>BITCOUNT</code>命令，该命令用于统计给定bit数组中，值为1的bit位的数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT userId:sign:1001:202108</span><br></pre></td></tr></table></figure><p>这样就实现了用户每个月签到打卡情况的统计，总的来说还是较为简单。</p><h3 id="统计用户首次打卡时间"><a href="#统计用户首次打卡时间" class="headerlink" title="统计用户首次打卡时间"></a>统计用户首次打卡时间</h3><p>现在有个需求，获取userId为1001的用户在2021年8月份首次签到打卡的时间。</p><p>Redis提供了<code>BITPOS</code>命令，用于返回第一个值为bitValue的offset的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS key bitValue [start] [end]</span><br></pre></td></tr></table></figure><p>默认情况下，<code>BITPOS</code>命令会检测整个位图，开发者可通过可选的start和end参数来指定需要检测的范围。</p><p>可以通过如下命令来获取userId为1001的用户，在2021年8月份首次签到打卡的时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS userId:sign:1001:202108 1</span><br></pre></td></tr></table></figure><p>可以看到返回结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITPOS userId:sign:1001:202108 1</span><br><span class="line">&quot;17&quot;</span><br></pre></td></tr></table></figure><p>请注意返回的是offset，实际值应该是offset+1，即第18天首次签到。</p><h3 id="统计连续签到用户总数"><a href="#统计连续签到用户总数" class="headerlink" title="统计连续签到用户总数"></a>统计连续签到用户总数</h3><p>现在有一份数据，记录了一个亿用户连续7天的签到打卡记录，那么如何统计出这连续7天都连续打卡的用户总数呢？</p><p>前面我们说过，将每天的日期作为 Bitmap的key，userId作为offset，如果用户签到打卡了，那么将offset位置处的bit设置为1。那么这个key所对应集合的每个bit 位的数据，则是一个用户在该日期的打卡记录。</p><p>那么就存在 7 个这样的 Bitmap，可以对这 7 个 Bitmap 的对应的 bit 位做与运算。同样userID的offset都是一样的，当一个userID在 7 个 Bitmap 对应的 offset 位置的 bit的值为 1 ，就说明该用户 7 天连续打卡。之后将结果保存到一个新Bitmap 中，然后通过 <code>BITCOUNT</code>命令来统计 bit值为 1 的个数，就能得到连续打卡 7 天的用户总数。</p><p>实际上Redis 提供了<code>BITOP</code>命令，用于对一个或者多个key的 Bitmap进行位与操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure><p>operation可以是 AND、OR、NOT、XOR等。BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-85af4485654fc32f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>定义了3 个 Bitmap，并将对应的 bit 位做与操作，然后将结果保存到新的 Bitmap中。上述操作指令表示将 3个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，然后对 destmap 执行 BITCOUNT 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line">// 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure><p>可以看到一个包含一亿bit位的 Bitmap占用的内存开销，大约是 12 MB 的内存（10^8/8/1024/1024），那么7 天的 Bitmap 的内存开销约为84 MB。不过开发者最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，这样可以节省内存。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当开发者在实际开发过程中遇到只需统计数据的二值状态时，如判断用户是否登录、IP是否存在黑名单、打卡是否签到等就可以考虑使用BitMap。BitMap只需一个 bit 位就能表示 0 和 1，这在统计海量数据时，将极大减少内存的占用。</p><h1 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h1><h3 id="基数统计概念"><a href="#基数统计概念" class="headerlink" title="基数统计概念"></a>基数统计概念</h3><p>基数统计，即统计一个集合中不重复元素的个数，常见于计算独立用户数（UV）。</p><p>实现基数统计最直接的方法就是使用集合（Set）这种数据结构，当一个元素从未在此集合中出现过，那么便将其添加到集合中，否则不集合保持不变。如果页面访问量巨大，就需要一个非常大的Set来进行统计，这必然会浪费大量的空间。</p><p>实际上这种数据不一定要很精准，可以采用Redis提供的<code>HyperLogLog</code>这一数据结构来解决这种场景的统计问题。</p><p><code>HyperLogLog</code>是一种不精确的去重基数方案，其统计规则是基于概率实现的，标准误差 0.81%，这样的精度足以满足UV统计需求。</p><h3 id="网站的-UV"><a href="#网站的-UV" class="headerlink" title="网站的 UV"></a>网站的 UV</h3><h5 id="采用Set实现"><a href="#采用Set实现" class="headerlink" title="采用Set实现"></a>采用Set实现</h5><p>一个用户一天内多次访问一个网站只能算作一次，因此最先想到的就是使用Redis提供的Set集合来实现。</p><p>举个例子，ID为1001的用户访问index页面时，可以将这个信息放到集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD index:uv 1001</span><br></pre></td></tr></table></figure><p>当这个ID为1001的用户多次访问首页时，Set集合的去重功能可以保证不会重复记录同一个用户ID。之后可通过SCARD命令来统计index页面的uv，该命令返回集合中元素的个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD index:uv</span><br></pre></td></tr></table></figure><h5 id="采用Hash实现"><a href="#采用Hash实现" class="headerlink" title="采用Hash实现"></a>采用Hash实现</h5><p>小明说也可以采用Hash这一数据结构来实现，将用户ID作为Hash集合的key，那么访问某个页面则执行HSET命令将value的值设置为1。这样即使用户重复访问，重复执行命令，也只会将这个userId的值设置为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET index:uv userId:1001 1</span><br></pre></td></tr></table></figure><p>最后利用<code>HLEN</code>命令来统计Hash集合中的元素个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN index:uv</span><br></pre></td></tr></table></figure><h5 id="采用HyperLogLog实现"><a href="#采用HyperLogLog实现" class="headerlink" title="采用HyperLogLog实现"></a>采用HyperLogLog实现</h5><p>Set集合尽管好用，但是如果首页访问量过大，那么一个Set中就保存了上千万个用户的ID，这还仅仅是首页，还有其他页面，这对内存的消耗太大了，同理Hash这种数据结构也是一样的。</p><p>此时就可以使用HyperLogLog这种数据结构，这是一种用于基数统计的数据集合类型，即使数据量很大，计算基数所需的空间也是固定的。每个HyperLogLog最多花费12KB的内存就可以计算2的64次方个元素的基数。</p><p>Redis对HyperLogLog的存储进行了优化，在计数较小时，存储空间采用系数矩阵，占用空间很小。只有在计数很大，稀疏矩阵占用的空间超过了阈值，才会转变成稠密矩阵，占用 12KB 空间。</p><p>开发者可使用<code>PFADD</code>命令，将访问index页面的每个用户ID添加到HyperLogLog中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3 userId4</span><br></pre></td></tr></table></figure><p>然后使用<code>PFCOUNT</code>命令，统计ndex页面的UV值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT index:uv</span><br></pre></td></tr></table></figure><p>当然了，HyperLogLog除了提供上面使用的<code>PFADD</code>和<code>PFCOUNT</code>命令，还提供了<code>PFMERGE</code>命令，用于将多个HyperLogLog合并在一起形成一个新的HyperLogLog。<code>PFMERGE</code>命令语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p>举个例子，在网站上有两个内容差不多的页面，运营人员说需要这两个页面的数据进行合并，也包含UV量，此时就可以使用<code>PFMERGE</code>命令，注意此时同一个用户访问这两个页面只算访问一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3  //3</span><br><span class="line">PFADD comment:uv userId1 userId3 userId4  //3</span><br><span class="line">PFMERGE website:uv index:uv comment:uv  //OK</span><br><span class="line">PFCOUNT website:uv  //4</span><br></pre></td></tr></table></figure><p>可以看到这里我们将多个HyperLogLog进行了合并输出为一个新的HyperLogLog，新HyperLogLog的基数接近于所有输入HyperLogLog的可见集合的并集。</p><h1 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h1><p>我们知道，Redis的4种集合类型（List、Set、Hash和SortedSet）中，只有List和SortedSet是有序的。</p><ul><li>List按照元素插入List的顺序进行排序，通常用于实现消息队列、最新列表、排行榜等；</li><li>SortedSet则是根据元素的score权重进行排序，开发者可自己决定每个元素的权重值，通常用于实现按照一定规则的排行榜（积分数、点赞数、播放量等）。<h3 id="最新评论列表"><a href="#最新评论列表" class="headerlink" title="最新评论列表"></a>最新评论列表</h3><h5 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h5>开发者可以使用List的插入顺序来实现评论列表。举个例子，如微信公众平台的后台回复列表，每一个公众号的文章都对应一个List，这个List就保存了该文章所对应的用户评论。</li></ul><p>当一个用户评论index这个文章时，可以使用LPUSH命令将评论插入到List头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH index zhangsan lisi wangwu</span><br></pre></td></tr></table></figure><p>接着我们再使用LRANGE命令来获取列表指定区间内的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE index 0 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;wangwu&quot;</span><br><span class="line">2)  &quot;lisi&quot;</span><br><span class="line">3)  &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意，并不是所有的最新列表都能使用List来实现，对于一些频繁更新的列表，不太建议使用List，因为List类型的分页可能导致列表元素重复或者漏掉。</strong></p><p>举个例子，假设当前评论列表为<code>List = &#123;A,B,C,D&#125;</code>，其中左侧表示最新评论，即D是最早的评论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list D C B A</span><br></pre></td></tr></table></figure><p>接下来第一页展示最新两个评论，获取到A和B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 0 1</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;A&quot;</span><br><span class="line">2)  &quot;B&quot;</span><br></pre></td></tr></table></figure><p>按照我们预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;C&quot;</span><br><span class="line">2)  &quot;D&quot;</span><br></pre></td></tr></table></figure><p>这是没有问题的，但是如果在展示第二页评论之前，又往列表里面添加了一个新的评论E，评论E通过如下命令插入到List队首：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list E</span><br></pre></td></tr></table></figure><p>那么此时List就变成了<code>List = &#123;A,B,C,D&#125;</code>，此时我们再来执行之前预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;B&quot;</span><br><span class="line">2)  &quot;C&quot;</span><br></pre></td></tr></table></figure><p>可以看到评论B又出现了，原因在于List是利用元素所在的位置进行排序，而一旦有新的元素插入，那么原有数据在List中的位置都会往后移动一位，进而导致读取了旧的元素。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c0aee7c06f112e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>因此只有在不需要分页（如每次只读取列表的前10个元素）或者更新频率比较低（如每天凌晨统计更新一下）的列表才适合使用List数据类型来实现。</p><p>对于需要分页且更新较为频繁的列表，就必须使用有序集合 Sorted Set类型来实现。</p><p>此外，List 类型无法实现通过时间范围查找的最新列表，此功能需要通过有序集合 Sorted Set 类型实现，举个例子以成交时间范围作为条件来查询的订单列表。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><h5 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h5><p>对于最新列表的场景，List和Sorted Set都可以实现，那为啥还使用List呢？直接使用Sorted Set那不是更好，它还可以设置score权重值，排序更为灵活。</p><p>原因在于Sorted Set 类型占用的内存容量是 List 类型的数倍之多，因此对于列表数量不多的情况，可以用 Sorted Set 类型来实现。如一周的音乐榜单，此时需要实时更新播放量，并且需要分页展示。除此以外，排序是根据播放量来决定的，此时List就无法满足。</p><p>开发者可以歌曲ID保存到 Sorted Set 集合中，score 设置成每首歌曲的播放量，该歌曲每播放一次则设置<code>score = score +1</code>。</p><p>举个例子，开发者可以使用<code>ZADD</code>命令，将《城府》和《稻香》这两首歌曲播放量放到musicTop集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD musicTop 100000 城府 9999999 稻香</span><br></pre></td></tr></table></figure><p>然后《城府》这首歌每播放一次，就使用<code>ZINCRBY</code>命令，将score进行加1操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY musicTop 1 城府</span><br></pre></td></tr></table></figure><p>执行结果返回”100001”，这就说明播放次数确实增加了。接着我们需要获取音乐播放量排名前10的歌曲，目前最大播放量是N，可通过如下命令来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE musicTop N-9 N WITHSCORES</span><br></pre></td></tr></table></figure><p>开发者可通过<code>ZREVRANGE key start stop [WITHSCORES]</code>命令来将集合中的元素按照score的值进行递减（从大到小）进行排序。具有相同score的值的成员，则按照字典的逆序进行排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE musicTop 0 0 WITHSCORES</span><br><span class="line"> 1)  &quot;稻香&quot;</span><br><span class="line"> 2)  &quot;9999999&quot;</span><br></pre></td></tr></table></figure><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>即使集合中的元素更新较为频繁，那么Sorted Set也能通过 <code>ZRANGEBYSCORE</code>命令来准确地获取到按序排列的数据。</p><p>当开发者遇到需要展示最新列表、排行榜等业务场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用 Sorted Set。</p><h1 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h1><h3 id="聚合统计概念"><a href="#聚合统计概念" class="headerlink" title="聚合统计概念"></a>聚合统计概念</h3><p>聚合统计，指的是统计多个集合元素的聚合结果，常用的有：<br>（1）统计多个元素的共有数据（交集）；<br>（2）统计多个元素的所有数据（并集）；<br>（3）统计两个集合其中某个独有的元素（差集）。</p><p>Redis的Set类型支持集合内的增删改查，底层使用Hash数据结构，因此无论是add、remove 都是 O(1) 时间复杂度。并且支持多个集合间的交集、并集、差集等操作，利用这些集合操作，可以很方便的解决上面提到的统计问题。</p><h3 id="共同好友（交集）"><a href="#共同好友（交集）" class="headerlink" title="共同好友（交集）"></a>共同好友（交集）</h3><p>举个例子，新浪微博中共同关注的人就是聚合统计中的交集。我们可以将用户Id作为key，该用户关注的用户Id作为Set集合中的value。</p><p>首先模拟两个用户关注的好友：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD userId:1001 1003 1004 1008</span><br><span class="line">SADD userId:1002 1004 1006 1009</span><br></pre></td></tr></table></figure><p>然后统计这两个用户共同关注的好友，就可以使用集合的交集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE userId:1001-1002 userId:1001 userId:1002</span><br></pre></td></tr></table></figure><p>之后两个用户交集都存在了userId:1001-1002这一集合中。</p><h3 id="每日新增用户数（差集）"><a href="#每日新增用户数（差集）" class="headerlink" title="每日新增用户数（差集）"></a>每日新增用户数（差集）</h3><p>举个例子，统计某个App每天新增的用户注册数，只需对近两天的总注册用户量集合进行取差集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE user:20210610-0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户差集都存在了userId:20210610-0609这一集合中，上面统计的是06-10比06-09号多的人数。</p><p>实际上，新浪微博还有一个可能认识的人这一功能，也可以使用差集实现，即将你关注的好友所关注的人减去你们共同关注的人即是可能认识的人。</p><h3 id="总共新增好友（并集）"><a href="#总共新增好友（并集）" class="headerlink" title="总共新增好友（并集）"></a>总共新增好友（并集）</h3><p>举个例子，统计某个App在2021-06-09和2021-06-10这两天，总的用户注册数，只需对近两天的总注册用户量集合进行取并集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE user:20210610+0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户并集都存在了userId:20210610+0609这一集合中。</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>Set的交集、并集、差集等操作计算的复杂度较高，在数据量比较大的情况下，直接执行这些操作可能会导致Redis实例阻塞。可以考虑专门部署一个集群用于统计，让它专门负责聚合计算或者是将数据读取到客户端，在客户端完成聚合统计，这样可以避免由于阻塞而导致其他服务无法快速响应的局面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信</summary>
      
    
    
    
    <category term="redis" scheme="http://aigoing.chat/categories/redis/"/>
    
    
    <category term="redis" scheme="http://aigoing.chat/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊Redis中的布隆过滤器</title>
    <link href="http://aigoing.chat/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/"/>
    <id>http://aigoing.chat/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/</id>
    <published>2023-04-06T11:55:30.000Z</published>
    <updated>2023-06-09T13:12:18.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写在前面<br>本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</p><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>在实际开发过程中遇到过这种情况，用户在使用APP阅读文章时，如何做到每次推荐给该用户的文章不重复，即需要过滤掉他已经阅读过的文章。</p><p>此时有人可能会说我们可以记录每个用户的浏览历史，然后每次在推荐的时候查询用户的浏览记录并进行过滤，进而实现文章的去重。如果开发者将用户的浏览历史存储在关系型数据库中，那么就需要频繁的对数据库进行exists判断，在并发量不高的情况下还能正常响应，但是一旦并发量上来，数据库是扛不住的。</p><p>那么又有人说，可以将这些浏览历史存在缓存中。请注意，千万不要将它们存在缓存中，这样会浪费很多内存，而且缓存适合更新频率比较低的情况，而用户的浏览历史可能每时每刻都在变化。</p><p>针对上述情况，即遇到数据量较大，又需要去重的时候，就可以考虑使用布隆过滤器。一般来说，布隆过滤器适用于如下场景：<br>（1）解决Redis中缓存穿透问题；<br>（2）爬虫过滤，对爬虫爬过的网站进行过滤，爬过的不再爬取；<br>（3）内容推荐，对已经推荐过的内容进行过滤，不再推荐；<br>（4）邮件过滤，对邮件设置的黑名单进行过滤；<br>……</p><h1 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h1><p>布隆过滤器 (Bloom Filter)由Burton Howard Bloom于1970年提出，它是一种 space efficient 的概率型数据结构，用于判断一个元素是否在集合中。</p><p>如果布隆过滤器说某个数据存在，那么这个数据实际上可能不存在；但是如果说某个数据不存在，那么此时这个数据一定不存在，即一种概率性的判断。</p><p>你可能会说判断元素是否在集合中，最简单的可以使用哈希表，但是完成同样问题时，布隆过滤器只需哈希表的1/8或1/4的空间复杂度。</p><p>请注意，布隆过滤器可以插入元素，但是不可以删除已有元素。而且布隆过滤器中的元素越多，那么<code>false positive rate</code>(误报率)越大，不过不会发生 <code>false negative</code> (漏报)。</p><h1 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h1><p>首先看下面一张图，快速了解一下布隆过滤器的原理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fe0098fcc3e04f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先分配一块内存空间做bit数组，数组的bit位初始值均为0。</p><p>接着往其中添加元素时，采用K个相互独立的 Hash 函数计算，然后将元素Hash 映射的K个位置全部设置为1。</p><p>当需要检测元素是否存在，会使用这K个 Hash 函数计算出 K 个位置，如果位置全部为1，则说明元素存在；否则不存在。</p><p><strong>由于哈希函数会出现碰撞，因此布隆过滤器也存在误判</strong>。一般我们会使用误判率，而误判率是指布隆过滤器判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值。因此有概率存在这样的 key，它们内容不同，但经过多次 Hash 后的 Hash 值相同。</p><p><strong>布隆过滤器判断某个元素不存在，那么这个元素必定不存在；判断某个元素存在，那么这个元素可能不存在</strong>。可以使用反证法进行验证，如果元素存在，那么它每次Hash计算后的Hash值位置必然为1，而不是0。</p><p>前面说了，可以往布隆过滤器中插入元素，但是不可以删除已有元素，为什么是这样呢？我们知道，删除意味着需要将对应的K个bit位置设置为0，而这些有可能是其他元素对应的bit，因此删除会发生<code>false negative </code>(漏报)，这是不允许的。</p><h1 id="Redis集成布隆过滤器"><a href="#Redis集成布隆过滤器" class="headerlink" title="Redis集成布隆过滤器"></a>Redis集成布隆过滤器</h1><p>Redis在4.0的时候官方提供插件机制，用于提供对布隆过滤器的支持。开发者可以点击 <a href="https://redis.com/redis-enterprise-software/download-center/software/">这里</a> 下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e1ea925af27287ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>使用布隆过滤器最低需要4.x版本，不过笔者建议使用6.x版本。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>开发者可以自行编译安装，从 github 下载，笔者使用的 release 版本是 v2.2.18，下载地址 <a href="https://github.com/RedisBloom/RedisBloom/releases/tag/v2.2.18">点击</a> 这里：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5865ad76ef8b2717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后将其进行解压，编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf RedisBloom-2.2.18.tar</span><br><span class="line">cd RedisBloom-2.2.18</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>之后会生成一个名为<code>redisbloom.so</code>的文件，那么接下来我们就是安装集成它了。</p><p>修改<code>redis.conf</code>文件，在里面新增一个loadmodule，值为上面生成的<code>redisbloom.so</code>文件的全路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集成BloomFilter</span><br><span class="line">loadmodule /home/envy/RedisBloom-2.2.18/redisbloom.so</span><br></pre></td></tr></table></figure><p>之后重启Redis，注意如果是Redis集群，那么每个实例的配置文件都需要加入该配置项。</p><p>启动的时候我们需要以指定配置文件启动Redis，进入到Redis的bin目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../conf/redis.conf</span><br></pre></td></tr></table></figure><p>然后使用客户端连接到Redis，开始进行测试。布隆过滤器常用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个元素到布隆过滤器</span><br><span class="line">BF.ADD element bloomfilter</span><br><span class="line"># 判断元素是否在布隆过滤器中</span><br><span class="line">BF.EXISTS element bloomfilter</span><br><span class="line"># 添加多个元素到布隆过滤器</span><br><span class="line">BF.MADD element1 element2 bloomfilter</span><br><span class="line"># 判断多个元素是否在布隆过滤器</span><br><span class="line">BF.MEXISTS element1 element2 bloomfilter</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9ec37586591616dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Redis布隆过滤器实战"><a href="#Redis布隆过滤器实战" class="headerlink" title="Redis布隆过滤器实战"></a>Redis布隆过滤器实战</h1><p>前面也说过，在Redis中布隆过滤器常用的作用就是解决缓存穿透问题，所谓的缓存穿透是指请求查询不存在的数据，即缓存和数据库中都没有的数据。</p><p>接下来我们模拟一个场景：用户在购买商品创建订单时，我们会往MQ中发送消息，将订单ID添加到布隆过滤器中，之后判断订单是否存在。整个流程如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ee80ba9daeed5da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="BF-RESERVE命令详解"><a href="#BF-RESERVE命令详解" class="headerlink" title="BF.RESERVE命令详解"></a><code>BF.RESERVE</code>命令详解</h3><p>前面的过程我们不编写具体的代码，而是通过一些数据来模拟对应的操作。首先我们来了解<code>BF.RESERVE</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION &#123;expansion&#125;] [NONSCALING]</span><br></pre></td></tr></table></figure><p>解释一下上述参数的含义：<br>（1）key是布隆过滤器的名称；<br>（2）<code>error_rate</code>是期望的错误率，默认值为0.1，值越低需要的空间就越大；<br>（3）<code>capacity</code>是初始容量，默认值为100，当实际元素的数量超出这个初始容量值时，错误率会上升；<br>（4）EXPANSION 是可选参数，当添加到布隆过滤器中的元素数量达到初始容量后，不会扩容过滤器，并且会抛出异常（<code>(error) ERR non scaling filter is full</code>）。这说明布隆过滤器的扩容是通过增加布隆过滤器的层数来完成的。每增加一层，查询时就可能会遍历多层布隆过滤器，默认情况下每一层的容量都是上一层的两倍。</p><p><strong>请注意，如果不使用<code>BF.RESERVE</code>命令来创建布隆过滤器，而使用Redis自动创建的布隆过滤器，那么默认的<code>error_rate</code>为0.1，初始容量为100。</strong></p><p>布隆过滤器的<code>error_rate</code>越小，需要的存储空间就越大，对于不需要过于精确的业务场景来说，<code>error_rate</code>的值可以设置大一些。</p><p>布隆过滤器的<code>capacity</code>设置的过大，会浪费存储空间；设置过小会影响准确率，因此在使用布隆过滤器之前，最好尽可能的精确估计元素的数量，同时加上一定的冗余空间，这样可避免实际元素会超出设定值很多的情况。</p><h3 id="创建orders布隆过滤器"><a href="#创建orders布隆过滤器" class="headerlink" title="创建orders布隆过滤器"></a>创建orders布隆过滤器</h3><p>接下来我们使用<code>BF.RESERVE</code>命令来手动创建一个名为orders的布隆过滤器，注意<code>error_rate</code>为0.1，初始容量为1000万：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE orders 0.1 10000000</span><br></pre></td></tr></table></figure><h3 id="添加订单ID到布隆过滤器"><a href="#添加订单ID到布隆过滤器" class="headerlink" title="添加订单ID到布隆过滤器"></a>添加订单ID到布隆过滤器</h3><p>接下来我们尝试使用<code>BF.ADD</code>命令往orders这一布隆过滤器中添加10010这一订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD orders 10010</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.ADD orders 10010</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>当然了也可以一次性添加三个订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.MADD orders 10011 10012 10013</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MADD orders 10011 10012 10013</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="判断订单是否存在"><a href="#判断订单是否存在" class="headerlink" title="判断订单是否存在"></a>判断订单是否存在</h3><p>开发者可以使用<code>BF.EXISTS</code>命令来判断某一元素是否存在于布隆过滤器中，返回值为1表示存在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.EXISTS orders 10011</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果想要批量检查多个元素是否在布隆过滤器中，可以使用<code>BF.MEXISTS</code>命令，该命令返回的是一个数组，其中1表示存在，0表示不存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element1 element2......</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011、10012、10013和10014的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MEXISTS orders 10011 10012 10013 10014</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br><span class="line"> 4)  &quot;0&quot;</span><br></pre></td></tr></table></figure><p>也就是说我们可以通过<code>BF.RESERVE</code>、<code>BF.ADD</code>和<code>BF.EXISTS</code>这三个命令来避免缓存穿透问题。</p><h3 id="查看创建的布隆过滤器信息"><a href="#查看创建的布隆过滤器信息" class="headerlink" title="查看创建的布隆过滤器信息"></a>查看创建的布隆过滤器信息</h3><p>开发者可以使用<code>BF.INFO key</code>命令来查看创建的布隆过滤器信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.INFO orders</span><br><span class="line"> 1)  &quot;Capacity&quot;</span><br><span class="line"> 2)  &quot;10000000&quot;</span><br><span class="line"> 3)  &quot;Size&quot;</span><br><span class="line"> 4)  &quot;7794184&quot;</span><br><span class="line"> 5)  &quot;Number of filters&quot;</span><br><span class="line"> 6)  &quot;1&quot;</span><br><span class="line"> 7)  &quot;Number of items inserted&quot;</span><br><span class="line"> 8)  &quot;4&quot;</span><br><span class="line"> 9)  &quot;Expansion rate&quot;</span><br><span class="line"> 10)  &quot;2&quot;</span><br></pre></td></tr></table></figure><p>解释一下上述返回值的含义：<br>（1）Capacity表示预设容量，即初始容量；<br>（2）Size表示实际占用情况，但如何计算需要进一步确认；<br>（3）Number of filters表示过滤器层数；<br>（4）Number of items inserted表示已经实际插入的元素数量；<br>（5）Expansion rate表示子过滤器扩容系数（默认值为2）。</p><h3 id="无法删除布隆过滤器"><a href="#无法删除布隆过滤器" class="headerlink" title="无法删除布隆过滤器"></a>无法删除布隆过滤器</h3><p>目前布隆过滤器是无法删除的，但是布谷过滤器(Cuckoo Filter)支持删除。</p><p>布隆过滤器在插入项目时通常表现出更好的性能和可伸缩性，因此如果开发者经常向数据集中添加元素，那么此时布隆过滤器还可以接受。不过布谷过滤器在检查操作上更快，也支持删除，可以点击 <a href="https://oss.redis.com/redisbloom/Cuckoo_Commands/">这里</a> 进行阅读。实际上本篇文章中的实战就来自于Redis官方提供的Redis布隆过滤器实战，可以点击 <a href="https://oss.redis.com/redisbloom/">这里</a> 进行阅读。</p><h1 id="Redission布隆过滤器实战"><a href="#Redission布隆过滤器实战" class="headerlink" title="Redission布隆过滤器实战"></a>Redission布隆过滤器实战</h1><h3 id="RBloomFilter接口"><a href="#RBloomFilter接口" class="headerlink" title="RBloomFilter接口"></a>RBloomFilter接口</h3><p>在Redisson中，与BloomFilter相关的操作都被定义到RBloomFilter接口中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface RBloomFilter&lt;T&gt; extends RExpirable &#123;</span><br><span class="line">    //添加元素</span><br><span class="line">    boolean add(T object);</span><br><span class="line">  </span><br><span class="line">    //判断元素是否存在</span><br><span class="line">    boolean contains(T object);</span><br><span class="line"></span><br><span class="line">    //根据指定的参数来初始化布隆过滤器</span><br><span class="line">    boolean tryInit(long expectedInsertions, double falseProbability);</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素的预期插入量</span><br><span class="line">    long getExpectedInsertions();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回元素存在的错误概率</span><br><span class="line">    double getFalseProbability();</span><br><span class="line"></span><br><span class="line">    //返回此实例所需的Redis内存中的bit数</span><br><span class="line">    long getSize();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素使用的哈希迭代次数</span><br><span class="line">    int getHashIterations();</span><br><span class="line"></span><br><span class="line">    //计算已添加到布隆过滤器的元素的概率数</span><br><span class="line">    long count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>，创建一个名为<code>redisson-fly</code>的SpringBoot项目，注意后续关于其他数据结构的代码都在这个项目中进行编写：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc0d405fc4ee701e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.13.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>application.yml</code>配置文件中新增如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.51.131</span><br><span class="line">    port: 6379</span><br><span class="line">    ssl: false</span><br><span class="line">    password: envy123</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，由于这里我们不对外提供接口，因此我们只创建service类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BoolFilterService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建布隆过滤器</span><br><span class="line">     * @param filterName 布隆过滤器</span><br><span class="line">     * @param expectedInsertions 预测插入数量</span><br><span class="line">     * @param falseProbability 误判率</span><br><span class="line">     * @param &lt;T&gt; 泛型</span><br><span class="line">     * @return 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; RBloomFilter&lt;T&gt; create(String filterName,long expectedInsertions,double falseProbability)&#123;</span><br><span class="line">        RBloomFilter&lt;T&gt; bloomFilter = redissonClient.getBloomFilter(filterName);</span><br><span class="line">        bloomFilter.tryInit(expectedInsertions, falseProbability);</span><br><span class="line">        return bloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，针对这个BoolFilterService类创建对应的测试类及测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class BoolFilterServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BoolFilterService boolFilterService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBloomFilter()&#123;</span><br><span class="line">        //布隆过滤器名称</span><br><span class="line">        String bloomFilterName = &quot;ipBlackList&quot;;</span><br><span class="line">        //初始容量</span><br><span class="line">        long expectedInsertions = 10000L;</span><br><span class="line">        //误判率</span><br><span class="line">        double falseProbability = 0.01;</span><br><span class="line">        RBloomFilter&lt;Long&gt; bloomFilter = boolFilterService.create(bloomFilterName, expectedInsertions, falseProbability);</span><br><span class="line"></span><br><span class="line">        //往布隆过滤器中添加元素</span><br><span class="line">        for (long i = 0; i &lt; expectedInsertions; i++) &#123;</span><br><span class="line">            bloomFilter.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long elementCount = bloomFilter.count();</span><br><span class="line">        log.info(&quot;布隆过滤器中的元素个数为：&#123;&#125;&quot;,elementCount);</span><br><span class="line"></span><br><span class="line">        //统计布隆过滤器中误判次数，即实际上不存在但是布隆过滤器却说存在的次数</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (long i = expectedInsertions; i &lt; expectedInsertions * 2; i++) &#123;</span><br><span class="line">            if(bloomFilter.contains(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;布隆过滤器中的误判次数为：&#123;&#125;&quot;,count);</span><br><span class="line">        //删除布隆过滤器</span><br><span class="line">        bloomFilter.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试逻辑非常简单，定义一个名为ipBlackList的布隆过滤器，然后设置初始容量为10000，误判率为0.01。然后往里面添加0-10000这些数字，接着我们判断10001到20000是否在这个ipBlackList中，进而得到误判的次数。</p><p>当然了，如果上面使用的是Redis集群，那么需要使用如下命令来初始化布隆过滤器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;Long &gt; bloomFilter = redisson.getClusteredBloomFilter(&quot;redisCluster&quot;);</span><br></pre></td></tr></table></figure><p>运行该测试方法，可以看到结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的元素个数为：9895</span><br><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的误判次数为：259</span><br></pre></td></tr></table></figure><p>可以看到是比较符合我们预定的误判率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布隆过滤器的思想就是判断元素可能存在或者一定不存在，因此在使用时需要结合实际情况进行分析。</p><p>参考资料：<a href="https://mp.weixin.qq.com/s/MFqQOzyO1zhrHF_Xcl0dvA">Redis 布隆（Bloom Filter）过滤器原理与实战</a>、<a href="https://redis.io/docs/stack/bloom/">Redis官方文档</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;写在前面&lt;br&gt;本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</summary>
      
    
    
    
    <category term="redis" scheme="http://aigoing.chat/categories/redis/"/>
    
    
    <category term="redis" scheme="http://aigoing.chat/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>功能开关在业务中的实践</title>
    <link href="http://aigoing.chat/2023/03/01/2023-100-practice-of-function-switch-in-business/"/>
    <id>http://aigoing.chat/2023/03/01/2023-100-practice-of-function-switch-in-business/</id>
    <published>2023-03-01T09:55:30.000Z</published>
    <updated>2023-03-14T07:11:51.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但是后续发现这样有个弊端，即只能针对一个活动或者相同时间的多个活动生效，而实际上我们的活动有多个，权衡再三决定使用功能开关来实现。</p><h1 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h1><p>功能开关其实是一种代码可配置性的实践，说到底就是通过控制开关的状态来实现对功能的决定控制。</p><p>功能开关的实现有很多种方式，可以使用MySQL或者Redis等数据库，出于对后续数据扩展和对存储容量的考量，此处使用Bit数组来实现。</p><h3 id="Bit数组原理"><a href="#Bit数组原理" class="headerlink" title="Bit数组原理"></a>Bit数组原理</h3><p>既然是数组，那么下标必然从0开始，bit只有两种取值，要么为0，要么为1：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3049804d68aadfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>而0和1正好对应开关的关闭和启用，即ON和OFF状态。之后开发者只需定义好每个开关所在的Bit数组的索引号和状态即可，这样后续就可以通过判断开关的状态来实现对功能的控制：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-e89b847c9308657f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到使用这种方式所占用的内存空间非常少，理论上只需占用2n位的内存，n为开关的数量。</p><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>Java中对于Bit数组可以使用BitSet来实现 ，里面有很多方法，这里我们摘几个用到的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BitSet implements Cloneable, java.io.Serializable &#123;</span><br><span class="line">    //给指定位置设置值</span><br><span class="line">    public void set(int bitIndex, boolean value) &#123;&#125;</span><br><span class="line">    //给指定位置的值取反操作</span><br><span class="line">    public void clear(int bitIndex) &#123;&#125;</span><br><span class="line">    //获取指定位置的值</span><br><span class="line">    public boolean get(int bitIndex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，新建开关状态常量SwitchConst：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关常量</span><br><span class="line"> */</span><br><span class="line">public class SwitchConst &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用</span><br><span class="line">     */</span><br><span class="line">    public static final boolean ON = true;</span><br><span class="line">    /**</span><br><span class="line">     * 关停</span><br><span class="line">     */</span><br><span class="line">    public static final boolean OFF = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于开关只有开和闭这两种状态，因此可以不使用枚举类。</p><p>第二步，新建功能开关枚举类SwitchEnum，这个就是开发者所要定义的开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能开关枚举类</span><br><span class="line"> */</span><br><span class="line">public enum SwitchEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * HTTPS</span><br><span class="line">     */</span><br><span class="line">    HTTPS(0,SwitchConst.ON,&quot;HTTPS设置&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 充值会员</span><br><span class="line">     */</span><br><span class="line">    RECHARGE(1,SwitchConst.OFF,&quot;充值送油卡&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下标</span><br><span class="line">     */</span><br><span class="line">    private int index;</span><br><span class="line">    /**</span><br><span class="line">     * 默认状态</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    SwitchEnum(int index,boolean status,String desc)&#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getIndex()&#123;</span><br><span class="line">        return this.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean getStatus()&#123;</span><br><span class="line">        return this.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return this.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;name=%s,desc=%s&quot;,name(),desc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>第三步，新建开关状态切换接口Switch，里面定义切换开关状态和判断接口状态的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关转态切换</span><br><span class="line"> */</span><br><span class="line">public interface Switch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOn(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOff(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断开关状态</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    boolean judgeStatus(SwitchEnum switchEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个BitSetSwitch，表示基于BitSet实现的开关，因此需要实现Switch接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum BitSetSwitch implements Switch&#123;</span><br><span class="line">    MYBITSET;</span><br><span class="line"></span><br><span class="line">    BitSetSwitch()&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOn(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.set(switchEnum.getIndex(),SwitchConst.ON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOff(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.clear(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean judgeStatus(SwitchEnum switchEnum) &#123;</span><br><span class="line">        return bitSet.get(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        Stream.of(SwitchEnum.values()).forEach(item-&gt;bitSet.set(item.getIndex(),item.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将BitSetSwitch设置为了一个枚举类，目的就是通过单例生成一个BitSetSwitch对象。注意不能将其设置为普通的类，如果那样的话，在使用的时候就需要通过new关键字生成BitSetSwitch对象，而且每调用一次就得新创建一个对象，这肯定是不行的，功能开关肯定是全局唯一的。</p><p>第五步，新建测试类SwitchTest，测试一下功能开关的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSetSwitch bitSetSwitch = BitSetSwitch.MYBITSET;</span><br><span class="line">        bitSetSwitch.turnOn(SwitchEnum.HTTPS);</span><br><span class="line">        bitSetSwitch.turnOff(SwitchEnum.RECHARGE);</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.HTTPS,bitSetSwitch.judgeStatus(SwitchEnum.HTTPS)));</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.RECHARGE,bitSetSwitch.judgeStatus(SwitchEnum.RECHARGE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行该方法，可以发现控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开关【name=HTTPS,desc=HTTPS设置】，状态为：true</span><br><span class="line">开关【name=RECHARGE,desc=充值送油卡】，状态为：false</span><br></pre></td></tr></table></figure><p>这说明当前项目开启了HTTPS设置，但是关停了充值送油卡这一活动。后期要实现灵活控制，可配合配置中心在配置文件中进行控制。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>功能开关在实际开发过程中非常实用，因此有必要在理解的基础上进行灵活使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但</summary>
      
    
    
    
    <category term="springboot" scheme="http://aigoing.chat/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://aigoing.chat/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins+Gitlab一键打包部署SpringBoot应用</title>
    <link href="http://aigoing.chat/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/"/>
    <id>http://aigoing.chat/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/</id>
    <published>2023-02-26T14:55:30.000Z</published>
    <updated>2023-03-14T06:52:35.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行。当我们的应用数量较多时，还可以使用Docker Compose的方式，但是毫无疑问上面的种种还都只是手动部署，本篇来学习如何使用Jenkins和Gitlab来实现一键打包部署SpringBoot应用。</p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><h3 id="GitLab简介"><a href="#GitLab简介" class="headerlink" title="GitLab简介"></a>GitLab简介</h3><p>GitLab是一款开源的基于Git的版本仓库管理工具，开发者可以使用它来搭建属于自己的Git仓库。</p><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><p><strong>第一步</strong>，下载GitLab的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/gitlab/config</span><br><span class="line">mkdir -p /mydata/gitlab/logs</span><br><span class="line">mkdir -p /mydata/gitlab/data</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动GitLab服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10443:443 -p 1080:80 -p 1022:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">-v /mydata/gitlab/config:/etc/gitlab \</span><br><span class="line">-v /mydata/gitlab/logs:/var/log/gitlab \</span><br><span class="line">-v /mydata/gitlab/data:/var/opt/gitlab \</span><br><span class="line">-d  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，开启防火墙：<br>由于Gitlab运行在1080端口，因此我们需要开放该端口，注意不能直接关闭防火墙，否则Gitlab会无法启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启1080端口</span><br><span class="line">firewall-cmd --zone=public --add-port=1080/tcp --permanent</span><br><span class="line"># 重启防火墙才能生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，打开浏览器，访问<code>http://宿主机IP:1080</code>链接，查看GitLab是否已经正常启动。请注意，由于GitLab启动比较慢，需要耐心等待10分钟左右，如果GitLab没有启动完成就访问，会出现502的错误。</p><p>开发者可以使用<code>docker logs gitlab -f</code>命令来动态查看容器启动日志，进而确定Gitlab是否已经启动完成。</p><p>之后访问<code>http://宿主机IP:1080</code>链接，可以看到GitLab已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebe4ce1f76be102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以使用如下命令来查看root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it gitlab grep &#x27;Password:&#x27; /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure><p>然后使用root用户加上上面得到的密码进行登录，注意root用户和kenbings用户的密码均为kenbings：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-298f808bd29ae8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="GitLab使用"><a href="#GitLab使用" class="headerlink" title="GitLab使用"></a>GitLab使用</h3><h5 id="创建组织"><a href="#创建组织" class="headerlink" title="创建组织"></a>创建组织</h5><p>首先创建一个组织，然后在这个组织下分别创建用户和项目，这样同组织的用户就可以使用该组织下的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-56b7f4bf0f6b38ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f18564bf73bb1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04c57d1455b307de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3de88e91015ce63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7126f255b6e95fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>点击 <a href="https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe">这里</a> 进行下载，然后一路Next进行安装。</p><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h5 id="下载代码到本地"><a href="#下载代码到本地" class="headerlink" title="下载代码到本地"></a>下载代码到本地</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http或者git地址</span><br></pre></td></tr></table></figure><h5 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h5><p>进入一个名为hello的项目目录，修改<code>README.md</code>并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入项目工程目录</span><br><span class="line">cd hello/</span><br><span class="line"># 将当前修改的文件添加到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 提交代码</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br></pre></td></tr></table></figure><h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h5 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="本地创建并提交分支"><a href="#本地创建并提交分支" class="headerlink" title="本地创建并提交分支"></a>本地创建并提交分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换并从当前分支创建一个dev分支</span><br><span class="line">git checkout -b dev</span><br><span class="line"># 将新创建的dev分支推送到远程仓库</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h5 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换到dev分支</span><br><span class="line">git checkout dev</span><br><span class="line"># 查看本地仓库文件状况</span><br><span class="line">git status</span><br><span class="line"># 查看本地所有分支</span><br><span class="line">git branch</span><br><span class="line"># 查看提交记录</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><p>Jenkins是开源CI&amp;CD软件的领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要，开发者可以用Jenkins来构建和部署自己的项目。举个例子，可以从自定义的代码仓库中获取代码，然后将代码打包成可执行的文件，之后通过远程的ssh工具执行脚本，最终实现运行项目这一目的。</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><strong>第一步</strong>，下载Jenkins的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/jenkins_home</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动Jenkins服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 50000:5000 --name jenkins \</span><br><span class="line">-u root \</span><br><span class="line">-v /mydata/jenkins_home:/var/jenkins_home \</span><br><span class="line">-d jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><h3 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h3><p>Jenkins服务启动后，然后访问<code>http://宿主机IP:8080</code>链接，页面出现如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-24988fcf53f76a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后使用如下命令从启动日志中获取到管理员密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs jenkins</span><br></pre></td></tr></table></figure><p>接着进行登录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d190ae88cf70c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择安装插件方式，这里我们直接安装推荐的插件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-74523a9030f27c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着就进入插件安装界面，联网等待插件安装：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f13bb799ee18f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>安装完成后，接下来我们创建一个管理员账号，账户和密码均为admin：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8785e2fbb1588637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后进行实例配置，配置Jenkins的访问URL：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dcfc0c2c2f0e81f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-703a4bbfdf686f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着点击“Manage Jenkins”–》“Manage Plugins”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-89737123c424524e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>确保以下插件被正确安装：<br>（1）根据角色管理权限的插件：Role-based Authorization Strategy；<br>（2）配置远程服务器：Publish Over SSH。</p><p>接下来新增maven的安装配置，点击“Manage Jenkins”–》“Global Tool Configuration”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8fbf0437fb8b534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-68ff4208251976f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后新增凭据，点击“Manage Jenkins”–》“Global Tool Configuration”，接着按照图片所示进行操作（注意里面配置的是通过ssh连接到宿主机的用户名和密码）：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-871bf5cc27c8425d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea8e8f2989b50dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着在点击“Manage Jenkins”–》“Configure System”，中添加全局ssh的配置，这样Jenkins使用ssh就可以执行远程linux的脚本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-914d9729c1e0f46c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Jenkins角色权限管理"><a href="#Jenkins角色权限管理" class="headerlink" title="Jenkins角色权限管理"></a>Jenkins角色权限管理</h3><p>开发者可以使用Jenkins的角色管理插件，来管理Jenkins的用户。举个例子，开发者可以给管理员赋予所有权限，给运维人员赋予执行任务的相关权限，而其他人员只赋予查看权限。</p><p>点击“Manage Jenkins”–》“Configure Global Security”，然后在里面启用基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9b38969b1d3d829f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们点击“Manage Jenkins”–》“Manage and Assign Roles”，然后在里面开始配置基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-00ae69b2af0f6f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fee924fad0462233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Manage Roles”，添加角色与权限关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-01c4781f8148613d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Assign Roles”，给用户分配角色：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64cdd0024c1e66f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="打包部署SpringBoot应用"><a href="#打包部署SpringBoot应用" class="headerlink" title="打包部署SpringBoot应用"></a>打包部署SpringBoot应用</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-jenkins</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-jenkins</code>这一Module中进行。</p><h3 id="将代码上传到GItlab中"><a href="#将代码上传到GItlab中" class="headerlink" title="将代码上传到GItlab中"></a>将代码上传到GItlab中</h3><p>修改POM文件中build标签中的内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>注意此处需要将dockerHost地址修改为开发者自己的Docker镜像仓库地址。同时项目在容器中运行的端口需要与后续启动脚本中的端口保持一致，这里为8088端口。</p><p>然后依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /shop-jenkins</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init project&quot;</span><br><span class="line">git remote add origin http://192.168.51.160:1080/myshop/shop-gitlab-jenkins.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -uf origin main</span><br></pre></td></tr></table></figure><p>注意如果在推送代码的过程中出现如下问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9af484a83d6a3321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>主要原因是因为向一个受保护的分支强制提交了代码，可以在仓库里面进行设置来解决这个问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c40f2c4217fef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e67581d3b3b7c47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="定义一个执行脚本"><a href="#定义一个执行脚本" class="headerlink" title="定义一个执行脚本"></a>定义一个执行脚本</h3><p>在<code>/mydata/sh</code>目录下定义一个名为<code>shop-jenkins.sh</code>的脚本，其中的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">app_name=&#x27;shop-jenkins&#x27;</span><br><span class="line">docker stop $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----stop container-----&#x27;</span><br><span class="line">docekr rm $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----rm container-----&#x27;</span><br><span class="line">docker run -p 8088:8088 --name $&#123;app_name&#125; \</span><br><span class="line">--link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/$&#123;app_name&#125;/logs:/var/logs \</span><br><span class="line">-d myshop-all/$&#123;app_name&#125;:0.0.1-SNAPSHOT</span><br><span class="line">echo &#x27;----start container----&#x27;</span><br></pre></td></tr></table></figure><p>注意里面的映射的端口信息，接着给该脚本赋予可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shop-jenkins.sh</span><br></pre></td></tr></table></figure><p>如果开发者是在Windows系统下创建的sh脚本，那么放到Linux系统上时需要修改文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用vim编辑器来修改</span><br><span class="line">vi shop-jenkins.sh</span><br><span class="line"># 查看文件格式，windows上传上来的默认为dos</span><br><span class="line">:set ff </span><br><span class="line">#修改文件格式为unix</span><br><span class="line">:set ff=unix </span><br><span class="line">#保存并退出</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>然后我们创建对应的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-jenkins</span><br></pre></td></tr></table></figure><h1 id="在Jenkins中创建执行任务"><a href="#在Jenkins中创建执行任务" class="headerlink" title="在Jenkins中创建执行任务"></a>在Jenkins中创建执行任务</h1><p><strong>第一步</strong>，新建一个任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69a4ee3649aedac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，设置任务名称后选择构建一个自由风格的软件项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-845861f3b8d6158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第三步</strong>，点击源码管理，然后在里面添加仓库地址：<code>http://192.168.51.160:1080/myshop/shop-gitlab-jenkins</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1f28a87cb227fe96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时显示连接不通，我们需要添加一个凭据，也就是Git仓库的账号和密码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-23b0f51cc134ba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>填写完该凭据后就选择它，此时就可以正常连接到Git仓库：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8afb66ed66c1d79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，添加一个构建用于调用顶层maven模板，该构建主要用于将源码打包为Docker镜像并上传至Docker镜像仓库中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96d012913b65027d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择maven版本并设置maven命令以及指定pom文件的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6c3b13b50a6744c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着设置需要执行的shell的命令，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mydata/sh/shop-jenkins.sh</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ca8e69c00cf15653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击保存操作，这样任务就创建完成了。</p><p><strong>第五步</strong>，在任务列表中可以点击运行来执行该任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9941d3d80b4fc277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可通过点击左侧的构建历史序号，然后选择控制台输出即可看到整个任务的执行过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-108a84f1c09d77a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d5f4a904325309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第六步</strong>，接着我们开放8088端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8088/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开浏览器，访问<code>http://宿主机IP:8088/swagger-ui.html</code>连接，查看<code>shop-jenkins</code>服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c382f1b4ee6fe432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Jenkins+Gitlab一键打包部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker Compose部署SpringBoot应用</title>
    <link href="http://aigoing.chat/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/"/>
    <id>http://aigoing.chat/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/</id>
    <published>2023-02-24T02:55:30.000Z</published>
    <updated>2023-03-14T06:50:53.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行，但是当我们的应用数量较多时，上述两种方式似乎变得很不友好。</p><p>此时可以使用Docker Compose来解决上述问题，Docker Compose是一个用于定义和运行多个docker容器应用的工具。使用Compose允许开发者使用YAML文件来配置应用服务，之后使用一个命令，就可以部署配置的所有服务。</p><h1 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h1><h3 id="下载Docker-Compose"><a href="#下载Docker-Compose" class="headerlink" title="下载Docker Compose"></a>下载Docker Compose</h3><p>使用如下命令来下载Docker Compose：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="修改下载文件的权限"><a href="#修改下载文件的权限" class="headerlink" title="修改下载文件的权限"></a>修改下载文件的权限</h3><p>将下载文件的权限设置为可执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="确认Docker-Compose安装成功"><a href="#确认Docker-Compose安装成功" class="headerlink" title="确认Docker Compose安装成功"></a>确认Docker Compose安装成功</h3><p>可使用如下命令来确认Docker Compose已经安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果输出Docker Compose的版本则说明它已经安装成功了。</p><h1 id="Docker-Compose使用步骤"><a href="#Docker-Compose使用步骤" class="headerlink" title="Docker Compose使用步骤"></a>Docker Compose使用步骤</h1><p>一般来说，Docker Compose的使用分为三个步骤：<br>（1）使用Dockerfile来定义应用的程序环境，注意此步只有在需要修改初始化镜像时，才执行；<br>（2）使用<code>docker-compose.yml</code>文件来定义需要部署的应用程序服务，以便后续可通过执行脚本来一次性部署服务；<br>（3）使用<code>docker-compose up</code>命令一次性将所有应用服务部署起来。</p><h1 id="docker-compose-yml配置文件常用命令"><a href="#docker-compose-yml配置文件常用命令" class="headerlink" title="docker-compose.yml配置文件常用命令"></a>docker-compose.yml配置文件常用命令</h1><p>Docker Compose将所管理的容器分为三层，即工程、服务及容器。<code>docker-compose.yml</code>中定义的所有服务组成了一个工程，services节点下即为服务，服务之下为容器。容器与容器之间可通过以服务名称为域名来进行访问。举个例子，在<code>shop-docker-compose</code>服务中可通过<code>jdbc:mysql://db:3306</code>这个地址来访问db这个mysql服务。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>version用于指定docker-compose的版本号，目前使用值都是3。</p><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>services是一系列服务的集合，该节点下定义具体的服务。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image用于指定服务所使用的镜像，举个例子如使用的是mysql5.7的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>container_name用于设置容器的名称，举个例子如指定容器名称为mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: mysql</span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>ports用于设置宿主机和容器的端口映射，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的3306端口映射到容器的3306端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - 3306:3306</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>volumes用于将宿主机的文件或者目录挂载到容器中，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的如下文件挂载到容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">  - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">  - /mydata/mysql/conf:/etc/mysql</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>environment用于设置环境变量，举个例子设置MySQL初始化时root账户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  - MYSQL_ROOT_PASSWORD=envy123</span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>links用于连接其他的容器服务，注意格式为<code>（SERVICE:ALIAS）</code>，举个例子以database为域名来访问服务名称为db的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  - db:database</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h1><h3 id="构建、创建、启动相关容器"><a href="#构建、创建、启动相关容器" class="headerlink" title="构建、创建、启动相关容器"></a>构建、创建、启动相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>其中的<code>-d</code>表示在后台运行。</p><h3 id="指定文件启动"><a href="#指定文件启动" class="headerlink" title="指定文件启动"></a>指定文件启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h3 id="停止所有相关容器"><a href="#停止所有相关容器" class="headerlink" title="停止所有相关容器"></a>停止所有相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h3 id="列出所有容器信息"><a href="#列出所有容器信息" class="headerlink" title="列出所有容器信息"></a>列出所有容器信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-compose</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-compose</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-compose-0.0.1-SNAPSHOT.jar /shop-docker-compose.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-compose.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-compose.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-compose.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ac5e57969321848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-compose\target\shop-docker-compose-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-compose ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.948 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T16:47:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-compose</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-compose</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-compose:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。</p><h1 id="使用Docker-Compose部署应用"><a href="#使用Docker-Compose部署应用" class="headerlink" title="使用Docker Compose部署应用"></a>使用Docker Compose部署应用</h1><h3 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为<code>docker-compose.yml</code>的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  db:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: mysql</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">    - 3306:3306</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">    - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">    - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">    - /mydata/mysql/conf:/etc/mysql</span><br><span class="line">    # 指定容器的环境变量</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=envy123</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  shop-docker-compose:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: myshop-all/shop-docker-compose:0.0.1-SNAPSHOT</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: shop-docker-compose</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">      - /mydata/app/shop-docker-compose/logs:/var/logs</span><br></pre></td></tr></table></figure><h3 id="运行Docker-Compose命令启动所有服务"><a href="#运行Docker-Compose命令启动所有服务" class="headerlink" title="运行Docker Compose命令启动所有服务"></a>运行Docker Compose命令启动所有服务</h3><p>将上面定义的<code>docker-compose.yml</code>文件上传至<code>/mydata/app/shop-docker-compose</code>目录中，然后在该目录中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看一下服务是否已经启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-compose]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                           COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">252d6d043a3d   myshop-all/shop-docker-compose:0.0.1-SNAPSHOT   &quot;java -jar /shop-doc…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              shop-docker-compose</span><br><span class="line">3c1f3944c4ca   registry:2                                      &quot;/entrypoint.sh /etc…&quot;   7 hours ago     Up 7 hours     0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp              registry2</span><br><span class="line">1f83ff04b145   mysql:5.7                                       &quot;docker-entrypoint.s…&quot;   25 hours ago    Up 2 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   mysql</span><br></pre></td></tr></table></figure><p>接着我们需要进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>然后创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p>接着打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到之前的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p>修改root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>接着我们开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>然后打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-compose服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Docker Compose部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile为SpringBoot应用构建Docker镜像</title>
    <link href="http://aigoing.chat/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/"/>
    <id>http://aigoing.chat/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-23T10:15:33.000Z</published>
    <updated>2023-03-14T06:49:25.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在部署第一篇中，我们学习了如何使用通过<code>docker-maven-plugin</code>来构建docker镜像，遗憾的是此方式需要依赖自建的Registry镜像仓库，这在实际开发过程中还是有困难的。</p><p>鉴于此，本篇来学习另一种方式，使用Dockerfile来构建docker镜像。注意此方式不需要依赖自建的镜像仓库，只需应用的jar包和一个Dockerfile文件。</p><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Dockerfile为SpringBoot应用构建Docker镜像。</p><h1 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM用于指定所需依赖的基础镜像，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像需要依赖java8的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br></pre></td></tr></table></figure><p>注意FROM命令必须放在Dockerfile文件的第一行。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER用于指定镜像维护者的名字，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像的维护者为kenbings：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER kenbings</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD用于复制文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如将当前目录下的<code>shop-docker-file.jar</code>包复制到docker容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD shop-docker-file.jar /shop-docker-file.jar</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT用于指定docker容器启动时执行的命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在启动容器时启动运行jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV用于设置环境变量，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>举个例子，在mysql运行时设置root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV MYSQL_ROOT_PASSWORD envy123</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE用于声明要暴露的端口（注意只会声明不会打开端口），格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port1&gt; &lt;port2&gt; ...</span><br></pre></td></tr></table></figure><p>举个例子，声明服务运行在8080端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN用于自定义容器在构建过程中需要执行的命令，如安装一些软件、创建一些文件等，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在容器构建过程中需要在/目录下创建一个名为<code>shop-docker-file.jar</code>的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-file</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-file</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-file.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c13081c65ae93a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-file\target\shop-docker-file-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-file ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.759 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T14:59:31+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-file</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-file</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。上述命令执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br><span class="line">Sending build context to Docker daemon   36.5MB</span><br><span class="line">Step 1/6 : FROM openjdk:8u102</span><br><span class="line"> ---&gt; ca5dd051db43</span><br><span class="line">Step 2/6 : MAINTAINER kenbings</span><br><span class="line"> ---&gt; Running in 89102f5205f6</span><br><span class="line">Removing intermediate container 89102f5205f6</span><br><span class="line"> ---&gt; 3a095a2cfe51</span><br><span class="line">Step 3/6 : ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"> ---&gt; 0429582ab23e</span><br><span class="line">Step 4/6 : RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"> ---&gt; Running in 3083441e10a6</span><br><span class="line">Removing intermediate container 3083441e10a6</span><br><span class="line"> ---&gt; 10be5dacfb00</span><br><span class="line">Step 5/6 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 505f2c42fbdf</span><br><span class="line">Removing intermediate container 505f2c42fbdf</span><br><span class="line"> ---&gt; fbab2deea31e</span><br><span class="line">Step 6/6 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br><span class="line"> ---&gt; Running in bde857feb023</span><br><span class="line">Removing intermediate container bde857feb023</span><br><span class="line"> ---&gt; 7c0df63d8996</span><br><span class="line">Successfully built 7c0df63d8996</span><br><span class="line">Successfully tagged myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>查看一下该镜像是否确实生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker images|grep &#x27;docker-file&#x27;</span><br><span class="line">myshop-all/shop-docker-file   0.0.1-SNAPSHOT   7c0df63d8996   About a minute ago   714MB</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker-file应用服务"><a href="#启动shop-docker-file应用服务" class="headerlink" title="启动shop-docker-file应用服务"></a>启动shop-docker-file应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker-file/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker-file/logs:/var/logs \</span><br><span class="line">--name shop-docker-file \</span><br><span class="line">-d myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-file服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Dockerfile为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在部署第一篇中，我们学习了如何使用通过&lt;code&gt;docker-maven-plugin&lt;/code&gt;来构建docker镜像</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://aigoing.chat/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
