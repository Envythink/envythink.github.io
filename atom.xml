<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2024-05-22T14:17:58.831Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解MySQL中的JSON数据类型</title>
    <link href="http://envyzhan.asia/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/"/>
    <id>http://envyzhan.asia/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/</id>
    <published>2024-03-23T10:55:30.000Z</published>
    <updated>2024-05-22T14:17:58.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习MySQL中的JSON数据类型，这在某些场景下比text类型好用很多。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON 是 JavaScript Object Notation（JavaScript 对象表示法）的缩写，是一个轻量级的，基于文本的，跨语言的数据交换格式，易于阅读和编写。</p><h1 id="JSON基本数据类型"><a href="#JSON基本数据类型" class="headerlink" title="JSON基本数据类型"></a>JSON基本数据类型</h1><p>JSON 的基本数据类型如下：<br>（1）数值：十进制数，前面不能有0，可以为负数或小数，也可以为 e 或 E 表示的指数。<br>（2）字符串：字符串必须用双引号括起来。<br>（3）布尔值：true，false。<br>（4）数组：一个由零或多个值组成的有序序列。每个值可以为任意类型。数组使用方括号[] 括起来，元素之间用逗号,分隔。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, &quot;abc&quot;, null, false, &quot;10:29:06.000000&quot;, &#123;&quot;id&quot;: 2&#125;]</span><br></pre></td></tr></table></figure><p>（5）对象：一个由零或者多个键值对组成的无序集合。其中键必须是字符串，值可以为任意类型。对象使用花括号{}括起来，键值对之间使用逗号,分隔，键与值之间用冒号:分隔。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;db&quot;: [&quot;mysql&quot;, &quot;oracle&quot;], &quot;id&quot;: 666, &quot;info&quot;: &#123;&quot;age&quot;: 26&#125;&#125;</span><br></pre></td></tr></table></figure><p>（6）空值：null。</p><h1 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h1><p>这里创建一个名为tb_json的表，对应的SQL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json(t1 json);</span><br></pre></td></tr></table></figure><h3 id="直接插入JSON数组"><a href="#直接插入JSON数组" class="headerlink" title="直接插入JSON数组"></a>直接插入JSON数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_json values(&#x27;[1, &quot;test&quot;, null, false, &quot;09:10:11.000000&quot;]&#x27;);</span><br></pre></td></tr></table></figure><h3 id="直接插入JSON对象"><a href="#直接插入JSON对象" class="headerlink" title="直接插入JSON对象"></a>直接插入JSON对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tb_json values(&#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 20&#125;&#x27;);</span><br></pre></td></tr></table></figure><h3 id="使用-JSON-ARRAY-构造JSON数组"><a href="#使用-JSON-ARRAY-构造JSON数组" class="headerlink" title="使用 JSON_ARRAY 构造JSON数组"></a>使用 JSON_ARRAY 构造JSON数组</h3><p>JSON_ARRAY(val1,val2,val3…)，用于构造JSON数组。该方法可接受0个或者多个值的列表，并返回一个包含这些值的 JSON 数组，开发者可利用该函数实现将List数组存储到数据库中。<br>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692323865019-d5f7f950-36d1-4a4a-9879-43de8b0a73fe.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=143&id=uc7885295&originHeight=214&originWidth=971&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20331&status=done&style=none&taskId=uf77f11f7-6fd3-422b-9706-cbd542abdc3&title=&width=647.3333333333334" alt="image.png"></p><h3 id="使用-JSON-OBJECT-构造JSON对象"><a href="#使用-JSON-OBJECT-构造JSON对象" class="headerlink" title="使用 JSON_OBJECT 构造JSON对象"></a>使用 JSON_OBJECT 构造JSON对象</h3><p>JSON_OBJECT(key1,val1,key2,val2…)，用于构造JSON对象。该方法可接受0个或者多个键值对列表，并返回一个包含这些对的 JSON 对象，利用该方法开发者可以很容易的创建一个json对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_object(&#x27;id&#x27;, 2, &#x27;name&#x27;, &#x27;zhangsan&#x27;, &#x27;age&#x27;, 20);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692323945023-ebbe05f4-c185-4ba2-87a9-a0c6b5281fa4.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=139&id=uc29a17c9&originHeight=208&originWidth=931&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19228&status=done&style=none&taskId=u66f32ec4-b814-4c78-a38a-0933d423930&title=&width=620.6666666666666" alt="image.png"></p><h3 id="使用-JSON-QUOTE-将JSON转为字符串"><a href="#使用-JSON-QUOTE-将JSON转为字符串" class="headerlink" title="使用 JSON_QUOTE 将JSON转为字符串"></a>使用 JSON_QUOTE 将JSON转为字符串</h3><p>JSON_QUOTE(json_val)，用于将JSON转为字符串。通常用于生成有效的 JSON 字符串文字以包含在 JSON 文档中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_quote(&#x27;[123456]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692324112765-535db8bd-9255-49f7-b01b-f7074b845084.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=136&id=u1316e3ef&originHeight=204&originWidth=535&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13485&status=done&style=none&taskId=ue8a1af62-5b68-4596-b55c-85d30465da2&title=&width=356.6666666666667" alt="image.png"></p><h3 id="JSON对象注意点"><a href="#JSON对象注意点" class="headerlink" title="JSON对象注意点"></a>JSON对象注意点</h3><p>对于 JSON 对象来说，KEY 名不能重复，具体的需要结合 MySQL 版本来进行说明。<br>（1）如果插入的值中存在重复 KEY，在 MySQL 8.0.3 之前，遵循 first duplicate key wins 原则，会保留第一个 KEY，后面的将被丢弃掉。<br>（2）而从 MySQL 8.0.3 开始，遵循的是 last duplicate key wins 原则，只会保留最后一个 KEY。</p><p>【MySQL 5.7.32】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30);</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| &#123;&quot;key1&quot;: 10, &quot;key2&quot;: 20&#125;                   |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>【MySQL 8.0.27】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30);</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| json_object(&#x27;key1&#x27;,10,&#x27;key2&#x27;,20,&#x27;key1&#x27;,30) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| &#123;&quot;key1&quot;: 30, &quot;key2&quot;: 20&#125;                   |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h1><h3 id="JSON-CONTAINS"><a href="#JSON-CONTAINS" class="headerlink" title="JSON_CONTAINS"></a><strong>JSON_CONTAINS</strong></h3><p>JSON_CONTAINS(json_doc, val[, path])，用于查询JSON格式数据中是否包含指定对象，如果包含则返回1，否则返回0。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692324751008-59d14e7f-1dc9-4cf5-88f0-0203c3c30142.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=298&id=u619d238a&originHeight=447&originWidth=812&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=31042&status=done&style=none&taskId=u732492bb-16ac-4750-b3ee-ab31eccfc8c&title=&width=541.3333333333334" alt="image.png"></p><h3 id="JSON-CONTAINS-PATH"><a href="#JSON-CONTAINS-PATH" class="headerlink" title="JSON_CONTAINS_PATH"></a><strong>JSON_CONTAINS_PATH</strong></h3><p>JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] …)，用于查询JSON格式数据中是否存在指定类型的key，如果包含则返回1，否则返回0。</p><p>如果有参数为NULL，那么返回NULL。请注意one_or_all的值只能为”one”或”all”，one表示只要有一个存在即可，all表示所有的都存在才行。</p><p>使用如下命令来创建一个测试表并插入一条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json2(t2 json);</span><br><span class="line">insert into tb_json2 values(&#x27;&#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125;&#x27;), (&#x27;&#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>接着我们尝试使用 JSON_CONTAINS_PATH 来查询t2中是否包含 ename 这个key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_contains_path(t2,&#x27;one&#x27;,&#x27;$.ename&#x27;) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692328836836-4d124f59-66cc-4e1f-83d5-644231021b67.png#averageHue=%23161616&clientId=u35032c6b-3321-4&from=paste&height=163&id=ucde6db02&originHeight=244&originWidth=954&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18508&status=done&style=none&taskId=u928297c5-b4ba-49a5-b93b-dccd83ac56e&title=&width=636" alt="image.png"></p><h3 id="JSON-EXTRACT"><a href="#JSON-EXTRACT" class="headerlink" title="JSON_EXTRACT"></a><strong>JSON_EXTRACT</strong></h3><p>JSON_EXTRACT(json_doc, path[, path] …)，用于从JSON中抽取指定数据。其中，json_doc 是 JSON 文档，path 是路径。该函数会从 JSON 文档提取指定路径（path）的元素。如果指定 path 不存在，会返回 NULL。注意，可指定多个 path，那么匹配到的多个值会以数组形式返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(t2,&#x27;$.ename&#x27;) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692335483883-266ba718-d5f1-449c-880c-e657a7390271.png#averageHue=%23161616&clientId=u35032c6b-3321-4&from=paste&height=163&id=u5d4861cf&originHeight=244&originWidth=779&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17082&status=done&style=none&taskId=u30678b04-0466-4dac-b1d0-256db851153&title=&width=519.3333333333334" alt="image.png"></p><h5 id="JSON-EXTRACT在数组中的使用"><a href="#JSON-EXTRACT在数组中的使用" class="headerlink" title="JSON_EXTRACT在数组中的使用"></a>JSON_EXTRACT在数组中的使用</h5><p>我们知道数组的路径是通过下标来表示的，而且第一个元素的下标是 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336159121-97956765-5ee3-4f46-8d6b-a33f80ee6c57.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u79c6d2c7&originHeight=217&originWidth=873&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17385&status=done&style=none&taskId=ubb7dd4dc-9a2f-4d11-b4f9-2c2b41c335b&title=&width=582" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0]&#x27;,&#x27;$[1]&#x27;,&#x27;$[2][2]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336245648-ff3ac220-a33d-4741-81df-675f0c9a0702.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=139&id=ue8cf8993&originHeight=209&originWidth=1105&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20751&status=done&style=none&taskId=u89932fad-0271-47ea-9cbe-15cd5223abf&title=&width=736.6666666666666" alt="image.png"><br>当然，我么还可以使用 [M to N] 来获取数组的子集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[0 to 1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336338518-c85f36ce-c7be-4ef7-bcab-4cbb88615fb5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u1b1ae785&originHeight=217&originWidth=939&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18789&status=done&style=none&taskId=u430ea725-9423-462f-ac36-2eca7a23b04&title=&width=626" alt="image.png"><br>也可以使用last来代表最后一个元素的下标，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[last-1 to last]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336438352-8dfe5df4-a373-48c6-88a6-47aa02ddb166.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=142&id=u2a40a4cb&originHeight=213&originWidth=1048&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20758&status=done&style=none&taskId=ue930ae36-b5ad-4732-add4-d2afca58a4d&title=&width=698.6666666666666" alt="image.png"><br>也可通过 [*] 来获取数组中的所有元素，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;[10, 20, [30, 40, 50]]&#x27;, &#x27;$[*]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692336508314-bbad0f73-17b5-4ead-872d-8a1df1925ff1.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=138&id=ub2e34c6e&originHeight=207&originWidth=870&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18366&status=done&style=none&taskId=u8dbaf399-be64-4316-8dc8-b04f9026b06&title=&width=580" alt="image.png"></p><h5 id="JSON-EXTRACT在对象中的使用"><a href="#JSON-EXTRACT在对象中的使用" class="headerlink" title="JSON_EXTRACT在对象中的使用"></a>JSON_EXTRACT在对象中的使用</h5><p>我们知道对象的路径是通过 KEY 来表示的。首先往数据表中定义一个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @j=&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;a c&quot;: 4&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>之后我们尝试从中获取key为a的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.a&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337859006-9525f7d2-6430-473a-9e97-c30c19668265.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=u774ec65e&originHeight=218&originWidth=544&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12281&status=done&style=none&taskId=u934f6a6f-b9d0-4d5b-addb-66a848662ba&title=&width=362.6666666666667" alt="image.png"><br>再来获取key为b，且数组下标为1的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.b[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337920555-f1011e67-eccd-44e1-bb48-5830f590bd86.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=143&id=u1437f46e&originHeight=215&originWidth=586&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13456&status=done&style=none&taskId=u0f7de5ae-5bdf-41fe-9b15-42054956a27&title=&width=390.6666666666667" alt="image.png"><br>请注意，如果 KEY 在路径表达式中不合法（如存在空格），那么在引用这个 KEY 时，需用双引号括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(@j, &#x27;$.&quot;a c&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692337980197-7b761f25-cf46-4163-a751-bba4224964a2.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=ue5f56c5b&originHeight=212&originWidth=603&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12972&status=done&style=none&taskId=u811d815d-996d-4866-9d0e-74308b1f4e5&title=&width=402" alt="image.png"><br>此外，开发者还可以通过 .*  来获取对象中的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;a c&quot;: 4&#125;&#x27;, &#x27;$.*&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338068263-9462510c-4dc7-419a-8fd9-a9f6049fce2d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=138&id=u45698e38&originHeight=207&originWidth=981&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18850&status=done&style=none&taskId=u9deda8f5-500c-489b-9f2a-9ff1148387a&title=&width=654" alt="image.png"><br>再来看一个通配符的情况，可以看到这里的 $**.b 会匹配 $.a.b 和 $.c.b 这两种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_extract(&#x27;&#123;&quot;a&quot;: &#123;&quot;b&quot;: 1&#125;, &quot;c&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;, &#x27;$**.b&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338196223-306ca6cf-215a-433c-b515-bb7a3d8571ae.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=139&id=ud287d3a1&originHeight=209&originWidth=986&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18072&status=done&style=none&taskId=u1ae788a8-6843-4d6b-8da0-35caac860c5&title=&width=657.3333333333334" alt="image.png"></p><h3 id="column-gt-path"><a href="#column-gt-path" class="headerlink" title="column-&gt;path"></a><strong>column-&gt;path</strong></h3><p>column-&gt;path 以及后面提到的 column-&gt;&gt;path，它们都是语法糖，在实际使用的时候都会转化为 JSON_EXTRACT。</p><p>column-&gt;path 等同于 JSON_EXTRACT(column, path) ，注意里面只能指定一个path。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json2(t2 json);</span><br><span class="line">insert into tb_json2 values(&#x27;&#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125;&#x27;), (&#x27;&#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>查看一下t2以及其中ename的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2 ,t2 -&gt; &#x27;$.ename&#x27; from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338461799-f5f7e715-f449-41f9-a3a8-c9eccd9fad4b.png#averageHue=%231b1b1b&clientId=u35032c6b-3321-4&from=paste&height=161&id=ub813f5c9&originHeight=241&originWidth=780&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19917&status=done&style=none&taskId=uc3e58f9f-6cd8-41a7-9bfd-6a557e7b2f5&title=&width=520" alt="image.png"><br>查看一下empno为1001的用户的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_json2 where t2 -&gt; &#x27;$.empno&#x27; = 1001;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338620358-aa7093c9-bd6b-45ee-8e35-8afb2bfc967f.png#averageHue=%23171717&clientId=u35032c6b-3321-4&from=paste&height=140&id=ue7c5d3b1&originHeight=210&originWidth=840&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15629&status=done&style=none&taskId=ufba36d5e-ee32-48fc-a112-6603aaf672f&title=&width=560" alt="image.png"></p><h3 id="column-gt-gt-path"><a href="#column-gt-gt-path" class="headerlink" title="column-&gt;&gt;path"></a><strong>column-&gt;&gt;path</strong></h3><p>和 column-&gt;path 类似，只不过它返回的是字符串，请注意，下面三者是等价的：</p><ul><li><p>JSON_UNQUOTE( JSON_EXTRACT(column, path) )</p></li><li><p>JSON_UNQUOTE(column -&gt; path)</p></li><li><p>column-&gt;&gt;path</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2-&gt;&#x27;$.ename&#x27;,json_extract(t2, &quot;$.ename&quot;),json_unquote(t2-&gt;&#x27;$.ename&#x27;),t2-&gt;&gt;&#x27;$.ename&#x27; from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692338778806-d962b960-eb1d-4f5f-854c-8669a8bc54e0.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=160&id=u4c428175&originHeight=240&originWidth=1593&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=29171&status=done&style=none&taskId=uf2a40b73-9949-4f36-9580-31e6e4a888d&title=&width=1062" alt="image.png"></p><h3 id="JSON-SEARCH"><a href="#JSON-SEARCH" class="headerlink" title="JSON_SEARCH"></a><strong>JSON_SEARCH</strong></h3><p>JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] …])，该方法用于返回某个字符串（search_str）在 JSON 文档中的位置。其中：</p></li><li><p>one_or_all：匹配的次数，one 是只匹配一次，all 是匹配所有。如果匹配到多个，结果会以数组的形式返回。</p></li><li><p>search_str：子串，支持模糊匹配：% 和 _ 。</p></li><li><p>escape_char：转义符，如果该参数不填或为 NULL，则取默认转义符 \ 。</p></li><li><p>path：查找路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;one&#x27;, &#x27;abc&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341861120-d716b263-cb2b-4515-8e41-e31721a9bc49.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=ud46d07b1&originHeight=217&originWidth=1392&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23747&status=done&style=none&taskId=u2255355c-2d5f-4eb3-aa0f-f1408b100c4&title=&width=928" alt="image.png"><br>再来将one修改为all试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;abc&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341911889-e7dc5f0c-15bb-461d-94f0-d9ecb28cc535.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=137&id=u87572faf&originHeight=206&originWidth=1374&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24124&status=done&style=none&taskId=u3464de8a-ebcb-4a68-a581-5157f7a1990&title=&width=916" alt="image.png"><br>再来尝试寻找一个不存在的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;ddd&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341970434-83060a2a-6905-47ce-af86-96958ffbf5f5.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=137&id=u53518f7b&originHeight=205&originWidth=1393&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23127&status=done&style=none&taskId=u95d6906e-6c7f-49be-87d1-c123ef8dc08&title=&width=928.6666666666666" alt="image.png"><br>再来看一个例子，这里我们设置转义符为NULL，查找路径path指定为$[1]，此时代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;%b%&#x27;, NULL, &#x27;$[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342393098-3c0cdff1-55bd-4b3b-a751-313d540ee4f2.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u2022898b&originHeight=207&originWidth=1580&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=27519&status=done&style=none&taskId=u83f164a3-6f9f-4ab2-b483-b11f53eea69&title=&width=1053.3333333333333" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_search(&#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;1&quot;&#125;, &quot;job&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;, &#x27;all&#x27;, &#x27;%b%&#x27;, NULL, &#x27;$[3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342525743-3296886e-cb83-4539-9b75-ccbded7e5f0d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=147&id=ue7824b1d&originHeight=220&originWidth=1580&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28290&status=done&style=none&taskId=ua7d08ff6-56d4-4b48-aef7-d549eba5f1b&title=&width=1053.3333333333333" alt="image.png"></p><h3 id="JSON-KEYS"><a href="#JSON-KEYS" class="headerlink" title="JSON_KEYS"></a><strong>JSON_KEYS</strong></h3><p>JSON_KEYS(json_doc[, path])，用于返回 JSON 文档最外层的 key，如果指定了 path，那么返回该 path 对应元素最外层的 key。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_keys(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 6&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342653491-9ab83fff-8f45-4944-bcbe-cb7b58a5b24d.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=143&id=ubc107274&originHeight=214&originWidth=730&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14997&status=done&style=none&taskId=u408aefbe-cefb-4ab9-894f-8d554189414&title=&width=486.6666666666667" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_keys(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 6&#125;&#125;&#x27;, &#x27;$.b&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342719716-7b89e4e2-3ddd-449c-9dc3-22a82880da55.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=u146bd41d&originHeight=212&originWidth=822&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16105&status=done&style=none&taskId=u93190263-d3ea-40a1-a300-f5e76967cb8&title=&width=548" alt="image.png"></p><h3 id="JSON-VALUE"><a href="#JSON-VALUE" class="headerlink" title="JSON_VALUE"></a><strong>JSON_VALUE</strong></h3><p>JSON_VALUE(json_doc, path)，它是MySQL 8.0.21 版本引入的，用于从 JSON 文档提取指定路径（path）的元素。该函数的完整语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JSON_VALUE(json_doc, path [RETURNING type] [on_empty] [on_error])</span><br><span class="line"></span><br><span class="line">on_empty:</span><br><span class="line">    &#123;NULL | ERROR | DEFAULT value&#125; ON EMPTY</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line">    &#123;NULL | ERROR | DEFAULT value&#125; ON ERROR</span><br></pre></td></tr></table></figure><p>上述命令中各参数的含义如下：</p></li><li><p>RETURNING type：返回值的类型，不指定，则默认是 VARCHAR(512)。不指定字符集，则默认是 utf8mb4，且区分大小写。</p></li><li><p>on_empty：如果指定路径没有值，会触发 on_empty 子句， 默认是返回 NULL，也可指定 ERROR 抛出错误，或者通过 DEFAULT value 返回默认值。</p></li><li><p>on_error：三种情况下会触发 on_error 子句：从数组或对象中提取元素时，会解析到多个值；类型转换错误，比如将 “abc” 转换为 unsigned 类型；值被 truncate 了。默认是返回 NULL。</p></li></ul><p>看一个简单的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;26&quot;&#125;&#x27;, &#x27;$.name&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692342932116-e1e94e9b-79dd-4d2b-8508-5bba057532b9.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u5e6d6dd6&originHeight=208&originWidth=1020&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19010&status=done&style=none&taskId=ue0d11c29-862f-4b70-9b35-5a4d7e1857b&title=&width=680" alt="image.png"><br>再来看一个指定RETURNING type的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.weight&#x27; returning decimal(5,2)) as weight;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343141729-9bc7ba22-e87c-4274-bcad-87a6cac11125.png#averageHue=%23121212&clientId=u35032c6b-3321-4&from=paste&height=142&id=u16894e28&originHeight=213&originWidth=1610&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21501&status=done&style=none&taskId=ue6552d18-130c-4e91-bf70-9b3b1356c1e&title=&width=1073.3333333333333" alt="image.png"><br>再看一个指定on_empty的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.weight1&#x27; error on empty);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343271714-6ec28591-b059-49d2-b0a1-c0d6339abb7f.png#averageHue=%23252525&clientId=u35032c6b-3321-4&from=paste&height=40&id=ueff83c5d&originHeight=60&originWidth=1375&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15339&status=done&style=none&taskId=u11f5e095-a924-433c-a7d8-4db39802a01&title=&width=916.6666666666666" alt="image.png"><br>再看一个指定on_error的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;[1, 2, 3, 4]&#x27;, &#x27;$[1 to 2]&#x27; error on error);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343361168-b9e05a72-b9b1-427a-96be-7accd256e46b.png#averageHue=%23222222&clientId=u35032c6b-3321-4&from=paste&height=43&id=u2f0227d3&originHeight=65&originWidth=1244&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13959&status=done&style=none&taskId=u02e84174-e4a0-4504-afc8-8cb0de77247&title=&width=829.3333333333334" alt="image.png"><br>再来看一个指定on_error的例子，是因为类型转换错误而导致的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_value(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;weight&quot;: &quot;132.82&quot;&#125;&#x27;, &#x27;$.name&#x27; returning unsigned error on error) as weight;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343669694-1ad8d804-d809-444c-8c84-15f4262182c2.png#averageHue=%23212121&clientId=u35032c6b-3321-4&from=paste&height=42&id=u8fdbd69c&originHeight=63&originWidth=1737&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16681&status=done&style=none&taskId=u7fe53ace-5727-471a-b05a-93394623a05&title=&width=1158" alt="image.png"></p><h3 id="MEMBER-OF"><a href="#MEMBER-OF" class="headerlink" title="MEMBER OF"></a><strong>MEMBER OF</strong></h3><p>value MEMBER OF(json_array)，用于判断 value 是否是 JSON 数组的一个元素，如果是，则返回 1；否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 18 member of(&#x27;[23, &quot;ad&quot;, 18, &quot;abc&quot;, 16]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343800781-34296a34-bd93-40f5-bd27-6cf2b7786564.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=uf820cc5e&originHeight=204&originWidth=797&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15655&status=done&style=none&taskId=u3779c79b-92b6-4436-8236-1699ad9437f&title=&width=531.3333333333334" alt="image.png"><br>再来看一个vaue为JOSN数组时的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cast(&#x27;[1,2]&#x27; as json) member of(&#x27;[[1,2],[3,4]]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692343881895-3b094579-b587-45ab-917f-2fa16ae68fa2.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=ufb8790b6&originHeight=204&originWidth=892&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16893&status=done&style=none&taskId=ue9c282b4-f0c5-48f8-a486-17525c5a69c&title=&width=594.6666666666666" alt="image.png"></p><h3 id="JSON-OVERLAPS"><a href="#JSON-OVERLAPS" class="headerlink" title="JSON_OVERLAPS"></a><strong>JSON_OVERLAPS</strong></h3><p>JSON_OVERLAPS(json_doc1, json_doc2)，它是 MySQL 8.0.17版本 引入的，用于比较两个 JSON 文档是否有相同的键值对或数组元素，如果有，则返回 1，否则返回0。如果两个参数都是标量，那么判断这两个标量是否相等。<br>首先看一下两个JOSN数组是否有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;[1,3,5,7,9]&#x27;, &#x27;[3,5,7]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344368505-f4c3da2a-1efa-4aa8-8e31-b0e54fb6efbb.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=145&id=u63eac0f4&originHeight=217&originWidth=767&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15320&status=done&style=none&taskId=u59e43344-67e9-4cf2-802f-477a57c5f6f&title=&width=511.3333333333333" alt="image.png"><br>看一个两个JOSN数组中没有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;[1,3,5,7,9]&#x27;, &#x27;[2,4,6]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344424376-067ba9a5-01ff-4696-84f6-bdec4c25e6a5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=137&id=u527f7731&originHeight=205&originWidth=770&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16100&status=done&style=none&taskId=udb995371-c541-4421-bd45-704784ca120&title=&width=513.3333333333334" alt="image.png"><br>再来看一个两个JOSN对象是否有相同元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;, &#x27;&#123;&quot;c&quot;:3,&quot;d&quot;:4,&quot;b&quot;:2&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692344554055-aaaefc2a-4ce9-4656-99a9-1f43bc945baf.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=138&id=u81d5d322&originHeight=207&originWidth=966&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17667&status=done&style=none&taskId=u6780bf9a-3e37-4709-9f80-90369473175&title=&width=644" alt="image.png"><br>再来一个比较简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_overlaps(&#x27;1&#x27;, &#x27;1&#x27;),json_overlaps(&#x27;1&#x27;, &#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345248986-faa90e61-16d1-4765-97c7-5fd3aec3bedf.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u19436e90&originHeight=207&originWidth=878&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15372&status=done&style=none&taskId=u04a463bd-dfde-4082-9bbe-b991d1eb358&title=&width=585.3333333333334" alt="image.png"><br>自 MySQL 8.0.17版本开始，InnoDB 支持多值索引，可用在 JSON 数组中。当开发者使用 JSON_CONTAINS、MEMBER OF、JSON_OVERLAPS 进行数组相关的操作时，可使用多值索引来加快查询。</p><h1 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h1><h3 id="JSON-INSERT"><a href="#JSON-INSERT" class="headerlink" title="JSON_INSERT"></a><strong>JSON_INSERT</strong></h3><p>JSON_INSERT(json_doc, path, val[, path, val] …)，该方法用于插入新值，注意仅当指定位置或指定 KEY 的值不存在时，才执行插入操作。此外，如果指定的 path 是数组下标，且 json_doc 不是数组，那么该函数首先会将 json_doc 转化为数组，然后再插入新值。</p><p>下面通过几个案例来学习如何使用JSON_INSERT这个函数，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;1&#x27;,&#x27;$[0]&#x27;,&quot;6&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339122210-55f80d8b-9e54-4d0b-8e12-1d79f00da72a.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u99cad776&originHeight=208&originWidth=600&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13009&status=done&style=none&taskId=u94f90d9a-5be0-4efb-8304-79904ec6fad&title=&width=400" alt="image.png"><br>接着我们通过path指定数组下标为1，此时执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;1&#x27;,&#x27;$[1]&#x27;,&quot;6&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339185145-9f6b08a0-597f-40cd-898e-ddb1b6f22aef.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=143&id=ue9314c1c&originHeight=215&originWidth=608&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13529&status=done&style=none&taskId=ueabaaaf9-791c-4965-8bad-9088559f2a9&title=&width=405.3333333333333" alt="image.png"><br>再来看一个数组的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]&#x27;,&#x27;$[3]&#x27;,&quot;8&quot;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339271760-2f0a20be-a20b-4157-88c1-bd61ee36620c.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=139&id=u91178613&originHeight=209&originWidth=770&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16341&status=done&style=none&taskId=u633bdb45-7c4e-4a26-a2e4-016cc6991c5&title=&width=513.3333333333334" alt="image.png"><br>再来看一下比较综合的案例，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_insert(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;, &#x27;$.a&#x27;, 6, &#x27;$.d&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339388328-693d7407-0425-4a3a-9025-3e8ae3360060.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=142&id=u7cb77c1b&originHeight=213&originWidth=1215&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24629&status=done&style=none&taskId=u247c84fe-d8e0-497f-8beb-c9628744014&title=&width=810" alt="image.png"></p><h3 id="JSON-SET"><a href="#JSON-SET" class="headerlink" title="JSON_SET"></a><strong>JSON_SET</strong></h3><p>JSON_SET(json_doc, path, val[, path, val] …)，该方法用于插入新值，并替换已经存在的值。也就是说，如果指定位置或指定 KEY 的值不存在，那么将执行插入操作；如果存在，则执行更新操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_set(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;, 8, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339568779-34be3fd8-e4ed-4d7c-b725-eabc180eb90f.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=u4c57a675&originHeight=218&originWidth=1212&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24840&status=done&style=none&taskId=u400a4f06-e0e4-404a-9d56-b076f100089&title=&width=808" alt="image.png"></p><h3 id="JSON-REPLACE"><a href="#JSON-REPLACE" class="headerlink" title="JSON_REPLACE"></a><strong>JSON_REPLACE</strong></h3><p>JSON_REPLACE(json_doc, path, val[, path, val] …)，该方法用于替换已经存在的值，如果该值不存在那么不会进行替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_replace(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;, 6, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339733503-924ed095-bccf-4557-9ab7-df4e268b2d28.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=139&id=ud7187169&originHeight=209&originWidth=1275&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24113&status=done&style=none&taskId=ufef2c797-2f54-4cf1-bafb-090d6a9cacf&title=&width=850" alt="image.png"></p><h3 id="JSON-ARRAY-APPEND"><a href="#JSON-ARRAY-APPEND" class="headerlink" title="JSON_ARRAY_APPEND"></a><strong>JSON_ARRAY_APPEND</strong></h3><p>JSON_ARRAY_APPEND(json_doc, path, val[, path, val] …)，用于向数组的指定位置追加元素，请注意，如果指定的 path 不存在，那么将不会添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[0]&#x27;, 1);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345664066-ac5a7a83-406a-44c1-a559-7f5637d884b1.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=142&id=u5a937e88&originHeight=213&originWidth=979&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19658&status=done&style=none&taskId=uab0421bb-3f3a-439e-a710-f111f85e77e&title=&width=652.6666666666666" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[1][0]&#x27;, 2);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345710645-3568c0c7-19cf-465d-bcfb-473ea3bb41f5.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=140&id=u27f0a147&originHeight=210&originWidth=1011&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20280&status=done&style=none&taskId=u6d880c30-e69b-4cc4-9fda-3629d50301f&title=&width=674" alt="image.png"><br>现在我们尝试修改一个不存在的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;, &#x27;$[3]&#x27;, 3);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692345746637-12505391-8bb7-41c2-8993-4d6098d21d9d.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=137&id=ub88f6388&originHeight=206&originWidth=978&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18946&status=done&style=none&taskId=u64c21c13-ed75-4b12-905d-d7208b0470c&title=&width=652" alt="image.png"><br>前面提到的都是JSON数组，接下来我们看一下JSON对象，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_append(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: 4&#125;&#x27;, &#x27;$.b&#x27;, &#x27;x&#x27;, &#x27;$&#x27;, &#x27;z&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346023296-dd896e22-0100-427e-ab8f-3c767fd47fa5.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=138&id=u13ad2a4a&originHeight=207&originWidth=1234&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23876&status=done&style=none&taskId=u0ed68f36-0614-4206-bcf6-34600a16527&title=&width=822.6666666666666" alt="image.png"></p><h3 id="JSON-ARRAY-INSERT"><a href="#JSON-ARRAY-INSERT" class="headerlink" title="JSON_ARRAY_INSERT"></a><strong>JSON_ARRAY_INSERT</strong></h3><p>JSON_ARRAY_INSERT(json_doc, path, val[, path, val] …)，用于向数组的指定位置插入元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[0]&#x27;, 1);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346205592-a066b414-9425-4c56-93a2-0ebe9f59f641.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u078d1649&originHeight=208&originWidth=1058&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21498&status=done&style=none&taskId=ubed87693-0a5e-44c3-8e49-22d2dcb6da6&title=&width=705.3333333333334" alt="image.png"><br>再来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[1]&#x27;, cast(&#x27;[1,2,3]&#x27; as json));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346311046-86b0334a-0ccc-417b-a3b2-939294be46c3.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=u632adfca&originHeight=209&originWidth=1370&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26359&status=done&style=none&taskId=u25b793a8-c0a1-482c-ab1c-06057d7a8ae&title=&width=913.3333333333334" alt="image.png"><br>接下来我们尝试往数组中不存在的索引位置处插入一个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_array_insert(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;],&#123;&quot;d&quot;:&quot;e&quot;&#125;]&#x27;, &#x27;$[8]&#x27;, 2);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346416270-1026a48d-0248-4e89-bd30-716523dd20e6.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=135&id=u14e9c78b&originHeight=203&originWidth=1042&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21352&status=done&style=none&taskId=u7c933517-d0e9-4a6b-91e3-a697237429b&title=&width=694.6666666666666" alt="image.png"><br>可以看到此时即使用户传入的下标超出了数组的索引，但是依旧能插入元素，只是在数组末尾进行了插入。</p><h3 id="JSON-MERGE-PATCH"><a href="#JSON-MERGE-PATCH" class="headerlink" title="JSON_MERGE_PATCH"></a><strong>JSON_MERGE_PATCH</strong></h3><p>JSON_MERGE_PATCH(json_doc, json_doc[, json_doc] …)，它是MySQL 8.0.3版本 引入的，用于合并多个 JSON 文档。合并规则如下：<br>（1）如果两个文档不全是 JSON 对象，那么合并后的结果是第二个文档。<br>（2）如果两个文档都是 JSON 对象，且不存在同名 KEY，那么合并后的文档包括两个文档的所有元素；如果存在同名 KEY，那么第二个文档的值会覆盖第一个。<br>首先看第一点，这里我们尝试合并两个JSON数组，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;[1, 2]&#x27;, &#x27;[3, 4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692346915784-8081947d-9f96-44f3-a024-aac1b2fca1ee.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=145&id=ucd346278&originHeight=218&originWidth=721&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15479&status=done&style=none&taskId=ufd3bdab3-0bcf-417f-86de-b35fd358231&title=&width=480.6666666666667" alt="image.png"><br>接着我们尝试将一个JOSN数组和一个JSON对象进行合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;[1, 2]&#x27;, &#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347000216-9177fb63-ae94-4b23-9456-d898049713a0.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=141&id=u1c60e98f&originHeight=212&originWidth=924&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19436&status=done&style=none&taskId=u7ce1ab6c-55ce-4ff4-b608-2c2962f6a67&title=&width=616" alt="image.png"><br>然后我们尝试合并两个JSON对象，这两个JSON对象不存在同名的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;, &#x27;&#123;&quot;b&quot;: 2&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347172411-a430c420-4f6a-4af6-bab0-d183adbf9025.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=144&id=ud130e65f&originHeight=216&originWidth=784&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16907&status=done&style=none&taskId=u09b8fa88-3b67-4bbc-95fb-904d2cab7e6&title=&width=522.6666666666666" alt="image.png"><br>接着我们尝试合并两个JSON对象，注意这两个JSON对象存在同名的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;:2 &#125;&#x27;,&#x27;&#123; &quot;a&quot;: 3, &quot;c&quot;:4 &#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347291515-bf8293d3-6fa6-4ec2-946e-68d02fc10df9.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=140&id=u962229bf&originHeight=210&originWidth=1019&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19831&status=done&style=none&taskId=u18d35517-21ed-4957-b83d-2c4103baf6c&title=&width=679.3333333333334" alt="image.png"><br>请注意，如果第二个文档中存在 null 值，那么文档合并后不会输出对应的 KEY，这一点需要引起注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_patch(&#x27;&#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;&#x27;, &#x27;&#123;&quot;a&quot;:3, &quot;b&quot;:null&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347411910-197ae876-b9d8-4d33-9ab3-6e3ce60030ac.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=136&id=u6affd741&originHeight=204&originWidth=993&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18930&status=done&style=none&taskId=uc6ec4f57-ff87-4541-94aa-f7963cefe6e&title=&width=662" alt="image.png"></p><h3 id="JSON-MERGE-PRESERVE"><a href="#JSON-MERGE-PRESERVE" class="headerlink" title="JSON_MERGE_PRESERVE"></a><strong>JSON_MERGE_PRESERVE</strong></h3><p>JSON_MERGE_PRESERVE(json_doc, json_doc[, json_doc] …)，它是自MySQL 8.0.3版本 引入的，用于代替 JSON_MERGE。它也是用来合并文档，但合并规则与 JSON_MERGE_PATCH 有所不同，具体如下：<br>（1）两个文档中，只要有一个文档是数组，那么就会将另一个文档合并到该数组中；<br>（2）两个文档都是 JSON 对象，如果存在同名 KEY ，那么第二个文档并不会覆盖第一个，而是会将值 append 到第一个文档中。<br>先看第一点，如下所示的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;1&#x27;,&#x27;2&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347913733-162e1c2b-f622-44bb-b289-1d86b05b85d7.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=137&id=u16b8f1bd&originHeight=206&originWidth=598&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12633&status=done&style=none&taskId=ue20702ff-23e6-4297-84b6-60ca46ead5b&title=&width=398.6666666666667" alt="image.png"><br>再来看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;[1, 2]&#x27;, &#x27;[3, 4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692347981109-eb6e32c1-217e-4ae5-be76-348631bb5dd6.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=140&id=u4055182c&originHeight=210&originWidth=767&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15682&status=done&style=none&taskId=u32a06f02-60d5-45ee-8f00-be81d3adbc2&title=&width=511.3333333333333" alt="image.png"><br>再来看一个例子，这个例子看起来更清晰一点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;[1, 2]&#x27;, &#x27;&#123;&quot;a&quot;: 1234&#125;&#x27;), json_merge_preserve(&#x27;&#123;&quot;a&quot;: 1234&#125;&#x27;, &#x27;[3,4]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348086960-605750c4-30b2-4f13-8766-6ef3f2c35cc4.png#averageHue=%231a1a1a&clientId=u35032c6b-3321-4&from=paste&height=141&id=u5385a835&originHeight=212&originWidth=1466&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=26424&status=done&style=none&taskId=u37dd13b5-2f65-4bce-96c6-c072d25920f&title=&width=977.3333333333334" alt="image.png"><br>再来看一个比较复杂的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_merge_preserve(&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;, &#x27;&#123;&quot;b&quot;: 2&#125;&#x27;), json_merge_preserve(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;:2 &#125;&#x27;,&#x27;&#123; &quot;a&quot;: 3, &quot;c&quot;:4 &#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348180174-8c4d57d2-168c-4b06-880b-ee75aba068eb.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=139&id=ub0e52592&originHeight=208&originWidth=1690&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=28264&status=done&style=none&taskId=uebc5b683-cecf-4c16-94f9-0d40d6b1721&title=&width=1126.6666666666667" alt="image.png"></p><h3 id="JSON-MERGE"><a href="#JSON-MERGE" class="headerlink" title="JSON_MERGE"></a>JSON_MERGE</h3><p>JSON_MERGE(json_doc, json_doc[, json_doc] …)，与 JSON_MERGE_PRESERVE 作用一样，不过自 MySQL 8.0.3版本开始就不建议使用，后续会移除。</p><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><h3 id="JSON-REMOVE"><a href="#JSON-REMOVE" class="headerlink" title="JSON_REMOVE"></a><strong>JSON_REMOVE</strong></h3><p>JSON_REMOVE(json_doc, path[, path] …)，该方法用于删除 JSON 文档中指定位置的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4]&#125;&#x27;, &#x27;$.a&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692339891455-9e6363ee-6f39-4e07-84c4-5dbf32dc2d1e.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=141&id=u7b55d02b&originHeight=212&originWidth=879&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18186&status=done&style=none&taskId=ufc22c531-d718-4d42-a319-e41dff9d945&title=&width=586" alt="image.png"><br>再来一个删除数组中指定位置元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;, &quot;e&quot;]&#x27;, &#x27;$[1]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692340892323-9c8f16ee-5215-4d60-a05d-39382bdc91d9.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=144&id=ua9df5050&originHeight=216&originWidth=925&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17855&status=done&style=none&taskId=ub723ef8a-5c3c-4413-b340-6e17a53ad68&title=&width=616.6666666666666" alt="image.png"><br>再来看一个同时删除对象和数组中指定位置元素的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_remove(&#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;, &quot;e&quot;]&#x27;, &#x27;$[1]&#x27;, &#x27;$[2]&#x27;);</span><br></pre></td></tr></table></figure><p>请注意，这里指定删除两个位置的元素，相对应的元素索引是在前面操作后结果的基础上，不是在原始JSON文档的索引基础上进行的操作，执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692341094925-8e223504-4cf3-41bc-87ec-53edc5930227.png#averageHue=%23181818&clientId=u35032c6b-3321-4&from=paste&height=143&id=u46442776&originHeight=214&originWidth=1043&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19062&status=done&style=none&taskId=u95170264-b078-475d-bda7-092e74dac8d&title=&width=695.3333333333334" alt="image.png"></p><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><h3 id="JSON-QUOTE"><a href="#JSON-QUOTE" class="headerlink" title="JSON_QUOTE"></a><strong>JSON_QUOTE</strong></h3><p>JSON_QUOTE(string)，用于生成有效的 JSON 字符串，主要是对一些特殊字符（如双引号）进行转义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_quote(&#x27;null&#x27;), json_quote(&#x27;&quot;null&quot;&#x27;), json_quote(&#x27;[1, 2, 3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692348491206-41c5a161-c952-41ac-9543-149116ff719b.png#averageHue=%23191919&clientId=u35032c6b-3321-4&from=paste&height=147&id=ucdfe8513&originHeight=220&originWidth=1146&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20698&status=done&style=none&taskId=ud060081b-d772-4027-9e8e-020df6427a5&title=&width=764" alt="image.png"><br>当然了，还可以通过 CAST(value AS JSON) 来进行类型转换。</p><h3 id="JSON-UNQUOTE"><a href="#JSON-UNQUOTE" class="headerlink" title="JSON_UNQUOTE"></a><strong>JSON_UNQUOTE</strong></h3><p>JSON_UNQUOTE(json_val)，用于将 JSON 转义成字符串输出。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t2-&gt;&#x27;$.ename&#x27;,json_unquote(t2-&gt;&#x27;$.ename&#x27;),json_valid(t2-&gt;&#x27;$.ename&#x27;),json_valid(json_unquote(t2-&gt;&#x27;$.ename&#x27;)) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692580154218-0c05e45a-e405-414e-b5dc-adf85c065372.png#averageHue=%23171717&clientId=u79b58c88-76cc-4&from=paste&height=179&id=u49e085e0&originHeight=268&originWidth=1917&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=34153&status=done&style=none&taskId=u9a5d7783-b124-483c-8da6-170a57df4c6&title=&width=1278" alt="image.png"><br>从执行结果中看，没使用 JSON_UNQUOTE 函数，那么字符串会用双引号引起来。而加了 JSON_UNQUOTE 函数，字符串就没有用双引号括起来。但本质上，前者是 JSON 中的 STRING 类型，后者是 MySQL 中的字符类型，这一点可通过 JSON_VALID 函数来进行判断。</p><h3 id="JSON-OBJECTAGG"><a href="#JSON-OBJECTAGG" class="headerlink" title="JSON_OBJECTAGG"></a><strong>JSON_OBJECTAGG</strong></h3><p>JSON_OBJECTAGG(key, value)方法，用于取表中的两列作为参数，其中第一列是 key，第二列是 value，并以JSON 对象进行返回。举个例子，如下所示的数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_json2;</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| t2                               | name | age  |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| &#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125; | jack |   20 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125; | mark |   19 |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试使用 json_objectagg() 方法，将name和age组成一个JOSN对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_objectagg(name, age) from tb_json2;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692580712946-dad69137-51f5-4750-af3a-1f48721b11ab.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=135&id=uab645cb8&originHeight=202&originWidth=758&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=15891&status=done&style=none&taskId=u0488156a-6350-4f3d-bcfa-554115d7b0c&title=&width=505.3333333333333" alt="image.png"></p><h3 id="JSON-ARRAYAGG"><a href="#JSON-ARRAYAGG" class="headerlink" title="JSON_ARRAYAGG"></a><strong>JSON_ARRAYAGG</strong></h3><p>JSON_ARRAYAGG(col_or_expr)方法，用于将列的值聚合成 JSON 数组，请注意 JSON 数组中元素的顺序是随机的。</p><p>举个例子，如下所示的数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_json2;</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| t2                               | name | age  |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">| &#123;&quot;empno&quot;: 1001, &quot;ename&quot;: &quot;jack&quot;&#125; | jack |   20 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1002, &quot;ename&quot;: &quot;mark&quot;&#125; | mark |   19 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1003, &quot;ename&quot;: &quot;book&quot;&#125; | book |   22 |</span><br><span class="line">| &#123;&quot;empno&quot;: 1004, &quot;ename&quot;: &quot;yook&quot;&#125; | yook |   25 |</span><br><span class="line">+----------------------------------+------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试使用 json_arrayagg() 方法，将 age 列的值聚合为一个JOSN数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name ,json_arrayagg(age) from tb_json2 group by name;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581144794-0614391d-0c27-41ee-b353-2639be0236fb.png#averageHue=%23151515&clientId=u79b58c88-76cc-4&from=paste&height=196&id=u43f1cbe2&originHeight=294&originWidth=950&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23359&status=done&style=none&taskId=uc273fecd-8264-4127-9495-e1a975cfd10&title=&width=633.3333333333334" alt="image.png"></p><h3 id="JSON-PRETTY"><a href="#JSON-PRETTY" class="headerlink" title="JSON_PRETTY"></a><strong>JSON_PRETTY</strong></h3><p>JSON_PRETTY(json_val)方法，用于格式化 JSON 。首先看一个格式化JSON数组的例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_pretty(&#x27;[1,2,3,4,5]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581319413-3e864613-ad61-4bf2-b207-6dfed6848002.png#averageHue=%23131313&clientId=u79b58c88-76cc-4&from=paste&height=258&id=u438e3226&originHeight=387&originWidth=590&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17421&status=done&style=none&taskId=ud6780927-47eb-4432-b831-4a9282de08d&title=&width=393.3333333333333" alt="image.png"><br>再来看一个格式化JSON对象的例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_pretty(&#x27;&#123;&quot;a&quot;: 1,&quot;b&quot;: 2,&quot;c&quot;:3&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581447956-d48747ff-3c44-400e-a55d-4aebec4ea710.png#averageHue=%23141414&clientId=u79b58c88-76cc-4&from=paste&height=216&id=u38f102fb&originHeight=324&originWidth=728&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19288&status=done&style=none&taskId=u108cffc0-dc1e-4148-a601-b9811d8be31&title=&width=485.3333333333333" alt="image.png"></p><h3 id="JSON-STORAGE-FREE"><a href="#JSON-STORAGE-FREE" class="headerlink" title="JSON_STORAGE_FREE"></a><strong>JSON_STORAGE_FREE</strong></h3><p>JSON_STORAGE_FREE(json_val)，该方法是MySQL 8.0 新增的，与 Partial Updates 有关，用于计算 JSON 文档在进行部分更新后的剩余空间。</p><h3 id="JSON-STORAGE-SIZE"><a href="#JSON-STORAGE-SIZE" class="headerlink" title="JSON_STORAGE_SIZE"></a><strong>JSON_STORAGE_SIZE</strong></h3><p>JSON_STORAGE_SIZE(json_val)，该方法是MySQL 5.7.22 引入的，用于计算 JSON 文档的空间使用情况。</p><h3 id="JSON-DEPTH"><a href="#JSON-DEPTH" class="headerlink" title="JSON_DEPTH"></a><strong>JSON_DEPTH</strong></h3><p>JSON_DEPTH(json_doc)，该方法用于返回 JSON 文档的最大深度。请注意，对于空数组，空对象，标量值，其深度为 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_depth(&#x27;&#123;&#125;&#x27;), json_depth(&#x27;[1,2,3]&#x27;), josn_depth(&#x27;[1,&#123;&quot;a&quot;: 2&#125;]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692581778951-609ae0fa-06f0-4d37-ad2f-d9534580475e.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u2dd097f6&originHeight=206&originWidth=1153&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20263&status=done&style=none&taskId=u960b7de1-3af1-4792-aea2-edd1a2e59ac&title=&width=768.6666666666666" alt="image.png"></p><h3 id="JSON-LENGTH"><a href="#JSON-LENGTH" class="headerlink" title="JSON_LENGTH"></a><strong>JSON_LENGTH</strong></h3><p>JSON_LENGTH(json_doc[, path])，该方法用于返回 JSON 文档的长度，计算规则如下：<br>（1）如果是标量值，其长度为 1；<br>（2）如果是数组，其长度为数组元素的个数；<br>（3）如果是对象，其长度为对象元素的个数；<br>（4）不包括嵌套数据和嵌套对象的长度。<br>接下来我们通过案例来演示上述计算规则的使用。首先是标量值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&quot;abcd&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582089291-856a250e-8cf2-4f35-aa3d-8c8a27fbb0b7.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=139&id=ud0068afe&originHeight=208&originWidth=512&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11277&status=done&style=none&taskId=ub493d140-26c1-4a2f-b897-1b27d658102&title=&width=341.3333333333333" alt="image.png"><br>看一个纯数组的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;[1,2,3]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582523263-931e5d62-b255-4c1c-9441-ea64ce2f95e1.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=142&id=u77670965&originHeight=213&originWidth=535&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=12025&status=done&style=none&taskId=u2d820909-c2e6-4ac1-b3e9-1b8152155b7&title=&width=356.6666666666667" alt="image.png"><br>看一个纯对象的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;sex&quot;: &quot;female&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582620978-a7359073-5592-4f8f-870a-1c0f12bff045.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=141&id=ua9c62b1b&originHeight=212&originWidth=951&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17321&status=done&style=none&taskId=u6fb56b42-42a7-40af-8fe8-ed3fa24d1b1&title=&width=634" alt="image.png"><br>来看一个数组和对象混用的例子，注意它不包括嵌套数据和嵌套对象的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;[1,2,3,&#123;&quot;name&quot;: &quot;wanger&quot;, &quot;sex&quot;: &quot;male&quot;&#125;]&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582768400-9e6cf437-78a9-47d2-bee2-d0d983dedf8c.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=135&id=u1a127da5&originHeight=203&originWidth=994&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=18743&status=done&style=none&taskId=u25969ded-4f3f-492d-8b1f-79cab3ac7f3&title=&width=662.6666666666666" alt="image.png"><br>再看一个对象和对象混用的例子，注意它同样不包括嵌套数据和嵌套对象的长度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;hobby&quot;:&#123;&quot;language&quot;: &quot;english&quot;,&quot;boll&quot;:&quot;footboll&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692582951088-fbf5ec4b-ef9a-4522-9cbc-64e6b482fc1e.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=144&id=ud744c117&originHeight=216&originWidth=1391&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24111&status=done&style=none&taskId=u762334fe-06e8-4935-8e0e-7aa8385af2e&title=&width=927.3333333333334" alt="image.png"><br>我们尝试输出hobby这个对象的长度，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_length(&#x27;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;hobby&quot;:&#123;&quot;language&quot;: &quot;english&quot;,&quot;boll&quot;:&quot;footboll&quot;&#125;&#125;&#x27;,&#x27;$.hobby&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583139153-0023cd5f-8a9b-4743-82a9-d5b4098b389c.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u07999bba&originHeight=206&originWidth=1539&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=25966&status=done&style=none&taskId=u994018e9-6c7e-4402-98b2-7c162ee44c9&title=&width=1026" alt="image.png"></p><h3 id="JSON-TYPE"><a href="#JSON-TYPE" class="headerlink" title="JSON_TYPE"></a><strong>JSON_TYPE</strong></h3><p>JSON_TYPE(json_val)，该方法用于返回 JSON 值的类型。首先看一个JSON整型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(&#x27;12345&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583417931-9854fce7-049b-48e7-a4c9-159660635190.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=142&id=u8e6c7f99&originHeight=213&originWidth=489&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11986&status=done&style=none&taskId=u4ffe10ba-d1e2-4150-b220-326548a7fe1&title=&width=326" alt="image.png"><br>再看一个JSON字符串类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(&#x27;&quot;abcd&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583545781-30ae4848-5860-4f9a-bb7e-89d8c46b8c55.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=139&id=u89b81e93&originHeight=209&originWidth=473&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11577&status=done&style=none&taskId=u9bd95972-1d0d-49d0-8e32-0db106491b8&title=&width=315.3333333333333" alt="image.png"><br>再看一个JOSN时间类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(cast(now() as json));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583596058-972bc826-7790-455f-9735-84e8c3ae5aa7.png#averageHue=%231b1b1b&clientId=u79b58c88-76cc-4&from=paste&height=137&id=u3cf30eb9&originHeight=205&originWidth=642&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13849&status=done&style=none&taskId=u779c3404-fb0d-4a31-a878-2e0b7f2c2da&title=&width=428" alt="image.png"><br>再看一个JOSN数组类型的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_type(json_extract(&#x27;&#123;&quot;a&quot;: [1234, false, &quot;1234&quot;]&#125;&#x27;, &#x27;$.a&#x27;));</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583671242-fedddf22-f1ce-4b3d-9839-51562a7071cd.png#averageHue=%231a1a1a&clientId=u79b58c88-76cc-4&from=paste&height=135&id=u3d156918&originHeight=203&originWidth=1082&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=20518&status=done&style=none&taskId=u1f588aac-0fe9-4d6c-8150-53ab496abb9&title=&width=721.3333333333334" alt="image.png"></p><h3 id="JSON-VALID"><a href="#JSON-VALID" class="headerlink" title="JSON_VALID"></a><strong>JSON_VALID</strong></h3><p>JSON_VALID(val)，该方法用于判断给定值是否为有效的 JSON 文档。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select json_valid(&#x27;hello&#x27;), json_valid(&#x27;&quot;hello&quot;&#x27;);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692583793642-42a978b7-6514-4144-bb82-fad5e573ba70.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=140&id=u0353df04&originHeight=210&originWidth=813&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14873&status=done&style=none&taskId=u904b1330-310c-4334-9d45-ea18aeb79fa&title=&width=542" alt="image.png"></p><h3 id="JSON-TABLE"><a href="#JSON-TABLE" class="headerlink" title="JSON_TABLE"></a><strong>JSON_TABLE</strong></h3><p>JSON_TABLE(expr, path COLUMNS (column_list) [AS] alias)，该方法用于从 JSON 文档中提取数据并以表格形式返回。</p><p>该方法的完整语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JSON_TABLE(</span><br><span class="line">    expr,</span><br><span class="line">    path COLUMNS (column_list)</span><br><span class="line">)   [AS] alias</span><br><span class="line"></span><br><span class="line">column_list:</span><br><span class="line">    column[, column][, ...]</span><br><span class="line"></span><br><span class="line">column:</span><br><span class="line">    name FOR ORDINALITY</span><br><span class="line">    |  name type PATH string_path [on_empty] [on_error]</span><br><span class="line">    |  name type EXISTS PATH string_path</span><br><span class="line">    |  NESTED [PATH] path COLUMNS (column_list)</span><br><span class="line"></span><br><span class="line">on_empty:</span><br><span class="line">    &#123;NULL | DEFAULT json_string | ERROR&#125; ON EMPTY</span><br><span class="line"></span><br><span class="line">on_error:</span><br><span class="line">    &#123;NULL | DEFAULT json_string | ERROR&#125; ON ERROR</span><br></pre></td></tr></table></figure><p>解释一下上述各个参数的含义：</p><ul><li>expr：可返回 JSON 文档的表达式。它可以是一个标量（ JSON 文档 ），列名或者一个函数调用（ JSON_EXTRACT(t1.json_data,’$.post.comments’) ）。</li><li>path：JSON 的路径表达式。</li><li>column：列的类型，支持以下四种类型：<ul><li>name FOR ORDINALITY：序号。name 是列名。</li><li>name type PATH string_path [on_empty] [on_error]：提取指定路径（ string_path ）的元素。name 是列名，type 是 MySQL 中的数据类型。</li><li>name type EXISTS PATH string_path：指定路径（ string_path ）的元素是否存在。</li><li>NESTED [PATH] path COLUMNS (column_list)：将嵌套对象或数组与来自父对象或数组的 JSON 值扁平化为一行输出。</li></ul></li></ul><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">* </span><br><span class="line">FROM</span><br><span class="line">json_table (</span><br><span class="line">&#x27;[&#123;&quot;x&quot;:2, &quot;y&quot;:&quot;8&quot;, &quot;z&quot;:9, &quot;b&quot;:[1,2,3]&#125;, &#123;&quot;x&quot;:&quot;3&quot;, &quot;y&quot;:&quot;7&quot;&#125;, &#123;&quot;x&quot;:&quot;4&quot;, &quot;y&quot;:6, &quot;z&quot;:10&#125;]&#x27;,</span><br><span class="line">&quot;$[*]&quot; COLUMNS (</span><br><span class="line">id FOR ordinality,</span><br><span class="line">xval VARCHAR ( 100 ) path &quot;$.x&quot;,</span><br><span class="line">yval VARCHAR ( 100 ) path &quot;$.y&quot;,</span><br><span class="line">z_exist INT EXISTS path &quot;$.z&quot;,</span><br><span class="line">nested path &#x27;$.b[*]&#x27; COLUMNS ( b INT PATH &#x27;$&#x27; ) </span><br><span class="line">) </span><br><span class="line">) AS t;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692584362428-64ceaaaa-d934-4c64-9517-e692107eb301.png#averageHue=%23121212&clientId=u79b58c88-76cc-4&from=paste&height=430&id=u04282bb6&originHeight=645&originWidth=1401&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=63070&status=done&style=none&taskId=u758fe789-a9e1-466e-809e-117c6f21e29&title=&width=934" alt="image.png"></p><h3 id="JSON-SCHEMA-VALID"><a href="#JSON-SCHEMA-VALID" class="headerlink" title="JSON_SCHEMA_VALID"></a><strong>JSON_SCHEMA_VALID</strong></h3><p>JSON_SCHEMA_VALID(schema,document)，该方法用于判断 document （ JSON 文档 ）是否满足 schema （ JSON 对象）定义的规范要求。完整的规范要求可参考 <a href="https://json-schema.org/specification-links.html#draft-4">Draft 4 of the JSON Schema specification</a>。如果不满足，可通过 JSON_SCHEMA_VALIDATION_REPORT() 方法来获取具体的原因。</p><p>举个例子，如下所示的 schema 信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set @schema = &#x27;&#123;</span><br><span class="line">   &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">   &quot;properties&quot;: &#123;</span><br><span class="line">     &quot;latitude&quot;: &#123;</span><br><span class="line">       &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">       &quot;minimum&quot;: -90,</span><br><span class="line">       &quot;maximum&quot;: 90</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;longitude&quot;: &#123;</span><br><span class="line">       &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">       &quot;minimum&quot;: -180,</span><br><span class="line">       &quot;maximum&quot;: 180</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;required&quot;: [&quot;latitude&quot;, &quot;longitude&quot;]</span><br><span class="line">&#125;&#x27;;</span><br></pre></td></tr></table></figure><p>从 schema 中可以看出如下信息：<br>（1）document 必须是 JSON 对象；<br>（2）JSON 对象必须有 latitude 和 longitude 这两个属性；<br>（3）latitude 和 longitude 必须是数值类型，且两者的大小分别在 -90 ～ 90，-180 ～ 180 之间。<br>那么接下来我们就通过定义一个document，并通过 json_schema_valid() 方法来验证document 是否满足 schema 定义的规范要求，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @schema = &#x27;&#123;</span><br><span class="line">    &#x27;&gt;    &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">    &#x27;&gt;    &quot;properties&quot;: &#123;</span><br><span class="line">    &#x27;&gt;      &quot;latitude&quot;: &#123;</span><br><span class="line">    &#x27;&gt;        &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">    &#x27;&gt;        &quot;minimum&quot;: -90,</span><br><span class="line">    &#x27;&gt;        &quot;maximum&quot;: 90</span><br><span class="line">    &#x27;&gt;      &#125;,</span><br><span class="line">    &#x27;&gt;      &quot;longitude&quot;: &#123;</span><br><span class="line">    &#x27;&gt;        &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">    &#x27;&gt;        &quot;minimum&quot;: -180,</span><br><span class="line">    &#x27;&gt;        &quot;maximum&quot;: 180</span><br><span class="line">    &#x27;&gt;      &#125;</span><br><span class="line">    &#x27;&gt;    &#125;,</span><br><span class="line">    &#x27;&gt;    &quot;required&quot;: [&quot;latitude&quot;, &quot;longitude&quot;]</span><br><span class="line">    &#x27;&gt; &#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 63.564456,&quot;longitude&quot;: 10.237812&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     1 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从上面执行结果中可以看出，验证是通过的。接下来我们尝试定义一个 document ，它只传入latitude这一个参数，可以看到验证是不通过的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 63.564456&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     0 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>之后我们尝试输出一下错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select json_pretty(json_schema_validation_report(@schema, @document))\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">json_pretty(json_schema_validation_report(@schema, @document)): &#123;</span><br><span class="line">  &quot;valid&quot;: false,</span><br><span class="line">  &quot;reason&quot;: &quot;The JSON document location &#x27;#&#x27; failed requirement &#x27;required&#x27; at JSON Schema location &#x27;#&#x27;&quot;,</span><br><span class="line">  &quot;schema-location&quot;: &quot;#&quot;,</span><br><span class="line">  &quot;document-location&quot;: &quot;#&quot;,</span><br><span class="line">  &quot;schema-failed-keyword&quot;: &quot;required&quot;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>可以看到这里的原因就是缺少longitude参数，那么接下来我们尝试传入longitude参数，但是取值我们又取错误的值，然后再来测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @document = &#x27;&#123;&quot;latitude&quot;: 96, &quot;longitude&quot;: 0&#125;&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_schema_valid(@schema, @document);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| json_schema_valid(@schema, @document) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                                     0 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select json_pretty(json_schema_validation_report(@schema, @document))\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">json_pretty(json_schema_validation_report(@schema, @document)): &#123;</span><br><span class="line">  &quot;valid&quot;: false,</span><br><span class="line">  &quot;reason&quot;: &quot;The JSON document location &#x27;#/latitude&#x27; failed requirement &#x27;maximum&#x27; at JSON Schema location &#x27;#/properties/latitude&#x27;&quot;,</span><br><span class="line">  &quot;schema-location&quot;: &quot;#/properties/latitude&quot;,</span><br><span class="line">  &quot;document-location&quot;: &quot;#/latitude&quot;,</span><br><span class="line">  &quot;schema-failed-keyword&quot;: &quot;maximum&quot;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure><p>从执行结果中也可以看到，验证不通过的原因就是取值超出了属性的可允许取值范围。</p><h1 id="对JSON字段创建索引"><a href="#对JSON字段创建索引" class="headerlink" title="对JSON字段创建索引"></a>对JSON字段创建索引</h1><p>实际上，和 TEXT，BLOB 字段一样，JSON 字段是不允许直接创建索引的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table tb_json3(t1 json, index(t1));</span><br><span class="line">ERROR 3152 (42000): JSON column &#x27;t1&#x27; supports indexing only via generated columns on a specified JSON path.</span><br></pre></td></tr></table></figure><p>实际上即使支持直接创建索引，其意义也不大，一般来说我们都是基于文档中的元素进行查询，很少会基于整个  JSON 文档。如果需要对文档中的元素进行查询，那么就需要使用到 MySQL 5.7 引入的虚拟列及函数索引。</p><p>如下所示，我们新建一个数据表tb_json3，其中t1类型为JOSN，然后t2是虚拟列，之后使用 index (t2) 来对虚拟列t2添加索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json3(t1 json, t2 varchar(100) as (JSON_UNQUOTE(t1 -&gt; &#x27;$.name&#x27;)), index (t2));</span><br></pre></td></tr></table></figure><p>之后我们往该数据表中插入5条测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_json3 ( t1 )</span><br><span class="line">VALUES</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;lisi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;wanger&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;mazi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 5, &quot;name&quot;: &quot;zhangsanfeng&quot;&#125;&#x27; )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>可以看到此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586568144-6ceee757-ef57-4520-923a-b774bdf73ca7.png#averageHue=%23daad66&clientId=u79b58c88-76cc-4&from=paste&height=115&id=u196a299b&originHeight=173&originWidth=1084&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14014&status=done&style=none&taskId=u9a802a78-9b6b-4522-a919-61d52151d63&title=&width=722.6666666666666" alt="image.png"><br>接下来我们尝试查询姓名为lisi的用户，首先使用虚拟列来进行查询，查看一下执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_json3 where t2 = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure><p>执行一下该执行计划，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586726584-a95d611a-543d-4dfc-8863-c36f0f992862.png#averageHue=%23e7e5e4&clientId=u79b58c88-76cc-4&from=paste&height=43&id=u11f04775&originHeight=65&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=11212&status=done&style=none&taskId=u78c47c55-e77d-4210-ab41-3294ed8cc5a&title=&width=948.6666666666666" alt="image.png"><br>接着我们尝试使用文档中的元素来查询，同样也是先看一下执行计划：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_json3 where t1 -&gt; &#x27;$.name&#x27; = &#x27;lisi&#x27;;</span><br></pre></td></tr></table></figure><p>执行一下该执行计划，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692586726584-a95d611a-543d-4dfc-8863-c36f0f992862.png#averageHue=%23e7e5e4&from=url&id=I8nlI&originHeight=65&originWidth=1423&originalType=binary&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&title="><br>从上述输出结果中可以看到，无论是使用虚拟列，还是文档中的元素来进行查询，它们都会用到索引。<strong>请注意，在创建虚拟列时，需要使用 JSON_UNQUOTE方法，来将 t1 -&gt; “$.name” 的返回值转换为字符串。</strong></p><h1 id="将存储-JSON-字符串的字符字段升级为-JSON-字段"><a href="#将存储-JSON-字符串的字符字段升级为-JSON-字段" class="headerlink" title="将存储 JSON 字符串的字符字段升级为 JSON 字段"></a>将存储 JSON 字符串的字符字段升级为 JSON 字段</h1><p>在 MySQL 支持 JSON 类型之前，对于 JSON 文档，一般是以字符串的形式存储在字符类型中（VARCHAR 或 TEXT）。</p><p>现在问题来了，在 JSON 类型出来后，如何将这些字符字段升级为 JSON 字段呢？为了学习的需要，这里先构建测试表和数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table tb_json4 (id int auto_increment primary key, t1 text);</span><br><span class="line"></span><br><span class="line">insert into tb_json4 (t1) values (&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;a&quot;&#125;&#x27;),</span><br><span class="line">(&#x27;&#123;&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;b&quot;&#125;&#x27;), </span><br><span class="line">(&#x27;&#123;&quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;c&quot;&#125;&#x27;), </span><br><span class="line">(&#x27;&#123;&quot;id&quot;, &quot;name&quot;: &quot;d&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>注意，第4条记录的json数据是有问题的，不符合JSON格式的要求，这里先不管，后面会进行修改，此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587376783-6e20adef-3bb1-4d15-b01a-e02d22ca5a9a.png#averageHue=%23d7aa63&clientId=u79b58c88-76cc-4&from=paste&height=97&id=uf90650c6&originHeight=146&originWidth=326&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=6336&status=done&style=none&taskId=udba0c808-d0fa-433b-adf7-387d82d0bdb&title=&width=217.33333333333334" alt="image.png"><br>接着，修改t1字段的类型。如果我们直接使用 DDL语句来修改字段的数据类型，那么它会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb_json4 modify t1 json;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587501344-bcad7f89-50b3-4131-9929-3e0700dab460.png#averageHue=%231e1e1e&clientId=u79b58c88-76cc-4&from=paste&height=42&id=u64da4e51&originHeight=63&originWidth=1967&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=17188&status=done&style=none&taskId=u4ed803c8-7e60-4186-b984-e193fa36e23&title=&width=1311.3333333333333" alt="image.png"><br>所以我们需要另一种方式来修改t1字段的类型，对应的修改步骤如下所示：<br>第一步，使用 json_valid 方法找出不满足 JSON 格式要求的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_json4 where json_valid(t1) = 0;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587645354-6af19a3f-6c69-4a18-ac1a-c827fbd33aa8.png#averageHue=%23171717&clientId=u79b58c88-76cc-4&from=paste&height=137&id=ubf6140ce&originHeight=206&originWidth=777&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=14531&status=done&style=none&taskId=ud2e56a09-ca4d-478e-99e9-f4a593191be&title=&width=518" alt="image.png"><br>第二步，处理不满足 JSON 格式要求的文档。接着我们就需要使用DDL语句来修改不满足JSON格式要求的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json4 set t1 = &#x27;&#123;&quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;d&quot;&#125;&#x27; where id = 4;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587815313-7c36a49c-e1a8-4a53-b08d-130c0c96a059.png#averageHue=%231e1e1e&clientId=u79b58c88-76cc-4&from=paste&height=82&id=u261c52d8&originHeight=123&originWidth=1017&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=19320&status=done&style=none&taskId=u56267011-364f-4215-af6b-e16644b4c03&title=&width=678" alt="image.png"><br>第三步，将 TEXT 字段修改为 JSON 字段。现在我们再次检查是否存在不符合JSON格式要求的文档，执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587923081-d20ed51b-2aee-459c-b1a3-4a2d49658bed.png#averageHue=%231f1f1f&clientId=u79b58c88-76cc-4&from=paste&height=40&id=uc5c9ea84&originHeight=60&originWidth=777&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7690&status=done&style=none&taskId=u783248f9-4b9c-40b9-9df3-986aee622db&title=&width=518" alt="image.png"><br>之后我们就可以修改t1字段的类型了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tb_json4 modify t1 json;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692587999908-c26ec33d-e133-4f1f-98f0-876163a4fea0.png#averageHue=%23191919&clientId=u79b58c88-76cc-4&from=paste&height=339&id=u4df7d335&originHeight=509&originWidth=609&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=36418&status=done&style=none&taskId=u6db2b8fe-bc98-4a7b-bcfd-1e46fe377c9&title=&width=406" alt="image.png"></p><h1 id="使用JSON时的注意事项"><a href="#使用JSON时的注意事项" class="headerlink" title="使用JSON时的注意事项"></a>使用JSON时的注意事项</h1><p>在使用JSON类型时，有如下四个注意事项：<br>（1）在 MySQL 8.0.13 之前，不允许对 BLOB，TEXT，GEOMETRY，JSON 字段设置默认值。而从 MySQL 8.0.13 开始，取则消了这个限制。</p><p>请注意，在设置默认值时，默认值需要由小括号 () 括起来，否则会抛出 JSON 字段不允许设置默认值的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table tb_json5(t1 json not null default &#x27;&#x27;);</span><br><span class="line">ERROR 1101 (42000): BLOB, TEXT, GEOMETRY or JSON column &#x27;t1&#x27; can&#x27;t have a default value</span><br><span class="line"></span><br><span class="line">mysql&gt; create table tb_json5(t1 json not null default (&#x27;&#x27;));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>（2）不允许直接给JSON类型字段创建索引，但可创建函数索引；<br>（3）JSON 列的最大大小和 LONGBLOB（LONGTEXT）一样，都是 4G；<br>（4）插入时，单个文档的大小受到 max_allowed_packet 的限制，该参数最大是 1G。</p><h1 id="Partial-Updates"><a href="#Partial-Updates" class="headerlink" title="Partial Updates"></a>Partial Updates</h1><p>在 MySQL 5.7 中，对于JSON 文档进行更新的策略：先删除旧的文档，再插入新的文档。这种方式效率非常低下，即使这个修改很微小，只涉及几个字节，也会替换掉整个文档。<br>在<br>而在 MySQL 8.0 中，针对 JSON 文档，引入了一项新的特性—Partial Updates（部分更新），它支持 JSON 文档的原地更新。得益于这个特性，JSON 文档的处理性能得到了极大提升。</p><p>如下所示，我们新建一个数据表tb_json6，其中id类型为int，而t1为JSON类型，对应的建表语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json6(id int auto_increment primary key, t1 json);</span><br></pre></td></tr></table></figure><p>之后我们往该数据表中插入5条测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_json6 ( t1 )</span><br><span class="line">VALUES</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;lisi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;wanger&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;mazi&quot;&#125;&#x27; ),</span><br><span class="line">( &#x27;&#123;&quot;id&quot;: 5, &quot;name&quot;: &quot;zhangsanfeng&quot;&#125;&#x27; )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>可以看到此时数据库中的数据如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692595548155-e6c04598-f311-499a-8073-4a05ca661ec2.png#averageHue=%23f6f4f2&clientId=u79b58c88-76cc-4&from=paste&height=118&id=ua6bae6d6&originHeight=177&originWidth=514&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=10416&status=done&style=none&taskId=u0f4fbdf9-5944-433a-8658-64ecd90c435&title=&width=342.6666666666667" alt="image.png"></p><h3 id="使用-Partial-Updates-的条件"><a href="#使用-Partial-Updates-的条件" class="headerlink" title="使用 Partial Updates 的条件"></a>使用 Partial Updates 的条件</h3><p>（1）被更新的列是 JSON 类型。<br>（2）使用 JSON_SET，JSON_REPLACE，JSON_REMOVE 这三个函数进行 UPDATE 操作。举个例子，如下所示更新语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_remove(t1,&#x27;$.id&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1692595783650-78015db6-687d-493f-a857-7ac5ee0182b8.png#averageHue=%231c1c1c&clientId=u79b58c88-76cc-4&from=paste&height=221&id=u50e44b81&originHeight=331&originWidth=603&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24384&status=done&style=none&taskId=uced3a7b2-50e6-496e-832e-9c09a060b8e&title=&width=402" alt="image.png"><br>请注意，如果开发者不使用上述三个函数赋值，而采用手动显式赋值，那么就不会进行部分更新。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;a&quot;&#125;&#x27; where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693187345536-3898cb52-bcd3-46e7-b015-3475f744fcf8.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=220&id=ub19d4dd9&originHeight=330&originWidth=613&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24316&status=done&style=none&taskId=u13a560a3-1218-4ef4-9d54-9671b05989e&title=&width=408.6666666666667" alt="image.png"><br>实际上此时它并不是进行部分更新，而是先删除旧的记录，然后再插入了新的记录，这个操作在数据量大的情况下会影响系统性能。<br>（3）输入列和目标列必须是同一列，否则也不会进行部分更新。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t1,&#x27;$.id&#x27;,10) where id=1;</span><br></pre></td></tr></table></figure><p>执行该语句后，我们查询一下数据表，结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693187681967-fbcbc51c-0afc-499d-b53c-7ed1e836e29e.png#averageHue=%231c1c1c&clientId=u6cd2691a-9d9f-4&from=paste&height=218&id=u97dbb472&originHeight=327&originWidth=604&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=24488&status=done&style=none&taskId=udd608f00-5d62-4dd6-8eb0-0405b331a41&title=&width=402.6666666666667" alt="image.png"><br>如果我们使用的是下面的语句，那么就不是部分更新了，这里的t2列实际上是不存在的，这里只是为了演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t2,&#x27;$.id&#x27;,10) where id=1;</span><br></pre></td></tr></table></figure><p>（4）变更前后，JSON 文档的空间使用不会增加。举个例子，首先我们查看一下id为1的记录所占用的空间大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188017872-df1d0bdf-471c-4706-8932-87dfb3aaf074.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=135&id=u778fcb6c&originHeight=203&originWidth=1193&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22083&status=done&style=none&taskId=u1ac1389d-05aa-4d6e-838f-c9881e988e0&title=&width=795.3333333333334" alt="image.png"><br>接着我们尝试修改id为1的记录，将id为1的记录中的id属性给去除，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_remove(t1,&#x27;$.id&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>之后我们再次执行查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188165598-36f8a9f0-a672-48b1-a46b-6afb491345f0.png#averageHue=%231a1a1a&clientId=u6cd2691a-9d9f-4&from=paste&height=139&id=u9a538d41&originHeight=208&originWidth=1200&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=21752&status=done&style=none&taskId=ube40082d-fce0-4b08-bc39-c8c37d8667f&title=&width=800" alt="image.png"><br>接下来我们使用json_set函数来更新JSON文档，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_set(t1,&#x27;$.id&#x27;,10086) where id=1;</span><br></pre></td></tr></table></figure><p>之后我们再次执行查询语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *,json_storage_size(t1),json_storage_free(t1) from tb_json6 where id=1;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188346984-51df017f-f4a6-4d74-97b1-ff04666a3c72.png#averageHue=%231b1b1b&clientId=u6cd2691a-9d9f-4&from=paste&height=135&id=u7e7dbc3f&originHeight=203&originWidth=1206&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=22636&status=done&style=none&taskId=u752486d4-3892-4759-a7f6-97c54a71714&title=&width=804" alt="image.png"><br>接这我们再次使用json_set函数来更新JSON文档，对应的SQL如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1=json_set(t1,&#x27;$.id&#x27;,&#x27;helloworld&#x27;) where id=1;</span><br></pre></td></tr></table></figure><p>之后再次执行查询语句，可以看到执行结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693188486922-90c1348c-8928-4b2d-939a-cfd8cf0edbc2.png#averageHue=%231a1a1a&clientId=u6cd2691a-9d9f-4&from=paste&height=143&id=u216f73ba&originHeight=215&originWidth=1281&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=23839&status=done&style=none&taskId=u760d749e-fcf3-4b22-9f09-462c7bbcf70&title=&width=854" alt="image.png"><br>怎么两次使用json_set函数查询出来的数据有些不一样呢？下面我们将对这些现象进行详细学习。</p><p>在上面的例子中，我们使用了json_storage_size和json_storage_free这两个函数，其中json_storage_size用于获取JSON文档的空间使用情况，而json_storage_free则是用于获取JSON文档在执行原地更新后的空间释放情况。</p><p>从例子中可以看出，我们一共执行了三次更新操作（两次json_set，一次json_remove），其中前两次是原地更新，而第三次不是。那么问题来了，同样使用了json_set方法，为什么第一次是原地更新，而第二次却不是呢？那是因为第一次的json_set复用了json_remove释放的空间，而第二次的json_set执行的是更新操作，且 ‘helloworld’ 比 10086 需要更多的存储空间，因此两次查询获取到的空间使用情况就不一样了。</p><h3 id="如何在-binlog-中开启-Partial-Updates"><a href="#如何在-binlog-中开启-Partial-Updates" class="headerlink" title="如何在 binlog 中开启 Partial Updates"></a>如何在 binlog 中开启 Partial Updates</h3><p>Partial Updates 不仅适用于存储引擎层，还可用于主从复制。主从复制场景下，开启 Partial Updates，只需将binlog_row_value_options参数设置为 PARTIAL_JSON，注意这个参数默认为空。</p><p>下面我们将通过一个案例来学习，同一个 UPDATE 操作，在开启和不开启 Partial Updates情况下，在 binlog 中的记录有什么区别。</p><p>这是UPDATE操作所使用的语句，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json6 set t1 = json_replace(t1,&#x27;$.id&#x27;,10) where id = 1;</span><br></pre></td></tr></table></figure><p>以下是未开启Partial Updates时的binlog记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### UPDATE `slowtech`.`tb_json6`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br><span class="line">### SET</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: 10, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>下面是开启了Partial Updates时的binlog记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### UPDATE `slowtech`.`tb_json6`</span><br><span class="line">### WHERE</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=&#x27;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;a&quot;&#125;&#x27;</span><br><span class="line">### SET</span><br><span class="line">###   @1=1</span><br><span class="line">###   @2=JSON_REPLACE(@2, &#x27;$.id&#x27;, 10)</span><br></pre></td></tr></table></figure><p>通过对上述两条binlog记录的对比，可以看出在不开启Partial Updates时，无论是修改前的镜像（before_image）还是修改后的镜像（after_image），记录的都是完整文档。而开启Partial Updates后，对于修改后的镜像，记录的是命令，而不是完整文档，这样可节省近一半的空间。</p><p>开发者在将 binlog_row_value_options 参数设置为 PARTIAL_JSON 后，对于可使用 Partial Updates 的操作，在 binlog 中，不再通过 ROWS_EVENT 来记录，而是新增了一个 PARTIAL_UPDATE_ROWS_EVENT 的事件类型。</p><p><strong>请注意，binlog 中使用 Partial Updates，只需满足存储引擎层使用 Partial Updates 的前三个条件，无需考虑变更前后，JSON 文档的空间使用是否会增加。</strong></p><h3 id="关于-Partial-Updates-的性能测试"><a href="#关于-Partial-Updates-的性能测试" class="headerlink" title="关于 Partial Updates 的性能测试"></a>关于 Partial Updates 的性能测试</h3><p>首先我们构造数据表和数据，假设tb_json7表一共有 16 个文档，每个文档近 10 MB，对应SQL语句如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table tb_json7(id int auto_increment primary key,</span><br><span class="line">               t1 json,</span><br><span class="line">               name varchar(100) as (t1-&gt;&gt;&#x27;$.name&#x27;),</span><br><span class="line">               age int as (t1-&gt;&#x27;$.age&#x27;));</span><br><span class="line"></span><br><span class="line">insert into tb_json7(t1) values</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Joe&#x27;, &#x27;age&#x27;, 24,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;x&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Sue&#x27;, &#x27;age&#x27;, 32,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;y&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Pete&#x27;, &#x27;age&#x27;, 40,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;z&#x27;, 10 * 1000 * 1000))),</span><br><span class="line">(json_object(&#x27;name&#x27;, &#x27;Jenny&#x27;, &#x27;age&#x27;, 27,</span><br><span class="line">             &#x27;data&#x27;, repeat(&#x27;w&#x27;, 10 * 1000 * 1000)));</span><br><span class="line"></span><br><span class="line">insert into tb_json7(t1) select t1 from tb_json7;</span><br><span class="line">insert into tb_json7(t1) select t1 from tb_json7;</span><br></pre></td></tr></table></figure><p>接着我们尝试测试如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_json7 set t1 = json_set(t1, &#x27;$.age&#x27;, age + 1);</span><br></pre></td></tr></table></figure><p>然后在如下四种场景进行执行，并统计对应的执行时间：<br>（1）MySQL 5.7.36；<br>（2）MySQL 8.0.27<br>（3）MySQL 8.0.27，binlog_row_value_options=PARTIAL_JSON<br>（4）MySQL 8.0.27，binlog_row_value_options=PARTIAL_JSON + binlog_row_image=MINIMAL<br>这里我们选择分别执行 10 次，然后去掉最大值和最小值，最后求平均值，得到的结果如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1693190440934-bb38d69a-8d19-4405-b483-7942d9cc96c3.png#averageHue=%2312133a&clientId=u6cd2691a-9d9f-4&from=paste&height=499&id=u2f8c004e&originHeight=749&originWidth=965&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=54229&status=done&style=none&taskId=u98fb6391-a999-4738-b96c-69cb585187a&title=&width=643.3333333333334" alt="image.png"><br>请注意，这里我们以 MySQL 5.7.36 的查询时间作为基准：<br>（1）MySQL 8.0 只开启存储引擎层的 Partial Updates，查询时间比 MySQL 5.7 快 1.94 倍。<br>（2）MySQL 8.0 同时开启存储引擎层和 binlog 中的 Partial Updates，查询时间比 MySQL 5.7 快 4.87 倍。<br>（3）如果在 （2）的基础上，同时将 binlog_row_image 设置为 MINIMAL，查询时间更是比 MySQL 5.7 快 102.22 倍。<br>当然，在生产环境，我们一般很少将 binlog_row_image 设置为 MINIMAL。但即便如此，<strong>只开启存储引擎层和 binlog 中的 Partial Updates，查询时间也比 MySQL 5.7 快 4.87 倍，这样看性能提升还是比较明显</strong>。</p><p>参考文章：</p><ol><li><a href="https://zh.wikipedia.org/wiki/JSON">JSON官网</a>；</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/json.html">The JSON Data Type</a>；</li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/json-functions.html">JSON Functions</a>；</li><li><a href="https://dev.mysql.com/blog-archive/upgrading-json-data-stored-in-text-columns/">Upgrading JSON data stored in TEXT columns</a>；</li><li><a href="https://dev.mysql.com/blog-archive/indexing-json-documents-via-virtual-columns/">Indexing JSON documents via Virtual Columns</a>；</li><li><a href="https://dev.mysql.com/blog-archive/partial-update-of-json-values/">Partial update of JSON values</a>；</li><li><a href="https://dev.mysql.com/blog-archive/mysql-8-0-innodb-introduces-lob-index-for-faster-updates/">MySQL 8.0: InnoDB Introduces LOB Index For Faster Updates</a>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习MySQL中的JSON数据类型，这在某些场景下比text类型好用很多。&lt;/p&gt;
&lt;h1 id=&quot;JSON&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="mysql" scheme="http://envyzhan.asia/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://envyzhan.asia/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊六种常用的属性配置读取方式</title>
    <link href="http://envyzhan.asia/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/"/>
    <id>http://envyzhan.asia/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/</id>
    <published>2024-03-02T02:55:30.000Z</published>
    <updated>2024-05-22T14:01:34.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力有极大帮助。使用的SpringBoot版本为 2.7.11 。</p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><h3 id="Environment简介"><a href="#Environment简介" class="headerlink" title="Environment简介"></a>Environment简介</h3><p>Environment 是 SpringBoot 的核心环境配置接口，它提供了很多方法用于访问应用程序属性，包括系统属性、操作系统环境变量、命令行参数和应用程序配置文件中定义的属性等。源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Environment extends PropertyResolver &#123;</span><br><span class="line">    String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line">    String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean acceptsProfiles(String... profiles);</span><br><span class="line"></span><br><span class="line">    boolean acceptsProfiles(Profiles profiles);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface PropertyResolver &#123;</span><br><span class="line">    boolean containsProperty(String key);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getProperty(String key);</span><br><span class="line"></span><br><span class="line">    String getProperty(String key, String defaultValue);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);</span><br><span class="line"></span><br><span class="line">    String getRequiredProperty(String key) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    String resolvePlaceholders(String text);</span><br><span class="line"></span><br><span class="line">    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个接口继承自 PropertyResolver 接口，PropertyResolver接口中定义了很多获取属性的方法，因此Environment这个接口才具备上述能力。</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>接下来我们通过分析SpringBoot项目在启动时，对配置进行初始化这一过程来深度了解Environment接口的作用。</p><p>我们知道SpringBoot项目在启动时会调用 SpringApplication.run() 方法，而这个方法内部会调用prepareEnvironment()方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690263104622-84102549-40ba-4876-920a-7b58a03d6e1c.png#averageHue=%232d2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=431&id=u75ec017d&originHeight=646&originWidth=1656&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=143909&status=done&style=none&taskId=u7a493edc-491f-4fda-a61b-147fec114a9&title=&width=1104" alt="image.png"><br>查看一下这个prepareEnvironment()方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123;</span><br><span class="line">    /** </span><br><span class="line">    * 1、创建ConfigurableEnvironment对象：调用getOrCreateEnvironment()方法获取或创建ConfigurableEnvironment对象，</span><br><span class="line">    * 该对象用于存储环境参数。如果已经存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的。</span><br><span class="line">    */</span><br><span class="line">    ConfigurableEnvironment environment = this.getOrCreateEnvironment();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 2、解析并加载用户指定的配置文件，将其作为 PropertySource 添加到环境对象中。该方法默认会解析application.properties和application.yml文件，并将其添加到ConfigurableEnvironment对象中。</span><br><span class="line">    * PropertySource或PropertySourcesPlaceholderConfigurer加载应用程序的定制化配置。</span><br><span class="line">    */</span><br><span class="line">    this.configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"></span><br><span class="line">    // 3、加载所有的系统属性，并将它们添加到ConfigurableEnvironment对象中</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">    // 4、通知监听器环境参数已经准备就绪</span><br><span class="line">    listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    *  5、将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值。</span><br><span class="line">    *  还可以避免用户无意中覆盖了SpringBoot提供的默认属性</span><br><span class="line">    */</span><br><span class="line">    DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">    Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;);</span><br><span class="line">    </span><br><span class="line">    // 6、将SpringBoot应用程序的属性绑定到环境对象上，以便能正确地读取和使用这些配置属性</span><br><span class="line">    this.bindToSpringApplication(environment);</span><br><span class="line"></span><br><span class="line">    // 7、如果没有自定义的环境类型，则使用EnvironmentConverter类型将环境对象转换为标准的环境类型，并添加到ConfigurableEnvironment对象中</span><br><span class="line">    if (!this.isCustomEnvironment) &#123;</span><br><span class="line">        EnvironmentConverter environmentConverter = new EnvironmentConverter(this.getClassLoader());</span><br><span class="line">        environment = environmentConverter.convertEnvironmentIfNecessary(environment, this.deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 8、再次加载系统配置，以防止被其他配置覆盖</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的流程：</p><ul><li>创建 ConfigurableEnvironment 环境对象 ，用于存储环境参数；</li><li>调用 configureEnvironment 方法加载默认的 application.properties 和 application.yml 配置文件，以及用户指定的配置文件，并将其封装为 PropertySource 对象添加到环境对象中；</li><li>ConfigurationPropertySources.attach 方法，用于加载所有的系统属性，并将它们添加到环境对象中；</li><li>listeners.environmentPrepared 方法，用于发送环境参数配置已经准备就绪的监听通知；</li><li>DefaultPropertiesPropertySource.moveToEnd 方法，用于将系统默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就能覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性；</li><li>bindToSpringApplication方法，用于将应用程序的属性绑定到Bean对象上；</li><li>ConfigurationPropertySources.attach方法，用于再次加载系统配置，防止被其他配置覆盖。</li></ul><p>下面是对于上述几个比较重要的方法进行详细介绍，如下所示：<br>（1）getOrCreateEnvironment方法的源码如下所示，可以看到该方法会返回一个ConfigurableEnvironment对象，该对象用于存储环境参数。如果已存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的ConfigurableEnvironment对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">    if (this.environment != null) &#123;</span><br><span class="line">        return this.environment;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ConfigurableEnvironment environment = this.applicationContextFactory.createEnvironment(this.webApplicationType);</span><br><span class="line">        if (environment == null &amp;&amp; this.applicationContextFactory != ApplicationContextFactory.DEFAULT) &#123;</span><br><span class="line">            environment = ApplicationContextFactory.DEFAULT.createEnvironment(this.webApplicationType);</span><br><span class="line">        &#125;</span><br><span class="line">        return (ConfigurableEnvironment)(environment != null ? environment : new ApplicationEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）configureEnvironment方法的源码如下所示，可以看到该方法会解析并加载用户指定的配置文件，并将其作为 PropertySource对象添加到环境对象中。configureEnvironment方法默认会解析<code>application.properties</code>和 <code>application.yml</code>文件，并将其添加到ConfigurableEnvironment对象中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    if (this.addConversionService) &#123;</span><br><span class="line">        environment.setConversionService(new ApplicationConversionService());</span><br><span class="line">    &#125;</span><br><span class="line">    this.configurePropertySources(environment, args);</span><br><span class="line">    this.configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">    if (!CollectionUtils.isEmpty(this.defaultProperties)) &#123;</span><br><span class="line">        DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">        String name = &quot;commandLineArgs&quot;;</span><br><span class="line">        if (sources.contains(name)) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">            CompositePropertySource composite = new CompositePropertySource(name);</span><br><span class="line">            composite.addPropertySource(new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));</span><br><span class="line">            composite.addPropertySource(source);</span><br><span class="line">            sources.replace(name, composite);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sources.addFirst(new SimpleCommandLinePropertySource(args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）DefaultPropertiesPropertySource.moveToEnd方法的源码如下所示，该方法会将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void moveToEnd(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    moveToEnd(environment.getPropertySources());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void moveToEnd(MutablePropertySources propertySources) &#123;</span><br><span class="line">    PropertySource&lt;?&gt; propertySource = propertySources.remove(&quot;defaultProperties&quot;);</span><br><span class="line">    if (propertySource != null) &#123;</span><br><span class="line">        propertySources.addLast(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析，我们知道各种配置属性最终都会被封装为一个个PropertySource对象，查看一下该对象的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class PropertySource&lt;T&gt; &#123;</span><br><span class="line">    protected final String name; // 属性名称</span><br><span class="line">    protected final T source; // 属性值（一个泛型，比如Map，Property）</span><br><span class="line">    public String getName();  // 获取属性的名字  </span><br><span class="line">    public T getSource(); // 获取属性值  </span><br><span class="line">    public boolean containsProperty(String name);  //是否包含某个属性  </span><br><span class="line">    public abstract Object getProperty(String name);   //根据属性名获取到对应属性  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>PropertySource这个抽象类有很多实现类，分别用于管理应用程序的配置属性。不同的PropertySource实现类，可从不同的来源来获取配置属性，如文件、环境变量、命令行参数等。下面是涉及到的一些常用实现类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690266427489-901c66fd-ae05-4be0-8446-4b82669ac20e.png#averageHue=%233c4145&clientId=uc1ab0a73-0559-4&from=paste&id=u8f832076&originHeight=379&originWidth=832&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ueb409361-f04f-483d-835d-b678c9df9e8&title="><br>简单解释一下上述涉及到的实现类的作用：</p><ul><li>MapPropertySource，用于将Map键值对转换为PropertySource对象；</li><li>PropertiesPropertySource，用于将Properties对象中的配置属性转换为PropertySource对象；</li><li>ResourcePropertySource，用于从文件系统或classpath中加载配置属性，并封装为PropertySource对象；</li><li>ServletConfigPropertySource，用于从Servlet配置中读取配置属性，并封装为PropertySource对象；</li><li>ServletContextPropertySource，用于从Servlet上下文中读取配置属性，并封装为PropertySource对象；</li><li>StubPropertySource，这是一个空的实现类，它的作用仅仅是给CompositePropertySource类作为默认的父级属性源，以避免空指针异常；</li><li>CompositePropertySource:，这是一个复合型的实现类，内部维护了PropertySource集合队列，可以将多个PropertySource对象进行合并；</li><li>SystemEnvironmentPropertySource，用于从操作系统环境变量中读取配置属性，并将其封装为PropertySource对象。</li></ul><p>上面各类配置初始化生成的PropertySource对象都会被维护到集合队列中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;PropertySource&lt;?&gt;&gt;()</span><br></pre></td></tr></table></figure><p>配置初始化完成后，应用程序上下文 AbstractApplicationContext 会加载配置，这样程序在运行时就可以随时获取到配置信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267487883-5dff1184-08f9-4a80-9b3f-d28624f7e167.png#averageHue=%232e2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=215&id=ua6decfd6&originHeight=323&originWidth=1499&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=74002&status=done&style=none&taskId=uc533859b-abb4-4348-835a-14896e389f8&title=&width=999.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267606290-b594f371-57d1-4970-945e-7127f376aa94.png#averageHue=%232d2d2c&clientId=uc1ab0a73-0559-4&from=paste&height=275&id=u6860fe12&originHeight=412&originWidth=1493&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79537&status=done&style=none&taskId=u15367136-7c78-4064-9a23-0b41a49b8be&title=&width=995.3333333333334" alt="image.png"></p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>前面我们已经学习了加载配置的整个流程，那么读取配置就是从维护的 PropertySource 队列中根据name获取对应的source对象了。</p><p>一般而言，我们会使用Environment接口对象提供的方法来获取配置信息，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = environment.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在前面阅读源码的时候，我们知道这个Environment接口继承PropertyResolver接口，PropertyResolver是获取配置的关键接口，其内部提供了操作PropertySource 队列的方法，查看一下这个接口的继承依赖关系：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690268378231-d67e5d69-866c-4f3f-9483-b43466a7574a.png#averageHue=%233b4043&clientId=uc1ab0a73-0559-4&from=paste&id=ud889ead3&originHeight=499&originWidth=481&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u149749e3-d686-4d31-bb47-aa567992a31&title="><br>因此，我们也可以直接使用PropertyResolver接口中的方法来获取对应的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PropertyResolver propertyResolver;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = propertyResolver.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Value注解"><a href="#Value注解" class="headerlink" title="Value注解"></a>Value注解</h1><p>@Value注解，是 Spring 框架提供的用于获取注入配置属性值的注解，可用在类的成员变量、方法参数和构造函数参数上。</p><p>我们知道，在应用程序启动时，使用@Value注解修饰的Bean会被实例化并加入到 PropertySourcesPlaceholderConfigurer 的后置处理器集合中。当后置处理器开始执行时，它会读取Bean中所有被 @Value 注解所修饰的值，并通过反射将解析后的属性值，赋值给被@Value 注解修饰成员变量、方法参数和构造函数参数。<br><strong>请注意，在使用 @Value 注解时，需要确保注入的属性值已被加载到 Spring 容器中，否则会导致注入失败。</strong></p><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在项目的 src/main/resources 目录下新建 application.yml 配置文件，并往其中添加如下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quick:</span><br><span class="line">  use: true</span><br></pre></td></tr></table></figure><p>对应的测试代码如下，只需变量上加 @Value(“${quick.use}”)注解，那么@Value 注解便会自动将配置文件中的quick.use 属性值注入到 isQuickUsed 字段中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管@Value注解使用起来很方便，但是也存在一些需要注意的地方，下面介绍几个比较容易出错的地方。</p><h3 id="缺失配置"><a href="#缺失配置" class="headerlink" title="缺失配置"></a>缺失配置</h3><p>如果开发者在代码中引用变量，但是在配置文件中为进行配置，此时就会出现如下的错误信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690332916832-6ed72f81-8422-46b6-9bba-465e81400431.png#averageHue=%23353332&clientId=uf1677bb8-9339-4&from=paste&height=115&id=u94f4bf5a&originHeight=172&originWidth=1508&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50792&status=done&style=none&taskId=u9a1f075f-d556-42e9-b1e5-73bceb87bef&title=&width=1005.3333333333334" alt="image.png"><br>为了避免此类错误导致服务无法正常启动，我们可以在引用变量的同时，给它赋一个默认值，这样即使未在配置文件中赋值，程序也是可以正常启动的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use:true&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量赋值"><a href="#静态变量赋值" class="headerlink" title="静态变量赋值"></a>静态变量赋值</h3><p><strong>请注意，将 @Value 注解添加到静态变量上，这样是无法获取静态变量的属性值。</strong>我们知道，静态变量属于类，不属于某个对象，而 Spring是基于对象的属性进行依赖注入，且类在应用启动时，静态变量就被初始化，此时 Bean还未被实例化，因此无法通过 @Value 注解来注入属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private static String isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：null</span><br></pre></td></tr></table></figure><p>尽管 @Value 注解无法直接作用在静态变量上，但是开发者可通过获取已有 Bean实例化后的属性值，并将其赋值给静态变量进而实现给静态变量赋值这一目的。</p><p>上述过程对应的具体操作如下：<br>（1）通过 @Value 注解将属性值注入到普通 Bean中；<br>（2）获取该 Bean对应的属性值；<br>（3）将其赋值给静态变量；<br>（4）在静态变量中使用该属性值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private void setIsQuickUsed(String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><p>当然了也可以在构造方法中设置isUsed变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    StaticVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量赋值"><a href="#常量赋值" class="headerlink" title="常量赋值"></a>常量赋值</h3><p>**请注意，将 @Value 注解添加到常量上，这样是无法获取常量的属性值。 **我们知道，被final修饰的变量在使用前必须赋值，且一旦赋值便不能修改。final修饰的变量可以在定义时、构造方法中或者静态代码中进行赋值，这里只讨论final变量在静态代码块中赋值的情况。前面说过， @Value 注解是在 Bean 实例化后才进行属性注入，因此无法在构造方法中初始化 final 变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class FinalVarTest &#123;</span><br><span class="line">    private final String isUsed;</span><br><span class="line">    </span><br><span class="line">    FinalVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isUsed的值为：&#123;&#125;&quot;, isUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><h3 id="非Spring容器管理的Bean中使用"><a href="#非Spring容器管理的Bean中使用" class="headerlink" title="非Spring容器管理的Bean中使用"></a>非Spring容器管理的Bean中使用</h3><p>在Spring中，只有被 @Component、@Service、@Controller、@Repository 或 @Configuration 等注解标识的类，才会被Spring容器所管理，在这些类中使用 @Value注解才会生效。而对于普通的POJO类，无法使用 @Value注解进行属性注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class NoBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就无法获取配置文件中 quick.use 配置项的值。</p><h3 id="引入方式不对"><a href="#引入方式不对" class="headerlink" title="引入方式不对"></a>引入方式不对</h3><p>当我们需要使用某个Spring容器管理的对象时，需要使用依赖注入的方式，不能通过new关键字来创建实例。</p><h1 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="ConfigurationProperties注解"></a>ConfigurationProperties注解</h1><p>@ConfigurationProperties 注解是 SpringBoot 提供的一种更优雅的方式，来读取配置文件中的属性值。通过自动绑定和类型转换等机制，可将指定前缀的属性集合自动绑定到一个Bean对象上。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>前面在分析 SpringBoot 项目的启动流程中，我们发现这个 prepareEnvironment() 方法中调用了一个非常重要的方法 bindToSpringApplication(environment)，该方法的作用是将配置文件中的属性值绑定到被 @ConfigurationProperties 注解标记的 Bean对象中。不过此时这些对象还没有被 Spring 容器管理，因此无法完成属性的自动注入。</p><p>那么问题来了，这些 Bean 对象是在何时被注册到 Spring 容器中呢？这就涉及到了 ConfigurationPropertiesBindingPostProcessor 类，它是 Bean 后置处理器，负责扫描容器中所有被 @ConfigurationProperties 注解所标记的 Bean对象。如果找到了，则使用 Binder 组件将外部属性的值绑定到它们身上，从而实现自动注入：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356409937-9f0d2bef-a612-44cc-ad54-42932a4ed8ec.png#averageHue=%232e2d2c&clientId=u313a9f9a-5626-4&from=paste&height=317&id=u91100481&originHeight=475&originWidth=1747&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=130729&status=done&style=none&taskId=u762011e4-80bd-44f6-8896-e1a2ff1566f&title=&width=1164.6666666666667" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void bindToSpringApplication(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));</span><br><span class="line">    &#125; catch (Exception var3) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356666349-e4c62109-418c-494a-bc4d-db0061d5f5d9.png#averageHue=%232f2c2b&clientId=u313a9f9a-5626-4&from=paste&id=u6206cbe3&originHeight=462&originWidth=1074&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u93c04198-1bbe-4818-8efc-5a02a4fe59a&title="></p><ul><li>bindToSpringApplication方法，主要将属性值绑定到 Bean 对象中；</li><li>ConfigurationPropertiesBindingPostProcessor类，主要负责在Spring容器启动时，将被注解标记的 Bean 对象注册到容器中，并完成后续的属性注入操作。<h3 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在application.yml配置文件中新增如下配置信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config:</span><br><span class="line">  custom:</span><br><span class="line">    prop1: prop1</span><br><span class="line">    prop2: prop2</span><br></pre></td></tr></table></figure>第二步，定义一个名为 UsePropertiesConfig 的类，该类用于承载所有前缀为 config.custom 的配置属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;config.custom&quot;)</span><br><span class="line">public class UsePropertiesConfig &#123;</span><br><span class="line">    private String prop1;</span><br><span class="line">    private String prop2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将UsePropertiesConfig类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UsePropertiesConfig usePropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;prop1 is :&#123;&#125;&quot;, usePropertiesConfig.getProp1());</span><br><span class="line">        log.info(&quot;prop2 is :&#123;&#125;&quot;, usePropertiesConfig.getProp2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：prop1和prop2</span><br></pre></td></tr></table></figure><h1 id="PropertySources-注解"><a href="#PropertySources-注解" class="headerlink" title="PropertySources 注解"></a>PropertySources 注解</h1>一般来说，系统默认提供的名为 application.yml 或者 application.properties 配置文件能满足绝大多数业务场景，但是在某些场景下我们还是希望自定义配置文件名称及内容。请注意，与默认的配置文件所不同的是，用户自定义的配置文件无法被应用自动加载，需要开发者手动加载。<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3>@PropertySources 注解的实现原理比较简单，如下所示：<br>（1）应用程序启动时，扫描所有被@PropertySources 注解修饰的类，并获取到注解中指定自定义配置文件的路径；<br>（2）将指定路径下的配置文件内容加载到 Environment 中，这样就可通过 @Value 注解或 Environment.getProperty() 方法来获取其中定义的属性值。<h3 id="示例使用-1"><a href="#示例使用-1" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在 src/main/resources 目录下定义一个名为 customProperties.properties 的自定义配置类，里面的配置项如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom.sex=male</span><br><span class="line">custom.address=shanghai</span><br></pre></td></tr></table></figure>第二步，在需要使用自定义配置文件的类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开。这里定义一个名为 CustomPropertiesConfig 的类，里面的代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customProperties.properties&quot;,encoding = &quot;utf-8&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class CustomPropertiesConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.address&#125;&quot;)</span><br><span class="line">    private String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将CustomPropertiesConfig 类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private CustomPropertiesConfig customPropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, customPropertiesConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.address is: &#123;&#125;&quot;, customPropertiesConfig.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h3 id="支持YML格式"><a href="#支持YML格式" class="headerlink" title="支持YML格式"></a>支持YML格式</h3>查看一下这个 @PropertySource 注解的源码，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(PropertySources.class)</span><br><span class="line">public @interface PropertySource &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    boolean ignoreResourceNotFound() default false;</span><br><span class="line"></span><br><span class="line">    String encoding() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到这里的 factory 属性，默认使用的是 PropertySourceFactory 类，而这个类是一个接口，查看一下该接口的源码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PropertySourceFactory &#123;</span><br><span class="line">    PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>里面只有一个 createPropertySource 方法，该方法会返回一个 PropertySource 对象，这个PropertySourceFactory 接口只有一个默认的实现类 DefaultPropertySourceFactory ，该实现类的源码如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultPropertySourceFactory implements PropertySourceFactory &#123;</span><br><span class="line">    public DefaultPropertySourceFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        return name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>也就是说它只能加载 .properties 结尾的配置文件，无法加载 yml 格式结尾的文件。如果我们需要加载 yml 格式的配置文件，那么需要自定义 PropertySourceFactory 接口实现类。</li></ul><p>第一步，在 src/main/resources 目录下定义一个名为 customYaml.yml 的自定义配置类，里面的配置项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  sex: male</span><br><span class="line">  city: shanghai</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 YamlPropertySourceFactory 的类，该类需要实现 PropertySourceFactory 接口并重写其中的 createPropertySource 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class YamlPropertySourceFactory  implements PropertySourceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();</span><br><span class="line">        factoryBean.setResources(resource.getResource());</span><br><span class="line"></span><br><span class="line">        Properties properties = factoryBean.getObject();</span><br><span class="line">        return new PropertiesPropertySource(resource.getResource().getFilename(), properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个名为 UseYamlConfig 的配置类，并在该类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customYaml.yml&quot;, encoding = &quot;utf-8&quot;, factory = YamlPropertySourceFactory.class)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class UseYamlConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.city&#125;&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个名为 UseYamlConfigTest 的类，该类会使用到前面的配置项，因此需要将UseYamlConfig 类进行注入并使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UseYamlConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UseYamlConfig useYamlConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, useYamlConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.city is: &#123;&#125;&quot;, useYamlConfig.getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h1 id="YamlPropertiesFactoryBean-加载-YAML-文件"><a href="#YamlPropertiesFactoryBean-加载-YAML-文件" class="headerlink" title="YamlPropertiesFactoryBean 加载 YAML 文件"></a>YamlPropertiesFactoryBean 加载 YAML 文件</h1><p>我们还可以使用 YamlPropertiesFactoryBean 这个类将 YAML 配置文件中的属性值注入到 Bean 中，具体操作如下：<br>第一步，定义一个名为 customBeanYaml.yml 的配置文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  email: qq@qq.com</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 CustomYamlPropertiesFactoryBeanConfig 的类，里面定义一个名为 yamlConfigurer 的方法，该方法需要返回一个 PropertySourcesPlaceholderConfigurer 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomYamlPropertiesFactoryBeanConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public static PropertySourcesPlaceholderConfigurer yamlConfigurer() &#123;</span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean();</span><br><span class="line">        yaml.setResources(new ClassPathResource(&quot;customBeanYaml.yml&quot;));</span><br><span class="line">        configurer.setProperties(Objects.requireNonNull(yaml.getObject()));</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个测试方法，开发者可通过 @Value 注解或 Environment.getProperty() 方法来获取配置文件中定义的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@Slf4j</span><br><span class="line">public class YamlPropertiesFactoryBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.email&#125;&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.email is: &#123;&#125;&quot;, email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义读取"><a href="#自定义读取" class="headerlink" title="自定义读取"></a>自定义读取</h1><p>如果开发者觉得上述读取方式不够优雅，自己想造轮子，此时可以直接注入 PropertySources 对象，来获取所有属性的配置队列，之后就可以按照要求进行实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CustomTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void customTest() &#123;</span><br><span class="line">        for (PropertySource&lt;?&gt; propertySource : propertySources) &#123;</span><br><span class="line">            log.info(&quot;自定义方式，来实现配置获取逻辑，属性名称为：&#123;&#125; ,属性源为：&#123;&#125;&quot;, propertySource.getName(), propertySource.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例使用"><a href="#案例使用" class="headerlink" title="案例使用"></a>案例使用</h1><p>接下来通过一个例子来灵活学习如何获取指定配置文件中的属性值，步骤如下所示：<br>第一步，定义一个名为PropertiesLoader的类，我们定义 loadProperties 方法用于读取指定配置文件中的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesLoader &#123;</span><br><span class="line">    private static final Logger logger = Logger.getLogger(PropertiesLoader.class.getName());</span><br><span class="line"></span><br><span class="line">    private PropertiesLoader() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Properties loadProperties(String location) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        logger.info(&quot;Loading properties file from path:&quot; + location);</span><br><span class="line">        InputStreamReader in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new InputStreamReader(PropertiesLoader.class.getClassLoader().getResourceAsStream(location), &quot;UTF-8&quot;);</span><br><span class="line">            props.load(in);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.log(Level.WARNING, &quot;error close inputstream&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步，定义一个方法用于获取配置文件中指定名称的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesTest &#123;</span><br><span class="line">    public static void init(String location)&#123;</span><br><span class="line">        Properties properties = PropertiesLoader.loadProperties(location);</span><br><span class="line">        String userName = properties.getProperty(&quot;user.name&quot;);</span><br><span class="line">        String userSex = properties.getProperty(&quot;user.sex&quot;);</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">        System.out.println(userSex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String location = &quot;user.properties&quot;;</span><br><span class="line">        init(location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个 user.properties 文件是定义在项目resources目录下的文件。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的学习，我们知道可通过 @Value 注解、Environment 类、@ConfigurationProperties 注解和@PropertySource 注解等方式来获取配置信息。<br>其中，@Value 注解适用于单个值的注入，其他几种方式适用于多个配置的批量注入，而且不同方式在效率、灵活性、易用性等方面存在差异，在选择的时候需要多方面进行考虑。</p><p>这里笔者结合实际的工作体会，给出一些比较有参考意义的建议：如果重视代码的可读性和可维护性，可选择 @ConfigurationProperties 注解；如果更注重运行效率，可选择使用 Environment 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊九种常用的分布式ID生成方案</title>
    <link href="http://envyzhan.asia/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/"/>
    <id>http://envyzhan.asia/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/</id>
    <published>2024-02-03T06:55:27.000Z</published>
    <updated>2024-05-22T14:13:22.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习9种常用的分布式ID生成方案，掌握这些对于提升自身能力有极大帮助。</p><h1 id="为什么使用分布式ID"><a href="#为什么使用分布式ID" class="headerlink" title="为什么使用分布式ID"></a>为什么使用分布式ID</h1><h3 id="分布式ID的定义"><a href="#分布式ID的定义" class="headerlink" title="分布式ID的定义"></a>分布式ID的定义</h3><p>这里以MySQL数据库为例进行说明，当我们的业务数据量不大时，单库单表完全可以支撑现有业务，数据再大一点时，使用MySQL主从同步、读写分离模式也能应付。但是当数据日益增长，达到亿级别的时候，就需要对数据库进行分库分表操作，而分库分表后需要有一个唯一的ID来标识每条数据，显然数据库的自增ID无法满足需求，那么这个 全局唯一ID 就叫 分布式ID 。</p><h3 id="分布式ID满足的条件"><a href="#分布式ID满足的条件" class="headerlink" title="分布式ID满足的条件"></a>分布式ID满足的条件</h3><p>一般来说，分布式ID需要满足如下五个要求：</p><ul><li>全局唯一：必须保证ID是全局性唯一；</li><li>高性能：高可用低延时，ID生成响应快，否则会成为业务瓶颈；</li><li>高可用：100%可用无法做到，但是要无限接近于100%的可用；</li><li>好接入：秉承拿来即用的设计原则，在系统设计和实现上要尽可能的简单；</li><li>趋势递增：最好有趋势递增，不过要结合实际业务进行分析。<h1 id="分布式ID的生成方式"><a href="#分布式ID的生成方式" class="headerlink" title="分布式ID的生成方式"></a>分布式ID的生成方式</h1>分布式ID的生成方式有很多种，此处列举常用的9种方式，如下所示：<br>（1）UUID；<br>（2）数据库自增ID；<br>（3）数据库多主模式；<br>（4）号段模式；<br>（5）Redis；<br>（6）SnowFlake（雪花算法）；<br>（7）Uidgenerator （百度）；<br>（8）TinyID（滴滴）；<br>（9）Leaf（美团）。<br>本篇文章将学习以上9种分布式ID的生成方式，并学习其原理和优缺点，以便在实际开发过程中能有针对性的进行选择使用。<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3>由于笔者使用的是Java语言，而Java自带了一个能生成全球唯一ID的UUID类，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行上述方法，输出结果为：15751784476b47719021f39dffe49003。实际上生成的UUID可以作为分布式ID，但是并不建议使用它。因为生成的UUID体现不出业务的含义，而且对于数据库而言，UUID的长度过长且是字符串，存储和查询性能较差。</li></ul><p><strong>优点：</strong></p><ul><li>生成逻辑简单，一行代码搞定；</li><li>本地生成无网络消耗且具有唯一性。</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性；</li><li>无法体现具体的业务含义；</li><li>长度过长且是字符串，存储和查询性能较差。<h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3>这里以MySQL数据库为例进行说明，可以使用MySQL的 auto_increment 自增ID来充当分布式ID。</li></ul><p>举个例子，下面是一个表，使用它的自增主键ID作为分布式ID，对应的建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sequence_id (</span><br><span class="line">    id bigint(20) unsigned NOT NULL auto_increment, </span><br><span class="line">    value char(10) NOT NULL default &#x27;&#x27;,</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into sequence_id(value) VALUES (&#x27;zhangsan&#x27;);</span><br></pre></td></tr></table></figure><p>当我们需要一个ID时，只需往该表中插入一条记录，即可返回该记录的主键ID，不过这种方式仅适用于并发量不大的情况，在分布式系统中不建议使用。</p><p><strong>优点：</strong></p><ul><li>实现简单且ID单调自增；</li><li>采用数值类型，因此查询速度快。</li></ul><p><strong>缺点：</strong></p><ul><li>数据库存在宕机故障，无法抗住高并发场景。<h3 id="数据库集群模式"><a href="#数据库集群模式" class="headerlink" title="数据库集群模式"></a>数据库集群模式</h3>既然单点数据库方式存在高并发问题，那么我们可对上述方式进优化，采用主从模式集群模式。考虑到单主节点挂掉，无法高可用，那么可采用双主模式集群，即两个Mysql实例都能单独生成自增ID。</li></ul><p>不过这里还有一个问题，就是两个MySQL实例的自增ID都从1开始，肯定会生成重复的ID，此时可以考虑错开设置起始值以及采用自增步长。</p><p>举个例子，假设这里有两个MySQL实例，接下来我们尝试对其做如下配置：<br>（1）MySQL_1的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>（2）MySQL_2的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class="line">set @@auto_increment_increment = 2;  -- 步长</span><br></pre></td></tr></table></figure><p>通过上面的配置，那么这两个MySQL实例的自增ID分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL_1：1、3、5、7、9 </span><br><span class="line">MySQL_2：2、4、6、8、10</span><br></pre></td></tr></table></figure><p>当然了，如果使用此集群后，性能还是不佳，无法扛住高并发，可考虑对MySQL集群进行扩容处理，即增加节点，不过这个操作比较复杂：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690164636483-e2181405-a519-4d02-9d00-6903f7d780c4.png#averageHue=%23f7f7f7&clientId=u9118ed87-b2b2-4&from=paste&height=328&id=u1e2bb6fe&originHeight=492&originWidth=868&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=53668&status=done&style=none&taskId=ub42491d9-4df1-4c25-b728-6289992fe1d&title=&width=578.6666666666666" alt="image.png"><br>可以看到，由于上述数据库集群支持水平扩展，因此有利于解决数据库单点压力的问题，同时为了ID生成特性，需要将自增步长按照机器数量来设置。</p><p>这个操作其实比较复杂，我们仅仅是往集群中添加了一个实例，就需要对上述三个实例的起始值和步长都进行调整，将第三台机器的ID起始值调整为比现有最大自增ID的值都大，而且必须在前面两台机器还没有增长到第三台机器的起始ID值时才能操作，否则自增ID就重复了，这是非常严重的问题，必要时还可能需要停机修改。</p><p><strong>优点：</strong></p><ul><li>解决数据库的单节点宕机故障。</li></ul><p><strong>缺点：</strong></p><ul><li>水平扩容较为复杂，且实际上单个数据库压力还是很大，依旧无法满足高并发场景。<h3 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h3>数据库号段模式是当前分布式ID生成器的主流实现方式之一，号段模式可以这样理解：首先从数据库批量获取自增ID，然后每次从数据库取出一个号段范围，如 (1,1000] 代表1000个ID，接着某一业务微服务将本号段生成1~1000的自增ID并加载到内存中。对应的表结构如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE id_generator (</span><br><span class="line">  id int(10) NOT NULL,</span><br><span class="line">  max_id bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  step int(20) NOT NULL COMMENT &#x27;号段的步长&#x27;,</span><br><span class="line">  biz_type    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,</span><br><span class="line">  version int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) </span><br></pre></td></tr></table></figure>简单解释一下上述字段的含义：<br>（1）max_id ，表示当前可用的最大id；<br>（2）step，表示号段的步长；<br>（3）biz_type，表示不同的业务类型；<br>（4）version ，一个乐观锁，注意每次对数据进行更新操作，都需要更新version字段，保证并发时数据的正确性。</li></ul><p>下面是一条示例，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690167055037-a72e14a2-75b8-4399-98d4-7492bc839947.png#averageHue=%23f1f1f0&clientId=u9118ed87-b2b2-4&from=paste&height=88&id=u44200825&originHeight=132&originWidth=979&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=13288&status=done&style=none&taskId=ub2437283-bcf0-4a63-ad5f-3354d5632bd&title=&width=652.6666666666666" alt="image.png"><br>后续等这批号段ID用完了，可再次向数据库申请新号段，只需对 max_id 字段做一次 update 操作，执行如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update id_generator</span><br><span class="line">set max_id = max_id + step, version = version + 1</span><br><span class="line">where biz_type = #&#123;bizType&#125;</span><br><span class="line">and max_id = #&#123;maxId&#125;</span><br><span class="line">and version = #&#123;version&#125;</span><br></pre></td></tr></table></figure><p>上述语句执行成功，则说明新号段获取成功，此时新的号段范围为 (max_id , max_id +step] 。考虑到多个业务可能同时操作，因此引入版本号 version 字段，采用乐观锁方式更新。</p><p><strong>优点：</strong></p><ul><li>不强依赖数据库，且不会频繁的访问数据库，对数据库的压力很小。</li></ul><p><strong>缺点：</strong></p><ul><li>当存在多个业务，且业务使用频率差距较大时，会造成有些业务号段不够用，有些使用率不高的情况。<h3 id="Redis模式"><a href="#Redis模式" class="headerlink" title="Redis模式"></a>Redis模式</h3>Redis提供了incr命令，因此通过该命令也可以实现分布式ID的生成功能。举个例子，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set sequence_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr sequence_id      // 增加1，并返回递增后的数值</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>请注意，在使用Redis实现时需要考虑Redis的持久化问题。我们知道Redis有两种持久化方式：RDB和AOF。下面说一下这两种情况分别可能存在的问题：<br>（1）RDB方式是定时生成一个快照，进而进行持久化。这样就有一个问题，假如连续自增的Redis没及时进行持久化就挂掉了，那么重启后就会出现ID重复的情况。<br>（2）AOF方式是针对每条写命令进行持久化，这样即使Redis挂掉也不会出现ID重复的情况。但是这样会有一个情况，由于incr命令的特殊性，它会导致Redis重启恢复数据的时间较长。</li></ul><p><strong>优点：</strong></p><ul><li>实现简单，不依赖与数据库，可实现高可用。</li></ul><p><strong>缺点：</strong></p><ul><li>RDB方式可能出现ID重复、AOF方式会导致Redis重启恢复数据的时间较长。<h3 id="雪花算法（Snowflake）模式"><a href="#雪花算法（Snowflake）模式" class="headerlink" title="雪花算法（Snowflake）模式"></a>雪花算法（Snowflake）模式</h3>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，各大公司在此基础上开发出了各具特色的分布式ID生成器。下图是雪花算法生成的Long类型ID的组成结构示意图：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690168415774-0d50e86a-e68e-4081-a32e-40fd60fb8c49.png#averageHue=%23f7f7f7&clientId=u9118ed87-b2b2-4&from=paste&height=194&id=u5879679a&originHeight=291&originWidth=966&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=89402&status=done&style=none&taskId=u6f5f18d0-f175-4c54-8726-bf6f92f7188&title=&width=644" alt="image.png"><br>Snowflake 生成的是一个Long类型的ID，而一个Long类型占8个字节，每个字节又占8比特，即一个Long类型占64 个比特。</li></ul><p>该Long类型的ID由64个比特组成，结构如下：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特）。</p><ul><li>第一个bit位（1bit）：Java中Long的最高位是符号位，代表正负，其中正数是0，负数是1，一般生成ID都为正数，所以默认是0。</li><li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，这样可使产生的ID从更小的值开始。41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年。</li><li>工作机器id（10bit）：也被叫做 workId ，这个可灵活配置，一般是机器ID+数据中心ID组成。</li><li>序列号部分（12bit）：自增值支持同一毫秒时间内，同一个节点可生成4096个ID。</li></ul><p>根据雪花算法的逻辑，开发者只需使用Java语言将其实现出来，并封装为一个工具方法，然后在各个业务系统中直接使用该工具方法来获取分布式ID，此时只需保证每个业务都有自己的工作机器id，不需要单独搭建一个获取分布式ID的系统。</p><p>下面是使用Java实现的雪花算法代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span><br><span class="line"> *</span><br><span class="line"> * https://github.com/beyondfengyu/SnowFlake</span><br><span class="line"> */</span><br><span class="line">public class SnowFlakeShortUrl &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     */</span><br><span class="line">    private final static long START_TIMESTAMP = 1480166465631L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     */</span><br><span class="line">    //序列号占用的位数</span><br><span class="line">    private final static long SEQUENCE_BIT = 12;</span><br><span class="line">    //数据中心占用的位数</span><br><span class="line">    private final static long DATA_CENTER_BIT = 5;</span><br><span class="line">    //机器标识占用的位数</span><br><span class="line">    private final static long MACHINE_BIT = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     */</span><br><span class="line">    //序列号的最大值</span><br><span class="line">    private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line">    //数据中心的最大值</span><br><span class="line">    private final static long MAX_DATA_CENTER_NUM = -1L ^ (-1L &lt;&lt; DATA_CENTER_BIT);</span><br><span class="line">    //机器标识的最大值</span><br><span class="line">    private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     */</span><br><span class="line">    //机器标识向左的位移</span><br><span class="line">    private final static long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    //数据中心向左的位移</span><br><span class="line">    private final static long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">    //时间戳向左的位移</span><br><span class="line">    private final static long TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class="line"></span><br><span class="line">    //数据中心</span><br><span class="line">    private long dataCenterId;</span><br><span class="line">    //机器标识</span><br><span class="line">    private long machineId;</span><br><span class="line">    //序列号</span><br><span class="line">    private long sequence = 0L;</span><br><span class="line">    //上一次时间戳</span><br><span class="line">    private long lastTimeStamp = -1L;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill = getNewTimeStamp();</span><br><span class="line">        while (mill &lt;= lastTimeStamp) &#123;</span><br><span class="line">            mill = getNewTimeStamp();</span><br><span class="line">        &#125;</span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewTimeStamp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span><br><span class="line">     *</span><br><span class="line">     * @param dataCenterId 数据中心ID</span><br><span class="line">     * @param machineId    机器标志ID</span><br><span class="line">     */</span><br><span class="line">    public SnowFlakeShortUrl(long dataCenterId, long machineId) &#123;</span><br><span class="line">        if (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.dataCenterId = dataCenterId;</span><br><span class="line">        this.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成下一个ID</span><br><span class="line">     */</span><br><span class="line">    public synchronized long nextId() &#123;</span><br><span class="line">        long currTimeStamp = getNewTimeStamp();</span><br><span class="line">        if (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currTimeStamp == lastTimeStamp) &#123;</span><br><span class="line">            //相同毫秒内，序列号自增</span><br><span class="line">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line">            //同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence == 0L) &#123;</span><br><span class="line">                currTimeStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //不同毫秒内，序列号置为0</span><br><span class="line">            sequence = 0L;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimeStamp = currTimeStamp;</span><br><span class="line"></span><br><span class="line">        return (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT //时间戳部分</span><br><span class="line">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       //数据中心部分</span><br><span class="line">                | machineId &lt;&lt; MACHINE_LEFT             //机器标识部分</span><br><span class="line">                | sequence;                             //序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SnowFlakeShortUrl snowFlake = new SnowFlakeShortUrl(2, 3);</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; (1 &lt;&lt; 4); i++) &#123;</span><br><span class="line">            //10进制</span><br><span class="line">            System.out.println(snowFlake.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Uidgenerator-（百度）"><a href="#Uidgenerator-（百度）" class="headerlink" title="Uidgenerator （百度）"></a>Uidgenerator （百度）</h3><p>uid-generator 是百度基于 Snowflake 算法实现的，项目 <a href="https://github.com/baidu/uid-generator">GitHub地址</a> 。与原始的 snowflake 算法不同，uid-generator 支持 自定义时间戳、工作机器ID 和 序列号 等各部分的位数，且 uid-generator 中采用用户自定义 workId 的生成策略。</p><p>uid-generator 需要与数据库配合来使用，数据库中需要新建一个名为 WORKER_NODE 的表。当系统启动时，会往数据库表中插入一条数据，插入成功后会返回自增的ID，该ID就是该机器的 workId 数据。workId 由host和port组成。</p><p>请注意，uid-generator ID的组成结构与原始的Snowflake 算法生成的ID不同，uid-generator ID的workId占用22个bit位，而时间占用28个bit位，序列化占用13个bit位，还有它的时间单位是秒，不是毫秒。同时workId 也不一样，且同一应用每次重启就会消费一个 workId 。关于 Uidgenerator中文说明文档可以点击  <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">GitHub地址</a> 进行阅读。</p><h3 id="TinyID（滴滴）"><a href="#TinyID（滴滴）" class="headerlink" title="TinyID（滴滴）"></a>TinyID（滴滴）</h3><p>TinyID是滴滴基于号段模式原理开发的，项目 <a href="https://github.com/didi/tinyid">GitHub地址</a> 。每个服务获取一个号段，如（1000,2000]、（2000,3000]、（3000,4000]，之后各服务使用号段进行业务调用：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690178105351-301f57f8-0659-4b4d-9ed7-df6c05cf4bd7.png#averageHue=%23fdf7f6&clientId=u9118ed87-b2b2-4&from=paste&height=430&id=u465c57f9&originHeight=645&originWidth=990&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=78683&status=done&style=none&taskId=ubcb7a563-6b5c-49f7-b692-986d1f1a0dd&title=&width=660" alt="image.png"><br>Tinyid 提供两种方式来进行接入：http 和 tinyid-client，下面将分别进行学习。</p><h5 id="http方式接入"><a href="#http方式接入" class="headerlink" title="http方式接入"></a>http方式接入</h5><p>第一步，使用如下命令来下载tinyid的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/didi/tinyid.git</span><br></pre></td></tr></table></figure><p>第二步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info`</span><br><span class="line">(</span><br><span class="line">    `id`          bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">    `biz_type`    varchar(63) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务类型，唯一&#x27;,</span><br><span class="line">    `begin_id`    bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;,</span><br><span class="line">    `max_id`      bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">    `step`        int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;步长&#x27;,</span><br><span class="line">    `delta`       int(11) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;每次id增量&#x27;,</span><br><span class="line">    `remainder`   int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;余数&#x27;,</span><br><span class="line">    `create_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    `version`     bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;版本号&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `uniq_biz_type` (`biz_type`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;id信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    `token`       varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;token&#x27;,</span><br><span class="line">    `biz_type`    varchar(63)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;此token可访问的业务类型标识&#x27;,</span><br><span class="line">    `remark`      varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;备注&#x27;,</span><br><span class="line">    `create_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;token信息表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (1, &#x27;test&#x27;, 1, 1, 100000, 1, 0, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-22 23:19:27&#x27;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (2, &#x27;test_odd&#x27;, 1, 1, 100000, 2, 1, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-23 00:39:24&#x27;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (1, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (2, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test_odd&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br></pre></td></tr></table></figure><p>第三步，配置tinyid-server项目offline包下的application.properties配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8086</span><br><span class="line">datasource.tinyid.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">datasource.tinyid.primary.username=root</span><br><span class="line">datasource.tinyid.primary.password=root</span><br></pre></td></tr></table></figure><p>注意笔者使用的MySQL版本为8系列。<br>第四步，启动tinyid-server项目，开始进行测试。访问如下链接，来获取单个的ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8086/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c</span><br></pre></td></tr></table></figure><p>返回结果为：2。</p><p>如果要批量获取ID，可使用如下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8086/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=3</span><br></pre></td></tr></table></figure><p>返回结果为：3,4,5。</p><h5 id="Java客户端方式接入"><a href="#Java客户端方式接入" class="headerlink" title="Java客户端方式接入"></a>Java客户端方式接入</h5><p>第一步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info`</span><br><span class="line">(</span><br><span class="line">    `id`          bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">    `biz_type`    varchar(63) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务类型，唯一&#x27;,</span><br><span class="line">    `begin_id`    bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;,</span><br><span class="line">    `max_id`      bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">    `step`        int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;步长&#x27;,</span><br><span class="line">    `delta`       int(11) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;每次id增量&#x27;,</span><br><span class="line">    `remainder`   int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;余数&#x27;,</span><br><span class="line">    `create_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp   NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    `version`     bigint(20) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;版本号&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    UNIQUE KEY `uniq_biz_type` (`biz_type`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;id信息表&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token`</span><br><span class="line">(</span><br><span class="line">    `id`          int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增id&#x27;,</span><br><span class="line">    `token`       varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;token&#x27;,</span><br><span class="line">    `biz_type`    varchar(63)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;此token可访问的业务类型标识&#x27;,</span><br><span class="line">    `remark`      varchar(255) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;备注&#x27;,</span><br><span class="line">    `create_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    `update_time` timestamp    NOT NULL DEFAULT &#x27;2010-01-01 00:00:00&#x27; COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;token信息表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (1, &#x27;test&#x27;, 1, 1, 100000, 1, 0, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-22 23:19:27&#x27;, 1);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`,`update_time`, `version`)</span><br><span class="line">VALUES (2, &#x27;test_odd&#x27;, 1, 1, 100000, 2, 1, &#x27;2018-07-21 23:52:58&#x27;, &#x27;2018-07-23 00:39:24&#x27;, 3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (1, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class="line">VALUES (2, &#x27;0f673adf80504e2eaa552f5d791b644c&#x27;, &#x27;test_odd&#x27;, &#x27;1&#x27;, &#x27;2017-12-14 16:36:46&#x27;, &#x27;2017-12-14 16:36:48&#x27;);</span><br></pre></td></tr></table></figure><p>第二步，配置tinyid-server项目offline包下的application.properties配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8086</span><br><span class="line">datasource.tinyid.primary.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">datasource.tinyid.primary.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">datasource.tinyid.primary.username=root</span><br><span class="line">datasource.tinyid.primary.password=root</span><br></pre></td></tr></table></figure><p>第三步，创建一个项目，然后在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tinyid-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;tinyid.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第四步，通过阅读源码可知，需要新建一个名为 tinyid_client.properties 的配置文件，然后往里面新增如下配置信息，后面两个配置项可以不配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tinyid.token=0f673adf80504e2eaa552f5d791b644c</span><br><span class="line">tinyid.server=localhost:8086</span><br><span class="line">tinyid.readTimeout=</span><br><span class="line">tinyid.connectTimeout=</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690182879239-8e2508f5-336a-4b0d-9941-58dc08760f91.png#averageHue=%232e2d2c&clientId=u9118ed87-b2b2-4&from=paste&height=557&id=u5dd24467&originHeight=835&originWidth=1633&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=209149&status=done&style=none&taskId=u6d8beecc-8ae6-4b45-9627-e3e8da23e29&title=&width=1088.6666666666667" alt="image.png"><br>第五步，启动项目，开始进行测试。通过对源码分析，可以看到实际上我们只需通过 TinyId 这个工具类提供的方法就能获取到生成的ID：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690183637784-6e650e9d-b140-4e74-9312-aa4746b7abc1.png#averageHue=%232c2c2b&clientId=u9118ed87-b2b2-4&from=paste&height=555&id=u1a7e9957&originHeight=833&originWidth=1057&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=111228&status=done&style=none&taskId=u877e574a-a5f2-4431-81fd-067db899c65&title=&width=704.6666666666666" alt="image.png"><br>如果你想获取单个的ID，可调用TinyId的 nextId(String bizType) 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyId.nextId(&quot;test&quot;);</span><br></pre></td></tr></table></figure><p>返回结果为：2。</p><p>如果想要批量获取ID，可调用TinyId的 nextId(String bizType, Integer batchSize) 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyId.nextId(&quot;test&quot;,3);</span><br></pre></td></tr></table></figure><p>返回结果为：3,4,5。请注意，上面的bizType和token必须对应起来，否则数据是无法查询出来的。</p><h3 id="Leaf（美团）"><a href="#Leaf（美团）" class="headerlink" title="Leaf（美团）"></a>Leaf（美团）</h3><p>Leaf 由美团开发，同时支持号段模式和 snowflake 算法模式（可切换使用）的分布式ID生成器，项目 <a href="https://github.com/Meituan-Dianping/Leaf">GitHub地址</a> 。</p><h5 id="号段模式接入"><a href="#号段模式接入" class="headerlink" title="号段模式接入"></a>号段模式接入</h5><p>第一步，使用如下命令来下载 Leaf 的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Meituan-Dianping/Leaf</span><br></pre></td></tr></table></figure><p>第二步，创建对应的数据库表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `leaf_alloc`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `leaf_alloc` (</span><br><span class="line">  `biz_tag` varchar(128)  NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;业务标签，唯一&#x27;,</span><br><span class="line">  `max_id` bigint(20) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(11) NOT NULL COMMENT &#x27;步长&#x27;,</span><br><span class="line">  `description` varchar(256)  DEFAULT NULL COMMENT &#x27;描述信息&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`biz_tag`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT=&#x27;号段分配表&#x27;;</span><br></pre></td></tr></table></figure><p>第三步，修改项目的一些依赖版本，具体如下：<br>（1）mysql-connector-java，由 5.1.38 调整为 8.0.33；<br>（2）druid，由 1.0.18 调整为 1.1.10。<br>第四步，修改 leaf-server 项目中的leaf.properties文件内容，我们这里使用号段模式，配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leaf.name=com.sankuai.leaf.opensource.test</span><br><span class="line">leaf.segment.enable=true</span><br><span class="line">leaf.jdbc.url=jdbc:mysql://localhost:3306/sequence_id?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">leaf.jdbc.username=root</span><br><span class="line">leaf.jdbc.password=root</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable=false</span><br></pre></td></tr></table></figure><p>既然我们这里使用了号段模式，因此需要关闭雪花算法模式。<br>第五步，启动 leaf-server 项目的入口类 LeafServerApplication，即可启动项目。然后往数据表leaf_alloc中插入一条数据，如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690248965265-8292884a-33f2-4901-b023-2b3889ec3904.png#averageHue=%23d8ebc6&clientId=u5eb8395b-a42d-4&from=paste&height=37&id=u006e5718&originHeight=55&originWidth=740&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=7578&status=done&style=none&taskId=ue44e2073-b1c8-4143-8cfd-a1984b3ccc5&title=&width=493.3333333333333" alt="image.png"><br>接着在浏览器地址栏中访问<code>[http://localhost:8080/api/segment/get/test_order](http://localhost:8080/api/segment/get/test_order)</code>链接，即可获取到生成的ID。<br>实际上，Leaf还提供了一个接口<code>[http://localhost:8080/cache](http://localhost:8080/cache)</code>来监控号段模式，界面如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690249124499-9dadd9d0-2d96-404a-b2ee-59ccf9b12dde.png#averageHue=%23fcfbfb&clientId=u5eb8395b-a42d-4&from=paste&height=81&id=u94200bcf&originHeight=122&originWidth=2123&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16287&status=done&style=none&taskId=ua67244e9-bbf1-45e5-ad65-1ef16e421d9&title=&width=1415.3333333333333" alt="image.png"></p><h5 id="雪花算法模式接入"><a href="#雪花算法模式接入" class="headerlink" title="雪花算法模式接入"></a>雪花算法模式接入</h5><p>Leaf和原始的雪花算法主要区别在 workId 的生成上。我们知道 Leaf 的雪花算法模式依赖ZooKeeper，它的 workId 是基于ZooKeeper的顺序Id来生成的。每个应用在使用 Leaf 的雪花模式接入时，在启动的时候，都会在Zookeeper中生成一个顺序Id，就相当于一台机器对应一个顺序节点，也就是一个workId。</p><p>前面三步和之前的一样，第四步配置信息有点差异，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leaf.segment.enable=false</span><br><span class="line"></span><br><span class="line">leaf.snowflake.enable=true</span><br><span class="line">leaf.snowflake.zk.address=127.0.0.1</span><br><span class="line">leaf.snowflake.port=2187</span><br></pre></td></tr></table></figure><p>之后启动 leaf-server 项目的入口类 LeafServerApplication，即可启动项目。然后在浏览器地址栏中访问<code>[http://localhost:8080/api/snowflake/get/test_order](http://localhost:8080/api/segment/get/test_order)</code>链接，即可获取到生成的ID。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习9种常用的分布式ID生成方案，掌握这些对于提升自身能力有极大帮助。&lt;/p&gt;
&lt;h1 id=&quot;为什么使用分布式ID&quot;</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>巧用分页列表缓存，快速响应用户请求</title>
    <link href="http://envyzhan.asia/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/"/>
    <id>http://envyzhan.asia/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/</id>
    <published>2023-05-28T08:55:30.000Z</published>
    <updated>2023-06-09T13:52:42.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响应用户的时间，主要用到了分页列表缓存。</p><h1 id="直接缓存分页列表"><a href="#直接缓存分页列表" class="headerlink" title="直接缓存分页列表"></a>直接缓存分页列表</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最简单，也是最能想到的方法就是直接缓存分页列表。举个例子，如下所示，直接将每页的数据以列表形式进行缓存：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-77510826a25930a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    String key = &quot;productPageList:pageNum:&quot; + pageNum+ &quot;pageSize:&quot; + pageSize+  &quot;param:&quot; + param ;</span><br><span class="line">    List&lt;Product&gt; productList = cacheUtil.get(key);</span><br><span class="line">    if(productList != null)return productList;</span><br><span class="line">    productList = queryFromDB(param,pageNum,pageSize);</span><br><span class="line">    if(productList != null) &#123;</span><br><span class="line">         cacheUtil.set(key , productList , Constants.ExpireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方式优点就是操作简单，性能也快，缺点就是缓存的粒度太粗。如果列表中数据发生增删，为了保证数据的一致性，需要修改分页列表缓存。</p><p>当然了，可以有两种方式来解决 ：<br>（1）利用缓存的过期时间来惰性删除，不过这种要求业务能接受；<br>（2）使用Redis提供的<code>keys</code>命令来找到对应的分页缓存，之后执行删除操作。不过<code>keys</code>命令对性能影响很大，会导致 Redis产生较大的延迟，这一点在并发性要求高的业务下是很难满足的 。而且生产环境使用<code>keys</code>命令比较危险，很容易出现问题，因此不推荐使用<code>keys</code>命令。</p><h1 id="先查询对象ID列表，再缓存每个对象"><a href="#先查询对象ID列表，再缓存每个对象" class="headerlink" title="先查询对象ID列表，再缓存每个对象"></a>先查询对象ID列表，再缓存每个对象</h1><p>前面说过直接缓存分页列表，导致缓存粒度较粗，很难保证数据的一致性，因此我们可以尝试细粒度缓存，即先查询对象ID列表，再缓存每个对象。</p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>举个例子，如下所示，首先我们查询分页对象ID列表，然后再缓存每一个对象，后续通过对象ID和缓存的对象来聚合形成列表返回给前端：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-adbcc181311b464e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    //1、构建返回对象</span><br><span class="line">    List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br><span class="line">    //2、从数据库中查询分页ID列表</span><br><span class="line">    List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br><span class="line">    //3、为空则直接返回空列表</span><br><span class="line">    if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">        return new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    //4、批量从缓存中获取缓存对象列表</span><br><span class="line">    Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br><span class="line">    //5、缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来</span><br><span class="line">    List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">    noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">        if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">            noHitpProductIdList.add(productId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //6、将前面没有命中的对象从数据库中查询并添加到缓存中</span><br><span class="line">    List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">    if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">        Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">        .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">        //将没有命中的对象添加到缓存中</span><br><span class="line">        cacheUtil.mset(noHitProductMap);</span><br><span class="line">        //将没有命中的对象添加到聚合Map中</span><br><span class="line">        cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">    &#125;</span><br><span class="line">    //7、组装返回对象</span><br><span class="line">    productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">      Product product = cacheProductMap.get(productId);</span><br><span class="line">      if(product != null)&#123;</span><br><span class="line">        result.add(product);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面简单解释一下上述代码的含义：<br>（1）构建返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br></pre></td></tr></table></figure><p>（2）从数据库中查询分页ID列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br></pre></td></tr></table></figure><p>其实这个就相当于执行如下的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t_product order by id limit (pageNum -1)* size,size;</span><br></pre></td></tr></table></figure><p>（3）为空则直接返回空列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">      return new ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）批量从缓存中获取缓存对象列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br></pre></td></tr></table></figure><p>这里我们采用的是分布式缓存系统Redis，它天然支持批量查询命令，如mget、mset等。<br>（5）缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">        noHitpProductIdList.add(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于缓存中可能出现对象过期或者其他原因，导致缓存没有命中，此时我们需要找到哪些对象是没有命中的。<br>（6）将前面没有命中的对象从数据库中查询并添加到缓存中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">    Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">    .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">    //将没有命中的对象添加到缓存中</span><br><span class="line">    cacheUtil.mset(noHitProductMap);</span><br><span class="line">     //将没有命中的对象添加到聚合Map中</span><br><span class="line">    cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先我们从数据库中批量查询出未命中的对象列表，其实就相当于执行如下SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_product where id in (1,2,3......);</span><br></pre></td></tr></table></figure><p>之后就将命中的对象添加到缓存和聚合Map中。<br>（7）组装返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    Product product = cacheProductMap.get(productId);</span><br><span class="line">    if(product != null)&#123;</span><br><span class="line">      result.add(product);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可以看到此时最坏的情况就是经过两次网络IO，第一次是数据库查询IO，第二次是Redis查询IO，我们就能得到所需要的数据。</p><p>“先查询对象ID列表，再缓存每个对象”这种方案灵活性很高，我们还可以将查询对象ID列表这一操作从数据库中变为从Redis、ElasticSearch等。下图是博客文章的搜索流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69072d5faeed1cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到，此时搜索的分页结果中只包含业务对象 ID ，而对象的详细信息则从缓存和数据库中获取。</p><h1 id="缓存对象ID列表同时缓存每个对象"><a href="#缓存对象ID列表同时缓存每个对象" class="headerlink" title="缓存对象ID列表同时缓存每个对象"></a>缓存对象ID列表同时缓存每个对象</h1><p>记得之前笔者在写一个社交APP的时候，遇到过Feed流的情况，需要以瀑布流的形式展示用户所关注的好友的动态。当时采用了推模式并结合Redis的ZSet数据结构来实现，将每一条动态ID存储在ZSet中，ZSet是一种有序的数据结构，由多个有序的唯一字符串组成，每个字符串都关联一个浮点类型的分数。</p><p>ZSet 使用的是 member -&gt; score 结构 ，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-82a033cd1cb7b693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>member是被排序的标识，也是默认的第二排序维度（ 即score相同时，Redis以member的字典序排列）；而score则是被排序的分值，存储类型是double。</p><p>我们可以使用ZSet来存储动态 ID 列表，其中member是动态编号，score是创建时间，然后通过ZSet 的<code>ZREVRANGE</code>命令就可以实现分页效果，它用于按照成员的分数从大到小返回有序集合中的指定范围的成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>当然了，为了实现分页效果，我们上面的start和stop的取值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int start = (pageNum -1) * pageSize;</span><br><span class="line">int stop = start + pageSize - 1;</span><br></pre></td></tr></table></figure><p>这样通过<code>ZREVRANGE</code>命令，我们就可以查询出动态ID列表了。在获取到动态ID列表之后，我们还需要缓存每个动态对象的信息，这些动态对象包括详情、评论、点赞、转发等内容，这些内容是需要单独做缓存的：</p><table><thead><tr><th align="center">动态信息</th><th align="center">Redis存储方式</th></tr></thead><tbody><tr><td align="center">动态</td><td align="center">使用Hash来存储动态详情</td></tr><tr><td align="center">点赞</td><td align="center">使用ZSET来存储userId，前端显示用户头像，使用String缓存用户信息</td></tr><tr><td align="center">收藏</td><td align="center">使用String来存储userId和FeedId的映射关系</td></tr><tr><td align="center">评论</td><td align="center">使用ZSET来存储commentId，使用String缓存评论详情信息</td></tr></tbody></table><p>当然，无论是查询还是更新缓存，笔者都是建议采用批量操作，这样效率更高。如果缓存对象结构简单，那么可以使用<code>mget</code>、<code>hmget</code>等命令；若结构复杂，可以使用pipleline，Lua脚本等方式。 笔者采用Redis的pipleline来实现批量操作。</p><p>“缓存对象ID列表同时缓存每个对象”这种方案的流程如下所示：<br>（1）使用ZSet来存储动态 ID 列表，并通过传入分页参数和<code>ZREVRANGE</code>命令来动态查询ID列表；<br>（2）通过传递动态ID列表参数，并采用Redis的pipleline功能，从缓存中批量获取动态的详情，评论，点赞，收藏等数据 ，最终组装成所需列表并返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要学习了分页缓存的三种方案，如下所示：<br>（1）直接缓存分页列表；<br>（2）先查询对象ID列表，再缓存每个对象；<br>（3）缓存对象ID列表同时缓存每个对象。<br>这三种方式层层递进，最终采用细粒度控制缓存对象和批量加载缓存对象，进而实现快速响应用户请求这一目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>基于请求参数校验的接口幂等性实现方案</title>
    <link href="http://envyzhan.asia/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/"/>
    <id>http://envyzhan.asia/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/</id>
    <published>2023-05-10T02:55:30.000Z</published>
    <updated>2023-06-09T13:50:03.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求参数的校验，这种方式在高并发环境下优势更明显。由于请求只有一次，所以不需要从服务端获取令牌。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>基于请求参数校验这一方式原理很简单，如果在某一个时间间隔内，同一个接口接收到的请求参数一样，则说明前后请求是重复的，服务端则拒绝处理后续请求。注意由于前后端通过JOSN格式传递数据，且需要多次重复读取JSON数据，所以前面介绍的文章还是有很大的帮助。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>第一步，新建一个名为<code>repeat-submit</code>的SpringBoot项目，然后在POM文件中引入redis、web和aop依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，在<code>application.yml</code>配置文件中新增redis配置信息及项目运行端口信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    password: root</span><br><span class="line">    database: 4</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>第三步，新建redis包，并在redis包内新建一个名为RedisCache的工具类，该类用于封装对Redis的操作。里面定义了两个方法，即对字符串进行存入和查看这两个操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCacheObject(final String key)&#123;</span><br><span class="line">        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void setCacheObject(final String key, final T value, Integer timeout, TimeUnit timeUnit)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，新建annotation包，并在annotation包内新建一个名为RepeatSubmit的注解，该注解可用在需要实现幂等的接口上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface RepeatSubmit &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 两个请求之间的间隔时间，单位毫秒</span><br><span class="line">     * 小于此间隔认为重复提交</span><br><span class="line">     */</span><br><span class="line">    public int interval() default 5000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重复提交时提示信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String message() default &quot;请勿重复提交，稍后再试&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，新建interceptor包，并在interceptor包内新建一个名为IdempotencyInterceptor的抽象类，这个抽象类通过拦截器来拦截所有被<code>RepeatSubmit</code>注解所修饰的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdempotencyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        if(handler instanceof HandlerMethod)&#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            RepeatSubmit annotation = method.getAnnotation(RepeatSubmit.class);</span><br><span class="line">            if(null != annotation)&#123;</span><br><span class="line">                //重复提交</span><br><span class="line">                if(isRepeatSubmit(request,annotation))&#123;</span><br><span class="line">                    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                    map.put(&quot;status&quot;,500);</span><br><span class="line">                    map.put(&quot;message&quot;,annotation.message());</span><br><span class="line">                    response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">                    response.getWriter().write(new ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，具体判断逻辑由子类确定</span><br><span class="line">     */</span><br><span class="line">    public abstract boolean isRepeatSubmit(HttpServletRequest request,RepeatSubmit repeatSubmit);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它重写了preHandle方法的逻辑，首先判断当前handler是否为HandlerMethod的实例，如果是就强转为Method对象并得到方法上的<code>@RepeatSubmit</code>注解。如果该注解存在，然后调用<code>isRepeatSubmit()</code>方法来判断是否为重复提交，如果是则返回既定的重复提交数据提示。注意，这里我们将<code>isRepeatSubmit()</code>方法设置为抽象方法，目的是针对重复提交的实现逻辑可以有很多种，这里我们采用的是根据“URL地址+请求参数”这一方式来判断。后期开发者可以对此有不同的实现，而不用修改此处的重复提交提示信息。</p><p>第六步，在interceptor包内新建一个名为isRepeatSubmit的类，这个类需要继承前面的IdempotencyInterceptor类并重写其中的isRepeatSubmit方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于请求地址URL+请求参数来判断是否重复提交</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RepeatSubmitInterceptor extends IdempotencyInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    public final String REPEAT_PARAMS = &quot;repeatParams&quot;;</span><br><span class="line">    public final String REPEAT_TIME = &quot;repeatTime&quot;;</span><br><span class="line">    public static final String REPEAT_SUBMIT_KEY = &quot;REPEAT_SUBMIT_KEY&quot;;</span><br><span class="line"></span><br><span class="line">    private String HEADER = &quot;Authorization&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，true则表示重复提交</span><br><span class="line">     * @param request</span><br><span class="line">     * @param repeatSubmit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchcked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRepeatSubmit(HttpServletRequest request, RepeatSubmit repeatSubmit) &#123;</span><br><span class="line">        String nowParams = &quot;&quot;;</span><br><span class="line">        if(request instanceof RepeatableReadRequestWrapper)&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = (RepeatableReadRequestWrapper) request;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = requestWrapper.getReader().readLine();</span><br><span class="line">            &#125;catch (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //body参数为空的话，获取Parameter中的参数</span><br><span class="line">        if(ObjectUtils.isEmpty(nowParams))&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = new ObjectMapper().writeValueAsString(request.getParameterMap());</span><br><span class="line">            &#125;catch (JsonProcessingException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //构建一个存于缓存的nowDataMap对象</span><br><span class="line">        Map&lt;String,Object&gt; nowDataMap = new HashMap&lt;&gt;();</span><br><span class="line">        nowDataMap.put(REPEAT_PARAMS,nowParams);</span><br><span class="line">        nowDataMap.put(REPEAT_TIME,System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        //获取请求地址，作为缓存中的key的一部分</span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        //获取消息头，注意这个值唯一,值不存在则使用请求地址</span><br><span class="line">        String header = request.getHeader(HEADER);</span><br><span class="line">        //构建缓存中的key</span><br><span class="line">        String cacheRepeatKey = REPEAT_SUBMIT_KEY + url + header.replace(&quot;Bearer &quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //查询缓存中是否存在对应的数据</span><br><span class="line">        Object cacheObject = redisCache.getCacheObject(cacheRepeatKey);</span><br><span class="line">        if(null != cacheObject)&#123;</span><br><span class="line">            Map&lt;String, Object&gt; cacheMap = (Map&lt;String, Object&gt;) cacheObject;</span><br><span class="line">            //参数一致且时间小于设定的间隔，则说明此为重复提交</span><br><span class="line">            if(compareParams(nowDataMap,cacheMap) &amp;&amp; compareTime(nowDataMap,cacheMap,repeatSubmit.interval()))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存中没有数据，说明不是重复提交</span><br><span class="line">        redisCache.setCacheObject(cacheRepeatKey,nowDataMap,repeatSubmit.interval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的参数是否一致</span><br><span class="line">     * @param nowDataMap 现在的参数值</span><br><span class="line">     * @param preDataMap 之前的参数值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareParams(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap)&#123;</span><br><span class="line">        String nowParams = (String)nowDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        String preParams = (String)preDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        return nowParams.equals(preParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的时间间隔是否小于RepeatSubmit注解中指定的值</span><br><span class="line">     * @param nowDataMap 现在时间</span><br><span class="line">     * @param preDataMap 之前时间</span><br><span class="line">     * @param interval RepeatSubmit注解中指定的时间间隔</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareTime(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap,int interval)&#123;</span><br><span class="line">        long nowTime = (Long)nowDataMap.get(REPEAT_TIME);</span><br><span class="line">        long preTime = (Long)preDataMap.get(REPEAT_TIME);</span><br><span class="line">        if((nowTime - preTime)&lt; interval)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）首先判断当前请求是否为RepeatableReadRequestWrapper的实例，如果是则说明当前请求参数格式为JSON，此时就会通过解析IO流来读取数据，关于这一部分在之前的《SpringBoot实现JSON数据重复读取》一文中进行了介绍；<br>（2）如果当前请求不是RepeatableReadRequestWrapper的实例，说明不是JSON格式，那么可以从请求参数中获取，即以key-value方式读取数据，并使用<code>objectMapper.writeValueAsString()</code>方法来将其转换成字符串；<br>（3）接下来我们构造一个用于存入Redis的对象，注意这里我们使用Redis的String类型，Value为Map对象，然后Map对象中存有从请求中读取的参数和当前时间；<br>（4）然后我们构造Redis的Key，这个Key的格式为“固定前缀+请求地址URL+请求头的令牌”，其中固定前缀值为<code>REPEAT_SUBMIT_KEY</code>，请求头的令牌需要去除其中的<code>Bearer </code>字符串。请注意，请求令牌此处必须添加，这样可以区分用户；<br>（5）根据Key去Redis中查询是否存在对应的缓存数据，如果存在则去判断参数是否相同以及两次请求的时间间隔是否小于既定时间间隔，如果两者同时满足，则说明前后两次请求为重复请求，并返回true；<br>（6）如果不是（5）中的结果，那么说明请求是第一次过来或者说已经过了既定的时间窗口，服务器都接受并处理请求，此时将得到的请求信息重新添加到Redis中，并返回false。</p><p>第七步，新建config包，并在config包内新建一个名为MyWebMvcConfig的配置类，这个配置类需要实现WebMvcConfigurer接口，并重写其中的addInterceptors方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手动将自定义的RepeatSubmitInterceptor拦截器注册到Spring容器中</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，新建request包，并在request包内新建一个名为RepeatableReadRequestWrapper的类，<br>这个类需要继承HttpServletRequestWrapper类并重写其中的getInputStream和getReader方法，同时重载一下父类ServletRequestWrapper中有HttpServletRequest和HttpServletResponse对象的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义请求包装类</span><br><span class="line"> */</span><br><span class="line">public class RepeatableReadRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private final byte[] bytes;</span><br><span class="line"></span><br><span class="line">    public RepeatableReadRequestWrapper (HttpServletRequest request,HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        bytes = request.getReader().readLine().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() throws IOException &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int available() throws IOException &#123;</span><br><span class="line">                return bytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() throws IOException &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是自定义了一个新的HttpServletRequest类，并重载了一个包含HttpServletRequest和HttpServletResponse对象的构造方法，目的就是修改请求和响应的字符编码格式以及从IO流出读取数据，然后存入一个字节数组中，并通过重写getInputStream和getReader方法分别从字节数组中获取数据并构造IO流进行返回，这样就实现了IO流的多次读取。</p><p>第九步，新建filter包，并在filter包内新建一个名为RepeatRequestFilter的类，这个类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 请求拦截器，只有JSON数据才会使用自定义的RequestWrapper</span><br><span class="line"> */</span><br><span class="line">public class RepeatRequestFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        if(StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE))&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = new RepeatableReadRequestWrapper(request,(HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(requestWrapper,servletResponse);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们重写了doFilter方法，目的就是判断请求的类型，如果请求是HttpServletRequest且请求数据类型为JSON格式才会调用自定义的RepeatableReadRequestWrapper，即将HttpServletRequest替换为RepeatableReadRequestWrapper，走IO流可以多次读取的逻辑，之后让过滤器继续往下执行。</p><p>请注意，过滤器最好不要使用<code>@Component</code>注解交由Spring容器来管理，这样会导致每个接口都会被进行过滤，最好是开发者自己手动注册，并且配置过滤的接口。</p><p>第十步，在之前定义的MyWebMvcConfig类中将这个自定义的RepeatRequestFilter过滤器注册进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手动将自定义的RepeatRequestFilter过滤器注册到Spring容器中</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">FilterRegistrationBean&lt;RepeatRequestFilter&gt; repeatRequestFilterFilterRegistrationBean()&#123;</span><br><span class="line">    FilterRegistrationBean&lt;RepeatRequestFilter&gt; bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new RepeatRequestFilter());</span><br><span class="line">    bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十一步，新建controller包，并在controller包内新建一个名为RepeatSubmitController的类，我们在该类中提供一个名为<code>/repeat</code>的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RepeatSubmitController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RepeatSubmitController.class);</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/repeat&quot;)</span><br><span class="line">    @RepeatSubmit(interval = 2000)</span><br><span class="line">    public String repeat(@RequestBody String message)&#123;</span><br><span class="line">        logger.info(&quot;message is: &#123;&#125;&quot;,message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于需要提交参数因此必须使用POST请求，同时这里设置了重复提交的时间间隔为2秒，即两秒内如有来自同一用户对同一接口多次请求相同参数时，可认为前后请求是重复提交的。</p><p>第十二步，启动项目进行测试。用户构造<code>http://localhost:8888/repeat</code>链接并以JSON形式传递message时，页面第一次会返回获取的message信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e524ea08a42c6655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果两秒内多次请求则会抛出此为重复请求，请稍后重试的提示信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0eb026568eff2fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过判断请求数据格式是否为JOSN形式，如果是则调用增强的HttpServletRequest并从请求中获取请求参数，然后构建Key并从Redis中查询缓存信息，如果缓存中存在则通过请求参数和时间间隔来判断是否为重复提交，如果是则给出相应提示信息并返回false；否则返回认为是非重复提交并返回true，继续后续流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Redis各种数据类型巧用</title>
    <link href="http://envyzhan.asia/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/"/>
    <id>http://envyzhan.asia/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/</id>
    <published>2023-04-20T02:55:30.000Z</published>
    <updated>2023-06-09T13:17:06.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信息：一个key关联一个数据集合，同时要对集合中的数据进行各种操作，诸如统计、排序等。</p><p>那么本篇笔者将结合工作实际，列举六种典型使用Redis的业务场景，如下所示：<br>（1）判断用户登录状态；（2）统计用户连续签到情况；（3）统计每天新增和第二天用户留存数；（4）统计网站访客量（Unique Visitor，UV）；（5）最新评论列表；（6）积分排行榜。</p><p>一般来说，我们面临的用户数量和访问量都是巨大的，如百万、千万级别用户数量，或者千万甚至亿级别的访问量，因此必须选择能够高效统计大量数据的集合类型。不过在此之前，首先需要了解常用的统计模式，并使用合理的数据类型来解决实际问题。</p><p>这里我们一般会使用如下四种统计类型：二值状态统计、基数统计、排序统计和聚合统计。</p><h1 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h1><h3 id="二值状态统计概念"><a href="#二值状态统计概念" class="headerlink" title="二值状态统计概念"></a>二值状态统计概念</h3><p>二值状态统计，即集合中的元素只有0和1这两种状态，统计对应状态出现的次数。</p><p>举个例子，用户在进行打卡签到的时候，只有签到（1）或未签到（0）这两种；判断用户是否登录，也只有已登录（1）或未登录（0）这两种，它们均合适使用二值状态来进行统计。</p><h3 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h3><p>可以使用BitMap来判断海量用户中某个用户是否登录，它提供了<code>GETBIT</code>、<code>SETBIT</code>等命令，通过一个偏移值offset对bit数组的offset位置的bit位进行读写操作，请注意offset从0开始。</p><p>这样只需使用一个<code>login_status</code>集合来存储用户登录状态，然后将用户ID作为offset，如果用户在线则设置为1，下线则设置为0。后续开发者就可以通过<code>GETBIT</code>来判断对应用户是否在线。</p><p><code>SETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>用于设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。</p><p><code>GETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;key&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><p>用于获取 key 的 value 在 offset 处的 bit 位的值，注意当 key 不存在时，返回 0。</p><p>举个例子，当我们需要判断userId为1001用户的登录情况，此时步骤如下：<br>（1）假定用户已经登录，往<code>login_status</code>集合中userId为1001的bit位处设置值为1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 1</span><br></pre></td></tr></table></figure><p>（2）判断该用户是否登录，返回值为1表示已登录，0表示未登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 1001</span><br></pre></td></tr></table></figure><p>（3）用户进行退出操作，将对应的offset值设置为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 0</span><br></pre></td></tr></table></figure><h3 id="统计用户每个月的签到情况"><a href="#统计用户每个月的签到情况" class="headerlink" title="统计用户每个月的签到情况"></a>统计用户每个月的签到情况</h3><p>在签到统计中，每个用户每天的签到使用1个Bit位表示，那么一年的签到只需365个Bit位。而一个月最多只有31天你，那么最多只要31个Bit位。</p><p>现在有一个需求，统计userId为10010的用户在2021年8月份的签到打卡情况，此时该如何操作呢？可以将key设置为<code>userId:sign:&#123;userId&#125;:&#123;yyyyMM&#125;</code>这一格式，月份每一天的值减去1就可以作为offset，因为offset从0开始。</p><p>第一步，假定userId为1001的用户在2021年8月18号签到打卡了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT userId:sign:1001:202108 17 1</span><br></pre></td></tr></table></figure><p>第二步，判断userId为1001的用户在2021年8月18号是否进行了签到打卡：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT userId:sign:1001:202108 17</span><br></pre></td></tr></table></figure><p>第三步，统计userId为1001的用户在2021年8月的签到打卡次数，可以使用<code>BITCOUNT</code>命令，该命令用于统计给定bit数组中，值为1的bit位的数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT userId:sign:1001:202108</span><br></pre></td></tr></table></figure><p>这样就实现了用户每个月签到打卡情况的统计，总的来说还是较为简单。</p><h3 id="统计用户首次打卡时间"><a href="#统计用户首次打卡时间" class="headerlink" title="统计用户首次打卡时间"></a>统计用户首次打卡时间</h3><p>现在有个需求，获取userId为1001的用户在2021年8月份首次签到打卡的时间。</p><p>Redis提供了<code>BITPOS</code>命令，用于返回第一个值为bitValue的offset的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS key bitValue [start] [end]</span><br></pre></td></tr></table></figure><p>默认情况下，<code>BITPOS</code>命令会检测整个位图，开发者可通过可选的start和end参数来指定需要检测的范围。</p><p>可以通过如下命令来获取userId为1001的用户，在2021年8月份首次签到打卡的时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS userId:sign:1001:202108 1</span><br></pre></td></tr></table></figure><p>可以看到返回结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITPOS userId:sign:1001:202108 1</span><br><span class="line">&quot;17&quot;</span><br></pre></td></tr></table></figure><p>请注意返回的是offset，实际值应该是offset+1，即第18天首次签到。</p><h3 id="统计连续签到用户总数"><a href="#统计连续签到用户总数" class="headerlink" title="统计连续签到用户总数"></a>统计连续签到用户总数</h3><p>现在有一份数据，记录了一个亿用户连续7天的签到打卡记录，那么如何统计出这连续7天都连续打卡的用户总数呢？</p><p>前面我们说过，将每天的日期作为 Bitmap的key，userId作为offset，如果用户签到打卡了，那么将offset位置处的bit设置为1。那么这个key所对应集合的每个bit 位的数据，则是一个用户在该日期的打卡记录。</p><p>那么就存在 7 个这样的 Bitmap，可以对这 7 个 Bitmap 的对应的 bit 位做与运算。同样userID的offset都是一样的，当一个userID在 7 个 Bitmap 对应的 offset 位置的 bit的值为 1 ，就说明该用户 7 天连续打卡。之后将结果保存到一个新Bitmap 中，然后通过 <code>BITCOUNT</code>命令来统计 bit值为 1 的个数，就能得到连续打卡 7 天的用户总数。</p><p>实际上Redis 提供了<code>BITOP</code>命令，用于对一个或者多个key的 Bitmap进行位与操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure><p>operation可以是 AND、OR、NOT、XOR等。BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-85af4485654fc32f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>定义了3 个 Bitmap，并将对应的 bit 位做与操作，然后将结果保存到新的 Bitmap中。上述操作指令表示将 3个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，然后对 destmap 执行 BITCOUNT 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line">// 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure><p>可以看到一个包含一亿bit位的 Bitmap占用的内存开销，大约是 12 MB 的内存（10^8/8/1024/1024），那么7 天的 Bitmap 的内存开销约为84 MB。不过开发者最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，这样可以节省内存。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当开发者在实际开发过程中遇到只需统计数据的二值状态时，如判断用户是否登录、IP是否存在黑名单、打卡是否签到等就可以考虑使用BitMap。BitMap只需一个 bit 位就能表示 0 和 1，这在统计海量数据时，将极大减少内存的占用。</p><h1 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h1><h3 id="基数统计概念"><a href="#基数统计概念" class="headerlink" title="基数统计概念"></a>基数统计概念</h3><p>基数统计，即统计一个集合中不重复元素的个数，常见于计算独立用户数（UV）。</p><p>实现基数统计最直接的方法就是使用集合（Set）这种数据结构，当一个元素从未在此集合中出现过，那么便将其添加到集合中，否则不集合保持不变。如果页面访问量巨大，就需要一个非常大的Set来进行统计，这必然会浪费大量的空间。</p><p>实际上这种数据不一定要很精准，可以采用Redis提供的<code>HyperLogLog</code>这一数据结构来解决这种场景的统计问题。</p><p><code>HyperLogLog</code>是一种不精确的去重基数方案，其统计规则是基于概率实现的，标准误差 0.81%，这样的精度足以满足UV统计需求。</p><h3 id="网站的-UV"><a href="#网站的-UV" class="headerlink" title="网站的 UV"></a>网站的 UV</h3><h5 id="采用Set实现"><a href="#采用Set实现" class="headerlink" title="采用Set实现"></a>采用Set实现</h5><p>一个用户一天内多次访问一个网站只能算作一次，因此最先想到的就是使用Redis提供的Set集合来实现。</p><p>举个例子，ID为1001的用户访问index页面时，可以将这个信息放到集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD index:uv 1001</span><br></pre></td></tr></table></figure><p>当这个ID为1001的用户多次访问首页时，Set集合的去重功能可以保证不会重复记录同一个用户ID。之后可通过SCARD命令来统计index页面的uv，该命令返回集合中元素的个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD index:uv</span><br></pre></td></tr></table></figure><h5 id="采用Hash实现"><a href="#采用Hash实现" class="headerlink" title="采用Hash实现"></a>采用Hash实现</h5><p>小明说也可以采用Hash这一数据结构来实现，将用户ID作为Hash集合的key，那么访问某个页面则执行HSET命令将value的值设置为1。这样即使用户重复访问，重复执行命令，也只会将这个userId的值设置为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET index:uv userId:1001 1</span><br></pre></td></tr></table></figure><p>最后利用<code>HLEN</code>命令来统计Hash集合中的元素个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN index:uv</span><br></pre></td></tr></table></figure><h5 id="采用HyperLogLog实现"><a href="#采用HyperLogLog实现" class="headerlink" title="采用HyperLogLog实现"></a>采用HyperLogLog实现</h5><p>Set集合尽管好用，但是如果首页访问量过大，那么一个Set中就保存了上千万个用户的ID，这还仅仅是首页，还有其他页面，这对内存的消耗太大了，同理Hash这种数据结构也是一样的。</p><p>此时就可以使用HyperLogLog这种数据结构，这是一种用于基数统计的数据集合类型，即使数据量很大，计算基数所需的空间也是固定的。每个HyperLogLog最多花费12KB的内存就可以计算2的64次方个元素的基数。</p><p>Redis对HyperLogLog的存储进行了优化，在计数较小时，存储空间采用系数矩阵，占用空间很小。只有在计数很大，稀疏矩阵占用的空间超过了阈值，才会转变成稠密矩阵，占用 12KB 空间。</p><p>开发者可使用<code>PFADD</code>命令，将访问index页面的每个用户ID添加到HyperLogLog中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3 userId4</span><br></pre></td></tr></table></figure><p>然后使用<code>PFCOUNT</code>命令，统计ndex页面的UV值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT index:uv</span><br></pre></td></tr></table></figure><p>当然了，HyperLogLog除了提供上面使用的<code>PFADD</code>和<code>PFCOUNT</code>命令，还提供了<code>PFMERGE</code>命令，用于将多个HyperLogLog合并在一起形成一个新的HyperLogLog。<code>PFMERGE</code>命令语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p>举个例子，在网站上有两个内容差不多的页面，运营人员说需要这两个页面的数据进行合并，也包含UV量，此时就可以使用<code>PFMERGE</code>命令，注意此时同一个用户访问这两个页面只算访问一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3  //3</span><br><span class="line">PFADD comment:uv userId1 userId3 userId4  //3</span><br><span class="line">PFMERGE website:uv index:uv comment:uv  //OK</span><br><span class="line">PFCOUNT website:uv  //4</span><br></pre></td></tr></table></figure><p>可以看到这里我们将多个HyperLogLog进行了合并输出为一个新的HyperLogLog，新HyperLogLog的基数接近于所有输入HyperLogLog的可见集合的并集。</p><h1 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h1><p>我们知道，Redis的4种集合类型（List、Set、Hash和SortedSet）中，只有List和SortedSet是有序的。</p><ul><li>List按照元素插入List的顺序进行排序，通常用于实现消息队列、最新列表、排行榜等；</li><li>SortedSet则是根据元素的score权重进行排序，开发者可自己决定每个元素的权重值，通常用于实现按照一定规则的排行榜（积分数、点赞数、播放量等）。<h3 id="最新评论列表"><a href="#最新评论列表" class="headerlink" title="最新评论列表"></a>最新评论列表</h3><h5 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h5>开发者可以使用List的插入顺序来实现评论列表。举个例子，如微信公众平台的后台回复列表，每一个公众号的文章都对应一个List，这个List就保存了该文章所对应的用户评论。</li></ul><p>当一个用户评论index这个文章时，可以使用LPUSH命令将评论插入到List头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH index zhangsan lisi wangwu</span><br></pre></td></tr></table></figure><p>接着我们再使用LRANGE命令来获取列表指定区间内的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE index 0 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;wangwu&quot;</span><br><span class="line">2)  &quot;lisi&quot;</span><br><span class="line">3)  &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意，并不是所有的最新列表都能使用List来实现，对于一些频繁更新的列表，不太建议使用List，因为List类型的分页可能导致列表元素重复或者漏掉。</strong></p><p>举个例子，假设当前评论列表为<code>List = &#123;A,B,C,D&#125;</code>，其中左侧表示最新评论，即D是最早的评论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list D C B A</span><br></pre></td></tr></table></figure><p>接下来第一页展示最新两个评论，获取到A和B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 0 1</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;A&quot;</span><br><span class="line">2)  &quot;B&quot;</span><br></pre></td></tr></table></figure><p>按照我们预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;C&quot;</span><br><span class="line">2)  &quot;D&quot;</span><br></pre></td></tr></table></figure><p>这是没有问题的，但是如果在展示第二页评论之前，又往列表里面添加了一个新的评论E，评论E通过如下命令插入到List队首：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list E</span><br></pre></td></tr></table></figure><p>那么此时List就变成了<code>List = &#123;A,B,C,D&#125;</code>，此时我们再来执行之前预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;B&quot;</span><br><span class="line">2)  &quot;C&quot;</span><br></pre></td></tr></table></figure><p>可以看到评论B又出现了，原因在于List是利用元素所在的位置进行排序，而一旦有新的元素插入，那么原有数据在List中的位置都会往后移动一位，进而导致读取了旧的元素。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c0aee7c06f112e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>因此只有在不需要分页（如每次只读取列表的前10个元素）或者更新频率比较低（如每天凌晨统计更新一下）的列表才适合使用List数据类型来实现。</p><p>对于需要分页且更新较为频繁的列表，就必须使用有序集合 Sorted Set类型来实现。</p><p>此外，List 类型无法实现通过时间范围查找的最新列表，此功能需要通过有序集合 Sorted Set 类型实现，举个例子以成交时间范围作为条件来查询的订单列表。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><h5 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h5><p>对于最新列表的场景，List和Sorted Set都可以实现，那为啥还使用List呢？直接使用Sorted Set那不是更好，它还可以设置score权重值，排序更为灵活。</p><p>原因在于Sorted Set 类型占用的内存容量是 List 类型的数倍之多，因此对于列表数量不多的情况，可以用 Sorted Set 类型来实现。如一周的音乐榜单，此时需要实时更新播放量，并且需要分页展示。除此以外，排序是根据播放量来决定的，此时List就无法满足。</p><p>开发者可以歌曲ID保存到 Sorted Set 集合中，score 设置成每首歌曲的播放量，该歌曲每播放一次则设置<code>score = score +1</code>。</p><p>举个例子，开发者可以使用<code>ZADD</code>命令，将《城府》和《稻香》这两首歌曲播放量放到musicTop集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD musicTop 100000 城府 9999999 稻香</span><br></pre></td></tr></table></figure><p>然后《城府》这首歌每播放一次，就使用<code>ZINCRBY</code>命令，将score进行加1操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY musicTop 1 城府</span><br></pre></td></tr></table></figure><p>执行结果返回”100001”，这就说明播放次数确实增加了。接着我们需要获取音乐播放量排名前10的歌曲，目前最大播放量是N，可通过如下命令来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE musicTop N-9 N WITHSCORES</span><br></pre></td></tr></table></figure><p>开发者可通过<code>ZREVRANGE key start stop [WITHSCORES]</code>命令来将集合中的元素按照score的值进行递减（从大到小）进行排序。具有相同score的值的成员，则按照字典的逆序进行排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE musicTop 0 0 WITHSCORES</span><br><span class="line"> 1)  &quot;稻香&quot;</span><br><span class="line"> 2)  &quot;9999999&quot;</span><br></pre></td></tr></table></figure><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>即使集合中的元素更新较为频繁，那么Sorted Set也能通过 <code>ZRANGEBYSCORE</code>命令来准确地获取到按序排列的数据。</p><p>当开发者遇到需要展示最新列表、排行榜等业务场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用 Sorted Set。</p><h1 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h1><h3 id="聚合统计概念"><a href="#聚合统计概念" class="headerlink" title="聚合统计概念"></a>聚合统计概念</h3><p>聚合统计，指的是统计多个集合元素的聚合结果，常用的有：<br>（1）统计多个元素的共有数据（交集）；<br>（2）统计多个元素的所有数据（并集）；<br>（3）统计两个集合其中某个独有的元素（差集）。</p><p>Redis的Set类型支持集合内的增删改查，底层使用Hash数据结构，因此无论是add、remove 都是 O(1) 时间复杂度。并且支持多个集合间的交集、并集、差集等操作，利用这些集合操作，可以很方便的解决上面提到的统计问题。</p><h3 id="共同好友（交集）"><a href="#共同好友（交集）" class="headerlink" title="共同好友（交集）"></a>共同好友（交集）</h3><p>举个例子，新浪微博中共同关注的人就是聚合统计中的交集。我们可以将用户Id作为key，该用户关注的用户Id作为Set集合中的value。</p><p>首先模拟两个用户关注的好友：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD userId:1001 1003 1004 1008</span><br><span class="line">SADD userId:1002 1004 1006 1009</span><br></pre></td></tr></table></figure><p>然后统计这两个用户共同关注的好友，就可以使用集合的交集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE userId:1001-1002 userId:1001 userId:1002</span><br></pre></td></tr></table></figure><p>之后两个用户交集都存在了userId:1001-1002这一集合中。</p><h3 id="每日新增用户数（差集）"><a href="#每日新增用户数（差集）" class="headerlink" title="每日新增用户数（差集）"></a>每日新增用户数（差集）</h3><p>举个例子，统计某个App每天新增的用户注册数，只需对近两天的总注册用户量集合进行取差集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE user:20210610-0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户差集都存在了userId:20210610-0609这一集合中，上面统计的是06-10比06-09号多的人数。</p><p>实际上，新浪微博还有一个可能认识的人这一功能，也可以使用差集实现，即将你关注的好友所关注的人减去你们共同关注的人即是可能认识的人。</p><h3 id="总共新增好友（并集）"><a href="#总共新增好友（并集）" class="headerlink" title="总共新增好友（并集）"></a>总共新增好友（并集）</h3><p>举个例子，统计某个App在2021-06-09和2021-06-10这两天，总的用户注册数，只需对近两天的总注册用户量集合进行取并集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE user:20210610+0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户并集都存在了userId:20210610+0609这一集合中。</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>Set的交集、并集、差集等操作计算的复杂度较高，在数据量比较大的情况下，直接执行这些操作可能会导致Redis实例阻塞。可以考虑专门部署一个集群用于统计，让它专门负责聚合计算或者是将数据读取到客户端，在客户端完成聚合统计，这样可以避免由于阻塞而导致其他服务无法快速响应的局面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信</summary>
      
    
    
    
    <category term="redis" scheme="http://envyzhan.asia/categories/redis/"/>
    
    
    <category term="redis" scheme="http://envyzhan.asia/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊Redis中的布隆过滤器</title>
    <link href="http://envyzhan.asia/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/"/>
    <id>http://envyzhan.asia/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/</id>
    <published>2023-04-06T11:55:30.000Z</published>
    <updated>2023-06-09T13:12:18.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写在前面<br>本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</p><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>在实际开发过程中遇到过这种情况，用户在使用APP阅读文章时，如何做到每次推荐给该用户的文章不重复，即需要过滤掉他已经阅读过的文章。</p><p>此时有人可能会说我们可以记录每个用户的浏览历史，然后每次在推荐的时候查询用户的浏览记录并进行过滤，进而实现文章的去重。如果开发者将用户的浏览历史存储在关系型数据库中，那么就需要频繁的对数据库进行exists判断，在并发量不高的情况下还能正常响应，但是一旦并发量上来，数据库是扛不住的。</p><p>那么又有人说，可以将这些浏览历史存在缓存中。请注意，千万不要将它们存在缓存中，这样会浪费很多内存，而且缓存适合更新频率比较低的情况，而用户的浏览历史可能每时每刻都在变化。</p><p>针对上述情况，即遇到数据量较大，又需要去重的时候，就可以考虑使用布隆过滤器。一般来说，布隆过滤器适用于如下场景：<br>（1）解决Redis中缓存穿透问题；<br>（2）爬虫过滤，对爬虫爬过的网站进行过滤，爬过的不再爬取；<br>（3）内容推荐，对已经推荐过的内容进行过滤，不再推荐；<br>（4）邮件过滤，对邮件设置的黑名单进行过滤；<br>……</p><h1 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h1><p>布隆过滤器 (Bloom Filter)由Burton Howard Bloom于1970年提出，它是一种 space efficient 的概率型数据结构，用于判断一个元素是否在集合中。</p><p>如果布隆过滤器说某个数据存在，那么这个数据实际上可能不存在；但是如果说某个数据不存在，那么此时这个数据一定不存在，即一种概率性的判断。</p><p>你可能会说判断元素是否在集合中，最简单的可以使用哈希表，但是完成同样问题时，布隆过滤器只需哈希表的1/8或1/4的空间复杂度。</p><p>请注意，布隆过滤器可以插入元素，但是不可以删除已有元素。而且布隆过滤器中的元素越多，那么<code>false positive rate</code>(误报率)越大，不过不会发生 <code>false negative</code> (漏报)。</p><h1 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h1><p>首先看下面一张图，快速了解一下布隆过滤器的原理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fe0098fcc3e04f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先分配一块内存空间做bit数组，数组的bit位初始值均为0。</p><p>接着往其中添加元素时，采用K个相互独立的 Hash 函数计算，然后将元素Hash 映射的K个位置全部设置为1。</p><p>当需要检测元素是否存在，会使用这K个 Hash 函数计算出 K 个位置，如果位置全部为1，则说明元素存在；否则不存在。</p><p><strong>由于哈希函数会出现碰撞，因此布隆过滤器也存在误判</strong>。一般我们会使用误判率，而误判率是指布隆过滤器判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值。因此有概率存在这样的 key，它们内容不同，但经过多次 Hash 后的 Hash 值相同。</p><p><strong>布隆过滤器判断某个元素不存在，那么这个元素必定不存在；判断某个元素存在，那么这个元素可能不存在</strong>。可以使用反证法进行验证，如果元素存在，那么它每次Hash计算后的Hash值位置必然为1，而不是0。</p><p>前面说了，可以往布隆过滤器中插入元素，但是不可以删除已有元素，为什么是这样呢？我们知道，删除意味着需要将对应的K个bit位置设置为0，而这些有可能是其他元素对应的bit，因此删除会发生<code>false negative </code>(漏报)，这是不允许的。</p><h1 id="Redis集成布隆过滤器"><a href="#Redis集成布隆过滤器" class="headerlink" title="Redis集成布隆过滤器"></a>Redis集成布隆过滤器</h1><p>Redis在4.0的时候官方提供插件机制，用于提供对布隆过滤器的支持。开发者可以点击 <a href="https://redis.com/redis-enterprise-software/download-center/software/">这里</a> 下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e1ea925af27287ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>使用布隆过滤器最低需要4.x版本，不过笔者建议使用6.x版本。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>开发者可以自行编译安装，从 github 下载，笔者使用的 release 版本是 v2.2.18，下载地址 <a href="https://github.com/RedisBloom/RedisBloom/releases/tag/v2.2.18">点击</a> 这里：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5865ad76ef8b2717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后将其进行解压，编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf RedisBloom-2.2.18.tar</span><br><span class="line">cd RedisBloom-2.2.18</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>之后会生成一个名为<code>redisbloom.so</code>的文件，那么接下来我们就是安装集成它了。</p><p>修改<code>redis.conf</code>文件，在里面新增一个loadmodule，值为上面生成的<code>redisbloom.so</code>文件的全路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集成BloomFilter</span><br><span class="line">loadmodule /home/envy/RedisBloom-2.2.18/redisbloom.so</span><br></pre></td></tr></table></figure><p>之后重启Redis，注意如果是Redis集群，那么每个实例的配置文件都需要加入该配置项。</p><p>启动的时候我们需要以指定配置文件启动Redis，进入到Redis的bin目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../conf/redis.conf</span><br></pre></td></tr></table></figure><p>然后使用客户端连接到Redis，开始进行测试。布隆过滤器常用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个元素到布隆过滤器</span><br><span class="line">BF.ADD element bloomfilter</span><br><span class="line"># 判断元素是否在布隆过滤器中</span><br><span class="line">BF.EXISTS element bloomfilter</span><br><span class="line"># 添加多个元素到布隆过滤器</span><br><span class="line">BF.MADD element1 element2 bloomfilter</span><br><span class="line"># 判断多个元素是否在布隆过滤器</span><br><span class="line">BF.MEXISTS element1 element2 bloomfilter</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9ec37586591616dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Redis布隆过滤器实战"><a href="#Redis布隆过滤器实战" class="headerlink" title="Redis布隆过滤器实战"></a>Redis布隆过滤器实战</h1><p>前面也说过，在Redis中布隆过滤器常用的作用就是解决缓存穿透问题，所谓的缓存穿透是指请求查询不存在的数据，即缓存和数据库中都没有的数据。</p><p>接下来我们模拟一个场景：用户在购买商品创建订单时，我们会往MQ中发送消息，将订单ID添加到布隆过滤器中，之后判断订单是否存在。整个流程如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ee80ba9daeed5da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="BF-RESERVE命令详解"><a href="#BF-RESERVE命令详解" class="headerlink" title="BF.RESERVE命令详解"></a><code>BF.RESERVE</code>命令详解</h3><p>前面的过程我们不编写具体的代码，而是通过一些数据来模拟对应的操作。首先我们来了解<code>BF.RESERVE</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION &#123;expansion&#125;] [NONSCALING]</span><br></pre></td></tr></table></figure><p>解释一下上述参数的含义：<br>（1）key是布隆过滤器的名称；<br>（2）<code>error_rate</code>是期望的错误率，默认值为0.1，值越低需要的空间就越大；<br>（3）<code>capacity</code>是初始容量，默认值为100，当实际元素的数量超出这个初始容量值时，错误率会上升；<br>（4）EXPANSION 是可选参数，当添加到布隆过滤器中的元素数量达到初始容量后，不会扩容过滤器，并且会抛出异常（<code>(error) ERR non scaling filter is full</code>）。这说明布隆过滤器的扩容是通过增加布隆过滤器的层数来完成的。每增加一层，查询时就可能会遍历多层布隆过滤器，默认情况下每一层的容量都是上一层的两倍。</p><p><strong>请注意，如果不使用<code>BF.RESERVE</code>命令来创建布隆过滤器，而使用Redis自动创建的布隆过滤器，那么默认的<code>error_rate</code>为0.1，初始容量为100。</strong></p><p>布隆过滤器的<code>error_rate</code>越小，需要的存储空间就越大，对于不需要过于精确的业务场景来说，<code>error_rate</code>的值可以设置大一些。</p><p>布隆过滤器的<code>capacity</code>设置的过大，会浪费存储空间；设置过小会影响准确率，因此在使用布隆过滤器之前，最好尽可能的精确估计元素的数量，同时加上一定的冗余空间，这样可避免实际元素会超出设定值很多的情况。</p><h3 id="创建orders布隆过滤器"><a href="#创建orders布隆过滤器" class="headerlink" title="创建orders布隆过滤器"></a>创建orders布隆过滤器</h3><p>接下来我们使用<code>BF.RESERVE</code>命令来手动创建一个名为orders的布隆过滤器，注意<code>error_rate</code>为0.1，初始容量为1000万：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE orders 0.1 10000000</span><br></pre></td></tr></table></figure><h3 id="添加订单ID到布隆过滤器"><a href="#添加订单ID到布隆过滤器" class="headerlink" title="添加订单ID到布隆过滤器"></a>添加订单ID到布隆过滤器</h3><p>接下来我们尝试使用<code>BF.ADD</code>命令往orders这一布隆过滤器中添加10010这一订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD orders 10010</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.ADD orders 10010</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>当然了也可以一次性添加三个订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.MADD orders 10011 10012 10013</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MADD orders 10011 10012 10013</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="判断订单是否存在"><a href="#判断订单是否存在" class="headerlink" title="判断订单是否存在"></a>判断订单是否存在</h3><p>开发者可以使用<code>BF.EXISTS</code>命令来判断某一元素是否存在于布隆过滤器中，返回值为1表示存在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.EXISTS orders 10011</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果想要批量检查多个元素是否在布隆过滤器中，可以使用<code>BF.MEXISTS</code>命令，该命令返回的是一个数组，其中1表示存在，0表示不存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element1 element2......</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011、10012、10013和10014的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MEXISTS orders 10011 10012 10013 10014</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br><span class="line"> 4)  &quot;0&quot;</span><br></pre></td></tr></table></figure><p>也就是说我们可以通过<code>BF.RESERVE</code>、<code>BF.ADD</code>和<code>BF.EXISTS</code>这三个命令来避免缓存穿透问题。</p><h3 id="查看创建的布隆过滤器信息"><a href="#查看创建的布隆过滤器信息" class="headerlink" title="查看创建的布隆过滤器信息"></a>查看创建的布隆过滤器信息</h3><p>开发者可以使用<code>BF.INFO key</code>命令来查看创建的布隆过滤器信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.INFO orders</span><br><span class="line"> 1)  &quot;Capacity&quot;</span><br><span class="line"> 2)  &quot;10000000&quot;</span><br><span class="line"> 3)  &quot;Size&quot;</span><br><span class="line"> 4)  &quot;7794184&quot;</span><br><span class="line"> 5)  &quot;Number of filters&quot;</span><br><span class="line"> 6)  &quot;1&quot;</span><br><span class="line"> 7)  &quot;Number of items inserted&quot;</span><br><span class="line"> 8)  &quot;4&quot;</span><br><span class="line"> 9)  &quot;Expansion rate&quot;</span><br><span class="line"> 10)  &quot;2&quot;</span><br></pre></td></tr></table></figure><p>解释一下上述返回值的含义：<br>（1）Capacity表示预设容量，即初始容量；<br>（2）Size表示实际占用情况，但如何计算需要进一步确认；<br>（3）Number of filters表示过滤器层数；<br>（4）Number of items inserted表示已经实际插入的元素数量；<br>（5）Expansion rate表示子过滤器扩容系数（默认值为2）。</p><h3 id="无法删除布隆过滤器"><a href="#无法删除布隆过滤器" class="headerlink" title="无法删除布隆过滤器"></a>无法删除布隆过滤器</h3><p>目前布隆过滤器是无法删除的，但是布谷过滤器(Cuckoo Filter)支持删除。</p><p>布隆过滤器在插入项目时通常表现出更好的性能和可伸缩性，因此如果开发者经常向数据集中添加元素，那么此时布隆过滤器还可以接受。不过布谷过滤器在检查操作上更快，也支持删除，可以点击 <a href="https://oss.redis.com/redisbloom/Cuckoo_Commands/">这里</a> 进行阅读。实际上本篇文章中的实战就来自于Redis官方提供的Redis布隆过滤器实战，可以点击 <a href="https://oss.redis.com/redisbloom/">这里</a> 进行阅读。</p><h1 id="Redission布隆过滤器实战"><a href="#Redission布隆过滤器实战" class="headerlink" title="Redission布隆过滤器实战"></a>Redission布隆过滤器实战</h1><h3 id="RBloomFilter接口"><a href="#RBloomFilter接口" class="headerlink" title="RBloomFilter接口"></a>RBloomFilter接口</h3><p>在Redisson中，与BloomFilter相关的操作都被定义到RBloomFilter接口中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface RBloomFilter&lt;T&gt; extends RExpirable &#123;</span><br><span class="line">    //添加元素</span><br><span class="line">    boolean add(T object);</span><br><span class="line">  </span><br><span class="line">    //判断元素是否存在</span><br><span class="line">    boolean contains(T object);</span><br><span class="line"></span><br><span class="line">    //根据指定的参数来初始化布隆过滤器</span><br><span class="line">    boolean tryInit(long expectedInsertions, double falseProbability);</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素的预期插入量</span><br><span class="line">    long getExpectedInsertions();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回元素存在的错误概率</span><br><span class="line">    double getFalseProbability();</span><br><span class="line"></span><br><span class="line">    //返回此实例所需的Redis内存中的bit数</span><br><span class="line">    long getSize();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素使用的哈希迭代次数</span><br><span class="line">    int getHashIterations();</span><br><span class="line"></span><br><span class="line">    //计算已添加到布隆过滤器的元素的概率数</span><br><span class="line">    long count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>，创建一个名为<code>redisson-fly</code>的SpringBoot项目，注意后续关于其他数据结构的代码都在这个项目中进行编写：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc0d405fc4ee701e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.13.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>application.yml</code>配置文件中新增如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.51.131</span><br><span class="line">    port: 6379</span><br><span class="line">    ssl: false</span><br><span class="line">    password: envy123</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，由于这里我们不对外提供接口，因此我们只创建service类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BoolFilterService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建布隆过滤器</span><br><span class="line">     * @param filterName 布隆过滤器</span><br><span class="line">     * @param expectedInsertions 预测插入数量</span><br><span class="line">     * @param falseProbability 误判率</span><br><span class="line">     * @param &lt;T&gt; 泛型</span><br><span class="line">     * @return 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; RBloomFilter&lt;T&gt; create(String filterName,long expectedInsertions,double falseProbability)&#123;</span><br><span class="line">        RBloomFilter&lt;T&gt; bloomFilter = redissonClient.getBloomFilter(filterName);</span><br><span class="line">        bloomFilter.tryInit(expectedInsertions, falseProbability);</span><br><span class="line">        return bloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，针对这个BoolFilterService类创建对应的测试类及测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class BoolFilterServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BoolFilterService boolFilterService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBloomFilter()&#123;</span><br><span class="line">        //布隆过滤器名称</span><br><span class="line">        String bloomFilterName = &quot;ipBlackList&quot;;</span><br><span class="line">        //初始容量</span><br><span class="line">        long expectedInsertions = 10000L;</span><br><span class="line">        //误判率</span><br><span class="line">        double falseProbability = 0.01;</span><br><span class="line">        RBloomFilter&lt;Long&gt; bloomFilter = boolFilterService.create(bloomFilterName, expectedInsertions, falseProbability);</span><br><span class="line"></span><br><span class="line">        //往布隆过滤器中添加元素</span><br><span class="line">        for (long i = 0; i &lt; expectedInsertions; i++) &#123;</span><br><span class="line">            bloomFilter.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long elementCount = bloomFilter.count();</span><br><span class="line">        log.info(&quot;布隆过滤器中的元素个数为：&#123;&#125;&quot;,elementCount);</span><br><span class="line"></span><br><span class="line">        //统计布隆过滤器中误判次数，即实际上不存在但是布隆过滤器却说存在的次数</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (long i = expectedInsertions; i &lt; expectedInsertions * 2; i++) &#123;</span><br><span class="line">            if(bloomFilter.contains(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;布隆过滤器中的误判次数为：&#123;&#125;&quot;,count);</span><br><span class="line">        //删除布隆过滤器</span><br><span class="line">        bloomFilter.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试逻辑非常简单，定义一个名为ipBlackList的布隆过滤器，然后设置初始容量为10000，误判率为0.01。然后往里面添加0-10000这些数字，接着我们判断10001到20000是否在这个ipBlackList中，进而得到误判的次数。</p><p>当然了，如果上面使用的是Redis集群，那么需要使用如下命令来初始化布隆过滤器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;Long &gt; bloomFilter = redisson.getClusteredBloomFilter(&quot;redisCluster&quot;);</span><br></pre></td></tr></table></figure><p>运行该测试方法，可以看到结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的元素个数为：9895</span><br><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的误判次数为：259</span><br></pre></td></tr></table></figure><p>可以看到是比较符合我们预定的误判率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布隆过滤器的思想就是判断元素可能存在或者一定不存在，因此在使用时需要结合实际情况进行分析。</p><p>参考资料：<a href="https://mp.weixin.qq.com/s/MFqQOzyO1zhrHF_Xcl0dvA">Redis 布隆（Bloom Filter）过滤器原理与实战</a>、<a href="https://redis.io/docs/stack/bloom/">Redis官方文档</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;写在前面&lt;br&gt;本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</summary>
      
    
    
    
    <category term="redis" scheme="http://envyzhan.asia/categories/redis/"/>
    
    
    <category term="redis" scheme="http://envyzhan.asia/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>功能开关在业务中的实践</title>
    <link href="http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/"/>
    <id>http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/</id>
    <published>2023-03-01T09:55:30.000Z</published>
    <updated>2023-03-14T07:11:51.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但是后续发现这样有个弊端，即只能针对一个活动或者相同时间的多个活动生效，而实际上我们的活动有多个，权衡再三决定使用功能开关来实现。</p><h1 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h1><p>功能开关其实是一种代码可配置性的实践，说到底就是通过控制开关的状态来实现对功能的决定控制。</p><p>功能开关的实现有很多种方式，可以使用MySQL或者Redis等数据库，出于对后续数据扩展和对存储容量的考量，此处使用Bit数组来实现。</p><h3 id="Bit数组原理"><a href="#Bit数组原理" class="headerlink" title="Bit数组原理"></a>Bit数组原理</h3><p>既然是数组，那么下标必然从0开始，bit只有两种取值，要么为0，要么为1：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3049804d68aadfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>而0和1正好对应开关的关闭和启用，即ON和OFF状态。之后开发者只需定义好每个开关所在的Bit数组的索引号和状态即可，这样后续就可以通过判断开关的状态来实现对功能的控制：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-e89b847c9308657f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到使用这种方式所占用的内存空间非常少，理论上只需占用2n位的内存，n为开关的数量。</p><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>Java中对于Bit数组可以使用BitSet来实现 ，里面有很多方法，这里我们摘几个用到的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BitSet implements Cloneable, java.io.Serializable &#123;</span><br><span class="line">    //给指定位置设置值</span><br><span class="line">    public void set(int bitIndex, boolean value) &#123;&#125;</span><br><span class="line">    //给指定位置的值取反操作</span><br><span class="line">    public void clear(int bitIndex) &#123;&#125;</span><br><span class="line">    //获取指定位置的值</span><br><span class="line">    public boolean get(int bitIndex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，新建开关状态常量SwitchConst：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关常量</span><br><span class="line"> */</span><br><span class="line">public class SwitchConst &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用</span><br><span class="line">     */</span><br><span class="line">    public static final boolean ON = true;</span><br><span class="line">    /**</span><br><span class="line">     * 关停</span><br><span class="line">     */</span><br><span class="line">    public static final boolean OFF = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于开关只有开和闭这两种状态，因此可以不使用枚举类。</p><p>第二步，新建功能开关枚举类SwitchEnum，这个就是开发者所要定义的开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能开关枚举类</span><br><span class="line"> */</span><br><span class="line">public enum SwitchEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * HTTPS</span><br><span class="line">     */</span><br><span class="line">    HTTPS(0,SwitchConst.ON,&quot;HTTPS设置&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 充值会员</span><br><span class="line">     */</span><br><span class="line">    RECHARGE(1,SwitchConst.OFF,&quot;充值送油卡&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下标</span><br><span class="line">     */</span><br><span class="line">    private int index;</span><br><span class="line">    /**</span><br><span class="line">     * 默认状态</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    SwitchEnum(int index,boolean status,String desc)&#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getIndex()&#123;</span><br><span class="line">        return this.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean getStatus()&#123;</span><br><span class="line">        return this.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return this.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;name=%s,desc=%s&quot;,name(),desc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>第三步，新建开关状态切换接口Switch，里面定义切换开关状态和判断接口状态的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关转态切换</span><br><span class="line"> */</span><br><span class="line">public interface Switch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOn(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOff(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断开关状态</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    boolean judgeStatus(SwitchEnum switchEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个BitSetSwitch，表示基于BitSet实现的开关，因此需要实现Switch接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum BitSetSwitch implements Switch&#123;</span><br><span class="line">    MYBITSET;</span><br><span class="line"></span><br><span class="line">    BitSetSwitch()&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOn(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.set(switchEnum.getIndex(),SwitchConst.ON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOff(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.clear(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean judgeStatus(SwitchEnum switchEnum) &#123;</span><br><span class="line">        return bitSet.get(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        Stream.of(SwitchEnum.values()).forEach(item-&gt;bitSet.set(item.getIndex(),item.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将BitSetSwitch设置为了一个枚举类，目的就是通过单例生成一个BitSetSwitch对象。注意不能将其设置为普通的类，如果那样的话，在使用的时候就需要通过new关键字生成BitSetSwitch对象，而且每调用一次就得新创建一个对象，这肯定是不行的，功能开关肯定是全局唯一的。</p><p>第五步，新建测试类SwitchTest，测试一下功能开关的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSetSwitch bitSetSwitch = BitSetSwitch.MYBITSET;</span><br><span class="line">        bitSetSwitch.turnOn(SwitchEnum.HTTPS);</span><br><span class="line">        bitSetSwitch.turnOff(SwitchEnum.RECHARGE);</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.HTTPS,bitSetSwitch.judgeStatus(SwitchEnum.HTTPS)));</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.RECHARGE,bitSetSwitch.judgeStatus(SwitchEnum.RECHARGE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行该方法，可以发现控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开关【name=HTTPS,desc=HTTPS设置】，状态为：true</span><br><span class="line">开关【name=RECHARGE,desc=充值送油卡】，状态为：false</span><br></pre></td></tr></table></figure><p>这说明当前项目开启了HTTPS设置，但是关停了充值送油卡这一活动。后期要实现灵活控制，可配合配置中心在配置文件中进行控制。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>功能开关在实际开发过程中非常实用，因此有必要在理解的基础上进行灵活使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins+Gitlab一键打包部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/</id>
    <published>2023-02-26T14:55:30.000Z</published>
    <updated>2023-03-14T06:52:35.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行。当我们的应用数量较多时，还可以使用Docker Compose的方式，但是毫无疑问上面的种种还都只是手动部署，本篇来学习如何使用Jenkins和Gitlab来实现一键打包部署SpringBoot应用。</p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><h3 id="GitLab简介"><a href="#GitLab简介" class="headerlink" title="GitLab简介"></a>GitLab简介</h3><p>GitLab是一款开源的基于Git的版本仓库管理工具，开发者可以使用它来搭建属于自己的Git仓库。</p><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><p><strong>第一步</strong>，下载GitLab的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/gitlab/config</span><br><span class="line">mkdir -p /mydata/gitlab/logs</span><br><span class="line">mkdir -p /mydata/gitlab/data</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动GitLab服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10443:443 -p 1080:80 -p 1022:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">-v /mydata/gitlab/config:/etc/gitlab \</span><br><span class="line">-v /mydata/gitlab/logs:/var/log/gitlab \</span><br><span class="line">-v /mydata/gitlab/data:/var/opt/gitlab \</span><br><span class="line">-d  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，开启防火墙：<br>由于Gitlab运行在1080端口，因此我们需要开放该端口，注意不能直接关闭防火墙，否则Gitlab会无法启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启1080端口</span><br><span class="line">firewall-cmd --zone=public --add-port=1080/tcp --permanent</span><br><span class="line"># 重启防火墙才能生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，打开浏览器，访问<code>http://宿主机IP:1080</code>链接，查看GitLab是否已经正常启动。请注意，由于GitLab启动比较慢，需要耐心等待10分钟左右，如果GitLab没有启动完成就访问，会出现502的错误。</p><p>开发者可以使用<code>docker logs gitlab -f</code>命令来动态查看容器启动日志，进而确定Gitlab是否已经启动完成。</p><p>之后访问<code>http://宿主机IP:1080</code>链接，可以看到GitLab已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebe4ce1f76be102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以使用如下命令来查看root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it gitlab grep &#x27;Password:&#x27; /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure><p>然后使用root用户加上上面得到的密码进行登录，注意root用户和kenbings用户的密码均为kenbings：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-298f808bd29ae8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="GitLab使用"><a href="#GitLab使用" class="headerlink" title="GitLab使用"></a>GitLab使用</h3><h5 id="创建组织"><a href="#创建组织" class="headerlink" title="创建组织"></a>创建组织</h5><p>首先创建一个组织，然后在这个组织下分别创建用户和项目，这样同组织的用户就可以使用该组织下的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-56b7f4bf0f6b38ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f18564bf73bb1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04c57d1455b307de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3de88e91015ce63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7126f255b6e95fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>点击 <a href="https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe">这里</a> 进行下载，然后一路Next进行安装。</p><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h5 id="下载代码到本地"><a href="#下载代码到本地" class="headerlink" title="下载代码到本地"></a>下载代码到本地</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http或者git地址</span><br></pre></td></tr></table></figure><h5 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h5><p>进入一个名为hello的项目目录，修改<code>README.md</code>并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入项目工程目录</span><br><span class="line">cd hello/</span><br><span class="line"># 将当前修改的文件添加到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 提交代码</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br></pre></td></tr></table></figure><h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h5 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="本地创建并提交分支"><a href="#本地创建并提交分支" class="headerlink" title="本地创建并提交分支"></a>本地创建并提交分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换并从当前分支创建一个dev分支</span><br><span class="line">git checkout -b dev</span><br><span class="line"># 将新创建的dev分支推送到远程仓库</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h5 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换到dev分支</span><br><span class="line">git checkout dev</span><br><span class="line"># 查看本地仓库文件状况</span><br><span class="line">git status</span><br><span class="line"># 查看本地所有分支</span><br><span class="line">git branch</span><br><span class="line"># 查看提交记录</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><p>Jenkins是开源CI&amp;CD软件的领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要，开发者可以用Jenkins来构建和部署自己的项目。举个例子，可以从自定义的代码仓库中获取代码，然后将代码打包成可执行的文件，之后通过远程的ssh工具执行脚本，最终实现运行项目这一目的。</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><strong>第一步</strong>，下载Jenkins的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/jenkins_home</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动Jenkins服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 50000:5000 --name jenkins \</span><br><span class="line">-u root \</span><br><span class="line">-v /mydata/jenkins_home:/var/jenkins_home \</span><br><span class="line">-d jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><h3 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h3><p>Jenkins服务启动后，然后访问<code>http://宿主机IP:8080</code>链接，页面出现如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-24988fcf53f76a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后使用如下命令从启动日志中获取到管理员密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs jenkins</span><br></pre></td></tr></table></figure><p>接着进行登录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d190ae88cf70c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择安装插件方式，这里我们直接安装推荐的插件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-74523a9030f27c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着就进入插件安装界面，联网等待插件安装：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f13bb799ee18f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>安装完成后，接下来我们创建一个管理员账号，账户和密码均为admin：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8785e2fbb1588637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后进行实例配置，配置Jenkins的访问URL：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dcfc0c2c2f0e81f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-703a4bbfdf686f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着点击“Manage Jenkins”–》“Manage Plugins”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-89737123c424524e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>确保以下插件被正确安装：<br>（1）根据角色管理权限的插件：Role-based Authorization Strategy；<br>（2）配置远程服务器：Publish Over SSH。</p><p>接下来新增maven的安装配置，点击“Manage Jenkins”–》“Global Tool Configuration”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8fbf0437fb8b534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-68ff4208251976f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后新增凭据，点击“Manage Jenkins”–》“Global Tool Configuration”，接着按照图片所示进行操作（注意里面配置的是通过ssh连接到宿主机的用户名和密码）：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-871bf5cc27c8425d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea8e8f2989b50dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着在点击“Manage Jenkins”–》“Configure System”，中添加全局ssh的配置，这样Jenkins使用ssh就可以执行远程linux的脚本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-914d9729c1e0f46c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Jenkins角色权限管理"><a href="#Jenkins角色权限管理" class="headerlink" title="Jenkins角色权限管理"></a>Jenkins角色权限管理</h3><p>开发者可以使用Jenkins的角色管理插件，来管理Jenkins的用户。举个例子，开发者可以给管理员赋予所有权限，给运维人员赋予执行任务的相关权限，而其他人员只赋予查看权限。</p><p>点击“Manage Jenkins”–》“Configure Global Security”，然后在里面启用基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9b38969b1d3d829f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们点击“Manage Jenkins”–》“Manage and Assign Roles”，然后在里面开始配置基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-00ae69b2af0f6f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fee924fad0462233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Manage Roles”，添加角色与权限关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-01c4781f8148613d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Assign Roles”，给用户分配角色：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64cdd0024c1e66f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="打包部署SpringBoot应用"><a href="#打包部署SpringBoot应用" class="headerlink" title="打包部署SpringBoot应用"></a>打包部署SpringBoot应用</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-jenkins</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-jenkins</code>这一Module中进行。</p><h3 id="将代码上传到GItlab中"><a href="#将代码上传到GItlab中" class="headerlink" title="将代码上传到GItlab中"></a>将代码上传到GItlab中</h3><p>修改POM文件中build标签中的内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>注意此处需要将dockerHost地址修改为开发者自己的Docker镜像仓库地址。同时项目在容器中运行的端口需要与后续启动脚本中的端口保持一致，这里为8088端口。</p><p>然后依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /shop-jenkins</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init project&quot;</span><br><span class="line">git remote add origin http://192.168.51.160:1080/myshop/shop-gitlab-jenkins.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -uf origin main</span><br></pre></td></tr></table></figure><p>注意如果在推送代码的过程中出现如下问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9af484a83d6a3321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>主要原因是因为向一个受保护的分支强制提交了代码，可以在仓库里面进行设置来解决这个问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c40f2c4217fef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e67581d3b3b7c47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="定义一个执行脚本"><a href="#定义一个执行脚本" class="headerlink" title="定义一个执行脚本"></a>定义一个执行脚本</h3><p>在<code>/mydata/sh</code>目录下定义一个名为<code>shop-jenkins.sh</code>的脚本，其中的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">app_name=&#x27;shop-jenkins&#x27;</span><br><span class="line">docker stop $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----stop container-----&#x27;</span><br><span class="line">docekr rm $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----rm container-----&#x27;</span><br><span class="line">docker run -p 8088:8088 --name $&#123;app_name&#125; \</span><br><span class="line">--link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/$&#123;app_name&#125;/logs:/var/logs \</span><br><span class="line">-d myshop-all/$&#123;app_name&#125;:0.0.1-SNAPSHOT</span><br><span class="line">echo &#x27;----start container----&#x27;</span><br></pre></td></tr></table></figure><p>注意里面的映射的端口信息，接着给该脚本赋予可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shop-jenkins.sh</span><br></pre></td></tr></table></figure><p>如果开发者是在Windows系统下创建的sh脚本，那么放到Linux系统上时需要修改文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用vim编辑器来修改</span><br><span class="line">vi shop-jenkins.sh</span><br><span class="line"># 查看文件格式，windows上传上来的默认为dos</span><br><span class="line">:set ff </span><br><span class="line">#修改文件格式为unix</span><br><span class="line">:set ff=unix </span><br><span class="line">#保存并退出</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>然后我们创建对应的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-jenkins</span><br></pre></td></tr></table></figure><h1 id="在Jenkins中创建执行任务"><a href="#在Jenkins中创建执行任务" class="headerlink" title="在Jenkins中创建执行任务"></a>在Jenkins中创建执行任务</h1><p><strong>第一步</strong>，新建一个任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69a4ee3649aedac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，设置任务名称后选择构建一个自由风格的软件项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-845861f3b8d6158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第三步</strong>，点击源码管理，然后在里面添加仓库地址：<code>http://192.168.51.160:1080/myshop/shop-gitlab-jenkins</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1f28a87cb227fe96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时显示连接不通，我们需要添加一个凭据，也就是Git仓库的账号和密码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-23b0f51cc134ba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>填写完该凭据后就选择它，此时就可以正常连接到Git仓库：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8afb66ed66c1d79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，添加一个构建用于调用顶层maven模板，该构建主要用于将源码打包为Docker镜像并上传至Docker镜像仓库中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96d012913b65027d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择maven版本并设置maven命令以及指定pom文件的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6c3b13b50a6744c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着设置需要执行的shell的命令，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mydata/sh/shop-jenkins.sh</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ca8e69c00cf15653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击保存操作，这样任务就创建完成了。</p><p><strong>第五步</strong>，在任务列表中可以点击运行来执行该任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9941d3d80b4fc277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可通过点击左侧的构建历史序号，然后选择控制台输出即可看到整个任务的执行过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-108a84f1c09d77a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d5f4a904325309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第六步</strong>，接着我们开放8088端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8088/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开浏览器，访问<code>http://宿主机IP:8088/swagger-ui.html</code>连接，查看<code>shop-jenkins</code>服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c382f1b4ee6fe432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Jenkins+Gitlab一键打包部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker Compose部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/</id>
    <published>2023-02-24T02:55:30.000Z</published>
    <updated>2023-03-14T06:50:53.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行，但是当我们的应用数量较多时，上述两种方式似乎变得很不友好。</p><p>此时可以使用Docker Compose来解决上述问题，Docker Compose是一个用于定义和运行多个docker容器应用的工具。使用Compose允许开发者使用YAML文件来配置应用服务，之后使用一个命令，就可以部署配置的所有服务。</p><h1 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h1><h3 id="下载Docker-Compose"><a href="#下载Docker-Compose" class="headerlink" title="下载Docker Compose"></a>下载Docker Compose</h3><p>使用如下命令来下载Docker Compose：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="修改下载文件的权限"><a href="#修改下载文件的权限" class="headerlink" title="修改下载文件的权限"></a>修改下载文件的权限</h3><p>将下载文件的权限设置为可执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="确认Docker-Compose安装成功"><a href="#确认Docker-Compose安装成功" class="headerlink" title="确认Docker Compose安装成功"></a>确认Docker Compose安装成功</h3><p>可使用如下命令来确认Docker Compose已经安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果输出Docker Compose的版本则说明它已经安装成功了。</p><h1 id="Docker-Compose使用步骤"><a href="#Docker-Compose使用步骤" class="headerlink" title="Docker Compose使用步骤"></a>Docker Compose使用步骤</h1><p>一般来说，Docker Compose的使用分为三个步骤：<br>（1）使用Dockerfile来定义应用的程序环境，注意此步只有在需要修改初始化镜像时，才执行；<br>（2）使用<code>docker-compose.yml</code>文件来定义需要部署的应用程序服务，以便后续可通过执行脚本来一次性部署服务；<br>（3）使用<code>docker-compose up</code>命令一次性将所有应用服务部署起来。</p><h1 id="docker-compose-yml配置文件常用命令"><a href="#docker-compose-yml配置文件常用命令" class="headerlink" title="docker-compose.yml配置文件常用命令"></a>docker-compose.yml配置文件常用命令</h1><p>Docker Compose将所管理的容器分为三层，即工程、服务及容器。<code>docker-compose.yml</code>中定义的所有服务组成了一个工程，services节点下即为服务，服务之下为容器。容器与容器之间可通过以服务名称为域名来进行访问。举个例子，在<code>shop-docker-compose</code>服务中可通过<code>jdbc:mysql://db:3306</code>这个地址来访问db这个mysql服务。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>version用于指定docker-compose的版本号，目前使用值都是3。</p><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>services是一系列服务的集合，该节点下定义具体的服务。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image用于指定服务所使用的镜像，举个例子如使用的是mysql5.7的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>container_name用于设置容器的名称，举个例子如指定容器名称为mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: mysql</span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>ports用于设置宿主机和容器的端口映射，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的3306端口映射到容器的3306端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - 3306:3306</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>volumes用于将宿主机的文件或者目录挂载到容器中，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的如下文件挂载到容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">  - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">  - /mydata/mysql/conf:/etc/mysql</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>environment用于设置环境变量，举个例子设置MySQL初始化时root账户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  - MYSQL_ROOT_PASSWORD=envy123</span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>links用于连接其他的容器服务，注意格式为<code>（SERVICE:ALIAS）</code>，举个例子以database为域名来访问服务名称为db的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  - db:database</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h1><h3 id="构建、创建、启动相关容器"><a href="#构建、创建、启动相关容器" class="headerlink" title="构建、创建、启动相关容器"></a>构建、创建、启动相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>其中的<code>-d</code>表示在后台运行。</p><h3 id="指定文件启动"><a href="#指定文件启动" class="headerlink" title="指定文件启动"></a>指定文件启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h3 id="停止所有相关容器"><a href="#停止所有相关容器" class="headerlink" title="停止所有相关容器"></a>停止所有相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h3 id="列出所有容器信息"><a href="#列出所有容器信息" class="headerlink" title="列出所有容器信息"></a>列出所有容器信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-compose</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-compose</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-compose-0.0.1-SNAPSHOT.jar /shop-docker-compose.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-compose.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-compose.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-compose.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ac5e57969321848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-compose\target\shop-docker-compose-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-compose ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.948 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T16:47:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-compose</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-compose</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-compose:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。</p><h1 id="使用Docker-Compose部署应用"><a href="#使用Docker-Compose部署应用" class="headerlink" title="使用Docker Compose部署应用"></a>使用Docker Compose部署应用</h1><h3 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为<code>docker-compose.yml</code>的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  db:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: mysql</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">    - 3306:3306</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">    - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">    - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">    - /mydata/mysql/conf:/etc/mysql</span><br><span class="line">    # 指定容器的环境变量</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=envy123</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  shop-docker-compose:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: myshop-all/shop-docker-compose:0.0.1-SNAPSHOT</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: shop-docker-compose</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">      - /mydata/app/shop-docker-compose/logs:/var/logs</span><br></pre></td></tr></table></figure><h3 id="运行Docker-Compose命令启动所有服务"><a href="#运行Docker-Compose命令启动所有服务" class="headerlink" title="运行Docker Compose命令启动所有服务"></a>运行Docker Compose命令启动所有服务</h3><p>将上面定义的<code>docker-compose.yml</code>文件上传至<code>/mydata/app/shop-docker-compose</code>目录中，然后在该目录中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看一下服务是否已经启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-compose]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                           COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">252d6d043a3d   myshop-all/shop-docker-compose:0.0.1-SNAPSHOT   &quot;java -jar /shop-doc…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              shop-docker-compose</span><br><span class="line">3c1f3944c4ca   registry:2                                      &quot;/entrypoint.sh /etc…&quot;   7 hours ago     Up 7 hours     0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp              registry2</span><br><span class="line">1f83ff04b145   mysql:5.7                                       &quot;docker-entrypoint.s…&quot;   25 hours ago    Up 2 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   mysql</span><br></pre></td></tr></table></figure><p>接着我们需要进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>然后创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p>接着打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到之前的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p>修改root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>接着我们开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>然后打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-compose服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Docker Compose部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-23T10:15:33.000Z</published>
    <updated>2023-03-14T06:49:25.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在部署第一篇中，我们学习了如何使用通过<code>docker-maven-plugin</code>来构建docker镜像，遗憾的是此方式需要依赖自建的Registry镜像仓库，这在实际开发过程中还是有困难的。</p><p>鉴于此，本篇来学习另一种方式，使用Dockerfile来构建docker镜像。注意此方式不需要依赖自建的镜像仓库，只需应用的jar包和一个Dockerfile文件。</p><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Dockerfile为SpringBoot应用构建Docker镜像。</p><h1 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM用于指定所需依赖的基础镜像，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像需要依赖java8的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br></pre></td></tr></table></figure><p>注意FROM命令必须放在Dockerfile文件的第一行。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER用于指定镜像维护者的名字，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像的维护者为kenbings：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER kenbings</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD用于复制文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如将当前目录下的<code>shop-docker-file.jar</code>包复制到docker容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD shop-docker-file.jar /shop-docker-file.jar</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT用于指定docker容器启动时执行的命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在启动容器时启动运行jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV用于设置环境变量，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>举个例子，在mysql运行时设置root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV MYSQL_ROOT_PASSWORD envy123</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE用于声明要暴露的端口（注意只会声明不会打开端口），格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port1&gt; &lt;port2&gt; ...</span><br></pre></td></tr></table></figure><p>举个例子，声明服务运行在8080端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN用于自定义容器在构建过程中需要执行的命令，如安装一些软件、创建一些文件等，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在容器构建过程中需要在/目录下创建一个名为<code>shop-docker-file.jar</code>的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-file</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-file</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-file.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c13081c65ae93a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-file\target\shop-docker-file-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-file ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.759 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T14:59:31+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-file</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-file</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。上述命令执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br><span class="line">Sending build context to Docker daemon   36.5MB</span><br><span class="line">Step 1/6 : FROM openjdk:8u102</span><br><span class="line"> ---&gt; ca5dd051db43</span><br><span class="line">Step 2/6 : MAINTAINER kenbings</span><br><span class="line"> ---&gt; Running in 89102f5205f6</span><br><span class="line">Removing intermediate container 89102f5205f6</span><br><span class="line"> ---&gt; 3a095a2cfe51</span><br><span class="line">Step 3/6 : ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"> ---&gt; 0429582ab23e</span><br><span class="line">Step 4/6 : RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"> ---&gt; Running in 3083441e10a6</span><br><span class="line">Removing intermediate container 3083441e10a6</span><br><span class="line"> ---&gt; 10be5dacfb00</span><br><span class="line">Step 5/6 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 505f2c42fbdf</span><br><span class="line">Removing intermediate container 505f2c42fbdf</span><br><span class="line"> ---&gt; fbab2deea31e</span><br><span class="line">Step 6/6 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br><span class="line"> ---&gt; Running in bde857feb023</span><br><span class="line">Removing intermediate container bde857feb023</span><br><span class="line"> ---&gt; 7c0df63d8996</span><br><span class="line">Successfully built 7c0df63d8996</span><br><span class="line">Successfully tagged myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>查看一下该镜像是否确实生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker images|grep &#x27;docker-file&#x27;</span><br><span class="line">myshop-all/shop-docker-file   0.0.1-SNAPSHOT   7c0df63d8996   About a minute ago   714MB</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker-file应用服务"><a href="#启动shop-docker-file应用服务" class="headerlink" title="启动shop-docker-file应用服务"></a>启动shop-docker-file应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker-file/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker-file/logs:/var/logs \</span><br><span class="line">--name shop-docker-file \</span><br><span class="line">-d myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-file服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Dockerfile为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在部署第一篇中，我们学习了如何使用通过&lt;code&gt;docker-maven-plugin&lt;/code&gt;来构建docker镜像</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven插件为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-20T03:51:30.000Z</published>
    <updated>2023-03-14T06:47:18.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Docker镜像，并上传至私有镜像仓库Docker Registry中。</p><h1 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h1><p>开发者可以使用Docker提供的registry这一镜像来搭建属于自己的私有仓库，这里选择版本为2的镜像即可，先将其下载到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry:2</span><br></pre></td></tr></table></figure><p>这里有它的快速使用方法，其实就是一条命令：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec61be9dc5bbcc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>执行下面的命令即可创建一个私有仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry2 registry:2</span><br></pre></td></tr></table></figure><h1 id="Docker开启远程API"><a href="#Docker开启远程API" class="headerlink" title="Docker开启远程API"></a>Docker开启远程API</h1><p>打开<code>docker.service</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>将其中的如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><br></pre></td></tr></table></figure><h1 id="让Docker支持http上传镜像"><a href="#让Docker支持http上传镜像" class="headerlink" title="让Docker支持http上传镜像"></a>让Docker支持http上传镜像</h1><p>使用如下命令来让Docker支持http上传镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&#123; &quot;insecure-registries&quot;:[&quot;192.168.51.160:5000&quot;] &#125;&#x27; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>修改完上述配置信息后，接下来需要使用如下命令来让配置生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>接着重启Docker服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>最后开启防火墙的Docker构建端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h1 id="使用Maven构建Docker镜像"><a href="#使用Maven构建Docker镜像" class="headerlink" title="使用Maven构建Docker镜像"></a>使用Maven构建Docker镜像</h1><p>再次强调，本篇代码是在第二篇《整合Swagger-UI实现在线API文档》的基础上进行修改的。</p><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker</code>这一Module中进行。</p><p><strong>第一步</strong>，在POM文件中新增<code>docker-maven-plugin</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>解释一下上述配置信息：<br>（1）<code>executions.execution.phase</code>表示配置在maven打包应用时构建docker镜像；<br>（2）<code>imageName</code>用于指定镜像名称，其中<code>myshop-all</code>是仓库名称，<code>$&#123;project.artifactId&#125;</code>是镜像名称，<code>$&#123;project.version&#125;</code>是仓库名称；<br>（3）<code>dockerHost</code>表示设置镜像打包后上传的docker服务器地址；<br>（4）<code>baseImage</code>表示该应用所依赖的基础镜像，此处为openjdk:8u102；<br>（5）<code>entryPoint</code>表示设置docker容器启动时执行的命令；<br>（6）<code>resources.resource.targetPath</code>表示将打包后的资源文件复制到该目录；<br>（7）<code>resources.resource.directory</code>表示待复制的文件所在的目录，注意Maven打包的应用jar包会保存在target目录下；<br>（8）<code>resources.resource.includ</code>表示需要复制的文件，即打包好的应用的jar包。</p><p><strong>第二步</strong>，修改<code>application.yml</code>配置文件，将其中的localhost修改为db：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://db:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p>实际上，我们可以将docker中的容器看做独立的虚拟机，这样<code>shop-docker</code>访问localhost时就不会访问到mysql，但是容器之间可通过指定服务名称来进行访问，如db，注意db这个名称需要在运行<code>shop-docker</code>容器时进行指定。</p><p><strong>第三步</strong>，使用IDEA打包项目并构建镜像，请注意依赖的基础镜像需要先下载到本地，否则会出现镜像构建超时的情况。接着执行maven的package命令来构建镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7fba034b80d2f8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c1f6abe0bac76a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时查看一下宿主机，可以看到宿主机上显示已经存在了该镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b76dce1634120500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="运行shop-docker服务"><a href="#运行shop-docker服务" class="headerlink" title="运行shop-docker服务"></a>运行shop-docker服务</h1><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker应用服务"><a href="#启动shop-docker应用服务" class="headerlink" title="启动shop-docker应用服务"></a>启动shop-docker应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker/logs:/var/logs \</span><br><span class="line">--name shop-docker \</span><br><span class="line">-d myshop-all/shop-docker:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Maven插件为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Dock</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合RabbitMQ实现延迟消息</title>
    <link href="http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/"/>
    <id>http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/</id>
    <published>2023-02-16T02:51:12.000Z</published>
    <updated>2023-03-14T06:45:40.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="AMQP简介"><a href="#AMQP简介" class="headerlink" title="AMQP简介"></a>AMQP简介</h3><p>AMQP (Advanced Message Queuing Protocol ，高级消息队列协议）是一个线路层的协议规范，而不是API 规范（例如JMS）。由于AMQP 是一个线路层协议规范，因此它天然就是跨平台的，就像SMTP、HTTP等协议一样，只要开发者按照规范的格式发送数据，任何平台都可以通过AMQP进行消息交互。像目前流行的StormMQ、RabbitMQ等都实现了AMQP协议。</p><h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ是一个实现了AMQP的开源消息中间件，使用高性能的Erlang编写。RabbitMQ具有可靠性、支持多种协议、高可用、支持消息集群以及多语言客户端等特点，在分布式系统中存储转发消息，具有不错的性能表现。</p><h3 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h3><p><strong>第一步</strong>，安装Erlang，可点击 <a href="http://erlang.org/download/otp_win64_23.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第二步</strong>，安装RabbitMQ，可点击 <a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.0/rabbitmq-server-3.8.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第三步</strong>，以管理员身份打开终端，并切换到RabbitMQ安装目录下的sbin目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3691d4f14d85cd00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后执行如下命令来开启管理功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://localhost:15672/</code>链接：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-962d2a01534f8f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第五步</strong>，输出账号和密码:guest和guest，然后登陆，点击右上角的Admin，创建用户名为kenbings和kenbings的用户，并设置角色为管理员：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-df8a5c4ccc8aecb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着创建一个名为<code>/shop</code>的虚拟host：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08ecd99c955f189d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后点击shop用户，进入到用户配置界面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-95d88b8d9ed02629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dc312644d1676024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样RabbitMQ的安装和配置就完成了，下面开始学习AMQP协议。</p><h1 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h1><p>AMQP协议作为RabbitMQ的规范，规定了RabbitMQ对外接口，同时学会了AMQP协议的使用，就基本掌握了RabbitMQ的使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae628aa7ee00312c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ就是Message Broker；<br><strong>Virtual Host</strong>：虚拟Broker，用于将多个单元隔离开；<br><strong>Connection</strong>：publisher/consumer和broker之间的TCP连接；<br><strong>Channel</strong>：connection内部建立的逻辑连接，通常每个线程创建单独的channel；<br><strong>Routing Key</strong>：路由键，用于指示消息的路由转发，相当于快递的地址；<br><strong>Exchange</strong>：交换机，相当于快递的分拨中心；<br><strong>Queue</strong>：消息队列，消息最终被送到这里等待consumer取走；<br><strong>Binding Key</strong>：exchange和queue之间的虚拟连接，用于message的分发依据。</p><h1 id="Exchange的作用"><a href="#Exchange的作用" class="headerlink" title="Exchange的作用"></a>Exchange的作用</h1><p>在AMQP协议或者是RabbitMQ实现中，最核心的组件是Exchange，Exchange承担RabbitMQ中的核心功能，即路由转发。Exchange有多个种类，配置多变，需要深度分析。</p><p>Exchange的功能是根据绑定关系和路由键为消息提供路由，将消息转发至相应的队列。</p><p>Exchange有4种类型，Direct、Topic、Fanout和Headers，其中Headers使用较少，以前三种为主。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2f35828e0212b741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h1><p>本篇要实现的延迟消息，是用户在下单之后，超过一定时间如30分钟，之后自动取消订单这一业务场景。可能的业务步骤如下：<br>（1）用户进行下单操作（会存在锁定商品库存、使用优惠券、积分、红包等操作）；<br>（2）生成订单信息，并获取订单id；<br>（3）根据订单id获取到设置的订单超时时间（假设设置30分钟内不支付取消订单）；<br>（4）按照订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；<br>（5）如果用户没有支付，那么就执行取消订单的操作（释放商品库存、优惠券、积分、红包等操作）。</p><h1 id="整合RabbitMQ实现延迟消息"><a href="#整合RabbitMQ实现延迟消息" class="headerlink" title="整合RabbitMQ实现延迟消息"></a>整合RabbitMQ实现延迟消息</h1><p><strong>第一步</strong>，复制一份<code>shop-mongodb</code>源码，将其名字修改为<code>shop-rabbitmq</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-rabbitmq</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-rabbitmq</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--消息队列相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在spring节点下添加RabbitMQ相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  # RabbitMQ相关    </span><br><span class="line">rabbitmq:</span><br><span class="line">  host: localhost # rabbitmq的连接地址</span><br><span class="line">  port: 5672 # rabbitmq的连接端口号</span><br><span class="line">  virtual-host: /shop # rabbitmq的虚拟host</span><br><span class="line">  username: kenbings # rabbitmq的用户名</span><br><span class="line">  password: kenbings # rabbitmq的密码</span><br><span class="line">  publisher-confirms: true #如果对异步消息需要回调必须设置为true</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shoprabbitmq</code>包内定义一个名为enums的包，接着在enums包内定义一个名为<code>QueueEnum</code>的枚举类，注意这是消息队列的枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列枚举类</span><br><span class="line"> */</span><br><span class="line">@Getter</span><br><span class="line">public enum QueueEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单取消通知队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_ORDER_CANCEL(&quot;shop.order.direct.exchange&quot;,&quot;shop.order.cancel.queue&quot;,&quot;shop.order.cancel.key&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息通知TTL队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(&quot;shop.order.direct.ttl.exchange&quot;,&quot;shop.order.cancel.ttl.queue&quot;,&quot;shop.order.cancel.ttl.key&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 交换机</span><br><span class="line">     */</span><br><span class="line">    private String exchange;</span><br><span class="line">    /**</span><br><span class="line">     * 队列名称</span><br><span class="line">     */</span><br><span class="line">    private String queue;</span><br><span class="line">    /**</span><br><span class="line">     * 路由键</span><br><span class="line">     */</span><br><span class="line">    private String routingKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String queue, String routingKey)&#123;</span><br><span class="line">        this.exchange = exchange;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在config包内定义一个名为<code>RabbitMQConfig</code>的配置类，注意这是消息队列的配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderTTLDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderQueue()&#123;</span><br><span class="line">        return new Queue(QueueEnum.QUEUE_ORDER_CANCEL.getQueue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟消息队列（死信队列）</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderTTLQueue()&#123;</span><br><span class="line">        return QueueBuilder.durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getQueue())</span><br><span class="line">                .withArgument(&quot;x-dead-letter-exchange&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getExchange()) //消息过期后转到的交换机</span><br><span class="line">        .withArgument(&quot;x-dead-letter-routing-key&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey()) //消息过期后转发的路由键</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将正常订单队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderBinding(DirectExchange orderDirectExchange,Queue orderQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderQueue).to(orderDirectExchange).with(QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将订单延迟队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderTTLBinding(DirectExchange orderTTLDirectExchange,Queue orderTTLQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderTTLQueue).to(orderTTLDirectExchange).with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们尝试启动一下项目入口类，然后查看一下RabbitMQ的浏览器控制台，然后查看Exchange：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8239e340336e0883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着再来查看一下队列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cadff6c72def3c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>shop.order.direct.exchange</code>（取消订单消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.queue</code>，这样如果有消息以<code>shop.order.cancel.key</code>为路由键发送过来，就会发送到此队列中。</p><p><code>shop.order.direct.ttl.exchange</code>（订单延迟消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.ttl.queue</code>，这样如果有消息以<code>shop.order.cancel.ttl.key</code>为路由键发送过来，就会发送到此队列中，并在此队列中保存一段时间，等到超时时间到，后自动将消息发送到<code>shop.order.cancel.queue</code>（取消订单消息队列）中。</p><p><strong>第六步</strong>，在component包内定义一个名为<code>CancelOrderSender</code>的类，该类用于往订单延迟队列(订单消息通知TTL队列，<code>shop.order.cancel.ttl.queue</code>)中发送消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往订单延迟队列(订单消息通知TTL队列，`shop.order.cancel.ttl.queue`)中发送消息</span><br><span class="line"> * 取消订单消息的发出者</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CancelOrderSender &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给延迟队列发送消息</span><br><span class="line">     * @param orderId 订单号</span><br><span class="line">     * @param delayTime 延迟时间（毫秒）</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(Long orderId,long delayTime)&#123;</span><br><span class="line">        String exchange = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange();</span><br><span class="line">        String routingKey = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey();</span><br><span class="line">        amqpTemplate.convertAndSend(exchange, routingKey, orderId, new MessagePostProcessor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">                        //给消息设置延迟时间，单位毫秒</span><br><span class="line">                        message.getMessageProperties().setExpiration(String.valueOf(delayTime));</span><br><span class="line">                        return message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        LOGGER.info(&quot;发送延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在component包内定义一个名为<code>CancelOrderReceiver</code>的类，该类用于从订单取消通知队列(<code>shop.order.cancel.queue</code>)中拉取消息并消费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理取消订单消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;shop.order.cancel.queue&quot;)</span><br><span class="line">public class CancelOrderReceiver &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderReceiver.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void handle(Long orderId)&#123;</span><br><span class="line">        LOGGER.info(&quot;收到延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在service包内定义一个名为<code>OmsPortalOrderService</code>的接口，用于定义与前台订单管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface OmsPortalOrderService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据提交信息生成订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    CommonResult generateOrder(OrderParam orderParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取消单个超时订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    void cancelOrder(Long orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在dto包内定义一个名为<code>OrderParam</code>的类，这是生成订单时需传入的参数对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成订单时需传入的参数</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class OrderParam &#123;</span><br><span class="line">    //收货地址id</span><br><span class="line">    private Long memberReceiveAddressId;</span><br><span class="line">    //优惠券id</span><br><span class="line">    private Long couponId;</span><br><span class="line">    //使用的积分数</span><br><span class="line">    private Integer useIntegration;</span><br><span class="line">    //支付方式</span><br><span class="line">    private Integer payType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在impl包内定义一个名为<code>OmsPortalOrderServiceImpl</code>的类，这个类需要实现<code>OmsPortalOrderService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class OmsPortalOrderServiceImpl implements OmsPortalOrderService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(OmsPortalOrderService.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CancelOrderSender cancelOrderSender;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateOrder(OrderParam orderParam) &#123;</span><br><span class="line">        //TODO 一系列下单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始生成订单&quot;);</span><br><span class="line">        //下单完成后发送一个延迟消息，用于实现当用户没有付款时取消订单这一功能，注意orderId应该在下单后生成</span><br><span class="line">        Long orderId = 516516161616L;</span><br><span class="line">        sendDelayMessageCancelOrder(orderId);</span><br><span class="line">        return CommonResult.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancelOrder(Long orderId) &#123;</span><br><span class="line">        //TODO 一系列取消订单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始取消订单，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendDelayMessageCancelOrder(Long orderId) &#123;</span><br><span class="line">        //获取订单超时时间，假设为30秒</span><br><span class="line">        long delayTimes = 30 * 1000;</span><br><span class="line">        //发送延迟消息</span><br><span class="line">        cancelOrderSender.sendMessage(orderId, delayTimes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在controller包内定义一个名为<code>OmsPortalOrderController</code>的类，这是前台订单管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理的Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;OmsPortalOrderController&quot;,description = &quot;订单管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OmsPortalOrderController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService omsPortalOrderService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;根据购物车信息生成订单&quot;)</span><br><span class="line">    @PostMapping(&quot;/generateOrder&quot;)</span><br><span class="line">    public Object generateOrder(@RequestBody OrderParam orderParam) &#123;</span><br><span class="line">        return omsPortalOrderService.generateOrder(orderParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa310e78ea1ddc34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，进行接口测试。首先后台用户进行登录，接着测试“下单接口”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8040f8eadc87c2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后回到IDEA控制台，可以看到输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:05:40.460  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.service.OmsPortalOrderService    : 开始生成订单</span><br><span class="line">2021-12-09 18:05:40.464  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.component.CancelOrderSender      : 发送延迟消息，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>之后等待30秒钟，IDEA控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:06:10.494  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.component.CancelOrderReceiver    : 收到延迟消息，订单号为：516516161616</span><br><span class="line">2021-12-09 18:06:10.495  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.service.OmsPortalOrderService    : 开始取消订单，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>可以看到时间间隔就是30秒，这也说明该订单下单30秒后未支付便被自动取消了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合MongoDB实现用户商品浏览记录</title>
    <link href="http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/"/>
    <id>http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/</id>
    <published>2023-02-13T11:15:10.000Z</published>
    <updated>2023-03-14T06:43:15.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><p>MongoDB是一个为快速开发互联网Web应用而构建的数据库系统，其数据模型和持久化策略就是为了构建高读/写吞吐量和高自动灾备伸缩性的系统。</p><h3 id="安装MongoDB服务"><a href="#安装MongoDB服务" class="headerlink" title="安装MongoDB服务"></a>安装MongoDB服务</h3><p>第一步，点击 <a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.2.21-signed.msi">这里</a> 下载MongoDB的安装包；</p><p>第二步，自定义MongoDB的安装路径：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ff90ac35c7ba41d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三步，在MongoDB安装路径下创建<code>data\db</code>和<code>data\log</code>这两个文件夹：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-357fca313358d035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第四步，在MongoDB安装路径下创建<code>mongod.cfg</code>配置文件，里面的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: E:\Application\MongoDB\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: E:\Application\MongoDB\data\db</span><br></pre></td></tr></table></figure><p>第五步，进入到MongoDB安装路径下的bin目录，里面有两个exe文件，分别是客户端和服务端运行程序：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-60c5c82bf617341e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后以管理员身份打开终端，并切换到bin目录下，执行如下命令来给系统安装MongoDB服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Application\MongoDB\bin\mongod.exe --config &quot;E:\Application\MongoDB\mongod.cfg&quot; --install</span><br></pre></td></tr></table></figure><p>第六步，一些与MongoDB服务管理相关的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动服务：net start MongoDB</span><br><span class="line">关闭服务：net stop MongoDB</span><br><span class="line">移除服务：E:\Application\MongoDB\bin\mongod.exe --remove</span><br></pre></td></tr></table></figure><p>使用上述命令来启动MongoDB服务。</p><h3 id="安装MongoDB客户端"><a href="#安装MongoDB客户端" class="headerlink" title="安装MongoDB客户端"></a>安装MongoDB客户端</h3><p>第一步，点击 <a href="https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip">这里</a> 下载MongoDB客户端的安装包；</p><p>第二步，将其解压到指定目录，并打开名为<code>robo3t.exe</code>的软件，然后连接到<code>localhost:27017</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-221869c039f544c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>Spring Data MongoDB是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-MongoDB常用注解"><a href="#Spring-Data-MongoDB常用注解" class="headerlink" title="Spring Data MongoDB常用注解"></a>Spring Data MongoDB常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到MongoDB文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    @AliasFor(&quot;collection&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String collection() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String language() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到MongoDB文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h3><p><code>@Indexed</code>注解添加到映射到MongoDB文档上的领域对象的某个字段上，用于标识该字段为MongoDB的索引字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Indexed &#123;</span><br><span class="line">    boolean unique() default false;</span><br><span class="line"></span><br><span class="line">    IndexDirection direction() default IndexDirection.ASCENDING;</span><br><span class="line"></span><br><span class="line">    boolean sparse() default false;</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean dropDups() default false;</span><br><span class="line"></span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useGeneratedName() default false;</span><br><span class="line"></span><br><span class="line">    boolean background() default false;</span><br><span class="line"></span><br><span class="line">    int expireAfterSeconds() default -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承MongoRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface MongoRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll(Sort var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; S insert(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; insert(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ff1fae57d08f8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，根据会员id按照时间倒序获取会员的浏览记录，直接在接口中定义如下方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-269ef8c63a11e00f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用MongoDB的JSON语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123; &#x27;memberId&#x27; : ?0 &#125;&quot;)</span><br><span class="line">List&lt;MemberReadHistory&gt; findByMemberId(Long memberId);</span><br></pre></td></tr></table></figure><h1 id="整合MongoDB实现用户商品浏览记录"><a href="#整合MongoDB实现用户商品浏览记录" class="headerlink" title="整合MongoDB实现用户商品浏览记录"></a>整合MongoDB实现用户商品浏览记录</h1><p><strong>第一步</strong>，复制一份<code>shop-elasticsearch</code>源码，将其名字修改为<code>shop-mongodb</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-mongodb</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-mongodb</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!---MongoDB相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在<code>spring.data</code>节点下添加MongoDB相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># MongoDB相关</span><br><span class="line">data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: localhost # mongodb的连接地址</span><br><span class="line">      port: 27017 # mongodb的连接端口号</span><br><span class="line">      database: shop-port # mongodb的连接的数据库</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在nosql包内定义一个名为mongodb的包，接着在mongodb包内定义一个名为document的包。然后在document包内定义一个名为<code>MemberReadHistory</code>的类，注意这是会员浏览记录文档对象。然后文档对象的ID域使用<code>@Id</code>注解，需要检索的字段添加<code>@Indexed</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户商品浏览历史记录文档对象</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document</span><br><span class="line">public class MemberReadHistory &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    /**</span><br><span class="line">     * 用户id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long memberId;</span><br><span class="line">    /**</span><br><span class="line">     * 用户昵称</span><br><span class="line">     */</span><br><span class="line">    private String memberNickname;</span><br><span class="line">    /**</span><br><span class="line">     * 用户头像</span><br><span class="line">     */</span><br><span class="line">    private String memberIcon;</span><br><span class="line">    /**</span><br><span class="line">     * 商品id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long productId;</span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    private String productName;</span><br><span class="line">    /**</span><br><span class="line">     * 商品图片</span><br><span class="line">     */</span><br><span class="line">    private String productPic;</span><br><span class="line">    /**</span><br><span class="line">     * 商品副标题</span><br><span class="line">     */</span><br><span class="line">    private String productSubTitle;</span><br><span class="line">    /**</span><br><span class="line">     * 商品价格</span><br><span class="line">     */</span><br><span class="line">    private String productPrice;</span><br><span class="line">    /**</span><br><span class="line">     * 浏览时间</span><br><span class="line">     */</span><br><span class="line">    private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，<br>在mongodb包内新建一个名为repository的包，并在该包内定义一个名为<code>MemberReadHistoryRepository</code>的接口，注意这个接口需要继承<code>MongoRepository</code>接口，这样就拥有了一些基本的操作MongoDB数据的方法，同时我们在里面定义了一个衍生的根据用户(会员)id按照时间倒序获取商品浏览历史记录的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在service包内定义一个名为<code>MemberReadHistoryService</code>的接口，用于定义与会员浏览商品历史记录管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 生成浏览历史记录</span><br><span class="line">     * @param memberReadHistory 浏览历史记录信息</span><br><span class="line">     */</span><br><span class="line">    int create(MemberReadHistory memberReadHistory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除浏览历史记录</span><br><span class="line">     * @param ids 浏览历史记录id</span><br><span class="line">     */</span><br><span class="line">    int delete(List&lt;String&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定会员的浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; list(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为<code>MemberReadHistoryServiceImpl</code>的类，这个类需要实现<code>MemberReadHistoryService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class MemberReadHistoryServiceImpl implements MemberReadHistoryService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryRepository memberReadHistoryRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int create(MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        memberReadHistory.setId(null);</span><br><span class="line">        memberReadHistory.setCreateTime(new Date());</span><br><span class="line">        memberReadHistoryRepository.save(memberReadHistory);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(List&lt;String&gt; ids) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; deleteMemberReadHistoryLists = new ArrayList&lt;&gt;();</span><br><span class="line">        for(String id:ids)&#123;</span><br><span class="line">            MemberReadHistory memberReadHistory = new MemberReadHistory();</span><br><span class="line">            memberReadHistory.setId(id);</span><br><span class="line">            deleteMemberReadHistoryLists.add(memberReadHistory);</span><br><span class="line">        &#125;</span><br><span class="line">        memberReadHistoryRepository.deleteAll(deleteMemberReadHistoryLists);</span><br><span class="line">        return deleteMemberReadHistoryLists.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MemberReadHistory&gt; list(Long memberId) &#123;</span><br><span class="line">        return memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为<code>MemberReadHistoryController</code>的类，这是会员商品浏览历史记录管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;MemberReadHistoryController&quot;,description = &quot;会员商品浏览历史记录管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/member/readHistory&quot;)</span><br><span class="line">public class MemberReadHistoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryService memberReadHistoryService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;创建浏览记录&quot;)</span><br><span class="line">    @PostMapping( &quot;/create&quot;)</span><br><span class="line">    public CommonResult create(@RequestBody MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        int count = memberReadHistoryService.create(memberReadHistory);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;删除浏览记录&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete&quot;)</span><br><span class="line">    public CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;String&gt; ids) &#123;</span><br><span class="line">        int count = memberReadHistoryService.delete(ids);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;展示浏览记录&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;MemberReadHistory&gt;&gt; list(@RequestParam(value = &quot;memberId&quot;)@ApiParam(&quot;会员id&quot;) Long memberId) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; memberReadHistoryList = memberReadHistoryService.list(memberId);</span><br><span class="line">        return CommonResult.success(memberReadHistoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dd8a052925639de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十步</strong>，进行接口测试。首先后台用户进行登录，接着测试“创建浏览记录”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e6f92e5435b42a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以更改memberId来创建两条测试数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ee8bb3da8a9c429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着测试一下查看某会员商品浏览历史记录接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cf379c721ab83d3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cfa677df390fa9b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合MongoDB实现用户商品浏览记录的学习就完成了，后续介绍如何整合RabbitMQ实现延迟消息这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-mongodb">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。&lt;</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用ElasticSearch实现商品复杂搜索</title>
    <link href="http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/"/>
    <id>http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/</id>
    <published>2023-02-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:41:37.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能。</p><h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><p>由于商品搜索涉及到中文搜索，因此ElasticSearch需要安装分词器才可以支持。前面我们安装的分词器是IKAnalyzer，接下来简单学习如何使用它。</p><h3 id="默认分词器"><a href="#默认分词器" class="headerlink" title="默认分词器"></a>默认分词器</h3><p>使用默认分词器，只是将中文逐字进行分割，并不符合我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae1a50cce244e752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="中文分词器-1"><a href="#中文分词器-1" class="headerlink" title="中文分词器"></a>中文分词器</h3><p>使用中文分词器后，可以将中文文本按照语境进行分隔，可以满足我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bdeab3b6591aa428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实在前一文中，我们就在EsProduct中，对于需要进行中文分词的字段，都使用了<code>@Field</code>注解且将analyzer属性设置为<code>ik_max_word</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品名称</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 副标题</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String subTitle;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关键字</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String keywords;</span><br></pre></td></tr></table></figure><h1 id="商品简单搜索"><a href="#商品简单搜索" class="headerlink" title="商品简单搜索"></a>商品简单搜索</h1><p>商品简单搜索即通过商品名称、副标题或者关键字来搜索包含指定关键字的商品。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现"><a href="#使用Query-DSL来调用ES的Restful-API来实现" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 5,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;小米&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92e8865c96648ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elasticsearch-Repository的衍生查询"><a href="#Elasticsearch-Repository的衍生查询" class="headerlink" title="Elasticsearch Repository的衍生查询"></a>Elasticsearch Repository的衍生查询</h1><p>Elasticsearch Repository的衍生查询原理其实很简单，就是将一定规则名称的方法转化为Elasticsearch的Query DSL语句，可以查看如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8cb04a107ff6d6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="复杂商品搜索"><a href="#复杂商品搜索" class="headerlink" title="复杂商品搜索"></a>复杂商品搜索</h1><p>复杂商品搜索会涉及到过滤、不同字段匹配权重以及排序等功能。</p><p>这里的需求是按照输入的关键字来搜索商品名称、副标题和关键字，可以按照品牌和分类进行筛选，可以有5种排序方式，默认按相关度进行排序。查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8984cbb5ee895f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里有一些比较特殊的需求，如商品名称匹配关键字的商品，我们认为与搜索条件更匹配，其次是副标题和关键字，此时就需要使用到<code>function_score</code>查询。</p><p>在ElasticSearch中，搜索到文档的相关性由<code>_score</code>字段来表示，文档的<code>_score</code>字段值越高，表示与搜索条件越匹配。而<code>function_score</code>查询可通过设置权重来影响<code>_score</code>字段值，因此使用<code>function_score</code>查询就可以很好的满足我们的需求。</p><p>这里我们设置商品名称权重为10，商品副标题权重为5，商品关键字权重为2。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-1"><a href="#使用Query-DSL来调用ES的Restful-API来实现-1" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;&quot;match_all&quot;: &#123;&#125;&#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must&quot; :[</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;brandId&quot;: 6</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;productCategoryId&quot;: 19</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 10</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_score&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-508e99c72af4b0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到EsProductService接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据关键字搜索名称、副标题或者关键字复合查询</span><br><span class="line"> * @param keyword 关键字</span><br><span class="line"> * @param brandId 品牌id</span><br><span class="line"> * @param productCategoryId 商品类别id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @param sort 排序字段</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; search(String keyword,Long brandId,Long productCategoryId,Integer pageNum, Integer pageSize,Integer sort);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个search方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; search(String keyword, Long brandId, Long productCategoryId, Integer pageNum, Integer pageSize, Integer sort) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    NativeSearchQueryBuilder nativeSearchQueryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //分页</span><br><span class="line">    nativeSearchQueryBuilder.withPageable(pageable);</span><br><span class="line">    //过滤</span><br><span class="line">    if(brandId != null || productCategoryId != null)&#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        if(brandId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;brandId&quot;,brandId));</span><br><span class="line">        &#125;</span><br><span class="line">        if(productCategoryId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;productCategoryId&quot;,productCategoryId));</span><br><span class="line">        &#125;</span><br><span class="line">        nativeSearchQueryBuilder.withFilter(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //搜索</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(10)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序</span><br><span class="line">    if(sort == 1)&#123;</span><br><span class="line">        //按新品从新到旧</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;id&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 2)&#123;</span><br><span class="line">        //按销量从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;sale&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 3)&#123;</span><br><span class="line">        //按价格从低到高</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.ASC));</span><br><span class="line">    &#125;else if(sort == 4)&#123;</span><br><span class="line">        //按价格从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //按相关度</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    &#125;</span><br><span class="line">    //不传则默认按照相关度由高到低排</span><br><span class="line">    nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    NativeSearchQuery searchQuery = nativeSearchQueryBuilder.build();</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">    return esProductRepository.search(searchQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为search的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;综合搜索、筛选、排序&quot;)</span><br><span class="line">@ApiImplicitParam(name = &quot;sort&quot;, value = &quot;排序字段:0-&gt;按相关度；1-&gt;按新品；2-&gt;按销量；3-&gt;价格从低到高；4-&gt;价格从高到低&quot;,</span><br><span class="line">        defaultValue = &quot;0&quot;, allowableValues = &quot;0,1,2,3,4&quot;, paramType = &quot;query&quot;, dataType = &quot;integer&quot;)</span><br><span class="line">@GetMapping(&quot;/search&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;品牌id&quot;) Long brandId,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;商品类别id&quot;) Long productCategoryId,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;) @ApiParam(&quot;排序字段&quot;)Integer sort) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword,brandId,productCategoryId,pageNum, pageSize,sort);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关商品推荐（猜你喜欢）"><a href="#相关商品推荐（猜你喜欢）" class="headerlink" title="相关商品推荐（猜你喜欢）"></a>相关商品推荐（猜你喜欢）</h1><p>当我们在查看某个商品的时候，底部一般会有一些商品推荐（猜你喜欢），这里我们选择使用ElasticSearch来简单实现。</p><p>这里的需求是，可以根据指定商品的id来查找相关商品，查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f2d3b4d8af714ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说我们这里的原理是这样的：首先根据商品id获取到指定商品的信息，然后以指定商品的名称、品牌、分类来搜索商品，并且过滤掉当前的商品（剔除此商品的id），调整搜索条件中的权重以获取最好的匹配度。</p><p>这里我们设置商品名称权重为8，商品副标题权重为2，商品关键字权重为2，商品品牌id权重为5，商品商品类别id权重为3。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-2"><a href="#使用Query-DSL来调用ES的Restful-API来实现-2" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must_not&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                  &quot;id&quot;: 28</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 8</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brandId&quot;: 6</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;productCategoryId&quot;: 19</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 3</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6427b03e1f96d556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据商品id推荐相关商品</span><br><span class="line"> * @param id 商品id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个recommend方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    List&lt;EsProduct&gt; esProductList = esProductDao.getAllEsProductList(id);</span><br><span class="line">    if(esProductList.size()&gt;0)&#123;</span><br><span class="line">        EsProduct esProduct = esProductList.get(0);</span><br><span class="line">        String keyword = esProduct.getName();</span><br><span class="line">        Long brandId = esProduct.getBrandId();</span><br><span class="line">        Long productCategoryId = esProduct.getProductCategoryId();</span><br><span class="line">        //根据商品标题、品牌、分类进行搜索</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(8)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;brandId&quot;,brandId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;productCategoryId&quot;,productCategoryId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(3)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        //过滤掉相同的商品</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();</span><br><span class="line">        boolQueryBuilder.mustNot(QueryBuilders.termQuery(&quot;id&quot;,id));</span><br><span class="line"></span><br><span class="line">        //构建查询条件</span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">        builder.withFilter(boolQueryBuilder);</span><br><span class="line">        builder.withPageable(pageable);</span><br><span class="line">        NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">        LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">        return esProductRepository.search(searchQuery);</span><br><span class="line">    &#125;</span><br><span class="line">    return new PageImpl&lt;&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为recommend的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;根据商品id推荐商品&quot;)</span><br><span class="line">@GetMapping( &quot;/recommend/&#123;id&#125;&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; recommend(@PathVariable @ApiParam(&quot;商品id&quot;) Long id,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.recommend(id, pageNum, pageSize);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聚合搜索商品相关信息"><a href="#聚合搜索商品相关信息" class="headerlink" title="聚合搜索商品相关信息"></a>聚合搜索商品相关信息</h1><p>在搜索商品时，通常会有一个筛选界面来帮助用户快速找到想要的商品，这里使用Elasticsearch来简单实现。</p><p>这里的需求是，可以根据搜索关键字获取到与关键字匹配商品相关的分类，品牌以及属性，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9305b0e633b7e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里可以使用ElasticSearch的聚合来实现，搜索出相关商品，聚合出商品的品牌、分类以及属性，取出现次数最多的前10个即可。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-3"><a href="#使用Query-DSL来调用ES的Restful-API来实现-3" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;华为&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,</span><br><span class="line">        &quot;subTitle&quot;,</span><br><span class="line">        &quot;keywords&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brandName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;productCategoryNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;productCategoryName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;allAttrValues&quot;: &#123;</span><br><span class="line">      &quot;nested&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;attrValueList&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;productAttrs&quot;: &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;attrValueList.type&quot;: 1</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;attrIds&quot;: &#123;</span><br><span class="line">              &quot;terms&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;attrValueList.productAttributeId&quot;,</span><br><span class="line">                &quot;size&quot;: 10</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;attrValues&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.value&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;attrNames&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.name&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，当我们搜索“华为”这个关键字时，聚合出了如下的分类和品牌信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08de9f19d304b551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>聚合出了“屏幕尺寸”、“网络”、“系统”等筛选属性信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6b22dccdf4ad08fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>在SpringBoot中实现聚合操作非常复杂，已经超出了Elasticsearch Repository的使用范围，需要直接使用更为底层的<code>ElasticsearchTemplate</code>来实现。</p><p><strong>第一步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内定义一个名为domain的包，并在domain包内定义一个名为<code>EsProductRelatedInfo</code>的类，这是搜索相关商品品牌名称，分类名称及属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索相关商品品牌名称，分类名称及属性</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductRelatedInfo &#123;</span><br><span class="line">    private List&lt;String&gt; brandNames;</span><br><span class="line">    private List&lt;String&gt; productCategoryNames;</span><br><span class="line">    private List&lt;ProductAttr&gt; productAttrs;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    public static class ProductAttr&#123;</span><br><span class="line">        private Long attrId;</span><br><span class="line">        private String attrName;</span><br><span class="line">        private List&lt;String&gt; attrValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取搜索词相关品牌、分类、属性</span><br><span class="line"> */</span><br><span class="line">EsProductRelatedInfo searchRelatedInfo(String keyword);</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>EsProductServiceImpl</code>类中实现这个<code>searchRelatedInfo</code>方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public EsProductRelatedInfo searchRelatedInfo(String keyword) &#123;</span><br><span class="line">    NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">    //搜索条件</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.multiMatchQuery(keyword,&quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //聚合搜索品牌名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;brandNames&quot;).field(&quot;brandName&quot;));</span><br><span class="line">    //集合搜索分类名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;productCategoryNames&quot;).field(&quot;productCategoryName&quot;));</span><br><span class="line">    //聚合搜索商品属性，去除type=1的属性</span><br><span class="line">    AbstractAggregationBuilder aggregationBuilder = AggregationBuilders.nested(&quot;allAttrValues&quot;,&quot;attrValueList&quot;)</span><br><span class="line">            .subAggregation(AggregationBuilders.filter(&quot;productAttrs&quot;,QueryBuilders.termQuery(&quot;attrValueList.type&quot;,1))</span><br><span class="line">                    .subAggregation(AggregationBuilders.terms(&quot;attrIds&quot;)</span><br><span class="line">                            .field(&quot;attrValueList.productAttributeId&quot;)</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrValues&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.value&quot;))</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrNames&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.name&quot;))));</span><br><span class="line">    builder.addAggregation(aggregationBuilder);</span><br><span class="line">    NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">    SearchResponse searchResponse = elasticsearchTemplate.query(searchQuery, response -&gt; response);</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;,searchQuery.getQuery().toString());</span><br><span class="line">    return convertProductRelatedInfo(searchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将返回结果转换为对象</span><br><span class="line"> */</span><br><span class="line">private EsProductRelatedInfo convertProductRelatedInfo(SearchResponse searchResponse) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = new EsProductRelatedInfo();</span><br><span class="line">    Map&lt;String, Aggregation&gt; aggregationMap = searchResponse.getAggregations().getAsMap();</span><br><span class="line">    //设置品牌</span><br><span class="line">    Aggregation brandNames = aggregationMap.get(&quot;brandNames&quot;);</span><br><span class="line">    List&lt;String&gt; brandNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i&lt;((Terms) brandNames).getBuckets().size(); i++)&#123;</span><br><span class="line">        brandNameList.add(((Terms) brandNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setBrandNames(brandNameList);</span><br><span class="line">    //设置分类</span><br><span class="line">    Aggregation productCategoryNames = aggregationMap.get(&quot;productCategoryNames&quot;);</span><br><span class="line">    List&lt;String&gt; productCategoryNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i=0;i&lt;((Terms) productCategoryNames).getBuckets().size();i++)&#123;</span><br><span class="line">        productCategoryNameList.add(((Terms) productCategoryNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductCategoryNames(productCategoryNameList);</span><br><span class="line">    //设置参数</span><br><span class="line">    Aggregation productAttrs = aggregationMap.get(&quot;allAttrValues&quot;);</span><br><span class="line">    List&lt;? extends Terms.Bucket&gt; attrIds = ((LongTerms) ((Filter) ((Nested) productAttrs).getAggregations().get(&quot;productAttrs&quot;)).getAggregations().get(&quot;attrIds&quot;)).getBuckets();</span><br><span class="line">    List&lt;EsProductRelatedInfo.ProductAttr&gt; attrList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Terms.Bucket attrId : attrIds) &#123;</span><br><span class="line">        EsProductRelatedInfo.ProductAttr attr = new EsProductRelatedInfo.ProductAttr();</span><br><span class="line">        attr.setAttrId((Long) attrId.getKey());</span><br><span class="line">        List&lt;String&gt; attrValueList = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrValues = ((StringTerms) attrId.getAggregations().get(&quot;attrValues&quot;)).getBuckets();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrNames = ((StringTerms) attrId.getAggregations().get(&quot;attrNames&quot;)).getBuckets();</span><br><span class="line">        for (Terms.Bucket attrValue : attrValues) &#123;</span><br><span class="line">            attrValueList.add(attrValue.getKeyAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        attr.setAttrValues(attrValueList);</span><br><span class="line">        if(!CollectionUtils.isEmpty(attrNames))&#123;</span><br><span class="line">            String attrName = attrNames.get(0).getKeyAsString();</span><br><span class="line">            attr.setAttrName(attrName);</span><br><span class="line">        &#125;</span><br><span class="line">        attrList.add(attr);</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductAttrs(attrList);</span><br><span class="line">    return productRelatedInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>EsProductController</code>类中定义一个名为<code>searchRelatedInfo</code>的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;获取搜索的相关品牌、分类及筛选属性&quot;)</span><br><span class="line">@GetMapping(value = &quot;/search/relate&quot;)</span><br><span class="line">public CommonResult&lt;EsProductRelatedInfo&gt; searchRelatedInfo(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = esProductService.searchRelatedInfo(keyword);</span><br><span class="line">    return CommonResult.success(productRelatedInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fef19695a18583e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后进行接口测试。首先后台用户进行登录，接着测试相关接口，可以看到接口都是正常的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a308b197290a377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1cd8c204dc3094e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于使用ElasticSearch实现商品复杂搜索的学习就完成了，后续介绍如何整合MongoDB实现用户商品浏览记录这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合ElasticSearch实现商品搜索</title>
    <link href="http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/"/>
    <id>http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/</id>
    <published>2023-01-20T06:55:30.000Z</published>
    <updated>2023-03-14T06:38:37.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索这一功能。</p><h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><p>ElasticSearch是一个分布式、可扩展、实时的搜索与数据分析引擎，它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，在日常工作和学习中扮演着非常重要的角色。关于ElasticSearch的学习，可以参考笔者的其他文章。注意本篇使用的ElasticSearch版本为6.8.6。</p><p>Kibana作为访问ElasticSearch的客户端，可以很方便的提供开发者可视化方式操作ES。</p><p>在整合前，请确保ElasticSearch和Kibana都已经正确安装并启动，且ElasticSearch的分词器也已经安装。</p><h1 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h1><p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-Elasticsearch常用注解"><a href="#Spring-Data-Elasticsearch常用注解" class="headerlink" title="Spring Data Elasticsearch常用注解"></a>Spring Data Elasticsearch常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到ElasticSearch文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    //索引名称，类似于数据库中的数据库</span><br><span class="line">    String indexName();</span><br><span class="line">    //类型，类似于数据库中的数据表</span><br><span class="line">    String type() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useServerConfiguration() default false;</span><br><span class="line">    //分片数，默认为5</span><br><span class="line">    short shards() default 5;</span><br><span class="line">    //副本数，默认为1</span><br><span class="line">    short replicas() default 1;</span><br><span class="line">    //每次刷新间隔，默认1秒</span><br><span class="line">    String refreshInterval() default &quot;1s&quot;;</span><br><span class="line"></span><br><span class="line">    String indexStoreType() default &quot;fs&quot;;</span><br><span class="line"></span><br><span class="line">    boolean createIndex() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到ElasticSearch文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="@Field"></a>@Field</h3><p><code>@Field</code>注解添加到映射到ElasticSearch文档上的领域对象字段上，注意它用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Field &#123;</span><br><span class="line">    //文档中字段的类型</span><br><span class="line">    FieldType type() default FieldType.Auto;</span><br><span class="line">    //是否建立倒排索引，默认是</span><br><span class="line">    boolean index() default true;</span><br><span class="line"></span><br><span class="line">    DateFormat format() default DateFormat.none;</span><br><span class="line"></span><br><span class="line">    String pattern() default &quot;&quot;;</span><br><span class="line">    //是否进行存储</span><br><span class="line">    boolean store() default false;</span><br><span class="line"></span><br><span class="line">    boolean fielddata() default false;</span><br><span class="line"></span><br><span class="line">    String searchAnalyzer() default &quot;&quot;;</span><br><span class="line">    //分词器名称</span><br><span class="line">    String analyzer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String normalizer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] ignoreFields() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    boolean includeInParent() default false;</span><br><span class="line"></span><br><span class="line">    String[] copyTo() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个FieldType是一个枚举类，用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum FieldType &#123;</span><br><span class="line">    Text,  //进行分词并建立索引的字符类型</span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,  //自动判断字段类型</span><br><span class="line">    Nested,  //嵌套对象类型</span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword;  //不进行分词并建立索引的类型</span><br><span class="line"></span><br><span class="line">    private FieldType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承ElasticsearchRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface ElasticsearchRepository&lt;T, ID extends Serializable&gt; extends ElasticsearchCrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; S index(S var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; search(QueryBuilder var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(QueryBuilder var1, Pageable var2);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(SearchQuery var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; searchSimilar(T var1, String[] var2, Pageable var3);</span><br><span class="line"></span><br><span class="line">    void refresh();</span><br><span class="line"></span><br><span class="line">    Class&lt;T&gt; getEntityClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d961153b53feaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，商品表中有商品名称、商品副标题和关键字，直接在接口中定义如下方法，即可对这三个字段进行全文搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索查询</span><br><span class="line"> * @param name 商品名称</span><br><span class="line"> * @param subTitle 商品副标题</span><br><span class="line"> * @param keywords 商品关键字</span><br><span class="line"> * @param page 分页信息</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fb03dc0544a57dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用ElasticSearch的DSL语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?0&quot;&#125;&#125;&#125;&#125;&quot;)</span><br><span class="line">Page&lt;EsProduct&gt; findByName(String name,Pageable pageable);</span><br></pre></td></tr></table></figure><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>（1）<code>pms_product</code>：商品信息表；<br>（2）<code>pms_product_attribute</code>：商品属性参数表；<br>（3）<code>pms_product_attribute_value</code>：存储产品参数值的表，即商品id与商品属性id之间的对应关系表。</p><h1 id="整合ElasticSearch实现商品搜索"><a href="#整合ElasticSearch实现商品搜索" class="headerlink" title="整合ElasticSearch实现商品搜索"></a>整合ElasticSearch实现商品搜索</h1><p><strong>第一步</strong>，复制一份<code>shop-springsecurity-jwt</code>源码，将其名字修改为<code>shop-elasticsearch</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-elasticsearch</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-elasticsearch</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Elasticsearch相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在spring节点下添加ElasticSearch相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ElasticSearch相关</span><br><span class="line">data:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    repositories:</span><br><span class="line">      enabled: true</span><br><span class="line">    cluster-nodes: localhost:9300 # es的连接地址及端口号</span><br><span class="line">    cluster-name: elasticsearch # es集群的名称</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述三张表的对应信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内新建一个名为nosql的包，并在nosql包内定义一个名为elasticsearch的包，接着在elasticsearch包内定义一个名为document的包。然后在document包内定义一个名为EsProduct的类，注意这是商品文档对象。</p><p>一般来说，不需要分词的字段可以设置类型为Keyword，也就是使用<code>@Field(type = FieldType.Keyword)</code>注解，如这里的货号、品牌名称和商品分类名称。而需要进行分词的字段可以设置为Text类型，即使用<code>@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</code>注解，如这里的商品名称、副标题和关键字，同时需要指定分词器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document(indexName = &quot;pms&quot;, type = &quot;product&quot;,shards = 1,replicas = 0)</span><br><span class="line">public class EsProduct implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -1L;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line">    private Long brandId;</span><br><span class="line">    private Long productCategoryId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 货号</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productSn;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 品牌名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String brandName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品分类名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productCategoryName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 副标题</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String subTitle;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关键字</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String keywords;</span><br><span class="line"></span><br><span class="line">    private String pic;</span><br><span class="line">    private BigDecimal price;</span><br><span class="line">    private Integer sale;</span><br><span class="line">    private Integer newStatus;</span><br><span class="line">    private Integer recommendStatus;</span><br><span class="line">    private Integer stock;</span><br><span class="line">    private Integer promotionType;</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 嵌套类型，商品属性列表</span><br><span class="line">     */</span><br><span class="line">    @Field(type =FieldType.Nested)</span><br><span class="line">    private List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在document包内定义一个名为<code>EsProductAttributeValue</code>的类，因为商品文档对象EsProduct中有一个名为attrValueList的属性，它是一个List类型，里面都是<code>EsProductAttributeValue</code>对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品属性信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductAttributeValue implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品属性值id</span><br><span class="line">     */</span><br><span class="line">    private Long productAttributeId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性值</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性参数：0-&gt;规格；1-&gt;参数</span><br><span class="line">     */</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type=FieldType.Keyword)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch</code>包内新建一个名为repository的包，并在该包内定义一个名为<code>EsProductRepository</code>的接口，注意这个接口需要继承<code>ElasticsearchRepository</code>接口，这样就拥有了一些基本的操作ElasticSearch数据的方法，同时我们在里面定义了一个衍生的根据条件搜索查询商品的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在dao包内定义一个名为<code>EsProductDao</code>的接口，这是搜索系统中商品管理自定义的Dao。我们在里面添加一个从数据库中查询所有商品文档对象EsProduct的方法，当然了这个方法也可以传入id变成查询指定id的商品文档对象。简单来说就是查询数据库的多张表，将商品信息组装为EsProduct对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索系统中商品管理自定义的Dao</span><br><span class="line"> */</span><br><span class="line">public interface EsProductDao &#123;</span><br><span class="line">    List&lt;EsProduct&gt; getAllEsProductList(@Param(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在<code>resources/mapper</code>包内定义一个名为<code>EsProductDao</code>的XML文件，这是第八步中对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopelasticsearch.dao.EsProductDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;esProductListMap&quot; type=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct&quot;</span><br><span class="line">               autoMapping=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">        &lt;collection property=&quot;attrValueList&quot; columnPrefix=&quot;attr_&quot; ofType=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue&quot;&gt;</span><br><span class="line">            &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;product_attribute_id&quot; property=&quot;productAttributeId&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;value&quot; property=&quot;value&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;type&quot; property=&quot;type&quot;/&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;select id=&quot;getAllEsProductList&quot; resultMap=&quot;esProductListMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">            p.id id,</span><br><span class="line">            p.product_sn productSn,</span><br><span class="line">            p.brand_id brandId,</span><br><span class="line">            p.brand_name brandName,</span><br><span class="line">            p.product_category_id productCategoryId,</span><br><span class="line">            p.product_category_name productCategoryName,</span><br><span class="line">            p.pic pic,</span><br><span class="line">            p.name name,</span><br><span class="line">            p.sub_title subTitle,</span><br><span class="line">            p.price price,</span><br><span class="line">            p.sale sale,</span><br><span class="line">            p.new_status newStatus,</span><br><span class="line">            p.recommend_status recommendStatus,</span><br><span class="line">            p.stock stock,</span><br><span class="line">            p.promotion_type promotionType,</span><br><span class="line">            p.keywords keywords,</span><br><span class="line">            p.sort sort,</span><br><span class="line">            pav.id attr_id,</span><br><span class="line">            pav.value attr_value,</span><br><span class="line">            pav.product_attribute_id attr_product_attribute_id,</span><br><span class="line">            pa.type attr_type,</span><br><span class="line">            pa.name attr_name</span><br><span class="line">        from pms_product p</span><br><span class="line">        left join pms_product_attribute_value pav on p.id = pav.product_id</span><br><span class="line">        left join pms_product_attribute pa on pav.product_attribute_id= pa.id</span><br><span class="line">        where delete_status = 0 and publish_status = 1</span><br><span class="line">        &lt;if test=&quot;id!=null&quot;&gt;</span><br><span class="line">            and p.id=#&#123;id&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下上述配置信息的含义：<br>（1）mapper标签中的namespace属性用于指定此Mapper文件所对应的接口文件是第八步中定义的接口文件，即该文件的项目路径；<br>（2）由于<code>getAllEsProductList(@Param(&quot;id&quot;) Long id)</code>方法返回的是一个<code>List&lt;EsProduct&gt;</code>对象，因此该select标签返回的是一个resultMap对象，而这个对象返回的应该是<code>List&lt;EsProduct&gt;</code>中的EsProduct对象；<br>（3）在该mapper文件中定义一个id为<code>esProductListMap</code>的resultMap，然后指定type属性为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct</code>，也就是ES中存的对象类型。同时这里需要设置autoMapping属性的值为true，表示自动根据sql语句查询的字段名称与EsProduct类中设置的属性名称进行映射绑定；<br>（4）在resultMap标签内使用一个collection标签，指定property属性为attrValueList，这个值必须与开发者在EsProduct中指定的属性名称完全一致。接着设置columnPrefix，表示我们从数据库使用sql语句查询得到的字段名称都是<code>attr_</code>开头的，ofType指定类型为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue</code>。接着我们就使用result标签来手动将其进行绑定；<br>（5）通过上面的分析，我们知道在select标签中，<code>pms_product</code>表里查询得到的字段必须指定别名为与EsProduct属性相同的名称，而<code>pms_product_attribute_value</code>表中查询得到的字段别名必须以<code>attr_</code>开头，且符合上述自定义的映射关系。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>EsProductService</code>的接口，用于定义EsProduct搜索相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索的Service</span><br><span class="line"> */</span><br><span class="line">public interface EsProductService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 从数据中导入所有商品到ES</span><br><span class="line">     * @return 导入的文档数</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除ES中的商品</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在ES中创建指定id的商品文档信息</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    EsProduct create(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id批量删除ES中的商品</span><br><span class="line">     * @param ids 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(List&lt;Long&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据关键字搜索商品信息</span><br><span class="line">     * @param keyword 关键字</span><br><span class="line">     * @param pageNum 页码</span><br><span class="line">     * @param pageSize 每页数量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; search(String keyword,Integer pageNum, Integer pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>EsProductServiceImpl</code>的类，这个类需要实现<code>EsProductService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(EsProductServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProductIterable = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; esProductIterator = esProductIterable.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (esProductIterator.hasNext())&#123;</span><br><span class="line">            result++;</span><br><span class="line">            esProductIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(Long id) &#123;</span><br><span class="line">        esProductRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public EsProduct create(Long id) &#123;</span><br><span class="line">        EsProduct result = null;</span><br><span class="line">        List&lt;EsProduct&gt; esProductLists = esProductDao.getAllEsProductList(id);</span><br><span class="line">        if(esProductLists.size()&gt;0)&#123;</span><br><span class="line">            EsProduct esProduct = esProductLists.get(0);</span><br><span class="line">            result = esProductRepository.save(esProduct);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(List&lt;Long&gt; ids) &#123;</span><br><span class="line">        if(!CollectionUtils.isEmpty(ids))&#123;</span><br><span class="line">            List&lt;EsProduct&gt; esProductList = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Long id:ids) &#123;</span><br><span class="line">                EsProduct esProduct = new EsProduct();</span><br><span class="line">                esProduct.setId(id);</span><br><span class="line">                esProductList.add(esProduct);</span><br><span class="line">            &#125;</span><br><span class="line">            esProductRepository.deleteAll(esProductList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，在controller包内定义一个名为<code>EsProductController</code>的类，这是商品搜索功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品搜索管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;EsProductController&quot;,description = &quot;商品搜索管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/esProduct&quot;)</span><br><span class="line">public class EsProductController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductService esProductService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;导入所有数据库中商品到ES&quot;)</span><br><span class="line">    @PostMapping(&quot;/importAll&quot;)</span><br><span class="line">    public CommonResult&lt;Integer&gt; importAllList() &#123;</span><br><span class="line">        int count = esProductService.importAll();</span><br><span class="line">        return CommonResult.success(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id删除Es中指定的商品信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@PathVariable Long id) &#123;</span><br><span class="line">        esProductService.delete(id);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id批量删除Es中的商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/delete/batch&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;</span><br><span class="line">        esProductService.delete(ids);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id在ES中创建商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/create/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;EsProduct&gt; create(@PathVariable Long id) &#123;</span><br><span class="line">        EsProduct esProduct = esProductService.create(id);</span><br><span class="line">        if (esProduct != null) &#123;</span><br><span class="line">            return CommonResult.success(esProduct);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;简单搜索&quot;)</span><br><span class="line">    @GetMapping(&quot;/search/simple&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">        Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword, pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，修改<code>com.kenbings.shop.shopelasticsearch.common.api.CommonPage</code>类，在里面新增加一个将SpringData 分页后的list转为分页信息的restPage方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将 SpringData 分页后的list转为分页信息</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; CommonPage&lt;T&gt; restPage(Page&lt;T&gt; pageInfo)&#123;</span><br><span class="line">    CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">    commonPage.setPageNum(pageInfo.getNumber());</span><br><span class="line">    commonPage.setPageSize(pageInfo.getSize());</span><br><span class="line">    commonPage.setTotalPage(pageInfo.getTotalPages());</span><br><span class="line">    commonPage.setTotal(pageInfo.getTotalElements());</span><br><span class="line">    commonPage.setList(pageInfo.getContent());</span><br><span class="line">    return commonPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-759bd6bcb461605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十五步</strong>，进行接口测试。首先后台用户进行登录，接着测试“导入所有数据库中商品到ES”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96277397495717d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“简单搜索”这一接口，可以看到测试成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b838446b00c212b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合ElasticSearch实现商品搜索的学习就完成了，后续介绍如何使用ElasticSearch实现复杂搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合SpringSecurity和JWT实现认证与授权</title>
    <link href="http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/"/>
    <id>http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/</id>
    <published>2023-01-14T10:55:30.000Z</published>
    <updated>2023-03-14T06:36:44.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>SpringSecurity是一个强大的可高度定制的认证与授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。关于SpringSecurity的学习，可以参考笔者的其他文章。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JWT是JSON WEB TOKEN的缩写，它是基于RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p><h5 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h5><p>JWT由三部分组成：header、playload和signature，JWT token的格式为<code>header.payload.signature</code>。</p><p>其中header中用于存放签名的生成算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;: &quot;HS512&quot;&#125;</span><br></pre></td></tr></table></figure><p>payload中用于存放用户名、token的生成时间和过期时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;sub&quot;:&quot;admin&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br></pre></td></tr></table></figure><p>signature为以header和payload生成的签名，一旦header和payload被篡改，那么验证将失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//secret为加密算法的密钥</span><br><span class="line">String signature = HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure><h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><p>如下是一个JWT的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw</span><br></pre></td></tr></table></figure><p>开发者可以点击 <a href="https://jwt.io/">这里</a> 获取到解析结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b52c581daa8e3375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="JWT实现认证和授权的原理"><a href="#JWT实现认证和授权的原理" class="headerlink" title="JWT实现认证和授权的原理"></a>JWT实现认证和授权的原理</h5><p>第一步，用户调用登录接口，登录成功后获取到JWT的token；</p><p>第二步，用户后续每次调用接口时，都会在http的header中添加一个名为Authorization的头，值为JWT的token；</p><p>第三步，后台程序通过对Authorization头中信息的解码及数字签名，校验来获取其中的用户信息，进而实现认证和授权。</p><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p>Hutool是一个丰富的Java开源工具包，可以帮助我们简化每一行代码，减少每一个方法。</p><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>由于此处采用的是RBAC（基于角色的权限控制）模型，一般会涉及到五张表，同时外加针对某个用户的特定角色，因此会涉及到六张表，分别如下所示：<br>（1）<code>ums_admin</code>：后台用户表；<br>（2）<code>ums_role</code>：后台用户角色表；<br>（3）<code>ums_permission</code>：后台用户权限表；<br>（4）<code>ums_admin_role_relation</code>：后台用户和角色关系表，用户与角色是多对多关系；<br>（5） <code>ums_role_permission_relation</code>：后台用户角色和权限关系表，角色与权限是多对多关系；<br>（6）<code>ums_admin_permission_relation</code>：后台用户和权限关系表(除角色中定义的权限以外的加减权限)，加权限是指用户比角色多出的权限，减权限是指用户比角色少的权限。</p><h1 id="整合SpringSecurity及JWT"><a href="#整合SpringSecurity及JWT" class="headerlink" title="整合SpringSecurity及JWT"></a>整合SpringSecurity及JWT</h1><p><strong>第一步</strong>，复制一份<code>shop-redis</code>源码，将其名字修改为<code>shop-springsecurity-jwt</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-springsecurity-jwt</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-springsecurity-jwt</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringSecurity依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Hutool Java工具包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--JWT(Json Web Token)登录支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在根节点下添加jwt自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自定义jwt的key</span><br><span class="line">jwt:</span><br><span class="line">  tokenHeader: Authorization #JWT存储的请求头</span><br><span class="line">  secret: mySecret #JWT加解密使用的密钥</span><br><span class="line">  expiration: 604800 #JWT的超期限时间(60*60*24)</span><br><span class="line">  tokenHead: Bearer  #JWT负载中拿到开头</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt.common</code>包内新建一个名为utils的包，并在utils包内定义一个名为JwtTokenUtil的工具类，该类用于生成和解析JWT token以获取对应信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JwtToken生成的工具类</span><br><span class="line"> * JWT token的格式：header.payload.signature</span><br><span class="line"> * header的格式（算法、token的类型）：</span><br><span class="line"> * &#123;&quot;alg&quot;: &quot;HS512&quot;,&quot;typ&quot;: &quot;JWT&quot;&#125;</span><br><span class="line"> * payload的格式（用户名、创建时间、生成时间）：</span><br><span class="line"> * &#123;&quot;sub&quot;:&quot;kenbings&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br><span class="line"> * signature的生成算法：</span><br><span class="line"> * HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);</span><br><span class="line">    private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;</span><br><span class="line">    private static final String CLAIM_KEY_CREATED = &quot;created&quot;;</span><br><span class="line">    @Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">    private String secret;</span><br><span class="line">    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span><br><span class="line">    private Long expiration;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT的token</span><br><span class="line">     */</span><br><span class="line">    private String generateToken(Map&lt;String, Object&gt; claims) &#123;</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取JWT中的负载</span><br><span class="line">     */</span><br><span class="line">    private Claims getClaimsFromToken(String token) &#123;</span><br><span class="line">        Claims claims = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.info(&quot;JWT格式验证失败:&#123;&#125;&quot;,token);</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成token的过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date generateExpirationDate() &#123;</span><br><span class="line">        return new Date(System.currentTimeMillis() + expiration * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取登录用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUserNameFromToken(String token) &#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username =  claims.getSubject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证token是否还有效</span><br><span class="line">     *</span><br><span class="line">     * @param token       客户端传入的token</span><br><span class="line">     * @param userDetails 从数据库中查询出来的用户信息</span><br><span class="line">     */</span><br><span class="line">    public boolean validateToken(String token, UserDetails userDetails) &#123;</span><br><span class="line">        String username = getUserNameFromToken(token);</span><br><span class="line">        return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否已经失效</span><br><span class="line">     */</span><br><span class="line">    private boolean isTokenExpired(String token) &#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        return expiredDate.before(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date getExpiredDateFromToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        return claims.getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户信息生成token</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否可以被刷新</span><br><span class="line">     */</span><br><span class="line">    public boolean canRefresh(String token) &#123;</span><br><span class="line">        return !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新token</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下其中比较重要的三个方法的作用：<br>（1）<code>generateToken(UserDetails userDetails)</code>方法，传入的是一个UserDetails对象，这是SpringSecurity提供的对象，其实就是用户登录成功后信息的一个封装对象；<br>（2）<code>getUserNameFromToken(String token)</code>方法，从token中获取用户姓名，诸如此类的方法还有很多，这里就不再说明；<br>（3）<code>validateToken(String token, UserDetails userDetails)</code>方法，用于判断token是否有效，其中token是客户端传入的，而userDetails则是从数据库中查询出来的用户信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为component的包，并在component包内定义一个名为<code>RestfulAccessDeniedHandler</code>的类，该类定义当访问接口没有权限时，应当返回的结果，注意它需要实现<code>AccessDeniedHandler</code>接口，并重写其中的handle方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当访问接口没有权限时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestfulAccessDeniedHandler implements AccessDeniedHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在component包内定义一个名为<code>RestAuthenticationEntryPoint</code>的类，该类定义当未登录或者token失效访问接口时，应当返回的结果，注意它需要实现<code>AuthenticationEntryPoint</code>接口，并重写其中的commence方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当未登录或者token失效访问接口时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述六张表的对应信息。</p><p><strong>第八步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dto的包，并在dto包内定义一个名为<code>AdminUserDetails</code>的类，该类定义SpringSecurity登录时需要使用到的UserDetails，注意它需要实现<code>UserDetails</code>接口，并重写其中对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity登录时需要使用到的UserDetails</span><br><span class="line"> */</span><br><span class="line">public class AdminUserDetails implements UserDetails &#123;</span><br><span class="line">    private UmsAdmin umsAdmin;</span><br><span class="line">    private List&lt;UmsPermission&gt; permissionList;</span><br><span class="line"></span><br><span class="line">    public AdminUserDetails(UmsAdmin umsAdmin,List&lt;UmsPermission&gt; permissionList)&#123;</span><br><span class="line">        this.umsAdmin = umsAdmin;</span><br><span class="line">        this.permissionList = permissionList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回当前用户的权限</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        return permissionList.stream().filter(permission -&gt; permission.getValue()!=null)</span><br><span class="line">                .map(permission -&gt; new SimpleGrantedAuthority(permission.getValue()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return umsAdmin.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return umsAdmin.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return umsAdmin.getStatus().equals(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，正常来说这里面方法的逻辑都需要在数据库中定义对应的字段信息，然后根据业务逻辑来进行判断，而不是像这里直接固定化。这个类不需要交由Spring去管理，因此不需要添加<code>@Component</code>注解。</p><p><strong>第九步</strong>，在component包内定义一个名为<code>JwtAuthenticationTokenFilter</code>的类，这是JWT登录授权过滤器，注意它需要继承<code>OncePerRequestFilter</code>类，并重写其中的doFilterInternal方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JWT登录授权过滤器</span><br><span class="line"> */</span><br><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationTokenFilter.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        String authHeader = request.getHeader(this.tokenHeader);</span><br><span class="line">        if (authHeader != null &amp;&amp; authHeader.startsWith(this.tokenHead)) &#123;</span><br><span class="line">            //获取&quot;Bearer &quot;之后的部分</span><br><span class="line">            String authToken = authHeader.substring(this.tokenHead.length());</span><br><span class="line">            String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">            LOGGER.info(&quot;检查用户:&#123;&#125;&quot;, username);</span><br><span class="line">            if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123;</span><br><span class="line">                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);</span><br><span class="line">                if (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    LOGGER.info(&quot;当前认证用户:&#123;&#125;&quot;, username);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在校验用户名和密码之前添加的过滤器，如果请求中包含jwt且token有效，那么会从中用户名，然后调用SpringSecurity的相关API来进行登录操作。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>UmsAdminService</code>的接口，用于定义后台管理员相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名查询后台管理员</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin getAdminByUsername(String username);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员注册</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin register(UmsAdmin umsAdminParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员登录</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param password 密码</span><br><span class="line">     * @return 生成的JWT的token</span><br><span class="line">     */</span><br><span class="line">    String login(String username, String password);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定后台管理员的所有权限（包括角色权限和+-权限）</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>UmsAdminServiceImpl</code>的类，这个类需要实现<code>UmsAdminService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsAdminServiceImpl implements UmsAdminService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(UmsAdminServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminMapper adminMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminRoleRelationDao adminRoleRelationDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin getAdminByUsername(String username) &#123;</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(username);</span><br><span class="line">        List&lt;UmsAdmin&gt; adminLists = adminMapper.selectByExample(example);</span><br><span class="line">        if(adminLists !=null &amp;&amp; !adminLists.isEmpty())&#123;</span><br><span class="line">            return adminLists.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin register(UmsAdmin umsAdminParam) &#123;</span><br><span class="line">        //查询是否有相同用户名的用户</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(umsAdminParam.getUsername());</span><br><span class="line">        List&lt;UmsAdmin&gt; umsAdminList = adminMapper.selectByExample(example);</span><br><span class="line">        if (!umsAdminList.isEmpty()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = new UmsAdmin();</span><br><span class="line">        BeanUtils.copyProperties(umsAdminParam, umsAdmin);</span><br><span class="line">        umsAdmin.setCreateTime(new Date());</span><br><span class="line">        umsAdmin.setStatus(1);</span><br><span class="line">        //将密码进行加密操作</span><br><span class="line">        String encodePassword = passwordEncoder.encode(umsAdmin.getPassword());</span><br><span class="line">        umsAdmin.setPassword(encodePassword);</span><br><span class="line">        adminMapper.insert(umsAdmin);</span><br><span class="line">        return umsAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String login(String username, String password) &#123;</span><br><span class="line">        String token = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">            if(userDetails == null)&#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;不存在对应的用户信息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!passwordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;密码不正确&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            LOGGER.warn(&quot;登录异常:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;UmsPermission&gt; getPermissionList(Long adminId) &#123;</span><br><span class="line">        return adminRoleRelationDao.getPermissionList(adminId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在后面我们定义了<code>getPermissionList(Long adminId)</code>方法，该方法用于根据adminId从数据库中查询用户所有的权限，包括角色权限以及个人独有的权限。</p><p><strong>第十二步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dao的包，并在dao包内定义一个名为<code>UmsAdminRoleRelationDao</code>的接口，这是一个自定义的dao，用于查询后台用户与角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于查询后台用户与角色的自定义DAO</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminRoleRelationDao &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取用户所有权限(包括+-权限)</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(@Param(&quot;adminId&quot;) Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，在resources目录下新建一个名为mapper的目录，并在mapper目录下定义一个名为<code>UmsAdminRoleRelationDao.xml</code>的XML文件，这个其实就是之前UmsAdminRoleRelationDao接口对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopspringsecurityjwt.dao.UmsAdminRoleRelationDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getPermissionList&quot; resultMap=&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper.UmsPermissionMapper.BaseResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_role_relation ar</span><br><span class="line">                LEFT JOIN ums_role r ON ar.role_id = r.id</span><br><span class="line">                LEFT JOIN ums_role_permission_relation rp ON r.id = rp.role_id</span><br><span class="line">                LEFT JOIN ums_permission p ON rp.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            ar.admin_id = #&#123;adminId&#125;</span><br><span class="line">          AND p.id IS NOT NULL</span><br><span class="line">          AND p.id NOT IN (</span><br><span class="line">            SELECT</span><br><span class="line">                p.id</span><br><span class="line">            FROM</span><br><span class="line">                ums_admin_permission_relation pr</span><br><span class="line">                    LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">            WHERE</span><br><span class="line">                pr.type = - 1</span><br><span class="line">              AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">        )</span><br><span class="line">        UNION</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_permission_relation pr</span><br><span class="line">                LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            pr.type = 1</span><br><span class="line">          AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，在config包内定义一个名为SecurityConfig的类，这是SpringSecurity的配置类，它需要继承<code>WebSecurityConfigurerAdapter</code>类，并实现其中的一些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled=true)</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器</span><br><span class="line">     * @param httpSecurity</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        httpSecurity.csrf()// 由于使用的是JWT，我们这里不需要csrf</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement()// 基于token，所以不需要session</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问</span><br><span class="line">                        &quot;/&quot;,</span><br><span class="line">                        &quot;/*.html&quot;,</span><br><span class="line">                        &quot;/favicon.ico&quot;,</span><br><span class="line">                        &quot;/**/*.html&quot;,</span><br><span class="line">                        &quot;/**/*.css&quot;,</span><br><span class="line">                        &quot;/**/*.js&quot;,</span><br><span class="line">                        &quot;/swagger-resources/**&quot;,</span><br><span class="line">                        &quot;/v2/api-docs/**&quot;</span><br><span class="line">                )</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(&quot;/admin/login&quot;, &quot;/admin/register&quot;)// 对登录注册要允许匿名访问</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求</span><br><span class="line">                .permitAll()</span><br><span class="line">//                .antMatchers(&quot;/**&quot;)//测试时全部运行访问</span><br><span class="line">//                .permitAll()</span><br><span class="line">                .anyRequest()// 除上面外的所有请求全部需要鉴权认证</span><br><span class="line">                .authenticated();</span><br><span class="line">        // 禁用缓存</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line">        // 添加JWT filter</span><br><span class="line">        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        //添加自定义未授权和未登录结果返回</span><br><span class="line">        httpSecurity.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(restAuthenticationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置UserDetailsService及PasswordEncoder</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService())</span><br><span class="line">                .passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">        //获取登录用户信息</span><br><span class="line">        return username -&gt; &#123;</span><br><span class="line">            UmsAdmin admin = adminService.getAdminByUsername(username);</span><br><span class="line">            if (admin != null) &#123;</span><br><span class="line">                List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(admin.getId());</span><br><span class="line">                return new AdminUserDetails(admin,permissionList);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()&#123;</span><br><span class="line">        return new JwtAuthenticationTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述一些方法：<br>（1）<code>configure(HttpSecurity httpSecurity)</code>方法，用于配置需要拦截的url路径、jwt过滤器及出现异常后的处理器；<br>（2）<code>configure(AuthenticationManagerBuilder auth)</code>方法，用于配置UserDetailsService及PasswordEncoder；<br>（3）<code>passwordEncoder()</code>方法，这是SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder；<br>（4）<code>userDetailsService()</code>方法，这是SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要开发者自行实现；<br>（5）<code>jwtAuthenticationTokenFilter()</code>方法，这是在校验用户名和密码前添加的过滤器，如果有jwt且token有效，那么会自行根据token信息进行登录；<br>（6）<code>RestfulAccessDeniedHandler</code>，这是当访问接口没有权限时，返回自定义的JSON格式结果；<br>（7）<code>RestAuthenticationEntryPoint</code>，这是当未登录或者token失效访问接口时，返回自定义的JSON格式结果。</p><p><strong>第十五步</strong>，在dto包内定义一个名为<code>UmsAdminLoginParam</code>的类，这是后台管理员登录参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录参数</span><br><span class="line"> */</span><br><span class="line">public class UmsAdminLoginParam &#123;</span><br><span class="line">    @ApiModelProperty(value = &quot;用户名&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;用户名不能为空&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @ApiModelProperty(value = &quot;密码&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;密码不能为空&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，在controller包内定义一个名为<code>UmsAdminController</code>的类，这是后台管理员登录注册功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录注册功能Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags = &quot;UmsAdminController&quot;, description = &quot;后台用户管理&quot;)</span><br><span class="line">@RequestMapping(&quot;/admin&quot;)</span><br><span class="line">public class UmsAdminController &#123;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;用户注册&quot;)</span><br><span class="line">    @PostMapping(&quot;/register&quot;)</span><br><span class="line">    public CommonResult&lt;UmsAdmin&gt; register(@RequestBody UmsAdmin umsAdminParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = adminService.register(umsAdminParam);</span><br><span class="line">        if (umsAdmin == null) &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">        return CommonResult.success(umsAdmin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;登录后返回token&quot;)</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public CommonResult login(@Validated @RequestBody UmsAdminLoginParam umsAdminLoginParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());</span><br><span class="line">        if (token == null) &#123;</span><br><span class="line">            return CommonResult.validateFailed(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;();</span><br><span class="line">        tokenMap.put(&quot;token&quot;, token);</span><br><span class="line">        tokenMap.put(&quot;tokenHead&quot;, tokenHead);</span><br><span class="line">        return CommonResult.success(tokenMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取用户所有权限（包括+-权限）&quot;)</span><br><span class="line">    @GetMapping(&quot;/permission/&#123;adminId&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public CommonResult&lt;List&lt;UmsPermission&gt;&gt; getPermissionList(@PathVariable @ApiParam(&quot;后台用户id&quot;)Long adminId) &#123;</span><br><span class="line">        List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(adminId);</span><br><span class="line">        return CommonResult.success(permissionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们只提供了三个接口，分别是后台用户登录、注册以及获取对应权限的接口。</p><p><strong>第十七步</strong>，修改config包中Swagger2Config类的代码为如下所示，这里其实就是实现接口调用时自带Authorization头，后续就可以访问需要登录的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopspringsecurityjwt.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                //添加登录认证</span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;ApiKey&gt; securitySchemes() &#123;</span><br><span class="line">        //设置请求头信息</span><br><span class="line">        List&lt;ApiKey&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        ApiKey apiKey = new ApiKey(&quot;Authorization&quot;, &quot;Authorization&quot;, &quot;header&quot;);</span><br><span class="line">        result.add(apiKey);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        //设置需要登录认证的路径</span><br><span class="line">        List&lt;SecurityContext&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        result.add(getContextByPath(&quot;/brand/.*&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SecurityContext getContextByPath(String pathRegex)&#123;</span><br><span class="line">        return SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(pathRegex))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityReference&gt; defaultAuth() &#123;</span><br><span class="line">        List&lt;SecurityReference&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];</span><br><span class="line">        authorizationScopes[0] = authorizationScope;</span><br><span class="line">        result.add(new SecurityReference(&quot;Authorization&quot;, authorizationScopes));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在<code>securityContexts()</code>方法中设置了需要登录认证的路径，即品牌相关的接口访问都需要登录之后才能访问。</p><p><strong>第十八步</strong>，修改之前PmsBrandController类中的方法，我们给它们添加如下访问权限：<br>（1）给添加接口添加<code>pms:brand:create</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:create&#x27;)&quot;)</span><br><span class="line">public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)</span><br></pre></td></tr></table></figure><p>（2）给删除接口添加<code>pms:brand:delete</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:delete&#x27;)&quot;)</span><br><span class="line">public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)</span><br></pre></td></tr></table></figure><p>（3）给修改接口添加<code>pms:brand:update</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:update&#x27;)&quot;)</span><br><span class="line">public CommonResult updateBrand(</span><br><span class="line">    @PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">    @RequestBody PmsBrand pmsBrandDTO, </span><br><span class="line">    BindingResult result</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（4）给查询接口添加<code>pms:brand:read</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)</span><br></pre></td></tr></table></figure><p>注意这里面的权限就是<code>ums_permission</code>数据表中value字段的值，因此值必须按照要求进行书写：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6fcc1f9d38bfc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第十九步</strong>，修改项目启动类<code>ShopSpringSecurityJwtApplication</code>，在其上面使用<code>@MapperScan</code>注解来指定扫描的mapper接口路径，注意我们的mapper接口路径有两个，因此需要使用字符串数组来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&#123;&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper&quot;,&quot;com.kenbings.shop.shopspringsecurityjwt.dao&quot;&#125;)</span><br><span class="line">public class ShopSpringSecurityJwtApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ShopSpringSecurityJwtApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二十步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8f52c710416dae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先是未登录，访问<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到返回之前定义的JSON信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f2c2db75536ff30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ac173bb1a1feff3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们尝试进行登录，登录账号为kenbings，密码为kenbings，访问<code>/admin/login</code>接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc4d2180603d3d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-12b5fc8e6fb6bcbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们已经登录成功了，接下来点击右侧的Authorize按钮，在弹框中输入登录接口中获取到的token信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2d6b3eb1c1600269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后我们再来访问之前的<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到该接口已经可以正常访问了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa6f5902c79f4d44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们再来访问一些需要权限的接口，如获取商品品牌管理中获取所有品牌信息的接口<code>/brand/listAll</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-129799d3530a2051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这是正常结果，因为当前用户没有任何权限，我们给这个用户可以访问该接口的权限，接着再去访问一下该接口，可以看到数据能正常返回了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ca370de9d75a069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合SpringSecurity和JWT实现认证与授权的学习就完成了，后续介绍如何整合ElasticSearch实现商品搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-springsecurity-jwt">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。&lt;/p</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Redis实现数据缓存</title>
    <link href="http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/"/>
    <id>http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/</id>
    <published>2023-01-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:32:47.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。</p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个使用C语言开发的高性能键值对数据库，可用于数据缓存，以实现大量数据的高并发负载访问。</p><p>点击 <a href="https://github.com/MicrosoftArchive/redis/releases">这里</a> 下载Redis，选择3.2.100的版本进行下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-26cb65d7746bafdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>下载之后解压到指定目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4369236c61892f6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着打开终端，切换到上述解压目录，执行redis启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p>可以看到此时redis就已经启动成功了。</p><h1 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h1><p><strong>第一步</strong>，复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-redis</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-redis</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-redis</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis依赖配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在指定位置处新增如下配置信息。首先在spring节点下新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost # Redis服务器地址</span><br><span class="line">    database: 2 # Redis数据库索引（默认为0）</span><br><span class="line">    port: 6379 # Redis服务器连接端口</span><br><span class="line">    password: envy123 # Redis服务器连接密码（默认为空）</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">        max-idle: 8 # 连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 # 连接池中的最小空闲连接</span><br><span class="line">    timeout: 3000ms # 连接超时时间（毫秒）</span><br></pre></td></tr></table></figure><p>然后在根节点下添加Redis自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 自定义redis的key</span><br><span class="line">redis:</span><br><span class="line">  key:</span><br><span class="line">    prefix:</span><br><span class="line">      authCode: &quot;portal:authCode:&quot;</span><br><span class="line">    expire:</span><br><span class="line">      authCode: 120 # 验证码超期时间，单位秒</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在service包内定义一个名为RedisService的接口，用于定义一些常用的Redis操作，此处我们让对象和数组都以JSON形式进行存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Redis操作</span><br><span class="line"> * 对象和数组都以JSON形式进行存储</span><br><span class="line"> */</span><br><span class="line">public interface RedisService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存储数据</span><br><span class="line">     */</span><br><span class="line">    void set(String key,String value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据</span><br><span class="line">     */</span><br><span class="line">    String get(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置超期时间</span><br><span class="line">     */</span><br><span class="line">    boolean expire(String key,long expire);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    void remove(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自增操作</span><br><span class="line">     * @param delta 自增步长</span><br><span class="line">     */</span><br><span class="line">    Long increment(String key,long delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在impl包内定义一个名为RedisServiceImpl的类，这个类需要实现RedisService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisServiceImpl implements RedisService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String get(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean expire(String key, long expire) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key,expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long increment(String key, long delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key,delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，这里我们以会员发送验证码为例来介绍如何使用Redis。在service包内定义一个名为UmsMemberService的接口，用于定义会员管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsMemberService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号生成验证码</span><br><span class="line">     */</span><br><span class="line">    CommonResult generateAuthCode(String telephone);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断验证码和手机号是否匹配</span><br><span class="line">     */</span><br><span class="line">    CommonResult verifyAuthCode(String telephone,String authCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为UmsMemberServiceImpl的类，这个类需要实现UmsMemberService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsMemberServiceImpl implements UmsMemberService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.prefix.authCode&#125;&quot;)</span><br><span class="line">    private String REDIS_KEY_PREFIX_AUTH_CODE;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.expire.authCode&#125;&quot;)</span><br><span class="line">    private Long AUTH_CODE_EXPIRE_SECONDS;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateAuthCode(String telephone) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            stringBuilder.append(random.nextInt(10));</span><br><span class="line">        &#125;</span><br><span class="line">        String authCode = stringBuilder.toString();</span><br><span class="line">        //验证码+手机号作为Key存储到Redis中</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        redisService.set(redisKey,authCode);</span><br><span class="line">        redisService.expire(redisKey,AUTH_CODE_EXPIRE_SECONDS);</span><br><span class="line">        return CommonResult.success(authCode,&quot;验证码获取成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult verifyAuthCode(String telephone, String authCode) &#123;</span><br><span class="line">        if(StringUtils.isEmpty(authCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;请输入验证码&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        String redisAuthCode = redisService.get(redisKey);</span><br><span class="line">        if(StringUtils.isEmpty(redisAuthCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result = authCode.equals(redisAuthCode);</span><br><span class="line">        if(result)&#123;</span><br><span class="line">            return CommonResult.success(null,&quot;验证码校验成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为UmsMemberController的类，这是会员登录注册管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;UmsMemberController&quot;,description = &quot;会员登录注册管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/sso&quot;)</span><br><span class="line">public class UmsMemberController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsMemberService umsMemberService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取验证码&quot;)</span><br><span class="line">    @GetMapping(&quot;/getAuthCode&quot;)</span><br><span class="line">    public CommonResult getAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone)&#123;</span><br><span class="line">        return umsMemberService.generateAuthCode(telephone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;校验验证码是否正确&quot;)</span><br><span class="line">    @PostMapping(&quot;/verifyAuthCode&quot;)</span><br><span class="line">    public CommonResult verifyAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone,@ApiParam(&quot;验证码&quot;)@RequestParam String authCode)&#123;</span><br><span class="line">        return umsMemberService.verifyAuthCode(telephone,authCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-88a3bea3216897d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后测试获取验证码的接口，可以发现测试是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3abff9e3628d2059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下校验验证码是否正确的接口，发现测试也是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ed658578a9933b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Redis实现数据缓存的学习就完成了，后续介绍如何整合SpringSecurity和JWT实现认证与授权这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-redis">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Swagger-UI实现在线API文档</title>
    <link href="http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/"/>
    <id>http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/</id>
    <published>2023-01-10T02:55:30.000Z</published>
    <updated>2023-03-14T06:29:52.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。</p><h1 id="Swagger-UI简介"><a href="#Swagger-UI简介" class="headerlink" title="Swagger-UI简介"></a>Swagger-UI简介</h1><p>Swagger-UI是HTML、CSS和Javascript的一个集合，可以动态地根据注解生成在线API文档，本篇将要整合的Swagger-UI版本为2系列。</p><p>Swagger-UI常用的一些注解如下所示：<br>（1）<code>@Api</code>：用于修饰Controller类，可生成Controller相关的文档信息；<br>（2）<code>@ApiOperation</code>：用于修饰Controller类中的方法，可生成接口方法相关的文档信息；<br>（3）<code>@ApiParam</code>：用于修饰接口中方法的参数，可生成接口参数相关的文档信息；<br>（4）<code>@ApiModelProperty</code>：用于修饰实体类的属性，当实体类是请求参数或返回结果时，会直接生成相关的文档信息。</p><p>关于Swagger-UI的详细介绍，可以参阅笔者其他的文章，此处不做过多介绍。</p><h1 id="整合Swagger-UI"><a href="#整合Swagger-UI" class="headerlink" title="整合Swagger-UI"></a>整合Swagger-UI</h1><p><strong>第一步</strong>，复制一份<code>shop-basic</code>源码，将其名字修改为<code>shop-swagger-ui</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-swagger-ui</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-swagger-ui</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.3.7&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;!--Swagger-UI API文档--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意，<code>mybatis-generator-core</code>的版本必须从1.3.3修改为1.3.7，否则后续在生成API文档的时候会出现异常问题，以及新生成的mapper文件无法覆盖旧文件的情况。</p><p><strong>第三步</strong>，在config包内新建一个名为Swagger2Config的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br><span class="line">                //为有@Api注解的Controller生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br><span class="line">                //为有@ApiOperation注解的方法生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，Swagger UI对生成API文档的范围有三种选择，分别如下所示：<br>（1）生成指定包下类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br></pre></td></tr></table></figure><p>（2）生成有指定注解的类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br></pre></td></tr></table></figure><p>（3）生成有指定注解的方法的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，给需要生成的Controller类添加Swagger注解，此处选择之前使用的品牌管理PmsBrandController类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;PmsBrandController&quot;,description = &quot;商品品牌管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取所有的品牌信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;添加品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;更新指定id的品牌信息&quot;)</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;删除指定id的品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;分页查询品牌列表&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取指定id的品牌详情&quot;)</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们充分使用了<code>@Api</code>、<code>@ApiOperation</code>和<code>@ApiParam</code>注解，没有使用到<code>@ApiModelProperty</code>注解，那是因为<code>@ApiModelProperty</code>注解用于修饰实体类的属性，我们如果要使用它，就要修改MyBatis Generator注释的生成规则。</p><p><strong>第五步</strong>，修改MyBatis Generator注释的生成规则。在前面我们说过，<code>CommentGenerator</code>类是自定义注释生成器，我们可以修改<code>addFieldComment</code>方法，使其可以生成Swagger的<code>@ApiModelProperty</code>注解来取代原来的方法注释。同时还需要添加<code>addJavaFileComment</code>方法，使其能在import中导入<code>@ApiModelProperty</code>，否则需要手动导入该类，这在需要生成大量实体类时，是一件非常痛苦的事情。</p><p><code>CommentGenerator</code>类中的代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line">    private static final String EXAMPLE_SUFFIX=&quot;Example&quot;;</span><br><span class="line">    private static final String API_MODEL_PROPERTY_FULL_CLASS_NAME=&quot;io.swagger.annotations.ApiModelProperty&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            //数据库中特殊字符需要转义</span><br><span class="line">            if(remarks.contains(&quot;\&quot;&quot;))&#123;</span><br><span class="line">                remarks = remarks.replace(&quot;\&quot;&quot;,&quot;&#x27;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //给model的字段添加swagger注解</span><br><span class="line">            field.addJavaDocLine(&quot;@ApiModelProperty(value = \&quot;&quot;+remarks+&quot;\&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addJavaFileComment(CompilationUnit compilationUnit) &#123;</span><br><span class="line">        super.addJavaFileComment(compilationUnit);</span><br><span class="line">        //只在model中添加swagger注解类的导入</span><br><span class="line">        if(!compilationUnit.isJavaInterface()&amp;&amp;!compilationUnit.getType().getFullyQualifiedName().contains(EXAMPLE_SUFFIX))&#123;</span><br><span class="line">            compilationUnit.addImportedType(new FullyQualifiedJavaType(API_MODEL_PROPERTY_FULL_CLASS_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在<code>generatorConfig.xml</code>文件中新增一行配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--生成mapper.xml时覆盖原文件--&gt;</span><br><span class="line">&lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;</span><br></pre></td></tr></table></figure><p>注意配置项的放置位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e333f0646a2cb799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第七步</strong>，执行Generator类中的main方法，可以看到此时会重新生成mbg中的代码。</p><p>可以看到新生成的PmsBrand类里面，已经根据数据库注释自动添加了<code>@ApiModelProperty</code>注解：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7b29773035cf8a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第八步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，效果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b7ab59b14cb1cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击添加品牌按钮，可以看到里面已经显示从<code>@ApiModelProperty</code>文件中生成的说明信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-76a53338333057a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击分页查询品牌列表，可以看到返回结果也已经进行了说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ba083acf7836a3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时开发者可以直接在文档上进行接口测试，这里以查询id为1的品牌详情信息为例进行说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-899fc1f73cb9b6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa9c286cf227f08f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Swagger-UI实现在线API文档的学习就完成了，后续介绍如何整合单机版Redis实现缓存这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-swagger-ui">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>项目骨架搭建</title>
    <link href="http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/"/>
    <id>http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/</id>
    <published>2023-01-08T09:55:30.000Z</published>
    <updated>2023-03-14T06:27:04.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操作，以及通过PageHelper实现分页查询。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>一个基于Spring的快速搭建Java企业级应用的开发框架。</p><h3 id="Mybatis-generator"><a href="#Mybatis-generator" class="headerlink" title="Mybatis generator"></a>Mybatis generator</h3><p>Mybatis代码生成器，可根据数据库生成对应的model、mapper.xml、mapper接口以及Example，这样一般的单表查询不用再手写mapper。</p><h3 id="PagerHelper"><a href="#PagerHelper" class="headerlink" title="PagerHelper"></a>PagerHelper</h3><p>MyBatis分页插件，只需几行简单事务代码就能实现分页功能。如果你使用的是SpringBoot，那么只要整合了PagerHelper就自动整合了MyBatis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">//之后进行查询操作将自动进行分页</span><br><span class="line">List&lt;PmsBrand&gt; brandList = brandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">//通过构造PageInfo对象获取分页信息，如当前页码，总页数，总条数</span><br><span class="line">PageInfo&lt;PmsBrand&gt; pageInfo = new PageInfo&lt;PmsBrand&gt;(list);</span><br></pre></td></tr></table></figure><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>阿里巴巴开源的数据库连接池，性能极佳，提供了多种特性和功能。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p><strong>第一步</strong>，使用Maven新建一个名为myshop-all的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-87cd54660844c03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，删除其中的src目录，并修改其中的pom文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;myshop-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;shop-basic&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在myshop-all目录下，使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为shop-basic的Module：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-14744df2535d4ea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，修改<code>shop-basic</code>这一web项目的pom文件内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-basic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;shop-basic&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;项目骨架搭建&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--集成druid连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Mysql数据库驱动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，修改<code>shop-basic</code>这一web项目的application.yml配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，新建<code>com.kenbings.shop.shopbasic.common.api</code>这两级目录，然后在api目录中新建IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 封装API的错误码</span><br><span class="line"> */</span><br><span class="line">public interface IErrorCode &#123;</span><br><span class="line">    long getCode();</span><br><span class="line"></span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建ResultCode枚举类，需要实现之前的IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一些常用API操作码枚举类</span><br><span class="line"> */</span><br><span class="line">public enum ResultCode implements IErrorCode&#123;</span><br><span class="line">    SUCCESS(200, &quot;操作成功&quot;),</span><br><span class="line">    FAILED(500, &quot;操作失败&quot;),</span><br><span class="line">    VALIDATE_FAILED(404, &quot;参数检验失败&quot;),</span><br><span class="line">    UNAUTHORIZED(401, &quot;暂未登录或token已经过期&quot;),</span><br><span class="line">    FORBIDDEN(403, &quot;没有相关权限&quot;);</span><br><span class="line"></span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    private ResultCode(long code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonResult类，用于构建一个通用的返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通用返回对象</span><br><span class="line"> */</span><br><span class="line">public class CommonResult&lt;T&gt; &#123;</span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public CommonResult()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public CommonResult(long code,String message,T data)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMessage(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data,String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), message,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param errorCode 返回的错误码</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(IErrorCode errorCode)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(errorCode.getCode(),errorCode.getMessage(),null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param message 返回的提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.FAILED.getCode(), message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed() &#123;</span><br><span class="line">        return failed(ResultCode.FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed() &#123;</span><br><span class="line">        return failed(ResultCode.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     * @param message 提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed(String message) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.VALIDATE_FAILED.getCode(), message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未登录返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; unauthorized(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.UNAUTHORIZED.getCode(), ResultCode.UNAUTHORIZED.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未授权返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; forbidden(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.FORBIDDEN.getCode(), ResultCode.FORBIDDEN.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(long code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonPage类，这是一个用于封装分页数据的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页数据封装类</span><br><span class="line"> */</span><br><span class="line">public class CommonPage&lt;T&gt; &#123;</span><br><span class="line">    private Integer pageNum;</span><br><span class="line">    private Integer pageSize;</span><br><span class="line">    private Integer totalPage;</span><br><span class="line">    private Long total;</span><br><span class="line">    private List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将 PageHelper 分页后的list转换为分页信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonPage&lt;T&gt; restPage(List&lt;T&gt; list)&#123;</span><br><span class="line">        CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">        PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(list);</span><br><span class="line">        commonPage.setPageNum(pageInfo.getPageNum());</span><br><span class="line">        commonPage.setPageSize(pageInfo.getPageSize());</span><br><span class="line">        commonPage.setTotalPage(pageInfo.getPages());</span><br><span class="line">        commonPage.setTotal(pageInfo.getTotal());</span><br><span class="line">        commonPage.setList(pageInfo.getList());</span><br><span class="line">        return commonPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageNum() &#123;</span><br><span class="line">        return pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageNum(Integer pageNum) &#123;</span><br><span class="line">        this.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageSize() &#123;</span><br><span class="line">        return pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageSize(Integer pageSize) &#123;</span><br><span class="line">        this.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getTotalPage() &#123;</span><br><span class="line">        return totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotalPage(Integer totalPage) &#123;</span><br><span class="line">        this.totalPage = totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getTotal() &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotal(Long total) &#123;</span><br><span class="line">        this.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，新建<code>com.kenbings.shop.shopbasic.config</code>目录，在里面定义一个名为MyBatisConfig的类，用于设置动态生成的mapper接口的路径信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;)</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，新建<code>com.kenbings.shop.shopbasic.mbg</code>目录，在里面定义一个名为CommentGenerator的类，它需要继承DefaultCommentGenerator类，用于自定义注释生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            addFieldJavaDoc(field, remarks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给model的字段添加注释</span><br><span class="line">     */</span><br><span class="line">    private void addFieldJavaDoc(Field field, String remarks) &#123;</span><br><span class="line">        //文档注释开始</span><br><span class="line">        field.addJavaDocLine(&quot;/**&quot;);</span><br><span class="line">        //获取数据库字段的备注信息</span><br><span class="line">        String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));</span><br><span class="line">        for (String remarkLine : remarkLines) &#123;</span><br><span class="line">            field.addJavaDocLine(&quot; * &quot; + remarkLine);</span><br><span class="line">        &#125;</span><br><span class="line">        addJavadocTag(field, false);</span><br><span class="line">        //文档注释结束</span><br><span class="line">        field.addJavaDocLine(&quot; */&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在mbg目录下新建一个名为Generator的类，用于执行MBG的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于执行MBG的代码</span><br><span class="line"> */</span><br><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream inputStream = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser configurationParser = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = configurationParser.parseConfiguration(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        //创建 MBG</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在resources目录下新建一个名为<code>generatorConfig.xml</code>的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!--可以自定义生成model的代码注释--&gt;</span><br><span class="line">        &lt;commentGenerator type=&quot;com.kenbings.shop.shopbasic.mbg.CommentGenerator&quot;&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--配置数据库连接--&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot;</span><br><span class="line">                        connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot;</span><br><span class="line">                        userId=&quot;$&#123;jdbc.userId&#125;&quot;</span><br><span class="line">                        password=&quot;$&#123;jdbc.password&#125;&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!--指定生成model的路径--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.model&quot; targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper.xml的路径--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot; targetProject=&quot;shop-basic\src\main\resources&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper接口的的路径--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;pms_brand&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在resources目录下新建一个名为<code>generator.properties</code>的数据配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.connectionURL=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">jdbc.userId=root</span><br><span class="line">jdbc.password=envy123</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，打开数据库，执行如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS shop;</span><br><span class="line">CREATE DATABASE shop;</span><br><span class="line">USE shop;</span><br><span class="line">DROP TABLE IF EXISTS pms_brand;</span><br><span class="line">CREATE TABLE `pms_brand` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,</span><br><span class="line">  `first_letter` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;首字母&#x27;,</span><br><span class="line">  `sort` int DEFAULT NULL,</span><br><span class="line">  `factory_status` int DEFAULT NULL COMMENT &#x27;是否为品牌制造商：0-&gt;不是；1-&gt;是&#x27;,</span><br><span class="line">  `show_status` int DEFAULT NULL,</span><br><span class="line">  `product_count` int DEFAULT NULL COMMENT &#x27;产品数量&#x27;,</span><br><span class="line">  `product_comment_count` int DEFAULT NULL COMMENT &#x27;产品评论数量&#x27;,</span><br><span class="line">  `logo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;品牌logo&#x27;,</span><br><span class="line">  `big_pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;专区大图&#x27;,</span><br><span class="line">  `brand_story` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT &#x27;品牌故事&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb3 COMMENT=&#x27;品牌表&#x27;;</span><br></pre></td></tr></table></figure><p>此时我们项目的基本骨架如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a2e09010d13779a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，执行Generator类中的main方法，可以看到此时生成后的目录结构如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3bf6f596d7e6e682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十四步</strong>，新建<code>com.kenbings.shop.shopbasic.service</code>目录，并在里面新建一个名为PmsBrandService的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface PmsBrandService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listAllBrand();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    int createBrand(PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    int updateBrand(Long id,PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    int deleteBrand(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    PmsBrand getBrand(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十五步</strong>，在之前的service目录中新建一个名为impl的目录，然后在impl目录中新建一个名为PmsBrandServiceImpl的类，注意这个类需要实现PmsBrandService接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PmsBrandServiceImpl implements PmsBrandService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandMapper pmsBrandMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listAllBrand() &#123;</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createBrand(PmsBrand pmsBrand) &#123;</span><br><span class="line">        return pmsBrandMapper.insertSelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int updateBrand(Long id, PmsBrand pmsBrand) &#123;</span><br><span class="line">        pmsBrand.setId(id);</span><br><span class="line">        return pmsBrandMapper.updateByPrimaryKeySelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int deleteBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PmsBrand getBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，新建<code>com.kenbings.shop.shopbasic.controller</code>目录，并在里面新建一个名为PmsBrandController的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第十七步</strong>，启动项目入口类ShopBasicApplication，打开浏览器进行测试，这里以访问id为1的品牌为例进行说明。</p><p>在浏览器地址栏中输入<code>http://localhost:8080/brand/1</code>，可以看到浏览器显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a87453b8a871d2a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样关于项目的骨架搭建就完成了，后续学习如何接入Swagger-UI实现API文档的在线使用。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-basic">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
