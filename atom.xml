<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2024-05-22T14:01:34.087Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊一聊六种常用的属性配置读取方式</title>
    <link href="http://envyzhan.asia/2024/03/02/2024-1-six-common-configuration-methods-for-reading-properties/"/>
    <id>http://envyzhan.asia/2024/03/02/2024-1-six-common-configuration-methods-for-reading-properties/</id>
    <published>2024-03-02T02:55:30.000Z</published>
    <updated>2024-05-22T14:01:34.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力有极大帮助。使用的SpringBoot版本为 2.7.11 。</p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><h3 id="Environment简介"><a href="#Environment简介" class="headerlink" title="Environment简介"></a>Environment简介</h3><p>Environment 是 SpringBoot 的核心环境配置接口，它提供了很多方法用于访问应用程序属性，包括系统属性、操作系统环境变量、命令行参数和应用程序配置文件中定义的属性等。源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Environment extends PropertyResolver &#123;</span><br><span class="line">    String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line">    String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean acceptsProfiles(String... profiles);</span><br><span class="line"></span><br><span class="line">    boolean acceptsProfiles(Profiles profiles);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface PropertyResolver &#123;</span><br><span class="line">    boolean containsProperty(String key);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    String getProperty(String key);</span><br><span class="line"></span><br><span class="line">    String getProperty(String key, String defaultValue);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue);</span><br><span class="line"></span><br><span class="line">    String getRequiredProperty(String key) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException;</span><br><span class="line"></span><br><span class="line">    String resolvePlaceholders(String text);</span><br><span class="line"></span><br><span class="line">    String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个接口继承自 PropertyResolver 接口，PropertyResolver接口中定义了很多获取属性的方法，因此Environment这个接口才具备上述能力。</p><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>接下来我们通过分析SpringBoot项目在启动时，对配置进行初始化这一过程来深度了解Environment接口的作用。</p><p>我们知道SpringBoot项目在启动时会调用 SpringApplication.run() 方法，而这个方法内部会调用prepareEnvironment()方法：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690263104622-84102549-40ba-4876-920a-7b58a03d6e1c.png#averageHue=%232d2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=431&id=u75ec017d&originHeight=646&originWidth=1656&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=143909&status=done&style=none&taskId=u7a493edc-491f-4fda-a61b-147fec114a9&title=&width=1104" alt="image.png"><br>查看一下这个prepareEnvironment()方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123;</span><br><span class="line">    /** </span><br><span class="line">    * 1、创建ConfigurableEnvironment对象：调用getOrCreateEnvironment()方法获取或创建ConfigurableEnvironment对象，</span><br><span class="line">    * 该对象用于存储环境参数。如果已经存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的。</span><br><span class="line">    */</span><br><span class="line">    ConfigurableEnvironment environment = this.getOrCreateEnvironment();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 2、解析并加载用户指定的配置文件，将其作为 PropertySource 添加到环境对象中。该方法默认会解析application.properties和application.yml文件，并将其添加到ConfigurableEnvironment对象中。</span><br><span class="line">    * PropertySource或PropertySourcesPlaceholderConfigurer加载应用程序的定制化配置。</span><br><span class="line">    */</span><br><span class="line">    this.configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"></span><br><span class="line">    // 3、加载所有的系统属性，并将它们添加到ConfigurableEnvironment对象中</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line"></span><br><span class="line">    // 4、通知监听器环境参数已经准备就绪</span><br><span class="line">    listeners.environmentPrepared(bootstrapContext, environment);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    *  5、将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值。</span><br><span class="line">    *  还可以避免用户无意中覆盖了SpringBoot提供的默认属性</span><br><span class="line">    */</span><br><span class="line">    DefaultPropertiesPropertySource.moveToEnd(environment);</span><br><span class="line">    Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;);</span><br><span class="line">    </span><br><span class="line">    // 6、将SpringBoot应用程序的属性绑定到环境对象上，以便能正确地读取和使用这些配置属性</span><br><span class="line">    this.bindToSpringApplication(environment);</span><br><span class="line"></span><br><span class="line">    // 7、如果没有自定义的环境类型，则使用EnvironmentConverter类型将环境对象转换为标准的环境类型，并添加到ConfigurableEnvironment对象中</span><br><span class="line">    if (!this.isCustomEnvironment) &#123;</span><br><span class="line">        EnvironmentConverter environmentConverter = new EnvironmentConverter(this.getClassLoader());</span><br><span class="line">        environment = environmentConverter.convertEnvironmentIfNecessary(environment, this.deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 8、再次加载系统配置，以防止被其他配置覆盖</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的流程：</p><ul><li>创建 ConfigurableEnvironment 环境对象 ，用于存储环境参数；</li><li>调用 configureEnvironment 方法加载默认的 application.properties 和 application.yml 配置文件，以及用户指定的配置文件，并将其封装为 PropertySource 对象添加到环境对象中；</li><li>ConfigurationPropertySources.attach 方法，用于加载所有的系统属性，并将它们添加到环境对象中；</li><li>listeners.environmentPrepared 方法，用于发送环境参数配置已经准备就绪的监听通知；</li><li>DefaultPropertiesPropertySource.moveToEnd 方法，用于将系统默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就能覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性；</li><li>bindToSpringApplication方法，用于将应用程序的属性绑定到Bean对象上；</li><li>ConfigurationPropertySources.attach方法，用于再次加载系统配置，防止被其他配置覆盖。</li></ul><p>下面是对于上述几个比较重要的方法进行详细介绍，如下所示：<br>（1）getOrCreateEnvironment方法的源码如下所示，可以看到该方法会返回一个ConfigurableEnvironment对象，该对象用于存储环境参数。如果已存在ConfigurableEnvironment对象，则直接使用它；否则根据用户的配置和默认配置创建一个新的ConfigurableEnvironment对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">    if (this.environment != null) &#123;</span><br><span class="line">        return this.environment;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ConfigurableEnvironment environment = this.applicationContextFactory.createEnvironment(this.webApplicationType);</span><br><span class="line">        if (environment == null &amp;&amp; this.applicationContextFactory != ApplicationContextFactory.DEFAULT) &#123;</span><br><span class="line">            environment = ApplicationContextFactory.DEFAULT.createEnvironment(this.webApplicationType);</span><br><span class="line">        &#125;</span><br><span class="line">        return (ConfigurableEnvironment)(environment != null ? environment : new ApplicationEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）configureEnvironment方法的源码如下所示，可以看到该方法会解析并加载用户指定的配置文件，并将其作为 PropertySource对象添加到环境对象中。configureEnvironment方法默认会解析<code>application.properties</code>和 <code>application.yml</code>文件，并将其添加到ConfigurableEnvironment对象中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    if (this.addConversionService) &#123;</span><br><span class="line">        environment.setConversionService(new ApplicationConversionService());</span><br><span class="line">    &#125;</span><br><span class="line">    this.configurePropertySources(environment, args);</span><br><span class="line">    this.configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">    MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">    if (!CollectionUtils.isEmpty(this.defaultProperties)) &#123;</span><br><span class="line">        DefaultPropertiesPropertySource.addOrMerge(this.defaultProperties, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">        String name = &quot;commandLineArgs&quot;;</span><br><span class="line">        if (sources.contains(name)) &#123;</span><br><span class="line">            PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">            CompositePropertySource composite = new CompositePropertySource(name);</span><br><span class="line">            composite.addPropertySource(new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args));</span><br><span class="line">            composite.addPropertySource(source);</span><br><span class="line">            sources.replace(name, composite);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sources.addFirst(new SimpleCommandLinePropertySource(args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）DefaultPropertiesPropertySource.moveToEnd方法的源码如下所示，该方法会将默认属性源中的所有属性值移到环境对象的队列末尾，这样用户自定义的属性值就可以覆盖默认的属性值，还可以避免用户无意中覆盖了SpringBoot提供的默认属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void moveToEnd(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    moveToEnd(environment.getPropertySources());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void moveToEnd(MutablePropertySources propertySources) &#123;</span><br><span class="line">    PropertySource&lt;?&gt; propertySource = propertySources.remove(&quot;defaultProperties&quot;);</span><br><span class="line">    if (propertySource != null) &#123;</span><br><span class="line">        propertySources.addLast(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析，我们知道各种配置属性最终都会被封装为一个个PropertySource对象，查看一下该对象的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class PropertySource&lt;T&gt; &#123;</span><br><span class="line">    protected final String name; // 属性名称</span><br><span class="line">    protected final T source; // 属性值（一个泛型，比如Map，Property）</span><br><span class="line">    public String getName();  // 获取属性的名字  </span><br><span class="line">    public T getSource(); // 获取属性值  </span><br><span class="line">    public boolean containsProperty(String name);  //是否包含某个属性  </span><br><span class="line">    public abstract Object getProperty(String name);   //根据属性名获取到对应属性  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>PropertySource这个抽象类有很多实现类，分别用于管理应用程序的配置属性。不同的PropertySource实现类，可从不同的来源来获取配置属性，如文件、环境变量、命令行参数等。下面是涉及到的一些常用实现类：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690266427489-901c66fd-ae05-4be0-8446-4b82669ac20e.png#averageHue=%233c4145&clientId=uc1ab0a73-0559-4&from=paste&id=u8f832076&originHeight=379&originWidth=832&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=ueb409361-f04f-483d-835d-b678c9df9e8&title="><br>简单解释一下上述涉及到的实现类的作用：</p><ul><li>MapPropertySource，用于将Map键值对转换为PropertySource对象；</li><li>PropertiesPropertySource，用于将Properties对象中的配置属性转换为PropertySource对象；</li><li>ResourcePropertySource，用于从文件系统或classpath中加载配置属性，并封装为PropertySource对象；</li><li>ServletConfigPropertySource，用于从Servlet配置中读取配置属性，并封装为PropertySource对象；</li><li>ServletContextPropertySource，用于从Servlet上下文中读取配置属性，并封装为PropertySource对象；</li><li>StubPropertySource，这是一个空的实现类，它的作用仅仅是给CompositePropertySource类作为默认的父级属性源，以避免空指针异常；</li><li>CompositePropertySource:，这是一个复合型的实现类，内部维护了PropertySource集合队列，可以将多个PropertySource对象进行合并；</li><li>SystemEnvironmentPropertySource，用于从操作系统环境变量中读取配置属性，并将其封装为PropertySource对象。</li></ul><p>上面各类配置初始化生成的PropertySource对象都会被维护到集合队列中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PropertySource&lt;?&gt;&gt; sources = new ArrayList&lt;PropertySource&lt;?&gt;&gt;()</span><br></pre></td></tr></table></figure><p>配置初始化完成后，应用程序上下文 AbstractApplicationContext 会加载配置，这样程序在运行时就可以随时获取到配置信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267487883-5dff1184-08f9-4a80-9b3f-d28624f7e167.png#averageHue=%232e2c2b&clientId=uc1ab0a73-0559-4&from=paste&height=215&id=ua6decfd6&originHeight=323&originWidth=1499&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=74002&status=done&style=none&taskId=uc533859b-abb4-4348-835a-14896e389f8&title=&width=999.3333333333334" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690267606290-b594f371-57d1-4970-945e-7127f376aa94.png#averageHue=%232d2d2c&clientId=uc1ab0a73-0559-4&from=paste&height=275&id=u6860fe12&originHeight=412&originWidth=1493&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=79537&status=done&style=none&taskId=u15367136-7c78-4064-9a23-0b41a49b8be&title=&width=995.3333333333334" alt="image.png"></p><h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p>前面我们已经学习了加载配置的整个流程，那么读取配置就是从维护的 PropertySource 队列中根据name获取对应的source对象了。</p><p>一般而言，我们会使用Environment接口对象提供的方法来获取配置信息，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = environment.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在前面阅读源码的时候，我们知道这个Environment接口继承PropertyResolver接口，PropertyResolver是获取配置的关键接口，其内部提供了操作PropertySource 队列的方法，查看一下这个接口的继承依赖关系：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690268378231-d67e5d69-866c-4f3f-9483-b43466a7574a.png#averageHue=%233b4043&clientId=uc1ab0a73-0559-4&from=paste&id=ud889ead3&originHeight=499&originWidth=481&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u149749e3-d686-4d31-bb47-aa567992a31&title="><br>因此，我们也可以直接使用PropertyResolver接口中的方法来获取对应的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class EnvironmentTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private PropertyResolver propertyResolver;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String username = propertyResolver.getProperty(&quot;user.name&quot;);</span><br><span class="line">        log.info(&quot;当前用户名为&#123;&#125;&quot;, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Value注解"><a href="#Value注解" class="headerlink" title="Value注解"></a>Value注解</h1><p>@Value注解，是 Spring 框架提供的用于获取注入配置属性值的注解，可用在类的成员变量、方法参数和构造函数参数上。</p><p>我们知道，在应用程序启动时，使用@Value注解修饰的Bean会被实例化并加入到 PropertySourcesPlaceholderConfigurer 的后置处理器集合中。当后置处理器开始执行时，它会读取Bean中所有被 @Value 注解所修饰的值，并通过反射将解析后的属性值，赋值给被@Value 注解修饰成员变量、方法参数和构造函数参数。<br><strong>请注意，在使用 @Value 注解时，需要确保注入的属性值已被加载到 Spring 容器中，否则会导致注入失败。</strong></p><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在项目的 src/main/resources 目录下新建 application.yml 配置文件，并往其中添加如下属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quick:</span><br><span class="line">  use: true</span><br></pre></td></tr></table></figure><p>对应的测试代码如下，只需变量上加 @Value(“${quick.use}”)注解，那么@Value 注解便会自动将配置文件中的quick.use 属性值注入到 isQuickUsed 字段中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管@Value注解使用起来很方便，但是也存在一些需要注意的地方，下面介绍几个比较容易出错的地方。</p><h3 id="缺失配置"><a href="#缺失配置" class="headerlink" title="缺失配置"></a>缺失配置</h3><p>如果开发者在代码中引用变量，但是在配置文件中为进行配置，此时就会出现如下的错误信息：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690332916832-6ed72f81-8422-46b6-9bba-465e81400431.png#averageHue=%23353332&clientId=uf1677bb8-9339-4&from=paste&height=115&id=u94f4bf5a&originHeight=172&originWidth=1508&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=50792&status=done&style=none&taskId=u9a1f075f-d556-42e9-b1e5-73bceb87bef&title=&width=1005.3333333333334" alt="image.png"><br>为了避免此类错误导致服务无法正常启动，我们可以在引用变量的同时，给它赋一个默认值，这样即使未在配置文件中赋值，程序也是可以正常启动的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ValueTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use:true&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量赋值"><a href="#静态变量赋值" class="headerlink" title="静态变量赋值"></a>静态变量赋值</h3><p><strong>请注意，将 @Value 注解添加到静态变量上，这样是无法获取静态变量的属性值。</strong>我们知道，静态变量属于类，不属于某个对象，而 Spring是基于对象的属性进行依赖注入，且类在应用启动时，静态变量就被初始化，此时 Bean还未被实例化，因此无法通过 @Value 注解来注入属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private static String isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：null</span><br></pre></td></tr></table></figure><p>尽管 @Value 注解无法直接作用在静态变量上，但是开发者可通过获取已有 Bean实例化后的属性值，并将其赋值给静态变量进而实现给静态变量赋值这一目的。</p><p>上述过程对应的具体操作如下：<br>（1）通过 @Value 注解将属性值注入到普通 Bean中；<br>（2）获取该 Bean对应的属性值；<br>（3）将其赋值给静态变量；<br>（4）在静态变量中使用该属性值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private void setIsQuickUsed(String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><p>当然了也可以在构造方法中设置isUsed变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class StaticVarTest &#123;</span><br><span class="line">    private static String isUsed;</span><br><span class="line"></span><br><span class="line">    StaticVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getIsQuickUsed()&#123;</span><br><span class="line">        return isUsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(getIsQuickUsed());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量赋值"><a href="#常量赋值" class="headerlink" title="常量赋值"></a>常量赋值</h3><p>**请注意，将 @Value 注解添加到常量上，这样是无法获取常量的属性值。 **我们知道，被final修饰的变量在使用前必须赋值，且一旦赋值便不能修改。final修饰的变量可以在定义时、构造方法中或者静态代码中进行赋值，这里只讨论final变量在静态代码块中赋值的情况。前面说过， @Value 注解是在 Bean 实例化后才进行属性注入，因此无法在构造方法中初始化 final 变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class FinalVarTest &#123;</span><br><span class="line">    private final String isUsed;</span><br><span class="line">    </span><br><span class="line">    FinalVarTest(@Value(&quot;$&#123;quick.use&#125;&quot;) String used)&#123;</span><br><span class="line">        isUsed = used;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isUsed的值为：&#123;&#125;&quot;, isUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果为：true</span><br></pre></td></tr></table></figure><h3 id="非Spring容器管理的Bean中使用"><a href="#非Spring容器管理的Bean中使用" class="headerlink" title="非Spring容器管理的Bean中使用"></a>非Spring容器管理的Bean中使用</h3><p>在Spring中，只有被 @Component、@Service、@Controller、@Repository 或 @Configuration 等注解标识的类，才会被Spring容器所管理，在这些类中使用 @Value注解才会生效。而对于普通的POJO类，无法使用 @Value注解进行属性注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class NoBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;quick.use&#125;&quot;)</span><br><span class="line">    private boolean isQuickUsed;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;isQuickUsed:&#123;&#125;&quot;, isQuickUsed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就无法获取配置文件中 quick.use 配置项的值。</p><h3 id="引入方式不对"><a href="#引入方式不对" class="headerlink" title="引入方式不对"></a>引入方式不对</h3><p>当我们需要使用某个Spring容器管理的对象时，需要使用依赖注入的方式，不能通过new关键字来创建实例。</p><h1 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="ConfigurationProperties注解"></a>ConfigurationProperties注解</h1><p>@ConfigurationProperties 注解是 SpringBoot 提供的一种更优雅的方式，来读取配置文件中的属性值。通过自动绑定和类型转换等机制，可将指定前缀的属性集合自动绑定到一个Bean对象上。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>前面在分析 SpringBoot 项目的启动流程中，我们发现这个 prepareEnvironment() 方法中调用了一个非常重要的方法 bindToSpringApplication(environment)，该方法的作用是将配置文件中的属性值绑定到被 @ConfigurationProperties 注解标记的 Bean对象中。不过此时这些对象还没有被 Spring 容器管理，因此无法完成属性的自动注入。</p><p>那么问题来了，这些 Bean 对象是在何时被注册到 Spring 容器中呢？这就涉及到了 ConfigurationPropertiesBindingPostProcessor 类，它是 Bean 后置处理器，负责扫描容器中所有被 @ConfigurationProperties 注解所标记的 Bean对象。如果找到了，则使用 Binder 组件将外部属性的值绑定到它们身上，从而实现自动注入：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356409937-9f0d2bef-a612-44cc-ad54-42932a4ed8ec.png#averageHue=%232e2d2c&clientId=u313a9f9a-5626-4&from=paste&height=317&id=u91100481&originHeight=475&originWidth=1747&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=130729&status=done&style=none&taskId=u762011e4-80bd-44f6-8896-e1a2ff1566f&title=&width=1164.6666666666667" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void bindToSpringApplication(ConfigurableEnvironment environment) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));</span><br><span class="line">    &#125; catch (Exception var3) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/12555354/1690356666349-e4c62109-418c-494a-bc4d-db0061d5f5d9.png#averageHue=%232f2c2b&clientId=u313a9f9a-5626-4&from=paste&id=u6206cbe3&originHeight=462&originWidth=1074&originalType=url&ratio=1.5&rotation=0&showTitle=false&status=done&style=none&taskId=u93c04198-1bbe-4818-8efc-5a02a4fe59a&title="></p><ul><li>bindToSpringApplication方法，主要将属性值绑定到 Bean 对象中；</li><li>ConfigurationPropertiesBindingPostProcessor类，主要负责在Spring容器启动时，将被注解标记的 Bean 对象注册到容器中，并完成后续的属性注入操作。<h3 id="示例使用"><a href="#示例使用" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在application.yml配置文件中新增如下配置信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config:</span><br><span class="line">  custom:</span><br><span class="line">    prop1: prop1</span><br><span class="line">    prop2: prop2</span><br></pre></td></tr></table></figure>第二步，定义一个名为 UsePropertiesConfig 的类，该类用于承载所有前缀为 config.custom 的配置属性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;config.custom&quot;)</span><br><span class="line">public class UsePropertiesConfig &#123;</span><br><span class="line">    private String prop1;</span><br><span class="line">    private String prop2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将UsePropertiesConfig类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UsePropertiesConfig usePropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;prop1 is :&#123;&#125;&quot;, usePropertiesConfig.getProp1());</span><br><span class="line">        log.info(&quot;prop2 is :&#123;&#125;&quot;, usePropertiesConfig.getProp2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：prop1和prop2</span><br></pre></td></tr></table></figure><h1 id="PropertySources-注解"><a href="#PropertySources-注解" class="headerlink" title="PropertySources 注解"></a>PropertySources 注解</h1>一般来说，系统默认提供的名为 application.yml 或者 application.properties 配置文件能满足绝大多数业务场景，但是在某些场景下我们还是希望自定义配置文件名称及内容。请注意，与默认的配置文件所不同的是，用户自定义的配置文件无法被应用自动加载，需要开发者手动加载。<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3>@PropertySources 注解的实现原理比较简单，如下所示：<br>（1）应用程序启动时，扫描所有被@PropertySources 注解修饰的类，并获取到注解中指定自定义配置文件的路径；<br>（2）将指定路径下的配置文件内容加载到 Environment 中，这样就可通过 @Value 注解或 Environment.getProperty() 方法来获取其中定义的属性值。<h3 id="示例使用-1"><a href="#示例使用-1" class="headerlink" title="示例使用"></a>示例使用</h3>第一步，在 src/main/resources 目录下定义一个名为 customProperties.properties 的自定义配置类，里面的配置项如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom.sex=male</span><br><span class="line">custom.address=shanghai</span><br></pre></td></tr></table></figure>第二步，在需要使用自定义配置文件的类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开。这里定义一个名为 CustomPropertiesConfig 的类，里面的代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customProperties.properties&quot;,encoding = &quot;utf-8&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class CustomPropertiesConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.address&#125;&quot;)</span><br><span class="line">    private String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>第三步，定义一个名为 UsePropertiesConfigTest 的类，该类会使用到前面的配置项，因此需要将CustomPropertiesConfig 类进行注入并使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UsePropertiesConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private CustomPropertiesConfig customPropertiesConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, customPropertiesConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.address is: &#123;&#125;&quot;, customPropertiesConfig.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h3 id="支持YML格式"><a href="#支持YML格式" class="headerlink" title="支持YML格式"></a>支持YML格式</h3>查看一下这个 @PropertySource 注解的源码，如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(PropertySources.class)</span><br><span class="line">public @interface PropertySource &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    boolean ignoreResourceNotFound() default false;</span><br><span class="line"></span><br><span class="line">    String encoding() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到这里的 factory 属性，默认使用的是 PropertySourceFactory 类，而这个类是一个接口，查看一下该接口的源码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PropertySourceFactory &#123;</span><br><span class="line">    PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>里面只有一个 createPropertySource 方法，该方法会返回一个 PropertySource 对象，这个PropertySourceFactory 接口只有一个默认的实现类 DefaultPropertySourceFactory ，该实现类的源码如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultPropertySourceFactory implements PropertySourceFactory &#123;</span><br><span class="line">    public DefaultPropertySourceFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        return name != null ? new ResourcePropertySource(name, resource) : new ResourcePropertySource(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>也就是说它只能加载 .properties 结尾的配置文件，无法加载 yml 格式结尾的文件。如果我们需要加载 yml 格式的配置文件，那么需要自定义 PropertySourceFactory 接口实现类。</li></ul><p>第一步，在 src/main/resources 目录下定义一个名为 customYaml.yml 的自定义配置类，里面的配置项如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  sex: male</span><br><span class="line">  city: shanghai</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 YamlPropertySourceFactory 的类，该类需要实现 PropertySourceFactory 接口并重写其中的 createPropertySource 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class YamlPropertySourceFactory  implements PropertySourceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException &#123;</span><br><span class="line">        YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();</span><br><span class="line">        factoryBean.setResources(resource.getResource());</span><br><span class="line"></span><br><span class="line">        Properties properties = factoryBean.getObject();</span><br><span class="line">        return new PropertiesPropertySource(resource.getResource().getFilename(), properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个名为 UseYamlConfig 的配置类，并在该类上添加 @PropertySources 注解，并在该注解中指定自定义配置文件的路径，多个路径使用逗号隔开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@PropertySources(&#123;</span><br><span class="line">        @PropertySource(value = &quot;classpath:customYaml.yml&quot;, encoding = &quot;utf-8&quot;, factory = YamlPropertySourceFactory.class)</span><br><span class="line">&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class UseYamlConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.sex&#125;&quot;)</span><br><span class="line">    private String sex;</span><br><span class="line">    @Value(&quot;$&#123;custom.city&#125;&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个名为 UseYamlConfigTest 的类，该类会使用到前面的配置项，因此需要将UseYamlConfig 类进行注入并使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UseYamlConfigTest &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UseYamlConfig useYamlConfig;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.sex is: &#123;&#125;&quot;, useYamlConfig.getSex());</span><br><span class="line">        log.info(&quot;custom.city is: &#123;&#125;&quot;, useYamlConfig.getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果：custom.sex is: male 和 custom.address is: shanghai</span><br></pre></td></tr></table></figure><h1 id="YamlPropertiesFactoryBean-加载-YAML-文件"><a href="#YamlPropertiesFactoryBean-加载-YAML-文件" class="headerlink" title="YamlPropertiesFactoryBean 加载 YAML 文件"></a>YamlPropertiesFactoryBean 加载 YAML 文件</h1><p>我们还可以使用 YamlPropertiesFactoryBean 这个类将 YAML 配置文件中的属性值注入到 Bean 中，具体操作如下：<br>第一步，定义一个名为 customBeanYaml.yml 的配置文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">custom:</span><br><span class="line">  email: qq@qq.com</span><br></pre></td></tr></table></figure><p>第二步，定义一个名为 CustomYamlPropertiesFactoryBeanConfig 的类，里面定义一个名为 yamlConfigurer 的方法，该方法需要返回一个 PropertySourcesPlaceholderConfigurer 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomYamlPropertiesFactoryBeanConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public static PropertySourcesPlaceholderConfigurer yamlConfigurer() &#123;</span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        YamlPropertiesFactoryBean yaml = new YamlPropertiesFactoryBean();</span><br><span class="line">        yaml.setResources(new ClassPathResource(&quot;customBeanYaml.yml&quot;));</span><br><span class="line">        configurer.setProperties(Objects.requireNonNull(yaml.getObject()));</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，定义一个测试方法，开发者可通过 @Value 注解或 Environment.getProperty() 方法来获取配置文件中定义的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@Slf4j</span><br><span class="line">public class YamlPropertiesFactoryBeanTest &#123;</span><br><span class="line">    @Value(&quot;$&#123;custom.email&#125;&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        log.info(&quot;custom.email is: &#123;&#125;&quot;, email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义读取"><a href="#自定义读取" class="headerlink" title="自定义读取"></a>自定义读取</h1><p>如果开发者觉得上述读取方式不够优雅，自己想造轮子，此时可以直接注入 PropertySources 对象，来获取所有属性的配置队列，之后就可以按照要求进行实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class CustomTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PropertySources propertySources;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void customTest() &#123;</span><br><span class="line">        for (PropertySource&lt;?&gt; propertySource : propertySources) &#123;</span><br><span class="line">            log.info(&quot;自定义方式，来实现配置获取逻辑，属性名称为：&#123;&#125; ,属性源为：&#123;&#125;&quot;, propertySource.getName(), propertySource.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例使用"><a href="#案例使用" class="headerlink" title="案例使用"></a>案例使用</h1><p>接下来通过一个例子来灵活学习如何获取指定配置文件中的属性值，步骤如下所示：<br>第一步，定义一个名为PropertiesLoader的类，我们定义 loadProperties 方法用于读取指定配置文件中的属性信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesLoader &#123;</span><br><span class="line">    private static final Logger logger = Logger.getLogger(PropertiesLoader.class.getName());</span><br><span class="line"></span><br><span class="line">    private PropertiesLoader() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Properties loadProperties(String location) &#123;</span><br><span class="line">        Properties props = new Properties();</span><br><span class="line">        logger.info(&quot;Loading properties file from path:&quot; + location);</span><br><span class="line">        InputStreamReader in = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new InputStreamReader(PropertiesLoader.class.getClassLoader().getResourceAsStream(location), &quot;UTF-8&quot;);</span><br><span class="line">            props.load(in);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.log(Level.WARNING, &quot;error close inputstream&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return props;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步，定义一个方法用于获取配置文件中指定名称的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesTest &#123;</span><br><span class="line">    public static void init(String location)&#123;</span><br><span class="line">        Properties properties = PropertiesLoader.loadProperties(location);</span><br><span class="line">        String userName = properties.getProperty(&quot;user.name&quot;);</span><br><span class="line">        String userSex = properties.getProperty(&quot;user.sex&quot;);</span><br><span class="line">        System.out.println(userName);</span><br><span class="line">        System.out.println(userSex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String location = &quot;user.properties&quot;;</span><br><span class="line">        init(location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个 user.properties 文件是定义在项目resources目录下的文件。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过上面的学习，我们知道可通过 @Value 注解、Environment 类、@ConfigurationProperties 注解和@PropertySource 注解等方式来获取配置信息。<br>其中，@Value 注解适用于单个值的注入，其他几种方式适用于多个配置的批量注入，而且不同方式在效率、灵活性、易用性等方面存在差异，在选择的时候需要多方面进行考虑。</p><p>这里笔者结合实际的工作体会，给出一些比较有参考意义的建议：如果重视代码的可读性和可维护性，可选择 @ConfigurationProperties 注解；如果更注重运行效率，可选择使用 Environment 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习使用SpringBoot进行日常开发过程中，经常使用到的6种读取配置文件内容的方式，掌握和熟练使用对于提升自我能力</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>巧用分页列表缓存，快速响应用户请求</title>
    <link href="http://envyzhan.asia/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/"/>
    <id>http://envyzhan.asia/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/</id>
    <published>2023-05-28T08:55:30.000Z</published>
    <updated>2023-06-09T13:52:42.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响应用户的时间，主要用到了分页列表缓存。</p><h1 id="直接缓存分页列表"><a href="#直接缓存分页列表" class="headerlink" title="直接缓存分页列表"></a>直接缓存分页列表</h1><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最简单，也是最能想到的方法就是直接缓存分页列表。举个例子，如下所示，直接将每页的数据以列表形式进行缓存：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-77510826a25930a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    String key = &quot;productPageList:pageNum:&quot; + pageNum+ &quot;pageSize:&quot; + pageSize+  &quot;param:&quot; + param ;</span><br><span class="line">    List&lt;Product&gt; productList = cacheUtil.get(key);</span><br><span class="line">    if(productList != null)return productList;</span><br><span class="line">    productList = queryFromDB(param,pageNum,pageSize);</span><br><span class="line">    if(productList != null) &#123;</span><br><span class="line">         cacheUtil.set(key , productList , Constants.ExpireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种方式优点就是操作简单，性能也快，缺点就是缓存的粒度太粗。如果列表中数据发生增删，为了保证数据的一致性，需要修改分页列表缓存。</p><p>当然了，可以有两种方式来解决 ：<br>（1）利用缓存的过期时间来惰性删除，不过这种要求业务能接受；<br>（2）使用Redis提供的<code>keys</code>命令来找到对应的分页缓存，之后执行删除操作。不过<code>keys</code>命令对性能影响很大，会导致 Redis产生较大的延迟，这一点在并发性要求高的业务下是很难满足的 。而且生产环境使用<code>keys</code>命令比较危险，很容易出现问题，因此不推荐使用<code>keys</code>命令。</p><h1 id="先查询对象ID列表，再缓存每个对象"><a href="#先查询对象ID列表，再缓存每个对象" class="headerlink" title="先查询对象ID列表，再缓存每个对象"></a>先查询对象ID列表，再缓存每个对象</h1><p>前面说过直接缓存分页列表，导致缓存粒度较粗，很难保证数据的一致性，因此我们可以尝试细粒度缓存，即先查询对象ID列表，再缓存每个对象。</p><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>举个例子，如下所示，首先我们查询分页对象ID列表，然后再缓存每一个对象，后续通过对象ID和缓存的对象来聚合形成列表返回给前端：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-adbcc181311b464e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>对应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Product&gt; getPageList(String param, int pageNum, int pageSize) &#123;</span><br><span class="line">    //1、构建返回对象</span><br><span class="line">    List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br><span class="line">    //2、从数据库中查询分页ID列表</span><br><span class="line">    List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br><span class="line">    //3、为空则直接返回空列表</span><br><span class="line">    if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">        return new ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    //4、批量从缓存中获取缓存对象列表</span><br><span class="line">    Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br><span class="line">    //5、缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来</span><br><span class="line">    List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">    noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">        if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">            noHitpProductIdList.add(productId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    //6、将前面没有命中的对象从数据库中查询并添加到缓存中</span><br><span class="line">    List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">    if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">        Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">        .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">        //将没有命中的对象添加到缓存中</span><br><span class="line">        cacheUtil.mset(noHitProductMap);</span><br><span class="line">        //将没有命中的对象添加到聚合Map中</span><br><span class="line">        cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">    &#125;</span><br><span class="line">    //7、组装返回对象</span><br><span class="line">    productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">      Product product = cacheProductMap.get(productId);</span><br><span class="line">      if(product != null)&#123;</span><br><span class="line">        result.add(product);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面简单解释一下上述代码的含义：<br>（1）构建返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; result = new ArrayList&lt;&gt;(pageSize);</span><br></pre></td></tr></table></figure><p>（2）从数据库中查询分页ID列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; productIdList = queryproductIdListFromDB(param,pageNum,pageSize);</span><br></pre></td></tr></table></figure><p>其实这个就相当于执行如下的SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t_product order by id limit (pageNum -1)* size,size;</span><br></pre></td></tr></table></figure><p>（3）为空则直接返回空列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(CollectionUtils.isEmpty(productIdList))&#123;</span><br><span class="line">      return new ArrayList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）批量从缓存中获取缓存对象列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, Product&gt; cacheProductMap = cacheUtil.mget(productIdList);</span><br></pre></td></tr></table></figure><p>这里我们采用的是分布式缓存系统Redis，它天然支持批量查询命令，如mget、mset等。<br>（5）缓存中可能没有一些对象(没命中对象)，那么需要将这些对象ID存起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; noHitpProductIdList = new ArrayList&lt;&gt;(productIdList.size());</span><br><span class="line">noHitpProductIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    if(!cacheProductMap.containsKey(productId))&#123;</span><br><span class="line">        noHitpProductIdList.add(productId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由于缓存中可能出现对象过期或者其他原因，导致缓存没有命中，此时我们需要找到哪些对象是没有命中的。<br>（6）将前面没有命中的对象从数据库中查询并添加到缓存中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Product&gt; noHitProductList = queryFromDBByIds(noHitpProductIdList);</span><br><span class="line">if(CollectionUtils.isNotEmpty(noHitProductList))&#123;</span><br><span class="line">    Map&lt;Long, Product&gt; noHitProductMap = noHitProductList.stream()</span><br><span class="line">    .collect(Collectors.toMap(Product::getId, Function.identity()));</span><br><span class="line">    //将没有命中的对象添加到缓存中</span><br><span class="line">    cacheUtil.mset(noHitProductMap);</span><br><span class="line">     //将没有命中的对象添加到聚合Map中</span><br><span class="line">    cacheProductMap.putAll(noHitProductMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先我们从数据库中批量查询出未命中的对象列表，其实就相当于执行如下SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_product where id in (1,2,3......);</span><br></pre></td></tr></table></figure><p>之后就将命中的对象添加到缓存和聚合Map中。<br>（7）组装返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productIdList.forEach(productId-&gt;&#123;</span><br><span class="line">    Product product = cacheProductMap.get(productId);</span><br><span class="line">    if(product != null)&#123;</span><br><span class="line">      result.add(product);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可以看到此时最坏的情况就是经过两次网络IO，第一次是数据库查询IO，第二次是Redis查询IO，我们就能得到所需要的数据。</p><p>“先查询对象ID列表，再缓存每个对象”这种方案灵活性很高，我们还可以将查询对象ID列表这一操作从数据库中变为从Redis、ElasticSearch等。下图是博客文章的搜索流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69072d5faeed1cb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到，此时搜索的分页结果中只包含业务对象 ID ，而对象的详细信息则从缓存和数据库中获取。</p><h1 id="缓存对象ID列表同时缓存每个对象"><a href="#缓存对象ID列表同时缓存每个对象" class="headerlink" title="缓存对象ID列表同时缓存每个对象"></a>缓存对象ID列表同时缓存每个对象</h1><p>记得之前笔者在写一个社交APP的时候，遇到过Feed流的情况，需要以瀑布流的形式展示用户所关注的好友的动态。当时采用了推模式并结合Redis的ZSet数据结构来实现，将每一条动态ID存储在ZSet中，ZSet是一种有序的数据结构，由多个有序的唯一字符串组成，每个字符串都关联一个浮点类型的分数。</p><p>ZSet 使用的是 member -&gt; score 结构 ，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-82a033cd1cb7b693.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>member是被排序的标识，也是默认的第二排序维度（ 即score相同时，Redis以member的字典序排列）；而score则是被排序的分值，存储类型是double。</p><p>我们可以使用ZSet来存储动态 ID 列表，其中member是动态编号，score是创建时间，然后通过ZSet 的<code>ZREVRANGE</code>命令就可以实现分页效果，它用于按照成员的分数从大到小返回有序集合中的指定范围的成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>当然了，为了实现分页效果，我们上面的start和stop的取值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int start = (pageNum -1) * pageSize;</span><br><span class="line">int stop = start + pageSize - 1;</span><br></pre></td></tr></table></figure><p>这样通过<code>ZREVRANGE</code>命令，我们就可以查询出动态ID列表了。在获取到动态ID列表之后，我们还需要缓存每个动态对象的信息，这些动态对象包括详情、评论、点赞、转发等内容，这些内容是需要单独做缓存的：</p><table><thead><tr><th align="center">动态信息</th><th align="center">Redis存储方式</th></tr></thead><tbody><tr><td align="center">动态</td><td align="center">使用Hash来存储动态详情</td></tr><tr><td align="center">点赞</td><td align="center">使用ZSET来存储userId，前端显示用户头像，使用String缓存用户信息</td></tr><tr><td align="center">收藏</td><td align="center">使用String来存储userId和FeedId的映射关系</td></tr><tr><td align="center">评论</td><td align="center">使用ZSET来存储commentId，使用String缓存评论详情信息</td></tr></tbody></table><p>当然，无论是查询还是更新缓存，笔者都是建议采用批量操作，这样效率更高。如果缓存对象结构简单，那么可以使用<code>mget</code>、<code>hmget</code>等命令；若结构复杂，可以使用pipleline，Lua脚本等方式。 笔者采用Redis的pipleline来实现批量操作。</p><p>“缓存对象ID列表同时缓存每个对象”这种方案的流程如下所示：<br>（1）使用ZSet来存储动态 ID 列表，并通过传入分页参数和<code>ZREVRANGE</code>命令来动态查询ID列表；<br>（2）通过传递动态ID列表参数，并采用Redis的pipleline功能，从缓存中批量获取动态的详情，评论，点赞，收藏等数据 ，最终组装成所需列表并返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要学习了分页缓存的三种方案，如下所示：<br>（1）直接缓存分页列表；<br>（2）先查询对象ID列表，再缓存每个对象；<br>（3）缓存对象ID列表同时缓存每个对象。<br>这三种方式层层递进，最终采用细粒度控制缓存对象和批量加载缓存对象，进而实现快速响应用户请求这一目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在写数据报表逻辑，里面大部分场景都是统计数据，对数据时效性要求不高，不过要求数据能立即响应用户。于是尝试借助缓存来加快响</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>基于请求参数校验的接口幂等性实现方案</title>
    <link href="http://envyzhan.asia/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/"/>
    <id>http://envyzhan.asia/2023/05/10/2023-103-implementation-of-interface-idempotency-verification-based-on-reqParam/</id>
    <published>2023-05-10T02:55:30.000Z</published>
    <updated>2023-06-09T13:50:03.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求参数的校验，这种方式在高并发环境下优势更明显。由于请求只有一次，所以不需要从服务端获取令牌。</p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>基于请求参数校验这一方式原理很简单，如果在某一个时间间隔内，同一个接口接收到的请求参数一样，则说明前后请求是重复的，服务端则拒绝处理后续请求。注意由于前后端通过JOSN格式传递数据，且需要多次重复读取JSON数据，所以前面介绍的文章还是有很大的帮助。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>第一步，新建一个名为<code>repeat-submit</code>的SpringBoot项目，然后在POM文件中引入redis、web和aop依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，在<code>application.yml</code>配置文件中新增redis配置信息及项目运行端口信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    password: root</span><br><span class="line">    database: 4</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br></pre></td></tr></table></figure><p>第三步，新建redis包，并在redis包内新建一个名为RedisCache的工具类，该类用于封装对Redis的操作。里面定义了两个方法，即对字符串进行存入和查看这两个操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCacheObject(final String key)&#123;</span><br><span class="line">        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void setCacheObject(final String key, final T value, Integer timeout, TimeUnit timeUnit)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，新建annotation包，并在annotation包内新建一个名为RepeatSubmit的注解，该注解可用在需要实现幂等的接口上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface RepeatSubmit &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 两个请求之间的间隔时间，单位毫秒</span><br><span class="line">     * 小于此间隔认为重复提交</span><br><span class="line">     */</span><br><span class="line">    public int interval() default 5000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重复提交时提示信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String message() default &quot;请勿重复提交，稍后再试&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，新建interceptor包，并在interceptor包内新建一个名为IdempotencyInterceptor的抽象类，这个抽象类通过拦截器来拦截所有被<code>RepeatSubmit</code>注解所修饰的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IdempotencyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        if(handler instanceof HandlerMethod)&#123;</span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            RepeatSubmit annotation = method.getAnnotation(RepeatSubmit.class);</span><br><span class="line">            if(null != annotation)&#123;</span><br><span class="line">                //重复提交</span><br><span class="line">                if(isRepeatSubmit(request,annotation))&#123;</span><br><span class="line">                    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">                    map.put(&quot;status&quot;,500);</span><br><span class="line">                    map.put(&quot;message&quot;,annotation.message());</span><br><span class="line">                    response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">                    response.getWriter().write(new ObjectMapper().writeValueAsString(map));</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，具体判断逻辑由子类确定</span><br><span class="line">     */</span><br><span class="line">    public abstract boolean isRepeatSubmit(HttpServletRequest request,RepeatSubmit repeatSubmit);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它重写了preHandle方法的逻辑，首先判断当前handler是否为HandlerMethod的实例，如果是就强转为Method对象并得到方法上的<code>@RepeatSubmit</code>注解。如果该注解存在，然后调用<code>isRepeatSubmit()</code>方法来判断是否为重复提交，如果是则返回既定的重复提交数据提示。注意，这里我们将<code>isRepeatSubmit()</code>方法设置为抽象方法，目的是针对重复提交的实现逻辑可以有很多种，这里我们采用的是根据“URL地址+请求参数”这一方式来判断。后期开发者可以对此有不同的实现，而不用修改此处的重复提交提示信息。</p><p>第六步，在interceptor包内新建一个名为isRepeatSubmit的类，这个类需要继承前面的IdempotencyInterceptor类并重写其中的isRepeatSubmit方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基于请求地址URL+请求参数来判断是否重复提交</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RepeatSubmitInterceptor extends IdempotencyInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    public final String REPEAT_PARAMS = &quot;repeatParams&quot;;</span><br><span class="line">    public final String REPEAT_TIME = &quot;repeatTime&quot;;</span><br><span class="line">    public static final String REPEAT_SUBMIT_KEY = &quot;REPEAT_SUBMIT_KEY&quot;;</span><br><span class="line"></span><br><span class="line">    private String HEADER = &quot;Authorization&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否为重复提交，true则表示重复提交</span><br><span class="line">     * @param request</span><br><span class="line">     * @param repeatSubmit</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchcked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRepeatSubmit(HttpServletRequest request, RepeatSubmit repeatSubmit) &#123;</span><br><span class="line">        String nowParams = &quot;&quot;;</span><br><span class="line">        if(request instanceof RepeatableReadRequestWrapper)&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = (RepeatableReadRequestWrapper) request;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = requestWrapper.getReader().readLine();</span><br><span class="line">            &#125;catch (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //body参数为空的话，获取Parameter中的参数</span><br><span class="line">        if(ObjectUtils.isEmpty(nowParams))&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                nowParams = new ObjectMapper().writeValueAsString(request.getParameterMap());</span><br><span class="line">            &#125;catch (JsonProcessingException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //构建一个存于缓存的nowDataMap对象</span><br><span class="line">        Map&lt;String,Object&gt; nowDataMap = new HashMap&lt;&gt;();</span><br><span class="line">        nowDataMap.put(REPEAT_PARAMS,nowParams);</span><br><span class="line">        nowDataMap.put(REPEAT_TIME,System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        //获取请求地址，作为缓存中的key的一部分</span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        //获取消息头，注意这个值唯一,值不存在则使用请求地址</span><br><span class="line">        String header = request.getHeader(HEADER);</span><br><span class="line">        //构建缓存中的key</span><br><span class="line">        String cacheRepeatKey = REPEAT_SUBMIT_KEY + url + header.replace(&quot;Bearer &quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //查询缓存中是否存在对应的数据</span><br><span class="line">        Object cacheObject = redisCache.getCacheObject(cacheRepeatKey);</span><br><span class="line">        if(null != cacheObject)&#123;</span><br><span class="line">            Map&lt;String, Object&gt; cacheMap = (Map&lt;String, Object&gt;) cacheObject;</span><br><span class="line">            //参数一致且时间小于设定的间隔，则说明此为重复提交</span><br><span class="line">            if(compareParams(nowDataMap,cacheMap) &amp;&amp; compareTime(nowDataMap,cacheMap,repeatSubmit.interval()))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存中没有数据，说明不是重复提交</span><br><span class="line">        redisCache.setCacheObject(cacheRepeatKey,nowDataMap,repeatSubmit.interval(), TimeUnit.MILLISECONDS);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的参数是否一致</span><br><span class="line">     * @param nowDataMap 现在的参数值</span><br><span class="line">     * @param preDataMap 之前的参数值</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareParams(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap)&#123;</span><br><span class="line">        String nowParams = (String)nowDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        String preParams = (String)preDataMap.get(REPEAT_PARAMS);</span><br><span class="line">        return nowParams.equals(preParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断缓存中前后两次请求的时间间隔是否小于RepeatSubmit注解中指定的值</span><br><span class="line">     * @param nowDataMap 现在时间</span><br><span class="line">     * @param preDataMap 之前时间</span><br><span class="line">     * @param interval RepeatSubmit注解中指定的时间间隔</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareTime(Map&lt;String,Object&gt; nowDataMap,Map&lt;String,Object&gt; preDataMap,int interval)&#123;</span><br><span class="line">        long nowTime = (Long)nowDataMap.get(REPEAT_TIME);</span><br><span class="line">        long preTime = (Long)preDataMap.get(REPEAT_TIME);</span><br><span class="line">        if((nowTime - preTime)&lt; interval)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）首先判断当前请求是否为RepeatableReadRequestWrapper的实例，如果是则说明当前请求参数格式为JSON，此时就会通过解析IO流来读取数据，关于这一部分在之前的《SpringBoot实现JSON数据重复读取》一文中进行了介绍；<br>（2）如果当前请求不是RepeatableReadRequestWrapper的实例，说明不是JSON格式，那么可以从请求参数中获取，即以key-value方式读取数据，并使用<code>objectMapper.writeValueAsString()</code>方法来将其转换成字符串；<br>（3）接下来我们构造一个用于存入Redis的对象，注意这里我们使用Redis的String类型，Value为Map对象，然后Map对象中存有从请求中读取的参数和当前时间；<br>（4）然后我们构造Redis的Key，这个Key的格式为“固定前缀+请求地址URL+请求头的令牌”，其中固定前缀值为<code>REPEAT_SUBMIT_KEY</code>，请求头的令牌需要去除其中的<code>Bearer </code>字符串。请注意，请求令牌此处必须添加，这样可以区分用户；<br>（5）根据Key去Redis中查询是否存在对应的缓存数据，如果存在则去判断参数是否相同以及两次请求的时间间隔是否小于既定时间间隔，如果两者同时满足，则说明前后两次请求为重复请求，并返回true；<br>（6）如果不是（5）中的结果，那么说明请求是第一次过来或者说已经过了既定的时间窗口，服务器都接受并处理请求，此时将得到的请求信息重新添加到Redis中，并返回false。</p><p>第七步，新建config包，并在config包内新建一个名为MyWebMvcConfig的配置类，这个配置类需要实现WebMvcConfigurer接口，并重写其中的addInterceptors方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RepeatSubmitInterceptor repeatSubmitInterceptor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 手动将自定义的RepeatSubmitInterceptor拦截器注册到Spring容器中</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(repeatSubmitInterceptor).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，新建request包，并在request包内新建一个名为RepeatableReadRequestWrapper的类，<br>这个类需要继承HttpServletRequestWrapper类并重写其中的getInputStream和getReader方法，同时重载一下父类ServletRequestWrapper中有HttpServletRequest和HttpServletResponse对象的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义请求包装类</span><br><span class="line"> */</span><br><span class="line">public class RepeatableReadRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private final byte[] bytes;</span><br><span class="line"></span><br><span class="line">    public RepeatableReadRequestWrapper (HttpServletRequest request,HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        bytes = request.getReader().readLine().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() throws IOException &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int available() throws IOException &#123;</span><br><span class="line">                return bytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() throws IOException &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是自定义了一个新的HttpServletRequest类，并重载了一个包含HttpServletRequest和HttpServletResponse对象的构造方法，目的就是修改请求和响应的字符编码格式以及从IO流出读取数据，然后存入一个字节数组中，并通过重写getInputStream和getReader方法分别从字节数组中获取数据并构造IO流进行返回，这样就实现了IO流的多次读取。</p><p>第九步，新建filter包，并在filter包内新建一个名为RepeatRequestFilter的类，这个类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 请求拦截器，只有JSON数据才会使用自定义的RequestWrapper</span><br><span class="line"> */</span><br><span class="line">public class RepeatRequestFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        if(StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE))&#123;</span><br><span class="line">            RepeatableReadRequestWrapper requestWrapper = new RepeatableReadRequestWrapper(request,(HttpServletResponse) servletResponse);</span><br><span class="line">            filterChain.doFilter(requestWrapper,servletResponse);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们重写了doFilter方法，目的就是判断请求的类型，如果请求是HttpServletRequest且请求数据类型为JSON格式才会调用自定义的RepeatableReadRequestWrapper，即将HttpServletRequest替换为RepeatableReadRequestWrapper，走IO流可以多次读取的逻辑，之后让过滤器继续往下执行。</p><p>请注意，过滤器最好不要使用<code>@Component</code>注解交由Spring容器来管理，这样会导致每个接口都会被进行过滤，最好是开发者自己手动注册，并且配置过滤的接口。</p><p>第十步，在之前定义的MyWebMvcConfig类中将这个自定义的RepeatRequestFilter过滤器注册进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 手动将自定义的RepeatRequestFilter过滤器注册到Spring容器中</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">FilterRegistrationBean&lt;RepeatRequestFilter&gt; repeatRequestFilterFilterRegistrationBean()&#123;</span><br><span class="line">    FilterRegistrationBean&lt;RepeatRequestFilter&gt; bean = new FilterRegistrationBean();</span><br><span class="line">    bean.setFilter(new RepeatRequestFilter());</span><br><span class="line">    bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十一步，新建controller包，并在controller包内新建一个名为RepeatSubmitController的类，我们在该类中提供一个名为<code>/repeat</code>的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RepeatSubmitController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RepeatSubmitController.class);</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/repeat&quot;)</span><br><span class="line">    @RepeatSubmit(interval = 2000)</span><br><span class="line">    public String repeat(@RequestBody String message)&#123;</span><br><span class="line">        logger.info(&quot;message is: &#123;&#125;&quot;,message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于需要提交参数因此必须使用POST请求，同时这里设置了重复提交的时间间隔为2秒，即两秒内如有来自同一用户对同一接口多次请求相同参数时，可认为前后请求是重复提交的。</p><p>第十二步，启动项目进行测试。用户构造<code>http://localhost:8888/repeat</code>链接并以JSON形式传递message时，页面第一次会返回获取的message信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e524ea08a42c6655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果两秒内多次请求则会抛出此为重复请求，请稍后重试的提示信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0eb026568eff2fda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过判断请求数据格式是否为JOSN形式，如果是则调用增强的HttpServletRequest并从请求中获取请求参数，然后构建Key并从Redis中查询缓存信息，如果缓存中存在则通过请求参数和时间间隔来判断是否为重复提交，如果是则给出相应提示信息并返回false；否则返回认为是非重复提交并返回true，继续后续流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面笔者使用的都是基于token令牌校验这一方式实现接口幂等，这种方式其实比较复杂，今天来介绍另一种比较简单的方式—基于请求</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Redis各种数据类型巧用</title>
    <link href="http://envyzhan.asia/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/"/>
    <id>http://envyzhan.asia/2023/04/20/2023-102-redis-skillfully-uses-various-data-types/</id>
    <published>2023-04-20T02:55:30.000Z</published>
    <updated>2023-06-09T13:17:06.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信息：一个key关联一个数据集合，同时要对集合中的数据进行各种操作，诸如统计、排序等。</p><p>那么本篇笔者将结合工作实际，列举六种典型使用Redis的业务场景，如下所示：<br>（1）判断用户登录状态；（2）统计用户连续签到情况；（3）统计每天新增和第二天用户留存数；（4）统计网站访客量（Unique Visitor，UV）；（5）最新评论列表；（6）积分排行榜。</p><p>一般来说，我们面临的用户数量和访问量都是巨大的，如百万、千万级别用户数量，或者千万甚至亿级别的访问量，因此必须选择能够高效统计大量数据的集合类型。不过在此之前，首先需要了解常用的统计模式，并使用合理的数据类型来解决实际问题。</p><p>这里我们一般会使用如下四种统计类型：二值状态统计、基数统计、排序统计和聚合统计。</p><h1 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h1><h3 id="二值状态统计概念"><a href="#二值状态统计概念" class="headerlink" title="二值状态统计概念"></a>二值状态统计概念</h3><p>二值状态统计，即集合中的元素只有0和1这两种状态，统计对应状态出现的次数。</p><p>举个例子，用户在进行打卡签到的时候，只有签到（1）或未签到（0）这两种；判断用户是否登录，也只有已登录（1）或未登录（0）这两种，它们均合适使用二值状态来进行统计。</p><h3 id="判断用户登陆态"><a href="#判断用户登陆态" class="headerlink" title="判断用户登陆态"></a>判断用户登陆态</h3><p>可以使用BitMap来判断海量用户中某个用户是否登录，它提供了<code>GETBIT</code>、<code>SETBIT</code>等命令，通过一个偏移值offset对bit数组的offset位置的bit位进行读写操作，请注意offset从0开始。</p><p>这样只需使用一个<code>login_status</code>集合来存储用户登录状态，然后将用户ID作为offset，如果用户在线则设置为1，下线则设置为0。后续开发者就可以通过<code>GETBIT</code>来判断对应用户是否在线。</p><p><code>SETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT &lt;key&gt; &lt;offset&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>用于设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。</p><p><code>GETBIT</code>命令用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT &lt;key&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure><p>用于获取 key 的 value 在 offset 处的 bit 位的值，注意当 key 不存在时，返回 0。</p><p>举个例子，当我们需要判断userId为1001用户的登录情况，此时步骤如下：<br>（1）假定用户已经登录，往<code>login_status</code>集合中userId为1001的bit位处设置值为1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 1</span><br></pre></td></tr></table></figure><p>（2）判断该用户是否登录，返回值为1表示已登录，0表示未登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 1001</span><br></pre></td></tr></table></figure><p>（3）用户进行退出操作，将对应的offset值设置为0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 1001 0</span><br></pre></td></tr></table></figure><h3 id="统计用户每个月的签到情况"><a href="#统计用户每个月的签到情况" class="headerlink" title="统计用户每个月的签到情况"></a>统计用户每个月的签到情况</h3><p>在签到统计中，每个用户每天的签到使用1个Bit位表示，那么一年的签到只需365个Bit位。而一个月最多只有31天你，那么最多只要31个Bit位。</p><p>现在有一个需求，统计userId为10010的用户在2021年8月份的签到打卡情况，此时该如何操作呢？可以将key设置为<code>userId:sign:&#123;userId&#125;:&#123;yyyyMM&#125;</code>这一格式，月份每一天的值减去1就可以作为offset，因为offset从0开始。</p><p>第一步，假定userId为1001的用户在2021年8月18号签到打卡了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT userId:sign:1001:202108 17 1</span><br></pre></td></tr></table></figure><p>第二步，判断userId为1001的用户在2021年8月18号是否进行了签到打卡：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT userId:sign:1001:202108 17</span><br></pre></td></tr></table></figure><p>第三步，统计userId为1001的用户在2021年8月的签到打卡次数，可以使用<code>BITCOUNT</code>命令，该命令用于统计给定bit数组中，值为1的bit位的数量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT userId:sign:1001:202108</span><br></pre></td></tr></table></figure><p>这样就实现了用户每个月签到打卡情况的统计，总的来说还是较为简单。</p><h3 id="统计用户首次打卡时间"><a href="#统计用户首次打卡时间" class="headerlink" title="统计用户首次打卡时间"></a>统计用户首次打卡时间</h3><p>现在有个需求，获取userId为1001的用户在2021年8月份首次签到打卡的时间。</p><p>Redis提供了<code>BITPOS</code>命令，用于返回第一个值为bitValue的offset的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS key bitValue [start] [end]</span><br></pre></td></tr></table></figure><p>默认情况下，<code>BITPOS</code>命令会检测整个位图，开发者可通过可选的start和end参数来指定需要检测的范围。</p><p>可以通过如下命令来获取userId为1001的用户，在2021年8月份首次签到打卡的时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS userId:sign:1001:202108 1</span><br></pre></td></tr></table></figure><p>可以看到返回结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITPOS userId:sign:1001:202108 1</span><br><span class="line">&quot;17&quot;</span><br></pre></td></tr></table></figure><p>请注意返回的是offset，实际值应该是offset+1，即第18天首次签到。</p><h3 id="统计连续签到用户总数"><a href="#统计连续签到用户总数" class="headerlink" title="统计连续签到用户总数"></a>统计连续签到用户总数</h3><p>现在有一份数据，记录了一个亿用户连续7天的签到打卡记录，那么如何统计出这连续7天都连续打卡的用户总数呢？</p><p>前面我们说过，将每天的日期作为 Bitmap的key，userId作为offset，如果用户签到打卡了，那么将offset位置处的bit设置为1。那么这个key所对应集合的每个bit 位的数据，则是一个用户在该日期的打卡记录。</p><p>那么就存在 7 个这样的 Bitmap，可以对这 7 个 Bitmap 的对应的 bit 位做与运算。同样userID的offset都是一样的，当一个userID在 7 个 Bitmap 对应的 offset 位置的 bit的值为 1 ，就说明该用户 7 天连续打卡。之后将结果保存到一个新Bitmap 中，然后通过 <code>BITCOUNT</code>命令来统计 bit值为 1 的个数，就能得到连续打卡 7 天的用户总数。</p><p>实际上Redis 提供了<code>BITOP</code>命令，用于对一个或者多个key的 Bitmap进行位与操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure><p>operation可以是 AND、OR、NOT、XOR等。BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-85af4485654fc32f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>定义了3 个 Bitmap，并将对应的 bit 位做与操作，然后将结果保存到新的 Bitmap中。上述操作指令表示将 3个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，然后对 destmap 执行 BITCOUNT 操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line">// 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure><p>可以看到一个包含一亿bit位的 Bitmap占用的内存开销，大约是 12 MB 的内存（10^8/8/1024/1024），那么7 天的 Bitmap 的内存开销约为84 MB。不过开发者最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，这样可以节省内存。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当开发者在实际开发过程中遇到只需统计数据的二值状态时，如判断用户是否登录、IP是否存在黑名单、打卡是否签到等就可以考虑使用BitMap。BitMap只需一个 bit 位就能表示 0 和 1，这在统计海量数据时，将极大减少内存的占用。</p><h1 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h1><h3 id="基数统计概念"><a href="#基数统计概念" class="headerlink" title="基数统计概念"></a>基数统计概念</h3><p>基数统计，即统计一个集合中不重复元素的个数，常见于计算独立用户数（UV）。</p><p>实现基数统计最直接的方法就是使用集合（Set）这种数据结构，当一个元素从未在此集合中出现过，那么便将其添加到集合中，否则不集合保持不变。如果页面访问量巨大，就需要一个非常大的Set来进行统计，这必然会浪费大量的空间。</p><p>实际上这种数据不一定要很精准，可以采用Redis提供的<code>HyperLogLog</code>这一数据结构来解决这种场景的统计问题。</p><p><code>HyperLogLog</code>是一种不精确的去重基数方案，其统计规则是基于概率实现的，标准误差 0.81%，这样的精度足以满足UV统计需求。</p><h3 id="网站的-UV"><a href="#网站的-UV" class="headerlink" title="网站的 UV"></a>网站的 UV</h3><h5 id="采用Set实现"><a href="#采用Set实现" class="headerlink" title="采用Set实现"></a>采用Set实现</h5><p>一个用户一天内多次访问一个网站只能算作一次，因此最先想到的就是使用Redis提供的Set集合来实现。</p><p>举个例子，ID为1001的用户访问index页面时，可以将这个信息放到集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD index:uv 1001</span><br></pre></td></tr></table></figure><p>当这个ID为1001的用户多次访问首页时，Set集合的去重功能可以保证不会重复记录同一个用户ID。之后可通过SCARD命令来统计index页面的uv，该命令返回集合中元素的个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD index:uv</span><br></pre></td></tr></table></figure><h5 id="采用Hash实现"><a href="#采用Hash实现" class="headerlink" title="采用Hash实现"></a>采用Hash实现</h5><p>小明说也可以采用Hash这一数据结构来实现，将用户ID作为Hash集合的key，那么访问某个页面则执行HSET命令将value的值设置为1。这样即使用户重复访问，重复执行命令，也只会将这个userId的值设置为1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET index:uv userId:1001 1</span><br></pre></td></tr></table></figure><p>最后利用<code>HLEN</code>命令来统计Hash集合中的元素个数，也就是用户访问数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN index:uv</span><br></pre></td></tr></table></figure><h5 id="采用HyperLogLog实现"><a href="#采用HyperLogLog实现" class="headerlink" title="采用HyperLogLog实现"></a>采用HyperLogLog实现</h5><p>Set集合尽管好用，但是如果首页访问量过大，那么一个Set中就保存了上千万个用户的ID，这还仅仅是首页，还有其他页面，这对内存的消耗太大了，同理Hash这种数据结构也是一样的。</p><p>此时就可以使用HyperLogLog这种数据结构，这是一种用于基数统计的数据集合类型，即使数据量很大，计算基数所需的空间也是固定的。每个HyperLogLog最多花费12KB的内存就可以计算2的64次方个元素的基数。</p><p>Redis对HyperLogLog的存储进行了优化，在计数较小时，存储空间采用系数矩阵，占用空间很小。只有在计数很大，稀疏矩阵占用的空间超过了阈值，才会转变成稠密矩阵，占用 12KB 空间。</p><p>开发者可使用<code>PFADD</code>命令，将访问index页面的每个用户ID添加到HyperLogLog中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3 userId4</span><br></pre></td></tr></table></figure><p>然后使用<code>PFCOUNT</code>命令，统计ndex页面的UV值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT index:uv</span><br></pre></td></tr></table></figure><p>当然了，HyperLogLog除了提供上面使用的<code>PFADD</code>和<code>PFCOUNT</code>命令，还提供了<code>PFMERGE</code>命令，用于将多个HyperLogLog合并在一起形成一个新的HyperLogLog。<code>PFMERGE</code>命令语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p>举个例子，在网站上有两个内容差不多的页面，运营人员说需要这两个页面的数据进行合并，也包含UV量，此时就可以使用<code>PFMERGE</code>命令，注意此时同一个用户访问这两个页面只算访问一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PFADD index:uv userId1 userId2 userId3  //3</span><br><span class="line">PFADD comment:uv userId1 userId3 userId4  //3</span><br><span class="line">PFMERGE website:uv index:uv comment:uv  //OK</span><br><span class="line">PFCOUNT website:uv  //4</span><br></pre></td></tr></table></figure><p>可以看到这里我们将多个HyperLogLog进行了合并输出为一个新的HyperLogLog，新HyperLogLog的基数接近于所有输入HyperLogLog的可见集合的并集。</p><h1 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h1><p>我们知道，Redis的4种集合类型（List、Set、Hash和SortedSet）中，只有List和SortedSet是有序的。</p><ul><li>List按照元素插入List的顺序进行排序，通常用于实现消息队列、最新列表、排行榜等；</li><li>SortedSet则是根据元素的score权重进行排序，开发者可自己决定每个元素的权重值，通常用于实现按照一定规则的排行榜（积分数、点赞数、播放量等）。<h3 id="最新评论列表"><a href="#最新评论列表" class="headerlink" title="最新评论列表"></a>最新评论列表</h3><h5 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h5>开发者可以使用List的插入顺序来实现评论列表。举个例子，如微信公众平台的后台回复列表，每一个公众号的文章都对应一个List，这个List就保存了该文章所对应的用户评论。</li></ul><p>当一个用户评论index这个文章时，可以使用LPUSH命令将评论插入到List头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH index zhangsan lisi wangwu</span><br></pre></td></tr></table></figure><p>接着我们再使用LRANGE命令来获取列表指定区间内的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE index 0 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;wangwu&quot;</span><br><span class="line">2)  &quot;lisi&quot;</span><br><span class="line">3)  &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意，并不是所有的最新列表都能使用List来实现，对于一些频繁更新的列表，不太建议使用List，因为List类型的分页可能导致列表元素重复或者漏掉。</strong></p><p>举个例子，假设当前评论列表为<code>List = &#123;A,B,C,D&#125;</code>，其中左侧表示最新评论，即D是最早的评论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list D C B A</span><br></pre></td></tr></table></figure><p>接下来第一页展示最新两个评论，获取到A和B：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 0 1</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;A&quot;</span><br><span class="line">2)  &quot;B&quot;</span><br></pre></td></tr></table></figure><p>按照我们预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;C&quot;</span><br><span class="line">2)  &quot;D&quot;</span><br></pre></td></tr></table></figure><p>这是没有问题的，但是如果在展示第二页评论之前，又往列表里面添加了一个新的评论E，评论E通过如下命令插入到List队首：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list E</span><br></pre></td></tr></table></figure><p>那么此时List就变成了<code>List = &#123;A,B,C,D&#125;</code>，此时我们再来执行之前预想的逻辑，第二页可通过<code>LRANGE list 2 3</code>来获取C和D：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE list 2 3</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)  &quot;B&quot;</span><br><span class="line">2)  &quot;C&quot;</span><br></pre></td></tr></table></figure><p>可以看到评论B又出现了，原因在于List是利用元素所在的位置进行排序，而一旦有新的元素插入，那么原有数据在List中的位置都会往后移动一位，进而导致读取了旧的元素。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c0aee7c06f112e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>因此只有在不需要分页（如每次只读取列表的前10个元素）或者更新频率比较低（如每天凌晨统计更新一下）的列表才适合使用List数据类型来实现。</p><p>对于需要分页且更新较为频繁的列表，就必须使用有序集合 Sorted Set类型来实现。</p><p>此外，List 类型无法实现通过时间范围查找的最新列表，此功能需要通过有序集合 Sorted Set 类型实现，举个例子以成交时间范围作为条件来查询的订单列表。</p><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><h5 id="功能实现-1"><a href="#功能实现-1" class="headerlink" title="功能实现"></a>功能实现</h5><p>对于最新列表的场景，List和Sorted Set都可以实现，那为啥还使用List呢？直接使用Sorted Set那不是更好，它还可以设置score权重值，排序更为灵活。</p><p>原因在于Sorted Set 类型占用的内存容量是 List 类型的数倍之多，因此对于列表数量不多的情况，可以用 Sorted Set 类型来实现。如一周的音乐榜单，此时需要实时更新播放量，并且需要分页展示。除此以外，排序是根据播放量来决定的，此时List就无法满足。</p><p>开发者可以歌曲ID保存到 Sorted Set 集合中，score 设置成每首歌曲的播放量，该歌曲每播放一次则设置<code>score = score +1</code>。</p><p>举个例子，开发者可以使用<code>ZADD</code>命令，将《城府》和《稻香》这两首歌曲播放量放到musicTop集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD musicTop 100000 城府 9999999 稻香</span><br></pre></td></tr></table></figure><p>然后《城府》这首歌每播放一次，就使用<code>ZINCRBY</code>命令，将score进行加1操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY musicTop 1 城府</span><br></pre></td></tr></table></figure><p>执行结果返回”100001”，这就说明播放次数确实增加了。接着我们需要获取音乐播放量排名前10的歌曲，目前最大播放量是N，可通过如下命令来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE musicTop N-9 N WITHSCORES</span><br></pre></td></tr></table></figure><p>开发者可通过<code>ZREVRANGE key start stop [WITHSCORES]</code>命令来将集合中的元素按照score的值进行递减（从大到小）进行排序。具有相同score的值的成员，则按照字典的逆序进行排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE musicTop 0 0 WITHSCORES</span><br><span class="line"> 1)  &quot;稻香&quot;</span><br><span class="line"> 2)  &quot;9999999&quot;</span><br></pre></td></tr></table></figure><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><p>即使集合中的元素更新较为频繁，那么Sorted Set也能通过 <code>ZRANGEBYSCORE</code>命令来准确地获取到按序排列的数据。</p><p>当开发者遇到需要展示最新列表、排行榜等业务场景时，如果数据更新频繁或者需要分页显示，建议优先考虑使用 Sorted Set。</p><h1 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h1><h3 id="聚合统计概念"><a href="#聚合统计概念" class="headerlink" title="聚合统计概念"></a>聚合统计概念</h3><p>聚合统计，指的是统计多个集合元素的聚合结果，常用的有：<br>（1）统计多个元素的共有数据（交集）；<br>（2）统计多个元素的所有数据（并集）；<br>（3）统计两个集合其中某个独有的元素（差集）。</p><p>Redis的Set类型支持集合内的增删改查，底层使用Hash数据结构，因此无论是add、remove 都是 O(1) 时间复杂度。并且支持多个集合间的交集、并集、差集等操作，利用这些集合操作，可以很方便的解决上面提到的统计问题。</p><h3 id="共同好友（交集）"><a href="#共同好友（交集）" class="headerlink" title="共同好友（交集）"></a>共同好友（交集）</h3><p>举个例子，新浪微博中共同关注的人就是聚合统计中的交集。我们可以将用户Id作为key，该用户关注的用户Id作为Set集合中的value。</p><p>首先模拟两个用户关注的好友：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD userId:1001 1003 1004 1008</span><br><span class="line">SADD userId:1002 1004 1006 1009</span><br></pre></td></tr></table></figure><p>然后统计这两个用户共同关注的好友，就可以使用集合的交集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE userId:1001-1002 userId:1001 userId:1002</span><br></pre></td></tr></table></figure><p>之后两个用户交集都存在了userId:1001-1002这一集合中。</p><h3 id="每日新增用户数（差集）"><a href="#每日新增用户数（差集）" class="headerlink" title="每日新增用户数（差集）"></a>每日新增用户数（差集）</h3><p>举个例子，统计某个App每天新增的用户注册数，只需对近两天的总注册用户量集合进行取差集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE user:20210610-0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户差集都存在了userId:20210610-0609这一集合中，上面统计的是06-10比06-09号多的人数。</p><p>实际上，新浪微博还有一个可能认识的人这一功能，也可以使用差集实现，即将你关注的好友所关注的人减去你们共同关注的人即是可能认识的人。</p><h3 id="总共新增好友（并集）"><a href="#总共新增好友（并集）" class="headerlink" title="总共新增好友（并集）"></a>总共新增好友（并集）</h3><p>举个例子，统计某个App在2021-06-09和2021-06-10这两天，总的用户注册数，只需对近两天的总注册用户量集合进行取并集操作即可。</p><p>如2021-06-09的总注册用户量存在于<code>key=user:20210609</code>集合中，2021-06-10的总注册用户量存在于<code>key=user:20210610</code>集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD user:20210609 1001 1002 1003</span><br><span class="line">SADD user:20210610 1001 1002 1003 1004 1005</span><br></pre></td></tr></table></figure><p>然后统计每日新增用户，就可以使用集合的差集命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE user:20210610+0609 user:20210610 user:20210609</span><br></pre></td></tr></table></figure><p>之后两个用户并集都存在了userId:20210610+0609这一集合中。</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>Set的交集、并集、差集等操作计算的复杂度较高，在数据量比较大的情况下，直接执行这些操作可能会导致Redis实例阻塞。可以考虑专门部署一个集群用于统计，让它专门负责聚合计算或者是将数据读取到客户端，在客户端完成聚合统计，这样可以避免由于阻塞而导致其他服务无法快速响应的局面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近参与了一个社交系统的前期需求评审会议，里面涉及到各种社交应用场景，使用Redis无疑是最合适不过的了。通常会保存这样的信</summary>
      
    
    
    
    <category term="redis" scheme="http://envyzhan.asia/categories/redis/"/>
    
    
    <category term="redis" scheme="http://envyzhan.asia/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊Redis中的布隆过滤器</title>
    <link href="http://envyzhan.asia/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/"/>
    <id>http://envyzhan.asia/2023/04/06/2023-101-talk-about-the-bloom-filter-in-redis/</id>
    <published>2023-04-06T11:55:30.000Z</published>
    <updated>2023-06-09T13:12:18.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写在前面<br>本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</p><h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>在实际开发过程中遇到过这种情况，用户在使用APP阅读文章时，如何做到每次推荐给该用户的文章不重复，即需要过滤掉他已经阅读过的文章。</p><p>此时有人可能会说我们可以记录每个用户的浏览历史，然后每次在推荐的时候查询用户的浏览记录并进行过滤，进而实现文章的去重。如果开发者将用户的浏览历史存储在关系型数据库中，那么就需要频繁的对数据库进行exists判断，在并发量不高的情况下还能正常响应，但是一旦并发量上来，数据库是扛不住的。</p><p>那么又有人说，可以将这些浏览历史存在缓存中。请注意，千万不要将它们存在缓存中，这样会浪费很多内存，而且缓存适合更新频率比较低的情况，而用户的浏览历史可能每时每刻都在变化。</p><p>针对上述情况，即遇到数据量较大，又需要去重的时候，就可以考虑使用布隆过滤器。一般来说，布隆过滤器适用于如下场景：<br>（1）解决Redis中缓存穿透问题；<br>（2）爬虫过滤，对爬虫爬过的网站进行过滤，爬过的不再爬取；<br>（3）内容推荐，对已经推荐过的内容进行过滤，不再推荐；<br>（4）邮件过滤，对邮件设置的黑名单进行过滤；<br>……</p><h1 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h1><p>布隆过滤器 (Bloom Filter)由Burton Howard Bloom于1970年提出，它是一种 space efficient 的概率型数据结构，用于判断一个元素是否在集合中。</p><p>如果布隆过滤器说某个数据存在，那么这个数据实际上可能不存在；但是如果说某个数据不存在，那么此时这个数据一定不存在，即一种概率性的判断。</p><p>你可能会说判断元素是否在集合中，最简单的可以使用哈希表，但是完成同样问题时，布隆过滤器只需哈希表的1/8或1/4的空间复杂度。</p><p>请注意，布隆过滤器可以插入元素，但是不可以删除已有元素。而且布隆过滤器中的元素越多，那么<code>false positive rate</code>(误报率)越大，不过不会发生 <code>false negative</code> (漏报)。</p><h1 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h1><p>首先看下面一张图，快速了解一下布隆过滤器的原理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fe0098fcc3e04f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先分配一块内存空间做bit数组，数组的bit位初始值均为0。</p><p>接着往其中添加元素时，采用K个相互独立的 Hash 函数计算，然后将元素Hash 映射的K个位置全部设置为1。</p><p>当需要检测元素是否存在，会使用这K个 Hash 函数计算出 K 个位置，如果位置全部为1，则说明元素存在；否则不存在。</p><p><strong>由于哈希函数会出现碰撞，因此布隆过滤器也存在误判</strong>。一般我们会使用误判率，而误判率是指布隆过滤器判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值。因此有概率存在这样的 key，它们内容不同，但经过多次 Hash 后的 Hash 值相同。</p><p><strong>布隆过滤器判断某个元素不存在，那么这个元素必定不存在；判断某个元素存在，那么这个元素可能不存在</strong>。可以使用反证法进行验证，如果元素存在，那么它每次Hash计算后的Hash值位置必然为1，而不是0。</p><p>前面说了，可以往布隆过滤器中插入元素，但是不可以删除已有元素，为什么是这样呢？我们知道，删除意味着需要将对应的K个bit位置设置为0，而这些有可能是其他元素对应的bit，因此删除会发生<code>false negative </code>(漏报)，这是不允许的。</p><h1 id="Redis集成布隆过滤器"><a href="#Redis集成布隆过滤器" class="headerlink" title="Redis集成布隆过滤器"></a>Redis集成布隆过滤器</h1><p>Redis在4.0的时候官方提供插件机制，用于提供对布隆过滤器的支持。开发者可以点击 <a href="https://redis.com/redis-enterprise-software/download-center/software/">这里</a> 下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e1ea925af27287ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>使用布隆过滤器最低需要4.x版本，不过笔者建议使用6.x版本。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>开发者可以自行编译安装，从 github 下载，笔者使用的 release 版本是 v2.2.18，下载地址 <a href="https://github.com/RedisBloom/RedisBloom/releases/tag/v2.2.18">点击</a> 这里：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5865ad76ef8b2717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后将其进行解压，编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf RedisBloom-2.2.18.tar</span><br><span class="line">cd RedisBloom-2.2.18</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>之后会生成一个名为<code>redisbloom.so</code>的文件，那么接下来我们就是安装集成它了。</p><p>修改<code>redis.conf</code>文件，在里面新增一个loadmodule，值为上面生成的<code>redisbloom.so</code>文件的全路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集成BloomFilter</span><br><span class="line">loadmodule /home/envy/RedisBloom-2.2.18/redisbloom.so</span><br></pre></td></tr></table></figure><p>之后重启Redis，注意如果是Redis集群，那么每个实例的配置文件都需要加入该配置项。</p><p>启动的时候我们需要以指定配置文件启动Redis，进入到Redis的bin目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../conf/redis.conf</span><br></pre></td></tr></table></figure><p>然后使用客户端连接到Redis，开始进行测试。布隆过滤器常用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个元素到布隆过滤器</span><br><span class="line">BF.ADD element bloomfilter</span><br><span class="line"># 判断元素是否在布隆过滤器中</span><br><span class="line">BF.EXISTS element bloomfilter</span><br><span class="line"># 添加多个元素到布隆过滤器</span><br><span class="line">BF.MADD element1 element2 bloomfilter</span><br><span class="line"># 判断多个元素是否在布隆过滤器</span><br><span class="line">BF.MEXISTS element1 element2 bloomfilter</span><br></pre></td></tr></table></figure><p>测试结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9ec37586591616dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Redis布隆过滤器实战"><a href="#Redis布隆过滤器实战" class="headerlink" title="Redis布隆过滤器实战"></a>Redis布隆过滤器实战</h1><p>前面也说过，在Redis中布隆过滤器常用的作用就是解决缓存穿透问题，所谓的缓存穿透是指请求查询不存在的数据，即缓存和数据库中都没有的数据。</p><p>接下来我们模拟一个场景：用户在购买商品创建订单时，我们会往MQ中发送消息，将订单ID添加到布隆过滤器中，之后判断订单是否存在。整个流程如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ee80ba9daeed5da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="BF-RESERVE命令详解"><a href="#BF-RESERVE命令详解" class="headerlink" title="BF.RESERVE命令详解"></a><code>BF.RESERVE</code>命令详解</h3><p>前面的过程我们不编写具体的代码，而是通过一些数据来模拟对应的操作。首先我们来了解<code>BF.RESERVE</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION &#123;expansion&#125;] [NONSCALING]</span><br></pre></td></tr></table></figure><p>解释一下上述参数的含义：<br>（1）key是布隆过滤器的名称；<br>（2）<code>error_rate</code>是期望的错误率，默认值为0.1，值越低需要的空间就越大；<br>（3）<code>capacity</code>是初始容量，默认值为100，当实际元素的数量超出这个初始容量值时，错误率会上升；<br>（4）EXPANSION 是可选参数，当添加到布隆过滤器中的元素数量达到初始容量后，不会扩容过滤器，并且会抛出异常（<code>(error) ERR non scaling filter is full</code>）。这说明布隆过滤器的扩容是通过增加布隆过滤器的层数来完成的。每增加一层，查询时就可能会遍历多层布隆过滤器，默认情况下每一层的容量都是上一层的两倍。</p><p><strong>请注意，如果不使用<code>BF.RESERVE</code>命令来创建布隆过滤器，而使用Redis自动创建的布隆过滤器，那么默认的<code>error_rate</code>为0.1，初始容量为100。</strong></p><p>布隆过滤器的<code>error_rate</code>越小，需要的存储空间就越大，对于不需要过于精确的业务场景来说，<code>error_rate</code>的值可以设置大一些。</p><p>布隆过滤器的<code>capacity</code>设置的过大，会浪费存储空间；设置过小会影响准确率，因此在使用布隆过滤器之前，最好尽可能的精确估计元素的数量，同时加上一定的冗余空间，这样可避免实际元素会超出设定值很多的情况。</p><h3 id="创建orders布隆过滤器"><a href="#创建orders布隆过滤器" class="headerlink" title="创建orders布隆过滤器"></a>创建orders布隆过滤器</h3><p>接下来我们使用<code>BF.RESERVE</code>命令来手动创建一个名为orders的布隆过滤器，注意<code>error_rate</code>为0.1，初始容量为1000万：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE orders 0.1 10000000</span><br></pre></td></tr></table></figure><h3 id="添加订单ID到布隆过滤器"><a href="#添加订单ID到布隆过滤器" class="headerlink" title="添加订单ID到布隆过滤器"></a>添加订单ID到布隆过滤器</h3><p>接下来我们尝试使用<code>BF.ADD</code>命令往orders这一布隆过滤器中添加10010这一订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.ADD orders 10010</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.ADD orders 10010</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>当然了也可以一次性添加三个订单号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.MADD orders 10011 10012 10013</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MADD orders 10011 10012 10013</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br></pre></td></tr></table></figure><h3 id="判断订单是否存在"><a href="#判断订单是否存在" class="headerlink" title="判断订单是否存在"></a>判断订单是否存在</h3><p>开发者可以使用<code>BF.EXISTS</code>命令来判断某一元素是否存在于布隆过滤器中，返回值为1表示存在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.EXISTS orders 10011</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>如果想要批量检查多个元素是否在布隆过滤器中，可以使用<code>BF.MEXISTS</code>命令，该命令返回的是一个数组，其中1表示存在，0表示不存在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.EXISTS key element1 element2......</span><br></pre></td></tr></table></figure><p>举个例子，判断订单号为10011、10012、10013和10014的订单是否存在orders这一布隆过滤器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.MEXISTS orders 10011 10012 10013 10014</span><br><span class="line"> 1)  &quot;1&quot;</span><br><span class="line"> 2)  &quot;1&quot;</span><br><span class="line"> 3)  &quot;1&quot;</span><br><span class="line"> 4)  &quot;0&quot;</span><br></pre></td></tr></table></figure><p>也就是说我们可以通过<code>BF.RESERVE</code>、<code>BF.ADD</code>和<code>BF.EXISTS</code>这三个命令来避免缓存穿透问题。</p><h3 id="查看创建的布隆过滤器信息"><a href="#查看创建的布隆过滤器信息" class="headerlink" title="查看创建的布隆过滤器信息"></a>查看创建的布隆过滤器信息</h3><p>开发者可以使用<code>BF.INFO key</code>命令来查看创建的布隆过滤器信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">192.168.51.131:0&gt;BF.INFO orders</span><br><span class="line"> 1)  &quot;Capacity&quot;</span><br><span class="line"> 2)  &quot;10000000&quot;</span><br><span class="line"> 3)  &quot;Size&quot;</span><br><span class="line"> 4)  &quot;7794184&quot;</span><br><span class="line"> 5)  &quot;Number of filters&quot;</span><br><span class="line"> 6)  &quot;1&quot;</span><br><span class="line"> 7)  &quot;Number of items inserted&quot;</span><br><span class="line"> 8)  &quot;4&quot;</span><br><span class="line"> 9)  &quot;Expansion rate&quot;</span><br><span class="line"> 10)  &quot;2&quot;</span><br></pre></td></tr></table></figure><p>解释一下上述返回值的含义：<br>（1）Capacity表示预设容量，即初始容量；<br>（2）Size表示实际占用情况，但如何计算需要进一步确认；<br>（3）Number of filters表示过滤器层数；<br>（4）Number of items inserted表示已经实际插入的元素数量；<br>（5）Expansion rate表示子过滤器扩容系数（默认值为2）。</p><h3 id="无法删除布隆过滤器"><a href="#无法删除布隆过滤器" class="headerlink" title="无法删除布隆过滤器"></a>无法删除布隆过滤器</h3><p>目前布隆过滤器是无法删除的，但是布谷过滤器(Cuckoo Filter)支持删除。</p><p>布隆过滤器在插入项目时通常表现出更好的性能和可伸缩性，因此如果开发者经常向数据集中添加元素，那么此时布隆过滤器还可以接受。不过布谷过滤器在检查操作上更快，也支持删除，可以点击 <a href="https://oss.redis.com/redisbloom/Cuckoo_Commands/">这里</a> 进行阅读。实际上本篇文章中的实战就来自于Redis官方提供的Redis布隆过滤器实战，可以点击 <a href="https://oss.redis.com/redisbloom/">这里</a> 进行阅读。</p><h1 id="Redission布隆过滤器实战"><a href="#Redission布隆过滤器实战" class="headerlink" title="Redission布隆过滤器实战"></a>Redission布隆过滤器实战</h1><h3 id="RBloomFilter接口"><a href="#RBloomFilter接口" class="headerlink" title="RBloomFilter接口"></a>RBloomFilter接口</h3><p>在Redisson中，与BloomFilter相关的操作都被定义到RBloomFilter接口中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface RBloomFilter&lt;T&gt; extends RExpirable &#123;</span><br><span class="line">    //添加元素</span><br><span class="line">    boolean add(T object);</span><br><span class="line">  </span><br><span class="line">    //判断元素是否存在</span><br><span class="line">    boolean contains(T object);</span><br><span class="line"></span><br><span class="line">    //根据指定的参数来初始化布隆过滤器</span><br><span class="line">    boolean tryInit(long expectedInsertions, double falseProbability);</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素的预期插入量</span><br><span class="line">    long getExpectedInsertions();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回元素存在的错误概率</span><br><span class="line">    double getFalseProbability();</span><br><span class="line"></span><br><span class="line">    //返回此实例所需的Redis内存中的bit数</span><br><span class="line">    long getSize();</span><br><span class="line"></span><br><span class="line">    //在布隆过滤器初始化期间计算，返回每个元素使用的哈希迭代次数</span><br><span class="line">    int getHashIterations();</span><br><span class="line"></span><br><span class="line">    //计算已添加到布隆过滤器的元素的概率数</span><br><span class="line">    long count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>，创建一个名为<code>redisson-fly</code>的SpringBoot项目，注意后续关于其他数据结构的代码都在这个项目中进行编写：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc0d405fc4ee701e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.13.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>application.yml</code>配置文件中新增如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.51.131</span><br><span class="line">    port: 6379</span><br><span class="line">    ssl: false</span><br><span class="line">    password: envy123</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，由于这里我们不对外提供接口，因此我们只创建service类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BoolFilterService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建布隆过滤器</span><br><span class="line">     * @param filterName 布隆过滤器</span><br><span class="line">     * @param expectedInsertions 预测插入数量</span><br><span class="line">     * @param falseProbability 误判率</span><br><span class="line">     * @param &lt;T&gt; 泛型</span><br><span class="line">     * @return 布隆过滤器</span><br><span class="line">     */</span><br><span class="line">    public &lt;T&gt; RBloomFilter&lt;T&gt; create(String filterName,long expectedInsertions,double falseProbability)&#123;</span><br><span class="line">        RBloomFilter&lt;T&gt; bloomFilter = redissonClient.getBloomFilter(filterName);</span><br><span class="line">        bloomFilter.tryInit(expectedInsertions, falseProbability);</span><br><span class="line">        return bloomFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，针对这个BoolFilterService类创建对应的测试类及测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class BoolFilterServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BoolFilterService boolFilterService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testBloomFilter()&#123;</span><br><span class="line">        //布隆过滤器名称</span><br><span class="line">        String bloomFilterName = &quot;ipBlackList&quot;;</span><br><span class="line">        //初始容量</span><br><span class="line">        long expectedInsertions = 10000L;</span><br><span class="line">        //误判率</span><br><span class="line">        double falseProbability = 0.01;</span><br><span class="line">        RBloomFilter&lt;Long&gt; bloomFilter = boolFilterService.create(bloomFilterName, expectedInsertions, falseProbability);</span><br><span class="line"></span><br><span class="line">        //往布隆过滤器中添加元素</span><br><span class="line">        for (long i = 0; i &lt; expectedInsertions; i++) &#123;</span><br><span class="line">            bloomFilter.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        long elementCount = bloomFilter.count();</span><br><span class="line">        log.info(&quot;布隆过滤器中的元素个数为：&#123;&#125;&quot;,elementCount);</span><br><span class="line"></span><br><span class="line">        //统计布隆过滤器中误判次数，即实际上不存在但是布隆过滤器却说存在的次数</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (long i = expectedInsertions; i &lt; expectedInsertions * 2; i++) &#123;</span><br><span class="line">            if(bloomFilter.contains(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;布隆过滤器中的误判次数为：&#123;&#125;&quot;,count);</span><br><span class="line">        //删除布隆过滤器</span><br><span class="line">        bloomFilter.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试逻辑非常简单，定义一个名为ipBlackList的布隆过滤器，然后设置初始容量为10000，误判率为0.01。然后往里面添加0-10000这些数字，接着我们判断10001到20000是否在这个ipBlackList中，进而得到误判的次数。</p><p>当然了，如果上面使用的是Redis集群，那么需要使用如下命令来初始化布隆过滤器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RClusteredBloomFilter&lt;Long &gt; bloomFilter = redisson.getClusteredBloomFilter(&quot;redisCluster&quot;);</span><br></pre></td></tr></table></figure><p>运行该测试方法，可以看到结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的元素个数为：9895</span><br><span class="line">c.k.r.service.BoolFilterServiceTest      : 布隆过滤器中的误判次数为：259</span><br></pre></td></tr></table></figure><p>可以看到是比较符合我们预定的误判率。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>布隆过滤器的思想就是判断元素可能存在或者一定不存在，因此在使用时需要结合实际情况进行分析。</p><p>参考资料：<a href="https://mp.weixin.qq.com/s/MFqQOzyO1zhrHF_Xcl0dvA">Redis 布隆（Bloom Filter）过滤器原理与实战</a>、<a href="https://redis.io/docs/stack/bloom/">Redis官方文档</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;写在前面&lt;br&gt;本篇来聊一聊Redis中的布隆过滤器，主要包括布隆过滤器原理、Redis集成布隆过滤器以及一个demo实战。</summary>
      
    
    
    
    <category term="redis" scheme="http://envyzhan.asia/categories/redis/"/>
    
    
    <category term="redis" scheme="http://envyzhan.asia/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>功能开关在业务中的实践</title>
    <link href="http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/"/>
    <id>http://envyzhan.asia/2023/03/01/2023-100-practice-of-function-switch-in-business/</id>
    <published>2023-03-01T09:55:30.000Z</published>
    <updated>2023-03-14T07:11:51.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但是后续发现这样有个弊端，即只能针对一个活动或者相同时间的多个活动生效，而实际上我们的活动有多个，权衡再三决定使用功能开关来实现。</p><h1 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h1><p>功能开关其实是一种代码可配置性的实践，说到底就是通过控制开关的状态来实现对功能的决定控制。</p><p>功能开关的实现有很多种方式，可以使用MySQL或者Redis等数据库，出于对后续数据扩展和对存储容量的考量，此处使用Bit数组来实现。</p><h3 id="Bit数组原理"><a href="#Bit数组原理" class="headerlink" title="Bit数组原理"></a>Bit数组原理</h3><p>既然是数组，那么下标必然从0开始，bit只有两种取值，要么为0，要么为1：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3049804d68aadfa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>而0和1正好对应开关的关闭和启用，即ON和OFF状态。之后开发者只需定义好每个开关所在的Bit数组的索引号和状态即可，这样后续就可以通过判断开关的状态来实现对功能的控制：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-e89b847c9308657f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到使用这种方式所占用的内存空间非常少，理论上只需占用2n位的内存，n为开关的数量。</p><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>Java中对于Bit数组可以使用BitSet来实现 ，里面有很多方法，这里我们摘几个用到的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BitSet implements Cloneable, java.io.Serializable &#123;</span><br><span class="line">    //给指定位置设置值</span><br><span class="line">    public void set(int bitIndex, boolean value) &#123;&#125;</span><br><span class="line">    //给指定位置的值取反操作</span><br><span class="line">    public void clear(int bitIndex) &#123;&#125;</span><br><span class="line">    //获取指定位置的值</span><br><span class="line">    public boolean get(int bitIndex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，新建开关状态常量SwitchConst：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关常量</span><br><span class="line"> */</span><br><span class="line">public class SwitchConst &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用</span><br><span class="line">     */</span><br><span class="line">    public static final boolean ON = true;</span><br><span class="line">    /**</span><br><span class="line">     * 关停</span><br><span class="line">     */</span><br><span class="line">    public static final boolean OFF = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于开关只有开和闭这两种状态，因此可以不使用枚举类。</p><p>第二步，新建功能开关枚举类SwitchEnum，这个就是开发者所要定义的开关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 功能开关枚举类</span><br><span class="line"> */</span><br><span class="line">public enum SwitchEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * HTTPS</span><br><span class="line">     */</span><br><span class="line">    HTTPS(0,SwitchConst.ON,&quot;HTTPS设置&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 充值会员</span><br><span class="line">     */</span><br><span class="line">    RECHARGE(1,SwitchConst.OFF,&quot;充值送油卡&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 下标</span><br><span class="line">     */</span><br><span class="line">    private int index;</span><br><span class="line">    /**</span><br><span class="line">     * 默认状态</span><br><span class="line">     */</span><br><span class="line">    private boolean status;</span><br><span class="line">    /**</span><br><span class="line">     * 描述</span><br><span class="line">     */</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    SwitchEnum(int index,boolean status,String desc)&#123;</span><br><span class="line">        this.index = index;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getIndex()&#123;</span><br><span class="line">        return this.index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean getStatus()&#123;</span><br><span class="line">        return this.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return this.desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;name=%s,desc=%s&quot;,name(),desc);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>第三步，新建开关状态切换接口Switch，里面定义切换开关状态和判断接口状态的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关转态切换</span><br><span class="line"> */</span><br><span class="line">public interface Switch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 启用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOn(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 停用开关</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    void turnOff(SwitchEnum switchEnum);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断开关状态</span><br><span class="line">     * @param switchEnum</span><br><span class="line">     */</span><br><span class="line">    boolean judgeStatus(SwitchEnum switchEnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，定义一个BitSetSwitch，表示基于BitSet实现的开关，因此需要实现Switch接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public enum BitSetSwitch implements Switch&#123;</span><br><span class="line">    MYBITSET;</span><br><span class="line"></span><br><span class="line">    BitSetSwitch()&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOn(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.set(switchEnum.getIndex(),SwitchConst.ON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void turnOff(SwitchEnum switchEnum) &#123;</span><br><span class="line">        bitSet.clear(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean judgeStatus(SwitchEnum switchEnum) &#123;</span><br><span class="line">        return bitSet.get(switchEnum.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init()&#123;</span><br><span class="line">        Stream.of(SwitchEnum.values()).forEach(item-&gt;bitSet.set(item.getIndex(),item.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们将BitSetSwitch设置为了一个枚举类，目的就是通过单例生成一个BitSetSwitch对象。注意不能将其设置为普通的类，如果那样的话，在使用的时候就需要通过new关键字生成BitSetSwitch对象，而且每调用一次就得新创建一个对象，这肯定是不行的，功能开关肯定是全局唯一的。</p><p>第五步，新建测试类SwitchTest，测试一下功能开关的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BitSetSwitch bitSetSwitch = BitSetSwitch.MYBITSET;</span><br><span class="line">        bitSetSwitch.turnOn(SwitchEnum.HTTPS);</span><br><span class="line">        bitSetSwitch.turnOff(SwitchEnum.RECHARGE);</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.HTTPS,bitSetSwitch.judgeStatus(SwitchEnum.HTTPS)));</span><br><span class="line">        System.out.println(String.format(&quot;开关【%s】，状态为：%s&quot;,SwitchEnum.RECHARGE,bitSetSwitch.judgeStatus(SwitchEnum.RECHARGE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后运行该方法，可以发现控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开关【name=HTTPS,desc=HTTPS设置】，状态为：true</span><br><span class="line">开关【name=RECHARGE,desc=充值送油卡】，状态为：false</span><br></pre></td></tr></table></figure><p>这说明当前项目开启了HTTPS设置，但是关停了充值送油卡这一活动。后期要实现灵活控制，可配合配置中心在配置文件中进行控制。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>功能开关在实际开发过程中非常实用，因此有必要在理解的基础上进行灵活使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;之前搞过一个报名送油卡的活动，这个活动不定期举办，因此需要考虑可配置性，起初考虑后台做个时间配置框，根据指定的时间来生效，但</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins+Gitlab一键打包部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/</id>
    <published>2023-02-26T14:55:30.000Z</published>
    <updated>2023-03-14T06:52:35.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行。当我们的应用数量较多时，还可以使用Docker Compose的方式，但是毫无疑问上面的种种还都只是手动部署，本篇来学习如何使用Jenkins和Gitlab来实现一键打包部署SpringBoot应用。</p><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><h3 id="GitLab简介"><a href="#GitLab简介" class="headerlink" title="GitLab简介"></a>GitLab简介</h3><p>GitLab是一款开源的基于Git的版本仓库管理工具，开发者可以使用它来搭建属于自己的Git仓库。</p><h3 id="GitLab安装"><a href="#GitLab安装" class="headerlink" title="GitLab安装"></a>GitLab安装</h3><p><strong>第一步</strong>，下载GitLab的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/gitlab/config</span><br><span class="line">mkdir -p /mydata/gitlab/logs</span><br><span class="line">mkdir -p /mydata/gitlab/data</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动GitLab服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10443:443 -p 1080:80 -p 1022:22 \</span><br><span class="line">--name gitlab \</span><br><span class="line">--restart always \</span><br><span class="line">-v /mydata/gitlab/config:/etc/gitlab \</span><br><span class="line">-v /mydata/gitlab/logs:/var/log/gitlab \</span><br><span class="line">-v /mydata/gitlab/data:/var/opt/gitlab \</span><br><span class="line">-d  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，开启防火墙：<br>由于Gitlab运行在1080端口，因此我们需要开放该端口，注意不能直接关闭防火墙，否则Gitlab会无法启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启1080端口</span><br><span class="line">firewall-cmd --zone=public --add-port=1080/tcp --permanent</span><br><span class="line"># 重启防火墙才能生效</span><br><span class="line">systemctl restart firewalld</span><br><span class="line"># 查看已经开放的端口</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，打开浏览器，访问<code>http://宿主机IP:1080</code>链接，查看GitLab是否已经正常启动。请注意，由于GitLab启动比较慢，需要耐心等待10分钟左右，如果GitLab没有启动完成就访问，会出现502的错误。</p><p>开发者可以使用<code>docker logs gitlab -f</code>命令来动态查看容器启动日志，进而确定Gitlab是否已经启动完成。</p><p>之后访问<code>http://宿主机IP:1080</code>链接，可以看到GitLab已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebe4ce1f76be102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以使用如下命令来查看root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it gitlab grep &#x27;Password:&#x27; /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure><p>然后使用root用户加上上面得到的密码进行登录，注意root用户和kenbings用户的密码均为kenbings：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-298f808bd29ae8a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="GitLab使用"><a href="#GitLab使用" class="headerlink" title="GitLab使用"></a>GitLab使用</h3><h5 id="创建组织"><a href="#创建组织" class="headerlink" title="创建组织"></a>创建组织</h5><p>首先创建一个组织，然后在这个组织下分别创建用户和项目，这样同组织的用户就可以使用该组织下的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-56b7f4bf0f6b38ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f18564bf73bb1f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04c57d1455b307de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3de88e91015ce63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7126f255b6e95fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>点击 <a href="https://github.com/git-for-windows/git/releases/download/v2.23.0.windows.1/Git-2.23.0-64-bit.exe">这里</a> 进行下载，然后一路Next进行安装。</p><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><h5 id="下载代码到本地"><a href="#下载代码到本地" class="headerlink" title="下载代码到本地"></a>下载代码到本地</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http或者git地址</span><br></pre></td></tr></table></figure><h5 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h5><p>进入一个名为hello的项目目录，修改<code>README.md</code>并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入项目工程目录</span><br><span class="line">cd hello/</span><br><span class="line"># 将当前修改的文件添加到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 提交代码</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br></pre></td></tr></table></figure><h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h5 id="拉取远程仓库代码"><a href="#拉取远程仓库代码" class="headerlink" title="拉取远程仓库代码"></a>拉取远程仓库代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h5 id="本地创建并提交分支"><a href="#本地创建并提交分支" class="headerlink" title="本地创建并提交分支"></a>本地创建并提交分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换并从当前分支创建一个dev分支</span><br><span class="line">git checkout -b dev</span><br><span class="line"># 将新创建的dev分支推送到远程仓库</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h5 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换到dev分支</span><br><span class="line">git checkout dev</span><br><span class="line"># 查看本地仓库文件状况</span><br><span class="line">git status</span><br><span class="line"># 查看本地所有分支</span><br><span class="line">git branch</span><br><span class="line"># 查看提交记录</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h3 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h3><p>Jenkins是开源CI&amp;CD软件的领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要，开发者可以用Jenkins来构建和部署自己的项目。举个例子，可以从自定义的代码仓库中获取代码，然后将代码打包成可执行的文件，之后通过远程的ssh工具执行脚本，最终实现运行项目这一目的。</p><h3 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h3><p><strong>第一步</strong>，下载Jenkins的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/jenkins_home</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动Jenkins服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -p 50000:5000 --name jenkins \</span><br><span class="line">-u root \</span><br><span class="line">-v /mydata/jenkins_home:/var/jenkins_home \</span><br><span class="line">-d jenkins/jenkins:latest-jdk8</span><br></pre></td></tr></table></figure><h3 id="Jenkins配置"><a href="#Jenkins配置" class="headerlink" title="Jenkins配置"></a>Jenkins配置</h3><p>Jenkins服务启动后，然后访问<code>http://宿主机IP:8080</code>链接，页面出现如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-24988fcf53f76a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后使用如下命令从启动日志中获取到管理员密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs jenkins</span><br></pre></td></tr></table></figure><p>接着进行登录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d190ae88cf70c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择安装插件方式，这里我们直接安装推荐的插件：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-74523a9030f27c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着就进入插件安装界面，联网等待插件安装：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f13bb799ee18f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>安装完成后，接下来我们创建一个管理员账号，账户和密码均为admin：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8785e2fbb1588637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后进行实例配置，配置Jenkins的访问URL：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dcfc0c2c2f0e81f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-703a4bbfdf686f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着点击“Manage Jenkins”–》“Manage Plugins”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-89737123c424524e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>确保以下插件被正确安装：<br>（1）根据角色管理权限的插件：Role-based Authorization Strategy；<br>（2）配置远程服务器：Publish Over SSH。</p><p>接下来新增maven的安装配置，点击“Manage Jenkins”–》“Global Tool Configuration”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8fbf0437fb8b534.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-68ff4208251976f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后新增凭据，点击“Manage Jenkins”–》“Global Tool Configuration”，接着按照图片所示进行操作（注意里面配置的是通过ssh连接到宿主机的用户名和密码）：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-871bf5cc27c8425d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea8e8f2989b50dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着在点击“Manage Jenkins”–》“Configure System”，中添加全局ssh的配置，这样Jenkins使用ssh就可以执行远程linux的脚本：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-914d9729c1e0f46c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="Jenkins角色权限管理"><a href="#Jenkins角色权限管理" class="headerlink" title="Jenkins角色权限管理"></a>Jenkins角色权限管理</h3><p>开发者可以使用Jenkins的角色管理插件，来管理Jenkins的用户。举个例子，开发者可以给管理员赋予所有权限，给运维人员赋予执行任务的相关权限，而其他人员只赋予查看权限。</p><p>点击“Manage Jenkins”–》“Configure Global Security”，然后在里面启用基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9b38969b1d3d829f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们点击“Manage Jenkins”–》“Manage and Assign Roles”，然后在里面开始配置基于角色的权限管理：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-00ae69b2af0f6f79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fee924fad0462233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Manage Roles”，添加角色与权限关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-01c4781f8148613d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击“Assign Roles”，给用户分配角色：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64cdd0024c1e66f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="打包部署SpringBoot应用"><a href="#打包部署SpringBoot应用" class="headerlink" title="打包部署SpringBoot应用"></a>打包部署SpringBoot应用</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-jenkins</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-jenkins</code>这一Module中进行。</p><h3 id="将代码上传到GItlab中"><a href="#将代码上传到GItlab中" class="headerlink" title="将代码上传到GItlab中"></a>将代码上传到GItlab中</h3><p>修改POM文件中build标签中的内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>注意此处需要将dockerHost地址修改为开发者自己的Docker镜像仓库地址。同时项目在容器中运行的端口需要与后续启动脚本中的端口保持一致，这里为8088端口。</p><p>然后依次执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /shop-jenkins</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init project&quot;</span><br><span class="line">git remote add origin http://192.168.51.160:1080/myshop/shop-gitlab-jenkins.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -uf origin main</span><br></pre></td></tr></table></figure><p>注意如果在推送代码的过程中出现如下问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9af484a83d6a3321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>主要原因是因为向一个受保护的分支强制提交了代码，可以在仓库里面进行设置来解决这个问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0c40f2c4217fef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e67581d3b3b7c47e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="定义一个执行脚本"><a href="#定义一个执行脚本" class="headerlink" title="定义一个执行脚本"></a>定义一个执行脚本</h3><p>在<code>/mydata/sh</code>目录下定义一个名为<code>shop-jenkins.sh</code>的脚本，其中的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">app_name=&#x27;shop-jenkins&#x27;</span><br><span class="line">docker stop $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----stop container-----&#x27;</span><br><span class="line">docekr rm $&#123;app_name&#125;</span><br><span class="line">echo &#x27;-----rm container-----&#x27;</span><br><span class="line">docker run -p 8088:8088 --name $&#123;app_name&#125; \</span><br><span class="line">--link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/$&#123;app_name&#125;/logs:/var/logs \</span><br><span class="line">-d myshop-all/$&#123;app_name&#125;:0.0.1-SNAPSHOT</span><br><span class="line">echo &#x27;----start container----&#x27;</span><br></pre></td></tr></table></figure><p>注意里面的映射的端口信息，接着给该脚本赋予可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shop-jenkins.sh</span><br></pre></td></tr></table></figure><p>如果开发者是在Windows系统下创建的sh脚本，那么放到Linux系统上时需要修改文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用vim编辑器来修改</span><br><span class="line">vi shop-jenkins.sh</span><br><span class="line"># 查看文件格式，windows上传上来的默认为dos</span><br><span class="line">:set ff </span><br><span class="line">#修改文件格式为unix</span><br><span class="line">:set ff=unix </span><br><span class="line">#保存并退出</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>然后我们创建对应的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-jenkins</span><br></pre></td></tr></table></figure><h1 id="在Jenkins中创建执行任务"><a href="#在Jenkins中创建执行任务" class="headerlink" title="在Jenkins中创建执行任务"></a>在Jenkins中创建执行任务</h1><p><strong>第一步</strong>，新建一个任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69a4ee3649aedac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，设置任务名称后选择构建一个自由风格的软件项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-845861f3b8d6158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第三步</strong>，点击源码管理，然后在里面添加仓库地址：<code>http://192.168.51.160:1080/myshop/shop-gitlab-jenkins</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1f28a87cb227fe96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时显示连接不通，我们需要添加一个凭据，也就是Git仓库的账号和密码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-23b0f51cc134ba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>填写完该凭据后就选择它，此时就可以正常连接到Git仓库：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8afb66ed66c1d79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，添加一个构建用于调用顶层maven模板，该构建主要用于将源码打包为Docker镜像并上传至Docker镜像仓库中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96d012913b65027d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后选择maven版本并设置maven命令以及指定pom文件的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6c3b13b50a6744c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着设置需要执行的shell的命令，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mydata/sh/shop-jenkins.sh</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ca8e69c00cf15653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击保存操作，这样任务就创建完成了。</p><p><strong>第五步</strong>，在任务列表中可以点击运行来执行该任务：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9941d3d80b4fc277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可通过点击左侧的构建历史序号，然后选择控制台输出即可看到整个任务的执行过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-108a84f1c09d77a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d5f4a904325309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第六步</strong>，接着我们开放8088端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8088/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开浏览器，访问<code>http://宿主机IP:8088/swagger-ui.html</code>连接，查看<code>shop-jenkins</code>服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c382f1b4ee6fe432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Jenkins+Gitlab一键打包部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker Compose部署SpringBoot应用</title>
    <link href="http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/</id>
    <published>2023-02-24T02:55:30.000Z</published>
    <updated>2023-03-14T06:50:53.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker镜像并运行，但是当我们的应用数量较多时，上述两种方式似乎变得很不友好。</p><p>此时可以使用Docker Compose来解决上述问题，Docker Compose是一个用于定义和运行多个docker容器应用的工具。使用Compose允许开发者使用YAML文件来配置应用服务，之后使用一个命令，就可以部署配置的所有服务。</p><h1 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h1><h3 id="下载Docker-Compose"><a href="#下载Docker-Compose" class="headerlink" title="下载Docker Compose"></a>下载Docker Compose</h3><p>使用如下命令来下载Docker Compose：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="修改下载文件的权限"><a href="#修改下载文件的权限" class="headerlink" title="修改下载文件的权限"></a>修改下载文件的权限</h3><p>将下载文件的权限设置为可执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="确认Docker-Compose安装成功"><a href="#确认Docker-Compose安装成功" class="headerlink" title="确认Docker Compose安装成功"></a>确认Docker Compose安装成功</h3><p>可使用如下命令来确认Docker Compose已经安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>如果输出Docker Compose的版本则说明它已经安装成功了。</p><h1 id="Docker-Compose使用步骤"><a href="#Docker-Compose使用步骤" class="headerlink" title="Docker Compose使用步骤"></a>Docker Compose使用步骤</h1><p>一般来说，Docker Compose的使用分为三个步骤：<br>（1）使用Dockerfile来定义应用的程序环境，注意此步只有在需要修改初始化镜像时，才执行；<br>（2）使用<code>docker-compose.yml</code>文件来定义需要部署的应用程序服务，以便后续可通过执行脚本来一次性部署服务；<br>（3）使用<code>docker-compose up</code>命令一次性将所有应用服务部署起来。</p><h1 id="docker-compose-yml配置文件常用命令"><a href="#docker-compose-yml配置文件常用命令" class="headerlink" title="docker-compose.yml配置文件常用命令"></a>docker-compose.yml配置文件常用命令</h1><p>Docker Compose将所管理的容器分为三层，即工程、服务及容器。<code>docker-compose.yml</code>中定义的所有服务组成了一个工程，services节点下即为服务，服务之下为容器。容器与容器之间可通过以服务名称为域名来进行访问。举个例子，在<code>shop-docker-compose</code>服务中可通过<code>jdbc:mysql://db:3306</code>这个地址来访问db这个mysql服务。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>version用于指定docker-compose的版本号，目前使用值都是3。</p><h3 id="services"><a href="#services" class="headerlink" title="services"></a>services</h3><p>services是一系列服务的集合，该节点下定义具体的服务。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>image用于指定服务所使用的镜像，举个例子如使用的是mysql5.7的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: mysql:5.7</span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>container_name用于设置容器的名称，举个例子如指定容器名称为mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: mysql</span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>ports用于设置宿主机和容器的端口映射，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的3306端口映射到容器的3306端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - 3306:3306</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>volumes用于将宿主机的文件或者目录挂载到容器中，注意格式为<code>（HOST:CONTAINER）</code>，举个例子将宿主机的如下文件挂载到容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">  - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">  - /mydata/mysql/conf:/etc/mysql</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>environment用于设置环境变量，举个例子设置MySQL初始化时root账户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  - MYSQL_ROOT_PASSWORD=envy123</span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><p>links用于连接其他的容器服务，注意格式为<code>（SERVICE:ALIAS）</code>，举个例子以database为域名来访问服务名称为db的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">links:</span><br><span class="line">  - db:database</span><br></pre></td></tr></table></figure><h1 id="Docker-Compose常用命令"><a href="#Docker-Compose常用命令" class="headerlink" title="Docker Compose常用命令"></a>Docker Compose常用命令</h1><h3 id="构建、创建、启动相关容器"><a href="#构建、创建、启动相关容器" class="headerlink" title="构建、创建、启动相关容器"></a>构建、创建、启动相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>其中的<code>-d</code>表示在后台运行。</p><h3 id="指定文件启动"><a href="#指定文件启动" class="headerlink" title="指定文件启动"></a>指定文件启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure><h3 id="停止所有相关容器"><a href="#停止所有相关容器" class="headerlink" title="停止所有相关容器"></a>停止所有相关容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h3 id="列出所有容器信息"><a href="#列出所有容器信息" class="headerlink" title="列出所有容器信息"></a>列出所有容器信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-compose</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-compose</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-compose-0.0.1-SNAPSHOT.jar /shop-docker-compose.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-compose.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-compose.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-compose.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ac5e57969321848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-compose\target\shop-docker-compose-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-compose ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.948 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T16:47:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-compose</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-compose</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-compose:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。</p><h1 id="使用Docker-Compose部署应用"><a href="#使用Docker-Compose部署应用" class="headerlink" title="使用Docker Compose部署应用"></a>使用Docker Compose部署应用</h1><h3 id="编写docker-compose-yml文件"><a href="#编写docker-compose-yml文件" class="headerlink" title="编写docker-compose.yml文件"></a>编写docker-compose.yml文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为<code>docker-compose.yml</code>的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  db:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: mysql</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">    - 3306:3306</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">    - /mydata/mysql/log:/var/log/mysql</span><br><span class="line">    - /mydata/mysql/data:/var/lib/mysql</span><br><span class="line">    - /mydata/mysql/conf:/etc/mysql</span><br><span class="line">    # 指定容器的环境变量</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=envy123</span><br><span class="line">  # 指定服务名称</span><br><span class="line">  shop-docker-compose:</span><br><span class="line">    # 指定服务使用的镜像</span><br><span class="line">    image: myshop-all/shop-docker-compose:0.0.1-SNAPSHOT</span><br><span class="line">    # 指定容器的名称</span><br><span class="line">    container_name: shop-docker-compose</span><br><span class="line">    # 指定服务运行的端口</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    # 指定容器中需要挂载的文件目录</span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime</span><br><span class="line">      - /mydata/app/shop-docker-compose/logs:/var/logs</span><br></pre></td></tr></table></figure><h3 id="运行Docker-Compose命令启动所有服务"><a href="#运行Docker-Compose命令启动所有服务" class="headerlink" title="运行Docker Compose命令启动所有服务"></a>运行Docker Compose命令启动所有服务</h3><p>将上面定义的<code>docker-compose.yml</code>文件上传至<code>/mydata/app/shop-docker-compose</code>目录中，然后在该目录中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看一下服务是否已经启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-compose]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                                           COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">252d6d043a3d   myshop-all/shop-docker-compose:0.0.1-SNAPSHOT   &quot;java -jar /shop-doc…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              shop-docker-compose</span><br><span class="line">3c1f3944c4ca   registry:2                                      &quot;/entrypoint.sh /etc…&quot;   7 hours ago     Up 7 hours     0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp              registry2</span><br><span class="line">1f83ff04b145   mysql:5.7                                       &quot;docker-entrypoint.s…&quot;   25 hours ago    Up 2 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   mysql</span><br></pre></td></tr></table></figure><p>接着我们需要进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p>使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>然后创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p>接着打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到之前的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p>修改root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>接着我们开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>然后打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-compose服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Docker Compose部署SpringBoot应用，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们已经学会了如何通过使用Maven插件或者Dockerfile的方式，来将SpringBoot应用构建为Docker</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-23T10:15:33.000Z</published>
    <updated>2023-03-14T06:49:25.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在部署第一篇中，我们学习了如何使用通过<code>docker-maven-plugin</code>来构建docker镜像，遗憾的是此方式需要依赖自建的Registry镜像仓库，这在实际开发过程中还是有困难的。</p><p>鉴于此，本篇来学习另一种方式，使用Dockerfile来构建docker镜像。注意此方式不需要依赖自建的镜像仓库，只需应用的jar包和一个Dockerfile文件。</p><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Dockerfile为SpringBoot应用构建Docker镜像。</p><h1 id="Dockerfile常用指令"><a href="#Dockerfile常用指令" class="headerlink" title="Dockerfile常用指令"></a>Dockerfile常用指令</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FROM用于指定所需依赖的基础镜像，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像需要依赖java8的镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br></pre></td></tr></table></figure><p>注意FROM命令必须放在Dockerfile文件的第一行。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>MAINTAINER用于指定镜像维护者的名字，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如某个镜像的维护者为kenbings：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER kenbings</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD用于复制文件，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如将当前目录下的<code>shop-docker-file.jar</code>包复制到docker容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD shop-docker-file.jar /shop-docker-file.jar</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT用于指定docker容器启动时执行的命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在启动容器时启动运行jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV用于设置环境变量，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>举个例子，在mysql运行时设置root用户的密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV MYSQL_ROOT_PASSWORD envy123</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>EXPOSE用于声明要暴露的端口（注意只会声明不会打开端口），格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port1&gt; &lt;port2&gt; ...</span><br></pre></td></tr></table></figure><p>举个例子，声明服务运行在8080端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN用于自定义容器在构建过程中需要执行的命令，如安装一些软件、创建一些文件等，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;...]</span><br></pre></td></tr></table></figure><p>举个例子，在容器构建过程中需要在/目录下创建一个名为<code>shop-docker-file.jar</code>的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br></pre></td></tr></table></figure><h1 id="使用Dockerfile构建SpringBoot应用镜像"><a href="#使用Dockerfile构建SpringBoot应用镜像" class="headerlink" title="使用Dockerfile构建SpringBoot应用镜像"></a>使用Dockerfile构建SpringBoot应用镜像</h1><h3 id="复制一个Module"><a href="#复制一个Module" class="headerlink" title="复制一个Module"></a>复制一个Module</h3><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker-file</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker-file</code>这一Module中进行。</p><h3 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h3><p>我们在项目的<code>src/main</code>目录中新建一个名为docker的目录，然后在docker目录中新建一个名为Dockerfile的文件，里面的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定该镜像所依赖的基础镜像</span><br><span class="line">FROM openjdk:8u102</span><br><span class="line"># 指定镜像的维护人</span><br><span class="line">MAINTAINER kenbings</span><br><span class="line"># 将当前目录下的jar包复制到docker容器中的/目录下</span><br><span class="line">ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"># 容器在运行过程中创建一个名为shop-docker-file.jar的文件</span><br><span class="line">RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"># 声明服务暴露在8080端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line"># 指定容器启动时执行的命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br></pre></td></tr></table></figure><h3 id="使用maven打包应用"><a href="#使用maven打包应用" class="headerlink" title="使用maven打包应用"></a>使用maven打包应用</h3><p>接下来我们按照图示操作进行打包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c13081c65ae93a21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Building jar: E:\MyShop\myshop-all\shop-docker-file\target\shop-docker-file-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- spring-boot-maven-plugin:2.1.3.RELEASE:repackage (repackage) @ shop-docker-file ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.759 s</span><br><span class="line">[INFO] Finished at: 2021-12-13T14:59:31+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>接着我们新建<code>/mydata/app/shop-docker-file</code>目录，然后将打包生成的jar包以及Dockerfile文件上传到该目录中。</p><h3 id="在Linux系统上构建Docker镜像"><a href="#在Linux系统上构建Docker镜像" class="headerlink" title="在Linux系统上构建Docker镜像"></a>在Linux系统上构建Docker镜像</h3><p>在<code>/mydata/app/shop-docker-file</code>目录下，执行如下命令来构建docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br></pre></td></tr></table></figure><p>其中<code>-t</code>表示指定镜像仓库名称/镜像名称:镜像标签，<code>.</code>表示使用当前目录下的Dockerfile文件。上述命令执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker build -t myshop-all/shop-docker-file:0.0.1-SNAPSHOT .</span><br><span class="line">Sending build context to Docker daemon   36.5MB</span><br><span class="line">Step 1/6 : FROM openjdk:8u102</span><br><span class="line"> ---&gt; ca5dd051db43</span><br><span class="line">Step 2/6 : MAINTAINER kenbings</span><br><span class="line"> ---&gt; Running in 89102f5205f6</span><br><span class="line">Removing intermediate container 89102f5205f6</span><br><span class="line"> ---&gt; 3a095a2cfe51</span><br><span class="line">Step 3/6 : ADD shop-docker-file-0.0.1-SNAPSHOT.jar /shop-docker-file.jar</span><br><span class="line"> ---&gt; 0429582ab23e</span><br><span class="line">Step 4/6 : RUN bash -c &#x27;touch /shop-docker-file.jar&#x27;</span><br><span class="line"> ---&gt; Running in 3083441e10a6</span><br><span class="line">Removing intermediate container 3083441e10a6</span><br><span class="line"> ---&gt; 10be5dacfb00</span><br><span class="line">Step 5/6 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in 505f2c42fbdf</span><br><span class="line">Removing intermediate container 505f2c42fbdf</span><br><span class="line"> ---&gt; fbab2deea31e</span><br><span class="line">Step 6/6 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/shop-docker-file.jar&quot;]</span><br><span class="line"> ---&gt; Running in bde857feb023</span><br><span class="line">Removing intermediate container bde857feb023</span><br><span class="line"> ---&gt; 7c0df63d8996</span><br><span class="line">Successfully built 7c0df63d8996</span><br><span class="line">Successfully tagged myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p>查看一下该镜像是否确实生成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kenbings shop-docker-file]# docker images|grep &#x27;docker-file&#x27;</span><br><span class="line">myshop-all/shop-docker-file   0.0.1-SNAPSHOT   7c0df63d8996   About a minute ago   714MB</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker-file应用服务"><a href="#启动shop-docker-file应用服务" class="headerlink" title="启动shop-docker-file应用服务"></a>启动shop-docker-file应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker-file/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker-file/logs:/var/logs \</span><br><span class="line">--name shop-docker-file \</span><br><span class="line">-d myshop-all/shop-docker-file:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker-file服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Dockerfile为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在部署第一篇中，我们学习了如何使用通过&lt;code&gt;docker-maven-plugin&lt;/code&gt;来构建docker镜像</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Maven插件为SpringBoot应用构建Docker镜像</title>
    <link href="http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/"/>
    <id>http://envyzhan.asia/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/</id>
    <published>2023-02-20T03:51:30.000Z</published>
    <updated>2023-03-14T06:47:18.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Docker镜像，并上传至私有镜像仓库Docker Registry中。</p><h1 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h1><p>开发者可以使用Docker提供的registry这一镜像来搭建属于自己的私有仓库，这里选择版本为2的镜像即可，先将其下载到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry:2</span><br></pre></td></tr></table></figure><p>这里有它的快速使用方法，其实就是一条命令：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ec61be9dc5bbcc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>执行下面的命令即可创建一个私有仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry2 registry:2</span><br></pre></td></tr></table></figure><h1 id="Docker开启远程API"><a href="#Docker开启远程API" class="headerlink" title="Docker开启远程API"></a>Docker开启远程API</h1><p>打开<code>docker.service</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>将其中的如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock</span><br></pre></td></tr></table></figure><h1 id="让Docker支持http上传镜像"><a href="#让Docker支持http上传镜像" class="headerlink" title="让Docker支持http上传镜像"></a>让Docker支持http上传镜像</h1><p>使用如下命令来让Docker支持http上传镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&#123; &quot;insecure-registries&quot;:[&quot;192.168.51.160:5000&quot;] &#125;&#x27; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>修改完上述配置信息后，接下来需要使用如下命令来让配置生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>接着重启Docker服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>最后开启防火墙的Docker构建端口，使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2375/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h1 id="使用Maven构建Docker镜像"><a href="#使用Maven构建Docker镜像" class="headerlink" title="使用Maven构建Docker镜像"></a>使用Maven构建Docker镜像</h1><p>再次强调，本篇代码是在第二篇《整合Swagger-UI实现在线API文档》的基础上进行修改的。</p><p>开发者可以复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-docker</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-docker</code>这一Module中进行。</p><p><strong>第一步</strong>，在POM文件中新增<code>docker-maven-plugin</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.22.1&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;/skipTests&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;myshop-all/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt;</span><br><span class="line">                &lt;dockerHost&gt;http://192.168.51.160:2375&lt;/dockerHost&gt;</span><br><span class="line">                &lt;baseImage&gt;openjdk:8u102&lt;/baseImage&gt;</span><br><span class="line">                &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]</span><br><span class="line">                &lt;/entryPoint&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                    &lt;/resource&gt;</span><br><span class="line">                &lt;/resources&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>解释一下上述配置信息：<br>（1）<code>executions.execution.phase</code>表示配置在maven打包应用时构建docker镜像；<br>（2）<code>imageName</code>用于指定镜像名称，其中<code>myshop-all</code>是仓库名称，<code>$&#123;project.artifactId&#125;</code>是镜像名称，<code>$&#123;project.version&#125;</code>是仓库名称；<br>（3）<code>dockerHost</code>表示设置镜像打包后上传的docker服务器地址；<br>（4）<code>baseImage</code>表示该应用所依赖的基础镜像，此处为openjdk:8u102；<br>（5）<code>entryPoint</code>表示设置docker容器启动时执行的命令；<br>（6）<code>resources.resource.targetPath</code>表示将打包后的资源文件复制到该目录；<br>（7）<code>resources.resource.directory</code>表示待复制的文件所在的目录，注意Maven打包的应用jar包会保存在target目录下；<br>（8）<code>resources.resource.includ</code>表示需要复制的文件，即打包好的应用的jar包。</p><p><strong>第二步</strong>，修改<code>application.yml</code>配置文件，将其中的localhost修改为db：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://db:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p>实际上，我们可以将docker中的容器看做独立的虚拟机，这样<code>shop-docker</code>访问localhost时就不会访问到mysql，但是容器之间可通过指定服务名称来进行访问，如db，注意db这个名称需要在运行<code>shop-docker</code>容器时进行指定。</p><p><strong>第三步</strong>，使用IDEA打包项目并构建镜像，请注意依赖的基础镜像需要先下载到本地，否则会出现镜像构建超时的情况。接着执行maven的package命令来构建镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7fba034b80d2f8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到镜像构建成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c1f6abe0bac76a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时查看一下宿主机，可以看到宿主机上显示已经存在了该镜像：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b76dce1634120500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="运行shop-docker服务"><a href="#运行shop-docker服务" class="headerlink" title="运行shop-docker服务"></a>运行shop-docker服务</h1><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p><strong>第一步</strong>，下载MySQL5.7的docker镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/mysql/log</span><br><span class="line">mkdir -p /mydata/mysql/data</span><br><span class="line">mkdir -p /mydata/mysql/conf</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，启动MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=envy123 \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p>简单解释一下参数含义：<br>（1）<code>-p 3306:3306</code>，表示将容器的3306端口映射到宿主机的3306端口，注意格式为“宿主机端口:容器端口”；<br>（2）<code>-v /mydata/mysql/log:/var/log/mysql</code>，表示将容器的日志文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（3）<code>-v /mydata/mysql/data:/var/lib/mysql</code>，表示将容器的数据文件夹挂载到宿主机，注意格式为“宿主机:容器；<br>（4）<code>-e MYSQL_ROOT_PASSWORD=envy123</code>，表示初始化容器中root用户的密码。</p><p><strong>第四步</strong>，进入到运行MySQL服务的docker容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，使用MySQL命令进入客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -penvy123 --default-character-set=utf8</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，创建shop数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shop character set utf8;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，打开一个新的终端，安装上传下载插件，将<code>shop.sql</code>文件上传到Linux服务器上，可指定目录为<code>/mydata</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz</span><br></pre></td></tr></table></figure><p>然后将<code>shop.sql</code>文件拷贝到mysql容器的<code>/</code>目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mydata/shop.sql mysql:/</span><br></pre></td></tr></table></figure><p>接着进入到<strong>第六步</strong>中的sql命令环境，将shop文件导入到数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use shop;</span><br><span class="line">source /shop.sql;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，root的账号的权限，使得任何ip都能访问到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>这样就完成了MySQL的启动服务。</p><h3 id="启动shop-docker应用服务"><a href="#启动shop-docker应用服务" class="headerlink" title="启动shop-docker应用服务"></a>启动shop-docker应用服务</h3><p><strong>第一步</strong>，创建对应目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/app/shop-docker/logs</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，使用如下命令来启动该服务，注意这里我们需要使用<code>--link</code>参数来让应用使用db域名来访问MySQL服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --link mysql:db \</span><br><span class="line">-v /etc/localtime:/etc/localtime \</span><br><span class="line">-v /mydata/app/shop-docker/logs:/var/logs \</span><br><span class="line">--name shop-docker \</span><br><span class="line">-d myshop-all/shop-docker:0.0.1-SNAPSHOT</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，开放8080端口（注意只有当防火墙是运行状态下才需要进行此操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://宿主机IP:8080/swagger-ui.html</code>连接，查看shop-docker服务是否已经正常启动：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa1d43f4709beb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们测试一下“获取所有的品牌信息”的接口，可以看到数据是可以正常返回的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ccba65288420c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ea6b1cffc43b619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就完成了使用Maven插件为SpringBoot应用构建Docker镜像，并运行项目这一功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇在第二篇《整合Swagger-UI实现在线API文档》的基础上，使用Maven插件为SpringBoot应用构建Dock</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合RabbitMQ实现延迟消息</title>
    <link href="http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/"/>
    <id>http://envyzhan.asia/2023/02/16/2023-8-integrate-rabbitmq-to-realize-delayed-messages/</id>
    <published>2023-02-16T02:51:12.000Z</published>
    <updated>2023-03-14T06:45:40.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。</p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="AMQP简介"><a href="#AMQP简介" class="headerlink" title="AMQP简介"></a>AMQP简介</h3><p>AMQP (Advanced Message Queuing Protocol ，高级消息队列协议）是一个线路层的协议规范，而不是API 规范（例如JMS）。由于AMQP 是一个线路层协议规范，因此它天然就是跨平台的，就像SMTP、HTTP等协议一样，只要开发者按照规范的格式发送数据，任何平台都可以通过AMQP进行消息交互。像目前流行的StormMQ、RabbitMQ等都实现了AMQP协议。</p><h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ是一个实现了AMQP的开源消息中间件，使用高性能的Erlang编写。RabbitMQ具有可靠性、支持多种协议、高可用、支持消息集群以及多语言客户端等特点，在分布式系统中存储转发消息，具有不错的性能表现。</p><h3 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h3><p><strong>第一步</strong>，安装Erlang，可点击 <a href="http://erlang.org/download/otp_win64_23.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第二步</strong>，安装RabbitMQ，可点击 <a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.8.0/rabbitmq-server-3.8.0.exe">这里</a> 进行下载，然后进行安装。</p><p><strong>第三步</strong>，以管理员身份打开终端，并切换到RabbitMQ安装目录下的sbin目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3691d4f14d85cd00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后执行如下命令来开启管理功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，打开浏览器，访问<code>http://localhost:15672/</code>链接：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-962d2a01534f8f3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第五步</strong>，输出账号和密码:guest和guest，然后登陆，点击右上角的Admin，创建用户名为kenbings和kenbings的用户，并设置角色为管理员：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-df8a5c4ccc8aecb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着创建一个名为<code>/shop</code>的虚拟host：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08ecd99c955f189d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后点击shop用户，进入到用户配置界面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-95d88b8d9ed02629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dc312644d1676024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样RabbitMQ的安装和配置就完成了，下面开始学习AMQP协议。</p><h1 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h1><p>AMQP协议作为RabbitMQ的规范，规定了RabbitMQ对外接口，同时学会了AMQP协议的使用，就基本掌握了RabbitMQ的使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae628aa7ee00312c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ就是Message Broker；<br><strong>Virtual Host</strong>：虚拟Broker，用于将多个单元隔离开；<br><strong>Connection</strong>：publisher/consumer和broker之间的TCP连接；<br><strong>Channel</strong>：connection内部建立的逻辑连接，通常每个线程创建单独的channel；<br><strong>Routing Key</strong>：路由键，用于指示消息的路由转发，相当于快递的地址；<br><strong>Exchange</strong>：交换机，相当于快递的分拨中心；<br><strong>Queue</strong>：消息队列，消息最终被送到这里等待consumer取走；<br><strong>Binding Key</strong>：exchange和queue之间的虚拟连接，用于message的分发依据。</p><h1 id="Exchange的作用"><a href="#Exchange的作用" class="headerlink" title="Exchange的作用"></a>Exchange的作用</h1><p>在AMQP协议或者是RabbitMQ实现中，最核心的组件是Exchange，Exchange承担RabbitMQ中的核心功能，即路由转发。Exchange有多个种类，配置多变，需要深度分析。</p><p>Exchange的功能是根据绑定关系和路由键为消息提供路由，将消息转发至相应的队列。</p><p>Exchange有4种类型，Direct、Topic、Fanout和Headers，其中Headers使用较少，以前三种为主。</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2f35828e0212b741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h1><p>本篇要实现的延迟消息，是用户在下单之后，超过一定时间如30分钟，之后自动取消订单这一业务场景。可能的业务步骤如下：<br>（1）用户进行下单操作（会存在锁定商品库存、使用优惠券、积分、红包等操作）；<br>（2）生成订单信息，并获取订单id；<br>（3）根据订单id获取到设置的订单超时时间（假设设置30分钟内不支付取消订单）；<br>（4）按照订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；<br>（5）如果用户没有支付，那么就执行取消订单的操作（释放商品库存、优惠券、积分、红包等操作）。</p><h1 id="整合RabbitMQ实现延迟消息"><a href="#整合RabbitMQ实现延迟消息" class="headerlink" title="整合RabbitMQ实现延迟消息"></a>整合RabbitMQ实现延迟消息</h1><p><strong>第一步</strong>，复制一份<code>shop-mongodb</code>源码，将其名字修改为<code>shop-rabbitmq</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-rabbitmq</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-rabbitmq</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--消息队列相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在spring节点下添加RabbitMQ相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  # RabbitMQ相关    </span><br><span class="line">rabbitmq:</span><br><span class="line">  host: localhost # rabbitmq的连接地址</span><br><span class="line">  port: 5672 # rabbitmq的连接端口号</span><br><span class="line">  virtual-host: /shop # rabbitmq的虚拟host</span><br><span class="line">  username: kenbings # rabbitmq的用户名</span><br><span class="line">  password: kenbings # rabbitmq的密码</span><br><span class="line">  publisher-confirms: true #如果对异步消息需要回调必须设置为true</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shoprabbitmq</code>包内定义一个名为enums的包，接着在enums包内定义一个名为<code>QueueEnum</code>的枚举类，注意这是消息队列的枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列枚举类</span><br><span class="line"> */</span><br><span class="line">@Getter</span><br><span class="line">public enum QueueEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单取消通知队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_ORDER_CANCEL(&quot;shop.order.direct.exchange&quot;,&quot;shop.order.cancel.queue&quot;,&quot;shop.order.cancel.key&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息通知TTL队列</span><br><span class="line">     */</span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(&quot;shop.order.direct.ttl.exchange&quot;,&quot;shop.order.cancel.ttl.queue&quot;,&quot;shop.order.cancel.ttl.key&quot;);</span><br><span class="line">    /**</span><br><span class="line">     * 交换机</span><br><span class="line">     */</span><br><span class="line">    private String exchange;</span><br><span class="line">    /**</span><br><span class="line">     * 队列名称</span><br><span class="line">     */</span><br><span class="line">    private String queue;</span><br><span class="line">    /**</span><br><span class="line">     * 路由键</span><br><span class="line">     */</span><br><span class="line">    private String routingKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String queue, String routingKey)&#123;</span><br><span class="line">        this.exchange = exchange;</span><br><span class="line">        this.queue = queue;</span><br><span class="line">        this.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在config包内定义一个名为<code>RabbitMQConfig</code>的配置类，注意这是消息队列的配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息队列配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟队列所绑定的交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange orderTTLDirectExchange()&#123;</span><br><span class="line">        return (DirectExchange) ExchangeBuilder.directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange()).durable(true).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单消息实际消费队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderQueue()&#123;</span><br><span class="line">        return new Queue(QueueEnum.QUEUE_ORDER_CANCEL.getQueue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订单延迟消息队列（死信队列）</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue orderTTLQueue()&#123;</span><br><span class="line">        return QueueBuilder.durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getQueue())</span><br><span class="line">                .withArgument(&quot;x-dead-letter-exchange&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getExchange()) //消息过期后转到的交换机</span><br><span class="line">        .withArgument(&quot;x-dead-letter-routing-key&quot;, QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey()) //消息过期后转发的路由键</span><br><span class="line">        .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将正常订单队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderBinding(DirectExchange orderDirectExchange,Queue orderQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderQueue).to(orderDirectExchange).with(QueueEnum.QUEUE_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将订单延迟队列绑定到交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding orderTTLBinding(DirectExchange orderTTLDirectExchange,Queue orderTTLQueue)&#123;</span><br><span class="line">        return BindingBuilder.bind(orderTTLQueue).to(orderTTLDirectExchange).with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们尝试启动一下项目入口类，然后查看一下RabbitMQ的浏览器控制台，然后查看Exchange：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8239e340336e0883.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着再来查看一下队列：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cadff6c72def3c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>shop.order.direct.exchange</code>（取消订单消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.queue</code>，这样如果有消息以<code>shop.order.cancel.key</code>为路由键发送过来，就会发送到此队列中。</p><p><code>shop.order.direct.ttl.exchange</code>（订单延迟消息队列所绑定的交换机），它所绑定的队列为<code>shop.order.cancel.ttl.queue</code>，这样如果有消息以<code>shop.order.cancel.ttl.key</code>为路由键发送过来，就会发送到此队列中，并在此队列中保存一段时间，等到超时时间到，后自动将消息发送到<code>shop.order.cancel.queue</code>（取消订单消息队列）中。</p><p><strong>第六步</strong>，在component包内定义一个名为<code>CancelOrderSender</code>的类，该类用于往订单延迟队列(订单消息通知TTL队列，<code>shop.order.cancel.ttl.queue</code>)中发送消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 往订单延迟队列(订单消息通知TTL队列，`shop.order.cancel.ttl.queue`)中发送消息</span><br><span class="line"> * 取消订单消息的发出者</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CancelOrderSender &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderSender.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给延迟队列发送消息</span><br><span class="line">     * @param orderId 订单号</span><br><span class="line">     * @param delayTime 延迟时间（毫秒）</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(Long orderId,long delayTime)&#123;</span><br><span class="line">        String exchange = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange();</span><br><span class="line">        String routingKey = QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRoutingKey();</span><br><span class="line">        amqpTemplate.convertAndSend(exchange, routingKey, orderId, new MessagePostProcessor() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Message postProcessMessage(Message message) throws AmqpException &#123;</span><br><span class="line">                        //给消息设置延迟时间，单位毫秒</span><br><span class="line">                        message.getMessageProperties().setExpiration(String.valueOf(delayTime));</span><br><span class="line">                        return message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        LOGGER.info(&quot;发送延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在component包内定义一个名为<code>CancelOrderReceiver</code>的类，该类用于从订单取消通知队列(<code>shop.order.cancel.queue</code>)中拉取消息并消费：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理取消订单消息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;shop.order.cancel.queue&quot;)</span><br><span class="line">public class CancelOrderReceiver &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(CancelOrderReceiver.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void handle(Long orderId)&#123;</span><br><span class="line">        LOGGER.info(&quot;收到延迟消息，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在service包内定义一个名为<code>OmsPortalOrderService</code>的接口，用于定义与前台订单管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface OmsPortalOrderService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据提交信息生成订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    CommonResult generateOrder(OrderParam orderParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取消单个超时订单</span><br><span class="line">     */</span><br><span class="line">    @Transactional</span><br><span class="line">    void cancelOrder(Long orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在dto包内定义一个名为<code>OrderParam</code>的类，这是生成订单时需传入的参数对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成订单时需传入的参数</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class OrderParam &#123;</span><br><span class="line">    //收货地址id</span><br><span class="line">    private Long memberReceiveAddressId;</span><br><span class="line">    //优惠券id</span><br><span class="line">    private Long couponId;</span><br><span class="line">    //使用的积分数</span><br><span class="line">    private Integer useIntegration;</span><br><span class="line">    //支付方式</span><br><span class="line">    private Integer payType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在impl包内定义一个名为<code>OmsPortalOrderServiceImpl</code>的类，这个类需要实现<code>OmsPortalOrderService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理 Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class OmsPortalOrderServiceImpl implements OmsPortalOrderService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(OmsPortalOrderService.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CancelOrderSender cancelOrderSender;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateOrder(OrderParam orderParam) &#123;</span><br><span class="line">        //TODO 一系列下单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始生成订单&quot;);</span><br><span class="line">        //下单完成后发送一个延迟消息，用于实现当用户没有付款时取消订单这一功能，注意orderId应该在下单后生成</span><br><span class="line">        Long orderId = 516516161616L;</span><br><span class="line">        sendDelayMessageCancelOrder(orderId);</span><br><span class="line">        return CommonResult.success(&quot;下单成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cancelOrder(Long orderId) &#123;</span><br><span class="line">        //TODO 一系列取消订单操作，这些逻辑可参考完整项目</span><br><span class="line">        LOGGER.info(&quot;开始取消订单，订单号为：&#123;&#125;&quot;,orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void sendDelayMessageCancelOrder(Long orderId) &#123;</span><br><span class="line">        //获取订单超时时间，假设为30秒</span><br><span class="line">        long delayTimes = 30 * 1000;</span><br><span class="line">        //发送延迟消息</span><br><span class="line">        cancelOrderSender.sendMessage(orderId, delayTimes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在controller包内定义一个名为<code>OmsPortalOrderController</code>的类，这是前台订单管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 前台订单管理的Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;OmsPortalOrderController&quot;,description = &quot;订单管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/order&quot;)</span><br><span class="line">public class OmsPortalOrderController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private OmsPortalOrderService omsPortalOrderService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;根据购物车信息生成订单&quot;)</span><br><span class="line">    @PostMapping(&quot;/generateOrder&quot;)</span><br><span class="line">    public Object generateOrder(@RequestBody OrderParam orderParam) &#123;</span><br><span class="line">        return omsPortalOrderService.generateOrder(orderParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa310e78ea1ddc34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，进行接口测试。首先后台用户进行登录，接着测试“下单接口”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8040f8eadc87c2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后回到IDEA控制台，可以看到输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:05:40.460  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.service.OmsPortalOrderService    : 开始生成订单</span><br><span class="line">2021-12-09 18:05:40.464  INFO 14628 --- [nio-8080-exec-1] c.k.s.s.component.CancelOrderSender      : 发送延迟消息，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>之后等待30秒钟，IDEA控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-12-09 18:06:10.494  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.component.CancelOrderReceiver    : 收到延迟消息，订单号为：516516161616</span><br><span class="line">2021-12-09 18:06:10.495  INFO 14628 --- [cTaskExecutor-1] c.k.s.s.service.OmsPortalOrderService    : 开始取消订单，订单号为：516516161616</span><br></pre></td></tr></table></figure><p>可以看到时间间隔就是30秒，这也说明该订单下单30秒后未支付便被自动取消了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第七篇《整合MongoDB实现用户商品浏览记录》的基础上整合RabbitMQ，实现延迟消息这一功能。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合MongoDB实现用户商品浏览记录</title>
    <link href="http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/"/>
    <id>http://envyzhan.asia/2023/02/13/2023-7-integrate-mongodb-to-realize-user&#39;s-product-browsing-record/</id>
    <published>2023-02-13T11:15:10.000Z</published>
    <updated>2023-03-14T06:43:15.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h3 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h3><p>MongoDB是一个为快速开发互联网Web应用而构建的数据库系统，其数据模型和持久化策略就是为了构建高读/写吞吐量和高自动灾备伸缩性的系统。</p><h3 id="安装MongoDB服务"><a href="#安装MongoDB服务" class="headerlink" title="安装MongoDB服务"></a>安装MongoDB服务</h3><p>第一步，点击 <a href="https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-3.2.21-signed.msi">这里</a> 下载MongoDB的安装包；</p><p>第二步，自定义MongoDB的安装路径：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ff90ac35c7ba41d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第三步，在MongoDB安装路径下创建<code>data\db</code>和<code>data\log</code>这两个文件夹：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-357fca313358d035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第四步，在MongoDB安装路径下创建<code>mongod.cfg</code>配置文件，里面的配置信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: E:\Application\MongoDB\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: E:\Application\MongoDB\data\db</span><br></pre></td></tr></table></figure><p>第五步，进入到MongoDB安装路径下的bin目录，里面有两个exe文件，分别是客户端和服务端运行程序：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-60c5c82bf617341e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后以管理员身份打开终端，并切换到bin目录下，执行如下命令来给系统安装MongoDB服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Application\MongoDB\bin\mongod.exe --config &quot;E:\Application\MongoDB\mongod.cfg&quot; --install</span><br></pre></td></tr></table></figure><p>第六步，一些与MongoDB服务管理相关的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动服务：net start MongoDB</span><br><span class="line">关闭服务：net stop MongoDB</span><br><span class="line">移除服务：E:\Application\MongoDB\bin\mongod.exe --remove</span><br></pre></td></tr></table></figure><p>使用上述命令来启动MongoDB服务。</p><h3 id="安装MongoDB客户端"><a href="#安装MongoDB客户端" class="headerlink" title="安装MongoDB客户端"></a>安装MongoDB客户端</h3><p>第一步，点击 <a href="https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip">这里</a> 下载MongoDB客户端的安装包；</p><p>第二步，将其解压到指定目录，并打开名为<code>robo3t.exe</code>的软件，然后连接到<code>localhost:27017</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-221869c039f544c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>Spring Data MongoDB是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-MongoDB常用注解"><a href="#Spring-Data-MongoDB常用注解" class="headerlink" title="Spring Data MongoDB常用注解"></a>Spring Data MongoDB常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到MongoDB文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    @AliasFor(&quot;collection&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String collection() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String language() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到MongoDB文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h3><p><code>@Indexed</code>注解添加到映射到MongoDB文档上的领域对象的某个字段上，用于标识该字段为MongoDB的索引字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.ANNOTATION_TYPE, ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Indexed &#123;</span><br><span class="line">    boolean unique() default false;</span><br><span class="line"></span><br><span class="line">    IndexDirection direction() default IndexDirection.ASCENDING;</span><br><span class="line"></span><br><span class="line">    boolean sparse() default false;</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    boolean dropDups() default false;</span><br><span class="line"></span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useGeneratedName() default false;</span><br><span class="line"></span><br><span class="line">    boolean background() default false;</span><br><span class="line"></span><br><span class="line">    int expireAfterSeconds() default -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承MongoRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface MongoRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findAll(Sort var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; S insert(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; insert(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2ff1fae57d08f8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，根据会员id按照时间倒序获取会员的浏览记录，直接在接口中定义如下方法即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-269ef8c63a11e00f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用MongoDB的JSON语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123; &#x27;memberId&#x27; : ?0 &#125;&quot;)</span><br><span class="line">List&lt;MemberReadHistory&gt; findByMemberId(Long memberId);</span><br></pre></td></tr></table></figure><h1 id="整合MongoDB实现用户商品浏览记录"><a href="#整合MongoDB实现用户商品浏览记录" class="headerlink" title="整合MongoDB实现用户商品浏览记录"></a>整合MongoDB实现用户商品浏览记录</h1><p><strong>第一步</strong>，复制一份<code>shop-elasticsearch</code>源码，将其名字修改为<code>shop-mongodb</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-mongodb</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。关于如何使用IDEA复制module，可以点击 <a href="https://www.jianshu.com/p/8d1f1785f6ea">这里</a> 进行阅读。</p><p><strong>第二步</strong>，在<code>shop-mongodb</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!---MongoDB相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往<code>application.yml</code>配置文件中在<code>spring.data</code>节点下添加MongoDB相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># MongoDB相关</span><br><span class="line">data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: localhost # mongodb的连接地址</span><br><span class="line">      port: 27017 # mongodb的连接端口号</span><br><span class="line">      database: shop-port # mongodb的连接的数据库</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在nosql包内定义一个名为mongodb的包，接着在mongodb包内定义一个名为document的包。然后在document包内定义一个名为<code>MemberReadHistory</code>的类，注意这是会员浏览记录文档对象。然后文档对象的ID域使用<code>@Id</code>注解，需要检索的字段添加<code>@Indexed</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户商品浏览历史记录文档对象</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document</span><br><span class="line">public class MemberReadHistory &#123;</span><br><span class="line">    @Id</span><br><span class="line">    private String id;</span><br><span class="line">    /**</span><br><span class="line">     * 用户id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long memberId;</span><br><span class="line">    /**</span><br><span class="line">     * 用户昵称</span><br><span class="line">     */</span><br><span class="line">    private String memberNickname;</span><br><span class="line">    /**</span><br><span class="line">     * 用户头像</span><br><span class="line">     */</span><br><span class="line">    private String memberIcon;</span><br><span class="line">    /**</span><br><span class="line">     * 商品id</span><br><span class="line">     */</span><br><span class="line">    @Indexed</span><br><span class="line">    private Long productId;</span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    private String productName;</span><br><span class="line">    /**</span><br><span class="line">     * 商品图片</span><br><span class="line">     */</span><br><span class="line">    private String productPic;</span><br><span class="line">    /**</span><br><span class="line">     * 商品副标题</span><br><span class="line">     */</span><br><span class="line">    private String productSubTitle;</span><br><span class="line">    /**</span><br><span class="line">     * 商品价格</span><br><span class="line">     */</span><br><span class="line">    private String productPrice;</span><br><span class="line">    /**</span><br><span class="line">     * 浏览时间</span><br><span class="line">     */</span><br><span class="line">    private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，<br>在mongodb包内新建一个名为repository的包，并在该包内定义一个名为<code>MemberReadHistoryRepository</code>的接口，注意这个接口需要继承<code>MongoRepository</code>接口，这样就拥有了一些基本的操作MongoDB数据的方法，同时我们在里面定义了一个衍生的根据用户(会员)id按照时间倒序获取商品浏览历史记录的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录Repository</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryRepository extends MongoRepository&lt;MemberReadHistory,String&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据会员id按照时间倒序获取商品浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     * @return 商品浏览历史记录</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; findByMemberIdOrderByCreateTimeDesc(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在service包内定义一个名为<code>MemberReadHistoryService</code>的接口，用于定义与会员浏览商品历史记录管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理 Service</span><br><span class="line"> */</span><br><span class="line">public interface MemberReadHistoryService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 生成浏览历史记录</span><br><span class="line">     * @param memberReadHistory 浏览历史记录信息</span><br><span class="line">     */</span><br><span class="line">    int create(MemberReadHistory memberReadHistory);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量删除浏览历史记录</span><br><span class="line">     * @param ids 浏览历史记录id</span><br><span class="line">     */</span><br><span class="line">    int delete(List&lt;String&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定会员的浏览历史记录</span><br><span class="line">     * @param memberId 会员id</span><br><span class="line">     */</span><br><span class="line">    List&lt;MemberReadHistory&gt; list(Long memberId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为<code>MemberReadHistoryServiceImpl</code>的类，这个类需要实现<code>MemberReadHistoryService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员浏览商品历史记录管理Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class MemberReadHistoryServiceImpl implements MemberReadHistoryService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryRepository memberReadHistoryRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int create(MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        memberReadHistory.setId(null);</span><br><span class="line">        memberReadHistory.setCreateTime(new Date());</span><br><span class="line">        memberReadHistoryRepository.save(memberReadHistory);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(List&lt;String&gt; ids) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; deleteMemberReadHistoryLists = new ArrayList&lt;&gt;();</span><br><span class="line">        for(String id:ids)&#123;</span><br><span class="line">            MemberReadHistory memberReadHistory = new MemberReadHistory();</span><br><span class="line">            memberReadHistory.setId(id);</span><br><span class="line">            deleteMemberReadHistoryLists.add(memberReadHistory);</span><br><span class="line">        &#125;</span><br><span class="line">        memberReadHistoryRepository.deleteAll(deleteMemberReadHistoryLists);</span><br><span class="line">        return deleteMemberReadHistoryLists.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;MemberReadHistory&gt; list(Long memberId) &#123;</span><br><span class="line">        return memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为<code>MemberReadHistoryController</code>的类，这是会员商品浏览历史记录管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员商品浏览历史记录管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;MemberReadHistoryController&quot;,description = &quot;会员商品浏览历史记录管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/member/readHistory&quot;)</span><br><span class="line">public class MemberReadHistoryController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MemberReadHistoryService memberReadHistoryService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;创建浏览记录&quot;)</span><br><span class="line">    @PostMapping( &quot;/create&quot;)</span><br><span class="line">    public CommonResult create(@RequestBody MemberReadHistory memberReadHistory) &#123;</span><br><span class="line">        int count = memberReadHistoryService.create(memberReadHistory);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;删除浏览记录&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete&quot;)</span><br><span class="line">    public CommonResult delete(@RequestParam(&quot;ids&quot;) List&lt;String&gt; ids) &#123;</span><br><span class="line">        int count = memberReadHistoryService.delete(ids);</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return CommonResult.success(count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;展示浏览记录&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;MemberReadHistory&gt;&gt; list(@RequestParam(value = &quot;memberId&quot;)@ApiParam(&quot;会员id&quot;) Long memberId) &#123;</span><br><span class="line">        List&lt;MemberReadHistory&gt; memberReadHistoryList = memberReadHistoryService.list(memberId);</span><br><span class="line">        return CommonResult.success(memberReadHistoryList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dd8a052925639de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十步</strong>，进行接口测试。首先后台用户进行登录，接着测试“创建浏览记录”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e6f92e5435b42a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以更改memberId来创建两条测试数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ee8bb3da8a9c429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着测试一下查看某会员商品浏览历史记录接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cf379c721ab83d3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cfa677df390fa9b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合MongoDB实现用户商品浏览记录的学习就完成了，后续介绍如何整合RabbitMQ实现延迟消息这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-mongodb">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第六篇《使用ElasticSearch实现商品复杂搜索》的基础上整合MongoDB，实现用户商品浏览记录这一功能。&lt;</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用ElasticSearch实现商品复杂搜索</title>
    <link href="http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/"/>
    <id>http://envyzhan.asia/2023/02/12/2023-6-use-elasticsearch-to-realize-complex-product-search/</id>
    <published>2023-02-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:41:37.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能。</p><h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><p>由于商品搜索涉及到中文搜索，因此ElasticSearch需要安装分词器才可以支持。前面我们安装的分词器是IKAnalyzer，接下来简单学习如何使用它。</p><h3 id="默认分词器"><a href="#默认分词器" class="headerlink" title="默认分词器"></a>默认分词器</h3><p>使用默认分词器，只是将中文逐字进行分割，并不符合我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ae1a50cce244e752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="中文分词器-1"><a href="#中文分词器-1" class="headerlink" title="中文分词器"></a>中文分词器</h3><p>使用中文分词器后，可以将中文文本按照语境进行分隔，可以满足我们的要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;华为手机使用较为丝滑&quot;,</span><br><span class="line">  &quot;tokenizer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bdeab3b6591aa428.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其实在前一文中，我们就在EsProduct中，对于需要进行中文分词的字段，都使用了<code>@Field</code>注解且将analyzer属性设置为<code>ik_max_word</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品名称</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 副标题</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String subTitle;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关键字</span><br><span class="line"> */</span><br><span class="line">@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">private String keywords;</span><br></pre></td></tr></table></figure><h1 id="商品简单搜索"><a href="#商品简单搜索" class="headerlink" title="商品简单搜索"></a>商品简单搜索</h1><p>商品简单搜索即通过商品名称、副标题或者关键字来搜索包含指定关键字的商品。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现"><a href="#使用Query-DSL来调用ES的Restful-API来实现" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 5,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;小米&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92e8865c96648ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Elasticsearch-Repository的衍生查询"><a href="#Elasticsearch-Repository的衍生查询" class="headerlink" title="Elasticsearch Repository的衍生查询"></a>Elasticsearch Repository的衍生查询</h1><p>Elasticsearch Repository的衍生查询原理其实很简单，就是将一定规则名称的方法转化为Elasticsearch的Query DSL语句，可以查看如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8cb04a107ff6d6ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="复杂商品搜索"><a href="#复杂商品搜索" class="headerlink" title="复杂商品搜索"></a>复杂商品搜索</h1><p>复杂商品搜索会涉及到过滤、不同字段匹配权重以及排序等功能。</p><p>这里的需求是按照输入的关键字来搜索商品名称、副标题和关键字，可以按照品牌和分类进行筛选，可以有5种排序方式，默认按相关度进行排序。查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8984cbb5ee895f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里有一些比较特殊的需求，如商品名称匹配关键字的商品，我们认为与搜索条件更匹配，其次是副标题和关键字，此时就需要使用到<code>function_score</code>查询。</p><p>在ElasticSearch中，搜索到文档的相关性由<code>_score</code>字段来表示，文档的<code>_score</code>字段值越高，表示与搜索条件越匹配。而<code>function_score</code>查询可通过设置权重来影响<code>_score</code>字段值，因此使用<code>function_score</code>查询就可以很好的满足我们的需求。</p><p>这里我们设置商品名称权重为10，商品副标题权重为5，商品关键字权重为2。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-1"><a href="#使用Query-DSL来调用ES的Restful-API来实现-1" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;&quot;match_all&quot;: &#123;&#125;&#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must&quot; :[</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;brandId&quot;: 6</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;productCategoryId&quot;: 19</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 10</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;小米&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_score&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-508e99c72af4b0c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-1" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到EsProductService接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据关键字搜索名称、副标题或者关键字复合查询</span><br><span class="line"> * @param keyword 关键字</span><br><span class="line"> * @param brandId 品牌id</span><br><span class="line"> * @param productCategoryId 商品类别id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @param sort 排序字段</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; search(String keyword,Long brandId,Long productCategoryId,Integer pageNum, Integer pageSize,Integer sort);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个search方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; search(String keyword, Long brandId, Long productCategoryId, Integer pageNum, Integer pageSize, Integer sort) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    NativeSearchQueryBuilder nativeSearchQueryBuilder = new NativeSearchQueryBuilder();</span><br><span class="line">    //分页</span><br><span class="line">    nativeSearchQueryBuilder.withPageable(pageable);</span><br><span class="line">    //过滤</span><br><span class="line">    if(brandId != null || productCategoryId != null)&#123;</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">        if(brandId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;brandId&quot;,brandId));</span><br><span class="line">        &#125;</span><br><span class="line">        if(productCategoryId != null)&#123;</span><br><span class="line">            boolQueryBuilder.must(QueryBuilders.termQuery(&quot;productCategoryId&quot;,productCategoryId));</span><br><span class="line">        &#125;</span><br><span class="line">        nativeSearchQueryBuilder.withFilter(boolQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //搜索</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(10)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        nativeSearchQueryBuilder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    //排序</span><br><span class="line">    if(sort == 1)&#123;</span><br><span class="line">        //按新品从新到旧</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;id&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 2)&#123;</span><br><span class="line">        //按销量从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;sale&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else if(sort == 3)&#123;</span><br><span class="line">        //按价格从低到高</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.ASC));</span><br><span class="line">    &#125;else if(sort == 4)&#123;</span><br><span class="line">        //按价格从高到低</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.fieldSort(&quot;price&quot;).order(SortOrder.DESC));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //按相关度</span><br><span class="line">        nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    &#125;</span><br><span class="line">    //不传则默认按照相关度由高到低排</span><br><span class="line">    nativeSearchQueryBuilder.withSort(SortBuilders.scoreSort().order(SortOrder.DESC));</span><br><span class="line">    NativeSearchQuery searchQuery = nativeSearchQueryBuilder.build();</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">    return esProductRepository.search(searchQuery);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为search的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;综合搜索、筛选、排序&quot;)</span><br><span class="line">@ApiImplicitParam(name = &quot;sort&quot;, value = &quot;排序字段:0-&gt;按相关度；1-&gt;按新品；2-&gt;按销量；3-&gt;价格从低到高；4-&gt;价格从高到低&quot;,</span><br><span class="line">        defaultValue = &quot;0&quot;, allowableValues = &quot;0,1,2,3,4&quot;, paramType = &quot;query&quot;, dataType = &quot;integer&quot;)</span><br><span class="line">@GetMapping(&quot;/search&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;品牌id&quot;) Long brandId,</span><br><span class="line">                                                  @RequestParam(required = false) @ApiParam(&quot;商品类别id&quot;) Long productCategoryId,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize,</span><br><span class="line">                                                  @RequestParam(required = false, defaultValue = &quot;0&quot;) @ApiParam(&quot;排序字段&quot;)Integer sort) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword,brandId,productCategoryId,pageNum, pageSize,sort);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关商品推荐（猜你喜欢）"><a href="#相关商品推荐（猜你喜欢）" class="headerlink" title="相关商品推荐（猜你喜欢）"></a>相关商品推荐（猜你喜欢）</h1><p>当我们在查看某个商品的时候，底部一般会有一些商品推荐（猜你喜欢），这里我们选择使用ElasticSearch来简单实现。</p><p>这里的需求是，可以根据指定商品的id来查找相关商品，查看一下接口文档：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f2d3b4d8af714ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说我们这里的原理是这样的：首先根据商品id获取到指定商品的信息，然后以指定商品的名称、品牌、分类来搜索商品，并且过滤掉当前的商品（剔除此商品的id），调整搜索条件中的权重以获取最好的匹配度。</p><p>这里我们设置商品名称权重为8，商品副标题权重为2，商品关键字权重为2，商品品牌id权重为5，商品商品类别id权重为3。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-2"><a href="#使用Query-DSL来调用ES的Restful-API来实现-2" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;function_score&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;bool&quot;: &#123;</span><br><span class="line">              &quot;must_not&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                  &quot;id&quot;: 28</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;functions&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 8</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;subTitle&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;match&quot;: &#123;</span><br><span class="line">              &quot;keywords&quot;: &quot;红米5A&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;brandId&quot;: 6</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 5</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;productCategoryId&quot;: 19</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;weight&quot;: 3</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;score_mode&quot;: &quot;sum&quot;,</span><br><span class="line">      &quot;min_score&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6427b03e1f96d556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-2" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据商品id推荐相关商品</span><br><span class="line"> * @param id 商品id</span><br><span class="line"> * @param pageNum 页码</span><br><span class="line"> * @param pageSize 每页数量</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize);</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductServiceImpl</code>类中实现这个recommend方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Page&lt;EsProduct&gt; recommend(Long id, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">    List&lt;EsProduct&gt; esProductList = esProductDao.getAllEsProductList(id);</span><br><span class="line">    if(esProductList.size()&gt;0)&#123;</span><br><span class="line">        EsProduct esProduct = esProductList.get(0);</span><br><span class="line">        String keyword = esProduct.getName();</span><br><span class="line">        Long brandId = esProduct.getBrandId();</span><br><span class="line">        Long productCategoryId = esProduct.getProductCategoryId();</span><br><span class="line">        //根据商品标题、品牌、分类进行搜索</span><br><span class="line">        List&lt;FunctionScoreQueryBuilder.FilterFunctionBuilder&gt; filterFunctionBuilders = new ArrayList&lt;&gt;();</span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;name&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(8)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;subTitle&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;keywords&quot;,keyword),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(2)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;brandId&quot;,brandId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(5)));</span><br><span class="line"></span><br><span class="line">        filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(QueryBuilders.matchQuery(&quot;productCategoryId&quot;,productCategoryId),</span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(3)));</span><br><span class="line"></span><br><span class="line">        FunctionScoreQueryBuilder.FilterFunctionBuilder[] builders = new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()];</span><br><span class="line">        filterFunctionBuilders.toArray(builders);</span><br><span class="line">        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(builders)</span><br><span class="line">                .scoreMode(FunctionScoreQuery.ScoreMode.SUM)</span><br><span class="line">                .setMinScore(2);</span><br><span class="line">        //过滤掉相同的商品</span><br><span class="line">        BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder();</span><br><span class="line">        boolQueryBuilder.mustNot(QueryBuilders.termQuery(&quot;id&quot;,id));</span><br><span class="line"></span><br><span class="line">        //构建查询条件</span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(functionScoreQueryBuilder);</span><br><span class="line">        builder.withFilter(boolQueryBuilder);</span><br><span class="line">        builder.withPageable(pageable);</span><br><span class="line">        NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">        LOGGER.info(&quot;DSL:&#123;&#125;&quot;, searchQuery.getQuery().toString());</span><br><span class="line">        return esProductRepository.search(searchQuery);</span><br><span class="line">    &#125;</span><br><span class="line">    return new PageImpl&lt;&gt;(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>EsProductController</code>类中定义一个名为recommend的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;根据商品id推荐商品&quot;)</span><br><span class="line">@GetMapping( &quot;/recommend/&#123;id&#125;&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; recommend(@PathVariable @ApiParam(&quot;商品id&quot;) Long id,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                     @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">    Page&lt;EsProduct&gt; esProductPage = esProductService.recommend(id, pageNum, pageSize);</span><br><span class="line">    return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聚合搜索商品相关信息"><a href="#聚合搜索商品相关信息" class="headerlink" title="聚合搜索商品相关信息"></a>聚合搜索商品相关信息</h1><p>在搜索商品时，通常会有一个筛选界面来帮助用户快速找到想要的商品，这里使用Elasticsearch来简单实现。</p><p>这里的需求是，可以根据搜索关键字获取到与关键字匹配商品相关的分类，品牌以及属性，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9305b0e633b7e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里可以使用ElasticSearch的聚合来实现，搜索出相关商品，聚合出商品的品牌、分类以及属性，取出现次数最多的前10个即可。</p><h3 id="使用Query-DSL来调用ES的Restful-API来实现-3"><a href="#使用Query-DSL来调用ES的Restful-API来实现-3" class="headerlink" title="使用Query DSL来调用ES的Restful API来实现"></a>使用Query DSL来调用ES的Restful API来实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">POST /pms/product/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;华为&quot;,</span><br><span class="line">      &quot;fields&quot;: [</span><br><span class="line">        &quot;name&quot;,</span><br><span class="line">        &quot;subTitle&quot;,</span><br><span class="line">        &quot;keywords&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brandName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;productCategoryNames&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;productCategoryName&quot;,</span><br><span class="line">        &quot;size&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;allAttrValues&quot;: &#123;</span><br><span class="line">      &quot;nested&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;attrValueList&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;productAttrs&quot;: &#123;</span><br><span class="line">          &quot;filter&quot;: &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;attrValueList.type&quot;: 1</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;attrIds&quot;: &#123;</span><br><span class="line">              &quot;terms&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;attrValueList.productAttributeId&quot;,</span><br><span class="line">                &quot;size&quot;: 10</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;aggs&quot;: &#123;</span><br><span class="line">                &quot;attrValues&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.value&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;attrNames&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: &#123;</span><br><span class="line">                    &quot;field&quot;: &quot;attrValueList.name&quot;,</span><br><span class="line">                    &quot;size&quot;: 10</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，当我们搜索“华为”这个关键字时，聚合出了如下的分类和品牌信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-08de9f19d304b551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>聚合出了“屏幕尺寸”、“网络”、“系统”等筛选属性信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6b22dccdf4ad08fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3"><a href="#在SpringBoot中使用Elasticsearch-Repository的衍生查询来实现-3" class="headerlink" title="在SpringBoot中使用Elasticsearch Repository的衍生查询来实现"></a>在SpringBoot中使用Elasticsearch Repository的衍生查询来实现</h3><p>在SpringBoot中实现聚合操作非常复杂，已经超出了Elasticsearch Repository的使用范围，需要直接使用更为底层的<code>ElasticsearchTemplate</code>来实现。</p><p><strong>第一步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内定义一个名为domain的包，并在domain包内定义一个名为<code>EsProductRelatedInfo</code>的类，这是搜索相关商品品牌名称，分类名称及属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索相关商品品牌名称，分类名称及属性</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductRelatedInfo &#123;</span><br><span class="line">    private List&lt;String&gt; brandNames;</span><br><span class="line">    private List&lt;String&gt; productCategoryNames;</span><br><span class="line">    private List&lt;ProductAttr&gt; productAttrs;</span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    public static class ProductAttr&#123;</span><br><span class="line">        private Long attrId;</span><br><span class="line">        private String attrName;</span><br><span class="line">        private List&lt;String&gt; attrValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到<code>EsProductService</code>接口，我们在里面新定义一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取搜索词相关品牌、分类、属性</span><br><span class="line"> */</span><br><span class="line">EsProductRelatedInfo searchRelatedInfo(String keyword);</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在<code>EsProductServiceImpl</code>类中实现这个<code>searchRelatedInfo</code>方法，注意此时需要开发者自定义查询条件<code>QueryBuilder</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public EsProductRelatedInfo searchRelatedInfo(String keyword) &#123;</span><br><span class="line">    NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">    //搜索条件</span><br><span class="line">    if(StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        builder.withQuery(QueryBuilders.multiMatchQuery(keyword,&quot;name&quot;,&quot;subTitle&quot;,&quot;keywords&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    //聚合搜索品牌名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;brandNames&quot;).field(&quot;brandName&quot;));</span><br><span class="line">    //集合搜索分类名称</span><br><span class="line">    builder.addAggregation(AggregationBuilders.terms(&quot;productCategoryNames&quot;).field(&quot;productCategoryName&quot;));</span><br><span class="line">    //聚合搜索商品属性，去除type=1的属性</span><br><span class="line">    AbstractAggregationBuilder aggregationBuilder = AggregationBuilders.nested(&quot;allAttrValues&quot;,&quot;attrValueList&quot;)</span><br><span class="line">            .subAggregation(AggregationBuilders.filter(&quot;productAttrs&quot;,QueryBuilders.termQuery(&quot;attrValueList.type&quot;,1))</span><br><span class="line">                    .subAggregation(AggregationBuilders.terms(&quot;attrIds&quot;)</span><br><span class="line">                            .field(&quot;attrValueList.productAttributeId&quot;)</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrValues&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.value&quot;))</span><br><span class="line">                            .subAggregation(AggregationBuilders.terms(&quot;attrNames&quot;)</span><br><span class="line">                                    .field(&quot;attrValueList.name&quot;))));</span><br><span class="line">    builder.addAggregation(aggregationBuilder);</span><br><span class="line">    NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">    SearchResponse searchResponse = elasticsearchTemplate.query(searchQuery, response -&gt; response);</span><br><span class="line">    LOGGER.info(&quot;DSL:&#123;&#125;&quot;,searchQuery.getQuery().toString());</span><br><span class="line">    return convertProductRelatedInfo(searchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将返回结果转换为对象</span><br><span class="line"> */</span><br><span class="line">private EsProductRelatedInfo convertProductRelatedInfo(SearchResponse searchResponse) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = new EsProductRelatedInfo();</span><br><span class="line">    Map&lt;String, Aggregation&gt; aggregationMap = searchResponse.getAggregations().getAsMap();</span><br><span class="line">    //设置品牌</span><br><span class="line">    Aggregation brandNames = aggregationMap.get(&quot;brandNames&quot;);</span><br><span class="line">    List&lt;String&gt; brandNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i = 0; i&lt;((Terms) brandNames).getBuckets().size(); i++)&#123;</span><br><span class="line">        brandNameList.add(((Terms) brandNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setBrandNames(brandNameList);</span><br><span class="line">    //设置分类</span><br><span class="line">    Aggregation productCategoryNames = aggregationMap.get(&quot;productCategoryNames&quot;);</span><br><span class="line">    List&lt;String&gt; productCategoryNameList = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int i=0;i&lt;((Terms) productCategoryNames).getBuckets().size();i++)&#123;</span><br><span class="line">        productCategoryNameList.add(((Terms) productCategoryNames).getBuckets().get(i).getKeyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductCategoryNames(productCategoryNameList);</span><br><span class="line">    //设置参数</span><br><span class="line">    Aggregation productAttrs = aggregationMap.get(&quot;allAttrValues&quot;);</span><br><span class="line">    List&lt;? extends Terms.Bucket&gt; attrIds = ((LongTerms) ((Filter) ((Nested) productAttrs).getAggregations().get(&quot;productAttrs&quot;)).getAggregations().get(&quot;attrIds&quot;)).getBuckets();</span><br><span class="line">    List&lt;EsProductRelatedInfo.ProductAttr&gt; attrList = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Terms.Bucket attrId : attrIds) &#123;</span><br><span class="line">        EsProductRelatedInfo.ProductAttr attr = new EsProductRelatedInfo.ProductAttr();</span><br><span class="line">        attr.setAttrId((Long) attrId.getKey());</span><br><span class="line">        List&lt;String&gt; attrValueList = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrValues = ((StringTerms) attrId.getAggregations().get(&quot;attrValues&quot;)).getBuckets();</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; attrNames = ((StringTerms) attrId.getAggregations().get(&quot;attrNames&quot;)).getBuckets();</span><br><span class="line">        for (Terms.Bucket attrValue : attrValues) &#123;</span><br><span class="line">            attrValueList.add(attrValue.getKeyAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        attr.setAttrValues(attrValueList);</span><br><span class="line">        if(!CollectionUtils.isEmpty(attrNames))&#123;</span><br><span class="line">            String attrName = attrNames.get(0).getKeyAsString();</span><br><span class="line">            attr.setAttrName(attrName);</span><br><span class="line">        &#125;</span><br><span class="line">        attrList.add(attr);</span><br><span class="line">    &#125;</span><br><span class="line">    productRelatedInfo.setProductAttrs(attrList);</span><br><span class="line">    return productRelatedInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>EsProductController</code>类中定义一个名为<code>searchRelatedInfo</code>的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ApiOperation(value = &quot;获取搜索的相关品牌、分类及筛选属性&quot;)</span><br><span class="line">@GetMapping(value = &quot;/search/relate&quot;)</span><br><span class="line">public CommonResult&lt;EsProductRelatedInfo&gt; searchRelatedInfo(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword) &#123;</span><br><span class="line">    EsProductRelatedInfo productRelatedInfo = esProductService.searchRelatedInfo(keyword);</span><br><span class="line">    return CommonResult.success(productRelatedInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><p>启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fef19695a18583e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后进行接口测试。首先后台用户进行登录，接着测试相关接口，可以看到接口都是正常的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a308b197290a377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1cd8c204dc3094e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于使用ElasticSearch实现商品复杂搜索的学习就完成了，后续介绍如何整合MongoDB实现用户商品浏览记录这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第五篇《整合ElasticSearch实现商品搜索》的基础上，使用ElasticSearch实现商品复杂搜索这一功能</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合ElasticSearch实现商品搜索</title>
    <link href="http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/"/>
    <id>http://envyzhan.asia/2023/01/20/2023-5-integrate-elasticsearch-to-realize-product-search/</id>
    <published>2023-01-20T06:55:30.000Z</published>
    <updated>2023-03-14T06:38:37.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索这一功能。</p><h1 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a>ElasticSearch简介</h1><p>ElasticSearch是一个分布式、可扩展、实时的搜索与数据分析引擎，它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，在日常工作和学习中扮演着非常重要的角色。关于ElasticSearch的学习，可以参考笔者的其他文章。注意本篇使用的ElasticSearch版本为6.8.6。</p><p>Kibana作为访问ElasticSearch的客户端，可以很方便的提供开发者可视化方式操作ES。</p><p>在整合前，请确保ElasticSearch和Kibana都已经正确安装并启动，且ElasticSearch的分词器也已经安装。</p><h1 id="Spring-Data-Elasticsearch"><a href="#Spring-Data-Elasticsearch" class="headerlink" title="Spring Data Elasticsearch"></a>Spring Data Elasticsearch</h1><p>Spring Data Elasticsearch是Spring提供的一种以Spring Data风格来操作数据存储的方式，可以避免开发者编写大量的样板代码，提升代码质量。</p><h1 id="Spring-Data-Elasticsearch常用注解"><a href="#Spring-Data-Elasticsearch常用注解" class="headerlink" title="Spring Data Elasticsearch常用注解"></a>Spring Data Elasticsearch常用注解</h1><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p><code>@Document</code>注解添加到需要映射到ElasticSearch文档上的领域对象上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Persistent</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">public @interface Document &#123;</span><br><span class="line">    //索引名称，类似于数据库中的数据库</span><br><span class="line">    String indexName();</span><br><span class="line">    //类型，类似于数据库中的数据表</span><br><span class="line">    String type() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean useServerConfiguration() default false;</span><br><span class="line">    //分片数，默认为5</span><br><span class="line">    short shards() default 5;</span><br><span class="line">    //副本数，默认为1</span><br><span class="line">    short replicas() default 1;</span><br><span class="line">    //每次刷新间隔，默认1秒</span><br><span class="line">    String refreshInterval() default &quot;1s&quot;;</span><br><span class="line"></span><br><span class="line">    String indexStoreType() default &quot;fs&quot;;</span><br><span class="line"></span><br><span class="line">    boolean createIndex() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p><code>@Id</code>注解添加到映射到ElasticSearch文档上的领域对象的ID字段上，即文档的id，类似于数据库中的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">public @interface Id &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Field"><a href="#Field" class="headerlink" title="@Field"></a>@Field</h3><p><code>@Field</code>注解添加到映射到ElasticSearch文档上的领域对象字段上，注意它用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Field &#123;</span><br><span class="line">    //文档中字段的类型</span><br><span class="line">    FieldType type() default FieldType.Auto;</span><br><span class="line">    //是否建立倒排索引，默认是</span><br><span class="line">    boolean index() default true;</span><br><span class="line"></span><br><span class="line">    DateFormat format() default DateFormat.none;</span><br><span class="line"></span><br><span class="line">    String pattern() default &quot;&quot;;</span><br><span class="line">    //是否进行存储</span><br><span class="line">    boolean store() default false;</span><br><span class="line"></span><br><span class="line">    boolean fielddata() default false;</span><br><span class="line"></span><br><span class="line">    String searchAnalyzer() default &quot;&quot;;</span><br><span class="line">    //分词器名称</span><br><span class="line">    String analyzer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String normalizer() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    String[] ignoreFields() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    boolean includeInParent() default false;</span><br><span class="line"></span><br><span class="line">    String[] copyTo() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个FieldType是一个枚举类，用于为文档自动指定元数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum FieldType &#123;</span><br><span class="line">    Text,  //进行分词并建立索引的字符类型</span><br><span class="line">    Integer,</span><br><span class="line">    Long,</span><br><span class="line">    Date,</span><br><span class="line">    Float,</span><br><span class="line">    Double,</span><br><span class="line">    Boolean,</span><br><span class="line">    Object,</span><br><span class="line">    Auto,  //自动判断字段类型</span><br><span class="line">    Nested,  //嵌套对象类型</span><br><span class="line">    Ip,</span><br><span class="line">    Attachment,</span><br><span class="line">    Keyword;  //不进行分词并建立索引的类型</span><br><span class="line"></span><br><span class="line">    private FieldType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Data操作数据的方式"><a href="#Spring-Data操作数据的方式" class="headerlink" title="Spring Data操作数据的方式"></a>Spring Data操作数据的方式</h1><p>如果你之前使用过JPA，你会发现Spring Data操作数据的方式都是类似的，即继承XXXRepository接口，然后就可以获得一些操作数据的常用方法。此处是继承ElasticsearchRepository接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@NoRepositoryBean</span><br><span class="line">public interface ElasticsearchRepository&lt;T, ID extends Serializable&gt; extends ElasticsearchCrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; S index(S var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; search(QueryBuilder var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(QueryBuilder var1, Pageable var2);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; search(SearchQuery var1);</span><br><span class="line"></span><br><span class="line">    Page&lt;T&gt; searchSimilar(T var1, String[] var2, Pageable var3);</span><br><span class="line"></span><br><span class="line">    void refresh();</span><br><span class="line"></span><br><span class="line">    Class&lt;T&gt; getEntityClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上开发者也可以使用衍生查询，即在接口中直接指定查询方法的名称就可以实现查询，无需提供具体的实现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-32d961153b53feaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>就像后面会使用到的，商品表中有商品名称、商品副标题和关键字，直接在接口中定义如下方法，即可对这三个字段进行全文搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索查询</span><br><span class="line"> * @param name 商品名称</span><br><span class="line"> * @param subTitle 商品副标题</span><br><span class="line"> * @param keywords 商品关键字</span><br><span class="line"> * @param page 分页信息</span><br><span class="line"> * @return 搜索结果</span><br><span class="line"> */</span><br><span class="line">Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br></pre></td></tr></table></figure><p>如果开发者使用的IDE是IDEA，那么它会在开发者编写方法的时候直接提示对应字段信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fb03dc0544a57dd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，开发者也可以使用<code>@Query</code>注解，直接使用ElasticSearch的DSL语句来进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;&#123;&quot;bool&quot; : &#123;&quot;must&quot; : &#123;&quot;field&quot; : &#123;&quot;name&quot; : &quot;?0&quot;&#125;&#125;&#125;&#125;&quot;)</span><br><span class="line">Page&lt;EsProduct&gt; findByName(String name,Pageable pageable);</span><br></pre></td></tr></table></figure><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>（1）<code>pms_product</code>：商品信息表；<br>（2）<code>pms_product_attribute</code>：商品属性参数表；<br>（3）<code>pms_product_attribute_value</code>：存储产品参数值的表，即商品id与商品属性id之间的对应关系表。</p><h1 id="整合ElasticSearch实现商品搜索"><a href="#整合ElasticSearch实现商品搜索" class="headerlink" title="整合ElasticSearch实现商品搜索"></a>整合ElasticSearch实现商品搜索</h1><p><strong>第一步</strong>，复制一份<code>shop-springsecurity-jwt</code>源码，将其名字修改为<code>shop-elasticsearch</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-elasticsearch</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-elasticsearch</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Elasticsearch相关依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在spring节点下添加ElasticSearch相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ElasticSearch相关</span><br><span class="line">data:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    repositories:</span><br><span class="line">      enabled: true</span><br><span class="line">    cluster-nodes: localhost:9300 # es的连接地址及端口号</span><br><span class="line">    cluster-name: elasticsearch # es集群的名称</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述三张表的对应信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopelasticsearch</code>包内新建一个名为nosql的包，并在nosql包内定义一个名为elasticsearch的包，接着在elasticsearch包内定义一个名为document的包。然后在document包内定义一个名为EsProduct的类，注意这是商品文档对象。</p><p>一般来说，不需要分词的字段可以设置类型为Keyword，也就是使用<code>@Field(type = FieldType.Keyword)</code>注解，如这里的货号、品牌名称和商品分类名称。而需要进行分词的字段可以设置为Text类型，即使用<code>@Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</code>注解，如这里的商品名称、副标题和关键字，同时需要指定分词器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@Document(indexName = &quot;pms&quot;, type = &quot;product&quot;,shards = 1,replicas = 0)</span><br><span class="line">public class EsProduct implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -1L;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line">    private Long brandId;</span><br><span class="line">    private Long productCategoryId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 货号</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productSn;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 品牌名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String brandName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品分类名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String productCategoryName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品名称</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 副标题</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String subTitle;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关键字</span><br><span class="line">     */</span><br><span class="line">    @Field(analyzer = &quot;ik_max_word&quot;,type = FieldType.Text)</span><br><span class="line">    private String keywords;</span><br><span class="line"></span><br><span class="line">    private String pic;</span><br><span class="line">    private BigDecimal price;</span><br><span class="line">    private Integer sale;</span><br><span class="line">    private Integer newStatus;</span><br><span class="line">    private Integer recommendStatus;</span><br><span class="line">    private Integer stock;</span><br><span class="line">    private Integer promotionType;</span><br><span class="line">    private Integer sort;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 嵌套类型，商品属性列表</span><br><span class="line">     */</span><br><span class="line">    @Field(type =FieldType.Nested)</span><br><span class="line">    private List&lt;EsProductAttributeValue&gt; attrValueList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在document包内定义一个名为<code>EsProductAttributeValue</code>的类，因为商品文档对象EsProduct中有一个名为attrValueList的属性，它是一个List类型，里面都是<code>EsProductAttributeValue</code>对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索中的商品属性信息</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">public class EsProductAttributeValue implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 商品属性值id</span><br><span class="line">     */</span><br><span class="line">    private Long productAttributeId;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性值</span><br><span class="line">     */</span><br><span class="line">    @Field(type = FieldType.Keyword)</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性参数：0-&gt;规格；1-&gt;参数</span><br><span class="line">     */</span><br><span class="line">    private Integer type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性名称</span><br><span class="line">     */</span><br><span class="line">    @Field(type=FieldType.Keyword)</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch</code>包内新建一个名为repository的包，并在该包内定义一个名为<code>EsProductRepository</code>的接口，注意这个接口需要继承<code>ElasticsearchRepository</code>接口，这样就拥有了一些基本的操作ElasticSearch数据的方法，同时我们在里面定义了一个衍生的根据条件搜索查询商品的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct,Long&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 搜索查询</span><br><span class="line">     * @param name 商品名称</span><br><span class="line">     * @param subTitle 商品副标题</span><br><span class="line">     * @param keywords 商品关键字</span><br><span class="line">     * @param page 分页信息</span><br><span class="line">     * @return 搜索结果</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在dao包内定义一个名为<code>EsProductDao</code>的接口，这是搜索系统中商品管理自定义的Dao。我们在里面添加一个从数据库中查询所有商品文档对象EsProduct的方法，当然了这个方法也可以传入id变成查询指定id的商品文档对象。简单来说就是查询数据库的多张表，将商品信息组装为EsProduct对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搜索系统中商品管理自定义的Dao</span><br><span class="line"> */</span><br><span class="line">public interface EsProductDao &#123;</span><br><span class="line">    List&lt;EsProduct&gt; getAllEsProductList(@Param(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在<code>resources/mapper</code>包内定义一个名为<code>EsProductDao</code>的XML文件，这是第八步中对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopelasticsearch.dao.EsProductDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;esProductListMap&quot; type=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct&quot;</span><br><span class="line">               autoMapping=&quot;true&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;</span><br><span class="line">        &lt;collection property=&quot;attrValueList&quot; columnPrefix=&quot;attr_&quot; ofType=&quot;com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue&quot;&gt;</span><br><span class="line">            &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;product_attribute_id&quot; property=&quot;productAttributeId&quot; jdbcType=&quot;BIGINT&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;value&quot; property=&quot;value&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;</span><br><span class="line">            &lt;result column=&quot;type&quot; property=&quot;type&quot;/&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    &lt;select id=&quot;getAllEsProductList&quot; resultMap=&quot;esProductListMap&quot;&gt;</span><br><span class="line">        select</span><br><span class="line">            p.id id,</span><br><span class="line">            p.product_sn productSn,</span><br><span class="line">            p.brand_id brandId,</span><br><span class="line">            p.brand_name brandName,</span><br><span class="line">            p.product_category_id productCategoryId,</span><br><span class="line">            p.product_category_name productCategoryName,</span><br><span class="line">            p.pic pic,</span><br><span class="line">            p.name name,</span><br><span class="line">            p.sub_title subTitle,</span><br><span class="line">            p.price price,</span><br><span class="line">            p.sale sale,</span><br><span class="line">            p.new_status newStatus,</span><br><span class="line">            p.recommend_status recommendStatus,</span><br><span class="line">            p.stock stock,</span><br><span class="line">            p.promotion_type promotionType,</span><br><span class="line">            p.keywords keywords,</span><br><span class="line">            p.sort sort,</span><br><span class="line">            pav.id attr_id,</span><br><span class="line">            pav.value attr_value,</span><br><span class="line">            pav.product_attribute_id attr_product_attribute_id,</span><br><span class="line">            pa.type attr_type,</span><br><span class="line">            pa.name attr_name</span><br><span class="line">        from pms_product p</span><br><span class="line">        left join pms_product_attribute_value pav on p.id = pav.product_id</span><br><span class="line">        left join pms_product_attribute pa on pav.product_attribute_id= pa.id</span><br><span class="line">        where delete_status = 0 and publish_status = 1</span><br><span class="line">        &lt;if test=&quot;id!=null&quot;&gt;</span><br><span class="line">            and p.id=#&#123;id&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下上述配置信息的含义：<br>（1）mapper标签中的namespace属性用于指定此Mapper文件所对应的接口文件是第八步中定义的接口文件，即该文件的项目路径；<br>（2）由于<code>getAllEsProductList(@Param(&quot;id&quot;) Long id)</code>方法返回的是一个<code>List&lt;EsProduct&gt;</code>对象，因此该select标签返回的是一个resultMap对象，而这个对象返回的应该是<code>List&lt;EsProduct&gt;</code>中的EsProduct对象；<br>（3）在该mapper文件中定义一个id为<code>esProductListMap</code>的resultMap，然后指定type属性为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProduct</code>，也就是ES中存的对象类型。同时这里需要设置autoMapping属性的值为true，表示自动根据sql语句查询的字段名称与EsProduct类中设置的属性名称进行映射绑定；<br>（4）在resultMap标签内使用一个collection标签，指定property属性为attrValueList，这个值必须与开发者在EsProduct中指定的属性名称完全一致。接着设置columnPrefix，表示我们从数据库使用sql语句查询得到的字段名称都是<code>attr_</code>开头的，ofType指定类型为<code>com.kenbings.shop.shopelasticsearch.nosql.elasticsearch.document.EsProductAttributeValue</code>。接着我们就使用result标签来手动将其进行绑定；<br>（5）通过上面的分析，我们知道在select标签中，<code>pms_product</code>表里查询得到的字段必须指定别名为与EsProduct属性相同的名称，而<code>pms_product_attribute_value</code>表中查询得到的字段别名必须以<code>attr_</code>开头，且符合上述自定义的映射关系。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>EsProductService</code>的接口，用于定义EsProduct搜索相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索的Service</span><br><span class="line"> */</span><br><span class="line">public interface EsProductService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 从数据中导入所有商品到ES</span><br><span class="line">     * @return 导入的文档数</span><br><span class="line">     */</span><br><span class="line">    int importAll();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id删除ES中的商品</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在ES中创建指定id的商品文档信息</span><br><span class="line">     * @param id 商品id</span><br><span class="line">     */</span><br><span class="line">    EsProduct create(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id批量删除ES中的商品</span><br><span class="line">     * @param ids 商品id</span><br><span class="line">     */</span><br><span class="line">    void delete(List&lt;Long&gt; ids);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据关键字搜索商品信息</span><br><span class="line">     * @param keyword 关键字</span><br><span class="line">     * @param pageNum 页码</span><br><span class="line">     * @param pageSize 每页数量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsProduct&gt; search(String keyword,Integer pageNum, Integer pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>EsProductServiceImpl</code>的类，这个类需要实现<code>EsProductService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * EsProduct搜索Service的实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class EsProductServiceImpl implements EsProductService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(EsProductServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductDao esProductDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductRepository esProductRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int importAll() &#123;</span><br><span class="line">        List&lt;EsProduct&gt; allEsProductList = esProductDao.getAllEsProductList(null);</span><br><span class="line">        Iterable&lt;EsProduct&gt; esProductIterable = esProductRepository.saveAll(allEsProductList);</span><br><span class="line">        Iterator&lt;EsProduct&gt; esProductIterator = esProductIterable.iterator();</span><br><span class="line">        int result = 0;</span><br><span class="line">        while (esProductIterator.hasNext())&#123;</span><br><span class="line">            result++;</span><br><span class="line">            esProductIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(Long id) &#123;</span><br><span class="line">        esProductRepository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public EsProduct create(Long id) &#123;</span><br><span class="line">        EsProduct result = null;</span><br><span class="line">        List&lt;EsProduct&gt; esProductLists = esProductDao.getAllEsProductList(id);</span><br><span class="line">        if(esProductLists.size()&gt;0)&#123;</span><br><span class="line">            EsProduct esProduct = esProductLists.get(0);</span><br><span class="line">            result = esProductRepository.save(esProduct);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void delete(List&lt;Long&gt; ids) &#123;</span><br><span class="line">        if(!CollectionUtils.isEmpty(ids))&#123;</span><br><span class="line">            List&lt;EsProduct&gt; esProductList = new ArrayList&lt;&gt;();</span><br><span class="line">            for (Long id:ids) &#123;</span><br><span class="line">                EsProduct esProduct = new EsProduct();</span><br><span class="line">                esProduct.setId(id);</span><br><span class="line">                esProductList.add(esProduct);</span><br><span class="line">            &#125;</span><br><span class="line">            esProductRepository.deleteAll(esProductList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) &#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(pageNum,pageSize);</span><br><span class="line">        return esProductRepository.findByNameOrSubTitleOrKeywords(keyword,keyword,keyword,pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，在controller包内定义一个名为<code>EsProductController</code>的类，这是商品搜索功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 商品搜索管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;EsProductController&quot;,description = &quot;商品搜索管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/esProduct&quot;)</span><br><span class="line">public class EsProductController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EsProductService esProductService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;导入所有数据库中商品到ES&quot;)</span><br><span class="line">    @PostMapping(&quot;/importAll&quot;)</span><br><span class="line">    public CommonResult&lt;Integer&gt; importAllList() &#123;</span><br><span class="line">        int count = esProductService.importAll();</span><br><span class="line">        return CommonResult.success(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id删除Es中指定的商品信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@PathVariable Long id) &#123;</span><br><span class="line">        esProductService.delete(id);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id批量删除Es中的商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/delete/batch&quot;)</span><br><span class="line">    public CommonResult&lt;Object&gt; delete(@RequestParam(&quot;ids&quot;) List&lt;Long&gt; ids) &#123;</span><br><span class="line">        esProductService.delete(ids);</span><br><span class="line">        return CommonResult.success(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;根据id在ES中创建商品信息&quot;)</span><br><span class="line">    @PostMapping( &quot;/create/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;EsProduct&gt; create(@PathVariable Long id) &#123;</span><br><span class="line">        EsProduct esProduct = esProductService.create(id);</span><br><span class="line">        if (esProduct != null) &#123;</span><br><span class="line">            return CommonResult.success(esProduct);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;简单搜索&quot;)</span><br><span class="line">    @GetMapping(&quot;/search/simple&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;EsProduct&gt;&gt; search(@RequestParam(required = false) @ApiParam(&quot;关键字&quot;) String keyword,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;0&quot;)@ApiParam(&quot;页码&quot;) Integer pageNum,</span><br><span class="line">                                                      @RequestParam(required = false, defaultValue = &quot;5&quot;)@ApiParam(&quot;每页数量&quot;) Integer pageSize) &#123;</span><br><span class="line">        Page&lt;EsProduct&gt; esProductPage = esProductService.search(keyword, pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(esProductPage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，修改<code>com.kenbings.shop.shopelasticsearch.common.api.CommonPage</code>类，在里面新增加一个将SpringData 分页后的list转为分页信息的restPage方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将 SpringData 分页后的list转为分页信息</span><br><span class="line"> */</span><br><span class="line">public static &lt;T&gt; CommonPage&lt;T&gt; restPage(Page&lt;T&gt; pageInfo)&#123;</span><br><span class="line">    CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">    commonPage.setPageNum(pageInfo.getNumber());</span><br><span class="line">    commonPage.setPageSize(pageInfo.getSize());</span><br><span class="line">    commonPage.setTotalPage(pageInfo.getTotalPages());</span><br><span class="line">    commonPage.setTotal(pageInfo.getTotalElements());</span><br><span class="line">    commonPage.setList(pageInfo.getContent());</span><br><span class="line">    return commonPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-759bd6bcb461605c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十五步</strong>，进行接口测试。首先后台用户进行登录，接着测试“导入所有数据库中商品到ES”：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96277397495717d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们测试一下“简单搜索”这一接口，可以看到测试成功：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b838446b00c212b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合ElasticSearch实现商品搜索的学习就完成了，后续介绍如何使用ElasticSearch实现复杂搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-elasticsearch">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第四篇《整合SpringSecurity和JWT实现认证与授权》的基础上整合ElasticSearch，实现商品搜索</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合SpringSecurity和JWT实现认证与授权</title>
    <link href="http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/"/>
    <id>http://envyzhan.asia/2023/01/14/2023-4-integrate-springsecurity-and-jwt-to-achieve-authentication-and-authorization/</id>
    <published>2023-01-14T10:55:30.000Z</published>
    <updated>2023-03-14T06:36:44.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>SpringSecurity是一个强大的可高度定制的认证与授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。关于SpringSecurity的学习，可以参考笔者的其他文章。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><h5 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h5><p>JWT是JSON WEB TOKEN的缩写，它是基于RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。</p><h5 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h5><p>JWT由三部分组成：header、playload和signature，JWT token的格式为<code>header.payload.signature</code>。</p><p>其中header中用于存放签名的生成算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;: &quot;HS512&quot;&#125;</span><br></pre></td></tr></table></figure><p>payload中用于存放用户名、token的生成时间和过期时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;sub&quot;:&quot;admin&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br></pre></td></tr></table></figure><p>signature为以header和payload生成的签名，一旦header和payload被篡改，那么验证将失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//secret为加密算法的密钥</span><br><span class="line">String signature = HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br></pre></td></tr></table></figure><h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><p>如下是一个JWT的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw</span><br></pre></td></tr></table></figure><p>开发者可以点击 <a href="https://jwt.io/">这里</a> 获取到解析结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b52c581daa8e3375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="JWT实现认证和授权的原理"><a href="#JWT实现认证和授权的原理" class="headerlink" title="JWT实现认证和授权的原理"></a>JWT实现认证和授权的原理</h5><p>第一步，用户调用登录接口，登录成功后获取到JWT的token；</p><p>第二步，用户后续每次调用接口时，都会在http的header中添加一个名为Authorization的头，值为JWT的token；</p><p>第三步，后台程序通过对Authorization头中信息的解码及数字签名，校验来获取其中的用户信息，进而实现认证和授权。</p><h3 id="Hutool"><a href="#Hutool" class="headerlink" title="Hutool"></a>Hutool</h3><p>Hutool是一个丰富的Java开源工具包，可以帮助我们简化每一行代码，减少每一个方法。</p><h1 id="项目使用到的表说明"><a href="#项目使用到的表说明" class="headerlink" title="项目使用到的表说明"></a>项目使用到的表说明</h1><p>由于此处采用的是RBAC（基于角色的权限控制）模型，一般会涉及到五张表，同时外加针对某个用户的特定角色，因此会涉及到六张表，分别如下所示：<br>（1）<code>ums_admin</code>：后台用户表；<br>（2）<code>ums_role</code>：后台用户角色表；<br>（3）<code>ums_permission</code>：后台用户权限表；<br>（4）<code>ums_admin_role_relation</code>：后台用户和角色关系表，用户与角色是多对多关系；<br>（5） <code>ums_role_permission_relation</code>：后台用户角色和权限关系表，角色与权限是多对多关系；<br>（6）<code>ums_admin_permission_relation</code>：后台用户和权限关系表(除角色中定义的权限以外的加减权限)，加权限是指用户比角色多出的权限，减权限是指用户比角色少的权限。</p><h1 id="整合SpringSecurity及JWT"><a href="#整合SpringSecurity及JWT" class="headerlink" title="整合SpringSecurity及JWT"></a>整合SpringSecurity及JWT</h1><p><strong>第一步</strong>，复制一份<code>shop-redis</code>源码，将其名字修改为<code>shop-springsecurity-jwt</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-springsecurity-jwt</code>这一Module中进行。注意复制之后需要重新执行一下Generator类，以覆盖之前项目的自动生成文件。</p><p><strong>第二步</strong>，在<code>shop-springsecurity-jwt</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringSecurity依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--Hutool Java工具包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--JWT(Json Web Token)登录支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在根节点下添加jwt自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 自定义jwt的key</span><br><span class="line">jwt:</span><br><span class="line">  tokenHeader: Authorization #JWT存储的请求头</span><br><span class="line">  secret: mySecret #JWT加解密使用的密钥</span><br><span class="line">  expiration: 604800 #JWT的超期限时间(60*60*24)</span><br><span class="line">  tokenHead: Bearer  #JWT负载中拿到开头</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt.common</code>包内新建一个名为utils的包，并在utils包内定义一个名为JwtTokenUtil的工具类，该类用于生成和解析JWT token以获取对应信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JwtToken生成的工具类</span><br><span class="line"> * JWT token的格式：header.payload.signature</span><br><span class="line"> * header的格式（算法、token的类型）：</span><br><span class="line"> * &#123;&quot;alg&quot;: &quot;HS512&quot;,&quot;typ&quot;: &quot;JWT&quot;&#125;</span><br><span class="line"> * payload的格式（用户名、创建时间、生成时间）：</span><br><span class="line"> * &#123;&quot;sub&quot;:&quot;kenbings&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</span><br><span class="line"> * signature的生成算法：</span><br><span class="line"> * HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);</span><br><span class="line">    private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;</span><br><span class="line">    private static final String CLAIM_KEY_CREATED = &quot;created&quot;;</span><br><span class="line">    @Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">    private String secret;</span><br><span class="line">    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span><br><span class="line">    private Long expiration;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT的token</span><br><span class="line">     */</span><br><span class="line">    private String generateToken(Map&lt;String, Object&gt; claims) &#123;</span><br><span class="line">        return Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setExpiration(generateExpirationDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取JWT中的负载</span><br><span class="line">     */</span><br><span class="line">    private Claims getClaimsFromToken(String token) &#123;</span><br><span class="line">        Claims claims = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.info(&quot;JWT格式验证失败:&#123;&#125;&quot;,token);</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成token的过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date generateExpirationDate() &#123;</span><br><span class="line">        return new Date(System.currentTimeMillis() + expiration * 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取登录用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUserNameFromToken(String token) &#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username =  claims.getSubject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证token是否还有效</span><br><span class="line">     *</span><br><span class="line">     * @param token       客户端传入的token</span><br><span class="line">     * @param userDetails 从数据库中查询出来的用户信息</span><br><span class="line">     */</span><br><span class="line">    public boolean validateToken(String token, UserDetails userDetails) &#123;</span><br><span class="line">        String username = getUserNameFromToken(token);</span><br><span class="line">        return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否已经失效</span><br><span class="line">     */</span><br><span class="line">    private boolean isTokenExpired(String token) &#123;</span><br><span class="line">        Date expiredDate = getExpiredDateFromToken(token);</span><br><span class="line">        return expiredDate.before(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从token中获取过期时间</span><br><span class="line">     */</span><br><span class="line">    private Date getExpiredDateFromToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        return claims.getExpiration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据用户信息生成token</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</span><br><span class="line">        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断token是否可以被刷新</span><br><span class="line">     */</span><br><span class="line">    public boolean canRefresh(String token) &#123;</span><br><span class="line">        return !isTokenExpired(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新token</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token) &#123;</span><br><span class="line">        Claims claims = getClaimsFromToken(token);</span><br><span class="line">        claims.put(CLAIM_KEY_CREATED, new Date());</span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下其中比较重要的三个方法的作用：<br>（1）<code>generateToken(UserDetails userDetails)</code>方法，传入的是一个UserDetails对象，这是SpringSecurity提供的对象，其实就是用户登录成功后信息的一个封装对象；<br>（2）<code>getUserNameFromToken(String token)</code>方法，从token中获取用户姓名，诸如此类的方法还有很多，这里就不再说明；<br>（3）<code>validateToken(String token, UserDetails userDetails)</code>方法，用于判断token是否有效，其中token是客户端传入的，而userDetails则是从数据库中查询出来的用户信息。</p><p><strong>第五步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为component的包，并在component包内定义一个名为<code>RestfulAccessDeniedHandler</code>的类，该类定义当访问接口没有权限时，应当返回的结果，注意它需要实现<code>AccessDeniedHandler</code>接口，并重写其中的handle方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当访问接口没有权限时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestfulAccessDeniedHandler implements AccessDeniedHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在component包内定义一个名为<code>RestAuthenticationEntryPoint</code>的类，该类定义当未登录或者token失效访问接口时，应当返回的结果，注意它需要实现<code>AuthenticationEntryPoint</code>接口，并重写其中的commence方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当未登录或者token失效访问接口时，返回自定义的结果</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;application/json&quot;);</span><br><span class="line">        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(e.getMessage())));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，修改<code>generatorConfig.xml</code>配置文件中的数据表信息，以生成前面所述六张表的对应信息。</p><p><strong>第八步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dto的包，并在dto包内定义一个名为<code>AdminUserDetails</code>的类，该类定义SpringSecurity登录时需要使用到的UserDetails，注意它需要实现<code>UserDetails</code>接口，并重写其中对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity登录时需要使用到的UserDetails</span><br><span class="line"> */</span><br><span class="line">public class AdminUserDetails implements UserDetails &#123;</span><br><span class="line">    private UmsAdmin umsAdmin;</span><br><span class="line">    private List&lt;UmsPermission&gt; permissionList;</span><br><span class="line"></span><br><span class="line">    public AdminUserDetails(UmsAdmin umsAdmin,List&lt;UmsPermission&gt; permissionList)&#123;</span><br><span class="line">        this.umsAdmin = umsAdmin;</span><br><span class="line">        this.permissionList = permissionList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回当前用户的权限</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        return permissionList.stream().filter(permission -&gt; permission.getValue()!=null)</span><br><span class="line">                .map(permission -&gt; new SimpleGrantedAuthority(permission.getValue()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return umsAdmin.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return umsAdmin.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return umsAdmin.getStatus().equals(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，正常来说这里面方法的逻辑都需要在数据库中定义对应的字段信息，然后根据业务逻辑来进行判断，而不是像这里直接固定化。这个类不需要交由Spring去管理，因此不需要添加<code>@Component</code>注解。</p><p><strong>第九步</strong>，在component包内定义一个名为<code>JwtAuthenticationTokenFilter</code>的类，这是JWT登录授权过滤器，注意它需要继承<code>OncePerRequestFilter</code>类，并重写其中的doFilterInternal方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JWT登录授权过滤器</span><br><span class="line"> */</span><br><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationTokenFilter.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        String authHeader = request.getHeader(this.tokenHeader);</span><br><span class="line">        if (authHeader != null &amp;&amp; authHeader.startsWith(this.tokenHead)) &#123;</span><br><span class="line">            //获取&quot;Bearer &quot;之后的部分</span><br><span class="line">            String authToken = authHeader.substring(this.tokenHead.length());</span><br><span class="line">            String username = jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">            LOGGER.info(&quot;检查用户:&#123;&#125;&quot;, username);</span><br><span class="line">            if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123;</span><br><span class="line">                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);</span><br><span class="line">                if (jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));</span><br><span class="line">                    LOGGER.info(&quot;当前认证用户:&#123;&#125;&quot;, username);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在校验用户名和密码之前添加的过滤器，如果请求中包含jwt且token有效，那么会从中用户名，然后调用SpringSecurity的相关API来进行登录操作。</p><p><strong>第十步</strong>，在service包内定义一个名为<code>UmsAdminService</code>的接口，用于定义后台管理员相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据用户名查询后台管理员</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin getAdminByUsername(String username);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员注册</span><br><span class="line">     */</span><br><span class="line">    UmsAdmin register(UmsAdmin umsAdminParam);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后台管理员登录</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param password 密码</span><br><span class="line">     * @return 生成的JWT的token</span><br><span class="line">     */</span><br><span class="line">    String login(String username, String password);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定后台管理员的所有权限（包括角色权限和+-权限）</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在impl包内定义一个名为<code>UmsAdminServiceImpl</code>的类，这个类需要实现<code>UmsAdminService</code>接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsAdminServiceImpl implements UmsAdminService &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(UmsAdminServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminMapper adminMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminRoleRelationDao adminRoleRelationDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin getAdminByUsername(String username) &#123;</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(username);</span><br><span class="line">        List&lt;UmsAdmin&gt; adminLists = adminMapper.selectByExample(example);</span><br><span class="line">        if(adminLists !=null &amp;&amp; !adminLists.isEmpty())&#123;</span><br><span class="line">            return adminLists.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UmsAdmin register(UmsAdmin umsAdminParam) &#123;</span><br><span class="line">        //查询是否有相同用户名的用户</span><br><span class="line">        UmsAdminExample example = new UmsAdminExample();</span><br><span class="line">        example.createCriteria().andUsernameEqualTo(umsAdminParam.getUsername());</span><br><span class="line">        List&lt;UmsAdmin&gt; umsAdminList = adminMapper.selectByExample(example);</span><br><span class="line">        if (!umsAdminList.isEmpty()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = new UmsAdmin();</span><br><span class="line">        BeanUtils.copyProperties(umsAdminParam, umsAdmin);</span><br><span class="line">        umsAdmin.setCreateTime(new Date());</span><br><span class="line">        umsAdmin.setStatus(1);</span><br><span class="line">        //将密码进行加密操作</span><br><span class="line">        String encodePassword = passwordEncoder.encode(umsAdmin.getPassword());</span><br><span class="line">        umsAdmin.setPassword(encodePassword);</span><br><span class="line">        adminMapper.insert(umsAdmin);</span><br><span class="line">        return umsAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String login(String username, String password) &#123;</span><br><span class="line">        String token = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">            if(userDetails == null)&#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;不存在对应的用户信息&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!passwordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">                throw new BadCredentialsException(&quot;密码不正确&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            token = jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            LOGGER.warn(&quot;登录异常:&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;UmsPermission&gt; getPermissionList(Long adminId) &#123;</span><br><span class="line">        return adminRoleRelationDao.getPermissionList(adminId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在后面我们定义了<code>getPermissionList(Long adminId)</code>方法，该方法用于根据adminId从数据库中查询用户所有的权限，包括角色权限以及个人独有的权限。</p><p><strong>第十二步</strong>，在<code>com.kenbings.shop.shopspringsecurityjwt</code>包内新建一个名为dao的包，并在dao包内定义一个名为<code>UmsAdminRoleRelationDao</code>的接口，这是一个自定义的dao，用于查询后台用户与角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于查询后台用户与角色的自定义DAO</span><br><span class="line"> */</span><br><span class="line">public interface UmsAdminRoleRelationDao &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取用户所有权限(包括+-权限)</span><br><span class="line">     */</span><br><span class="line">    List&lt;UmsPermission&gt; getPermissionList(@Param(&quot;adminId&quot;) Long adminId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十三步</strong>，在resources目录下新建一个名为mapper的目录，并在mapper目录下定义一个名为<code>UmsAdminRoleRelationDao.xml</code>的XML文件，这个其实就是之前UmsAdminRoleRelationDao接口对应的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.kenbings.shop.shopspringsecurityjwt.dao.UmsAdminRoleRelationDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getPermissionList&quot; resultMap=&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper.UmsPermissionMapper.BaseResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_role_relation ar</span><br><span class="line">                LEFT JOIN ums_role r ON ar.role_id = r.id</span><br><span class="line">                LEFT JOIN ums_role_permission_relation rp ON r.id = rp.role_id</span><br><span class="line">                LEFT JOIN ums_permission p ON rp.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            ar.admin_id = #&#123;adminId&#125;</span><br><span class="line">          AND p.id IS NOT NULL</span><br><span class="line">          AND p.id NOT IN (</span><br><span class="line">            SELECT</span><br><span class="line">                p.id</span><br><span class="line">            FROM</span><br><span class="line">                ums_admin_permission_relation pr</span><br><span class="line">                    LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">            WHERE</span><br><span class="line">                pr.type = - 1</span><br><span class="line">              AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">        )</span><br><span class="line">        UNION</span><br><span class="line">        SELECT</span><br><span class="line">            p.*</span><br><span class="line">        FROM</span><br><span class="line">            ums_admin_permission_relation pr</span><br><span class="line">                LEFT JOIN ums_permission p ON pr.permission_id = p.id</span><br><span class="line">        WHERE</span><br><span class="line">            pr.type = 1</span><br><span class="line">          AND pr.admin_id = #&#123;adminId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>第十四步</strong>，在config包内定义一个名为SecurityConfig的类，这是SpringSecurity的配置类，它需要继承<code>WebSecurityConfigurerAdapter</code>类，并实现其中的一些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringSecurity配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled=true)</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器</span><br><span class="line">     * @param httpSecurity</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        httpSecurity.csrf()// 由于使用的是JWT，我们这里不需要csrf</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement()// 基于token，所以不需要session</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问</span><br><span class="line">                        &quot;/&quot;,</span><br><span class="line">                        &quot;/*.html&quot;,</span><br><span class="line">                        &quot;/favicon.ico&quot;,</span><br><span class="line">                        &quot;/**/*.html&quot;,</span><br><span class="line">                        &quot;/**/*.css&quot;,</span><br><span class="line">                        &quot;/**/*.js&quot;,</span><br><span class="line">                        &quot;/swagger-resources/**&quot;,</span><br><span class="line">                        &quot;/v2/api-docs/**&quot;</span><br><span class="line">                )</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(&quot;/admin/login&quot;, &quot;/admin/register&quot;)// 对登录注册要允许匿名访问</span><br><span class="line">                .permitAll()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求</span><br><span class="line">                .permitAll()</span><br><span class="line">//                .antMatchers(&quot;/**&quot;)//测试时全部运行访问</span><br><span class="line">//                .permitAll()</span><br><span class="line">                .anyRequest()// 除上面外的所有请求全部需要鉴权认证</span><br><span class="line">                .authenticated();</span><br><span class="line">        // 禁用缓存</span><br><span class="line">        httpSecurity.headers().cacheControl();</span><br><span class="line">        // 添加JWT filter</span><br><span class="line">        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        //添加自定义未授权和未登录结果返回</span><br><span class="line">        httpSecurity.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(restAuthenticationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于配置UserDetailsService及PasswordEncoder</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService())</span><br><span class="line">                .passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserDetailsService userDetailsService() &#123;</span><br><span class="line">        //获取登录用户信息</span><br><span class="line">        return username -&gt; &#123;</span><br><span class="line">            UmsAdmin admin = adminService.getAdminByUsername(username);</span><br><span class="line">            if (admin != null) &#123;</span><br><span class="line">                List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(admin.getId());</span><br><span class="line">                return new AdminUserDetails(admin,permissionList);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()&#123;</span><br><span class="line">        return new JwtAuthenticationTokenFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述一些方法：<br>（1）<code>configure(HttpSecurity httpSecurity)</code>方法，用于配置需要拦截的url路径、jwt过滤器及出现异常后的处理器；<br>（2）<code>configure(AuthenticationManagerBuilder auth)</code>方法，用于配置UserDetailsService及PasswordEncoder；<br>（3）<code>passwordEncoder()</code>方法，这是SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder；<br>（4）<code>userDetailsService()</code>方法，这是SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要开发者自行实现；<br>（5）<code>jwtAuthenticationTokenFilter()</code>方法，这是在校验用户名和密码前添加的过滤器，如果有jwt且token有效，那么会自行根据token信息进行登录；<br>（6）<code>RestfulAccessDeniedHandler</code>，这是当访问接口没有权限时，返回自定义的JSON格式结果；<br>（7）<code>RestAuthenticationEntryPoint</code>，这是当未登录或者token失效访问接口时，返回自定义的JSON格式结果。</p><p><strong>第十五步</strong>，在dto包内定义一个名为<code>UmsAdminLoginParam</code>的类，这是后台管理员登录参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录参数</span><br><span class="line"> */</span><br><span class="line">public class UmsAdminLoginParam &#123;</span><br><span class="line">    @ApiModelProperty(value = &quot;用户名&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;用户名不能为空&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @ApiModelProperty(value = &quot;密码&quot;, required = true)</span><br><span class="line">    @NotEmpty(message = &quot;密码不能为空&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，在controller包内定义一个名为<code>UmsAdminController</code>的类，这是后台管理员登录注册功能的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 后台管理员登录注册功能Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags = &quot;UmsAdminController&quot;, description = &quot;后台用户管理&quot;)</span><br><span class="line">@RequestMapping(&quot;/admin&quot;)</span><br><span class="line">public class UmsAdminController &#123;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span><br><span class="line">    private String tokenHeader;</span><br><span class="line">    @Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span><br><span class="line">    private String tokenHead;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsAdminService adminService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;用户注册&quot;)</span><br><span class="line">    @PostMapping(&quot;/register&quot;)</span><br><span class="line">    public CommonResult&lt;UmsAdmin&gt; register(@RequestBody UmsAdmin umsAdminParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        UmsAdmin umsAdmin = adminService.register(umsAdminParam);</span><br><span class="line">        if (umsAdmin == null) &#123;</span><br><span class="line">            return CommonResult.failed();</span><br><span class="line">        &#125;</span><br><span class="line">        return CommonResult.success(umsAdmin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = &quot;登录后返回token&quot;)</span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public CommonResult login(@Validated @RequestBody UmsAdminLoginParam umsAdminLoginParam, BindingResult result) &#123;</span><br><span class="line">        if (result.hasErrors()) &#123;</span><br><span class="line">            return CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());</span><br><span class="line">        if (token == null) &#123;</span><br><span class="line">            return CommonResult.validateFailed(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;();</span><br><span class="line">        tokenMap.put(&quot;token&quot;, token);</span><br><span class="line">        tokenMap.put(&quot;tokenHead&quot;, tokenHead);</span><br><span class="line">        return CommonResult.success(tokenMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取用户所有权限（包括+-权限）&quot;)</span><br><span class="line">    @GetMapping(&quot;/permission/&#123;adminId&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public CommonResult&lt;List&lt;UmsPermission&gt;&gt; getPermissionList(@PathVariable @ApiParam(&quot;后台用户id&quot;)Long adminId) &#123;</span><br><span class="line">        List&lt;UmsPermission&gt; permissionList = adminService.getPermissionList(adminId);</span><br><span class="line">        return CommonResult.success(permissionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们只提供了三个接口，分别是后台用户登录、注册以及获取对应权限的接口。</p><p><strong>第十七步</strong>，修改config包中Swagger2Config类的代码为如下所示，这里其实就是实现接口调用时自带Authorization头，后续就可以访问需要登录的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopspringsecurityjwt.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                //添加登录认证</span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;ApiKey&gt; securitySchemes() &#123;</span><br><span class="line">        //设置请求头信息</span><br><span class="line">        List&lt;ApiKey&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        ApiKey apiKey = new ApiKey(&quot;Authorization&quot;, &quot;Authorization&quot;, &quot;header&quot;);</span><br><span class="line">        result.add(apiKey);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        //设置需要登录认证的路径</span><br><span class="line">        List&lt;SecurityContext&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        result.add(getContextByPath(&quot;/brand/.*&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private SecurityContext getContextByPath(String pathRegex)&#123;</span><br><span class="line">        return SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(pathRegex))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;SecurityReference&gt; defaultAuth() &#123;</span><br><span class="line">        List&lt;SecurityReference&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        AuthorizationScope authorizationScope = new AuthorizationScope(&quot;global&quot;, &quot;accessEverything&quot;);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = new AuthorizationScope[1];</span><br><span class="line">        authorizationScopes[0] = authorizationScope;</span><br><span class="line">        result.add(new SecurityReference(&quot;Authorization&quot;, authorizationScopes));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在<code>securityContexts()</code>方法中设置了需要登录认证的路径，即品牌相关的接口访问都需要登录之后才能访问。</p><p><strong>第十八步</strong>，修改之前PmsBrandController类中的方法，我们给它们添加如下访问权限：<br>（1）给添加接口添加<code>pms:brand:create</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:create&#x27;)&quot;)</span><br><span class="line">public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)</span><br></pre></td></tr></table></figure><p>（2）给删除接口添加<code>pms:brand:delete</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:delete&#x27;)&quot;)</span><br><span class="line">public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)</span><br></pre></td></tr></table></figure><p>（3）给修改接口添加<code>pms:brand:update</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:update&#x27;)&quot;)</span><br><span class="line">public CommonResult updateBrand(</span><br><span class="line">    @PathVariable(&quot;id&quot;) Long id,</span><br><span class="line">    @RequestBody PmsBrand pmsBrandDTO, </span><br><span class="line">    BindingResult result</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（4）给查询接口添加<code>pms:brand:read</code>权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">@PreAuthorize(&quot;hasAuthority(&#x27;pms:brand:read&#x27;)&quot;)</span><br><span class="line">public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)</span><br></pre></td></tr></table></figure><p>注意这里面的权限就是<code>ums_permission</code>数据表中value字段的值，因此值必须按照要求进行书写：</p><p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6fcc1f9d38bfc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p><p><strong>第十九步</strong>，修改项目启动类<code>ShopSpringSecurityJwtApplication</code>，在其上面使用<code>@MapperScan</code>注解来指定扫描的mapper接口路径，注意我们的mapper接口路径有两个，因此需要使用字符串数组来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&#123;&quot;com.kenbings.shop.shopspringsecurityjwt.mbg.mapper&quot;,&quot;com.kenbings.shop.shopspringsecurityjwt.dao&quot;&#125;)</span><br><span class="line">public class ShopSpringSecurityJwtApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      SpringApplication.run(ShopSpringSecurityJwtApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二十步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8f52c710416dae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>首先是未登录，访问<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到返回之前定义的JSON信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f2c2db75536ff30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ac173bb1a1feff3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们尝试进行登录，登录账号为kenbings，密码为kenbings，访问<code>/admin/login</code>接口：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fc4d2180603d3d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-12b5fc8e6fb6bcbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们已经登录成功了，接下来点击右侧的Authorize按钮，在弹框中输入登录接口中获取到的token信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2d6b3eb1c1600269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后我们再来访问之前的<code>/admin/permission/&#123;adminId&#125;</code>接口，可以看到该接口已经可以正常访问了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa6f5902c79f4d44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后我们再来访问一些需要权限的接口，如获取商品品牌管理中获取所有品牌信息的接口<code>/brand/listAll</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-129799d3530a2051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这是正常结果，因为当前用户没有任何权限，我们给这个用户可以访问该接口的权限，接着再去访问一下该接口，可以看到数据能正常返回了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ca370de9d75a069.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合SpringSecurity和JWT实现认证与授权的学习就完成了，后续介绍如何整合ElasticSearch实现商品搜索这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-springsecurity-jwt">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第三篇《整合Redis实现数据缓存》的基础上整合SpringSecurity和JWT，实现认证与授权这一功能。&lt;/p</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Redis实现数据缓存</title>
    <link href="http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/"/>
    <id>http://envyzhan.asia/2023/01/12/2023-3-integrate-redis-to-achieve-data-caching/</id>
    <published>2023-01-12T06:55:30.000Z</published>
    <updated>2023-03-14T06:32:47.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。</p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个使用C语言开发的高性能键值对数据库，可用于数据缓存，以实现大量数据的高并发负载访问。</p><p>点击 <a href="https://github.com/MicrosoftArchive/redis/releases">这里</a> 下载Redis，选择3.2.100的版本进行下载：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-26cb65d7746bafdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>下载之后解压到指定目录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4369236c61892f6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着打开终端，切换到上述解压目录，执行redis启动命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><p>可以看到此时redis就已经启动成功了。</p><h1 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h1><p><strong>第一步</strong>，复制一份<code>shop-swagger-ui</code>源码，将其名字修改为<code>shop-redis</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-redis</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-redis</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis依赖配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，往application.yml配置文件中在指定位置处新增如下配置信息。首先在spring节点下新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost # Redis服务器地址</span><br><span class="line">    database: 2 # Redis数据库索引（默认为0）</span><br><span class="line">    port: 6379 # Redis服务器连接端口</span><br><span class="line">    password: envy123 # Redis服务器连接密码（默认为空）</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">        max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">        max-idle: 8 # 连接池中的最大空闲连接</span><br><span class="line">        min-idle: 0 # 连接池中的最小空闲连接</span><br><span class="line">    timeout: 3000ms # 连接超时时间（毫秒）</span><br></pre></td></tr></table></figure><p>然后在根节点下添加Redis自定义key的相关配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 自定义redis的key</span><br><span class="line">redis:</span><br><span class="line">  key:</span><br><span class="line">    prefix:</span><br><span class="line">      authCode: &quot;portal:authCode:&quot;</span><br><span class="line">    expire:</span><br><span class="line">      authCode: 120 # 验证码超期时间，单位秒</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在service包内定义一个名为RedisService的接口，用于定义一些常用的Redis操作，此处我们让对象和数组都以JSON形式进行存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Redis操作</span><br><span class="line"> * 对象和数组都以JSON形式进行存储</span><br><span class="line"> */</span><br><span class="line">public interface RedisService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存储数据</span><br><span class="line">     */</span><br><span class="line">    void set(String key,String value);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取数据</span><br><span class="line">     */</span><br><span class="line">    String get(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置超期时间</span><br><span class="line">     */</span><br><span class="line">    boolean expire(String key,long expire);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    void remove(String key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自增操作</span><br><span class="line">     * @param delta 自增步长</span><br><span class="line">     */</span><br><span class="line">    Long increment(String key,long delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在impl包内定义一个名为RedisServiceImpl的类，这个类需要实现RedisService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RedisServiceImpl implements RedisService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set(String key, String value) &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String get(String key) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean expire(String key, long expire) &#123;</span><br><span class="line">        return stringRedisTemplate.expire(key,expire, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void remove(String key) &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Long increment(String key, long delta) &#123;</span><br><span class="line">        return stringRedisTemplate.opsForValue().increment(key,delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，这里我们以会员发送验证码为例来介绍如何使用Redis。在service包内定义一个名为UmsMemberService的接口，用于定义会员管理相关的接口方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service</span><br><span class="line"> */</span><br><span class="line">public interface UmsMemberService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据手机号生成验证码</span><br><span class="line">     */</span><br><span class="line">    CommonResult generateAuthCode(String telephone);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断验证码和手机号是否匹配</span><br><span class="line">     */</span><br><span class="line">    CommonResult verifyAuthCode(String telephone,String authCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，在impl包内定义一个名为UmsMemberServiceImpl的类，这个类需要实现UmsMemberService接口，并重写其中的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Service实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UmsMemberServiceImpl implements UmsMemberService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService redisService;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.prefix.authCode&#125;&quot;)</span><br><span class="line">    private String REDIS_KEY_PREFIX_AUTH_CODE;</span><br><span class="line">    @Value(&quot;$&#123;redis.key.expire.authCode&#125;&quot;)</span><br><span class="line">    private Long AUTH_CODE_EXPIRE_SECONDS;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult generateAuthCode(String telephone) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">            stringBuilder.append(random.nextInt(10));</span><br><span class="line">        &#125;</span><br><span class="line">        String authCode = stringBuilder.toString();</span><br><span class="line">        //验证码+手机号作为Key存储到Redis中</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        redisService.set(redisKey,authCode);</span><br><span class="line">        redisService.expire(redisKey,AUTH_CODE_EXPIRE_SECONDS);</span><br><span class="line">        return CommonResult.success(authCode,&quot;验证码获取成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CommonResult verifyAuthCode(String telephone, String authCode) &#123;</span><br><span class="line">        if(StringUtils.isEmpty(authCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;请输入验证码&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String redisKey = REDIS_KEY_PREFIX_AUTH_CODE + telephone;</span><br><span class="line">        String redisAuthCode = redisService.get(redisKey);</span><br><span class="line">        if(StringUtils.isEmpty(redisAuthCode))&#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean result = authCode.equals(redisAuthCode);</span><br><span class="line">        if(result)&#123;</span><br><span class="line">            return CommonResult.success(null,&quot;验证码校验成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return CommonResult.failed(&quot;验证码不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，在controller包内定义一个名为UmsMemberController的类，这是会员登录注册管理的Controller：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会员管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;UmsMemberController&quot;,description = &quot;会员登录注册管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/sso&quot;)</span><br><span class="line">public class UmsMemberController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UmsMemberService umsMemberService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;获取验证码&quot;)</span><br><span class="line">    @GetMapping(&quot;/getAuthCode&quot;)</span><br><span class="line">    public CommonResult getAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone)&#123;</span><br><span class="line">        return umsMemberService.generateAuthCode(telephone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;校验验证码是否正确&quot;)</span><br><span class="line">    @PostMapping(&quot;/verifyAuthCode&quot;)</span><br><span class="line">    public CommonResult verifyAuthCode(@RequestParam @ApiParam(&quot;手机号&quot;)String telephone,@ApiParam(&quot;验证码&quot;)@RequestParam String authCode)&#123;</span><br><span class="line">        return umsMemberService.verifyAuthCode(telephone,authCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，可以看到新的接口已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-88a3bea3216897d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后测试获取验证码的接口，可以发现测试是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3abff9e3628d2059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来看一下校验验证码是否正确的接口，发现测试也是通过的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4ed658578a9933b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Redis实现数据缓存的学习就完成了，后续介绍如何整合SpringSecurity和JWT实现认证与授权这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-redis">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第二篇《整合Swagger-UI实现在线API文档》的基础上整合Redis，实现数据缓存这一功能。&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>整合Swagger-UI实现在线API文档</title>
    <link href="http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/"/>
    <id>http://envyzhan.asia/2023/01/10/2023-2-integrate-swagger-ui-to-realize-online-API-documentation/</id>
    <published>2023-01-10T02:55:30.000Z</published>
    <updated>2023-03-14T06:29:52.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。</p><h1 id="Swagger-UI简介"><a href="#Swagger-UI简介" class="headerlink" title="Swagger-UI简介"></a>Swagger-UI简介</h1><p>Swagger-UI是HTML、CSS和Javascript的一个集合，可以动态地根据注解生成在线API文档，本篇将要整合的Swagger-UI版本为2系列。</p><p>Swagger-UI常用的一些注解如下所示：<br>（1）<code>@Api</code>：用于修饰Controller类，可生成Controller相关的文档信息；<br>（2）<code>@ApiOperation</code>：用于修饰Controller类中的方法，可生成接口方法相关的文档信息；<br>（3）<code>@ApiParam</code>：用于修饰接口中方法的参数，可生成接口参数相关的文档信息；<br>（4）<code>@ApiModelProperty</code>：用于修饰实体类的属性，当实体类是请求参数或返回结果时，会直接生成相关的文档信息。</p><p>关于Swagger-UI的详细介绍，可以参阅笔者其他的文章，此处不做过多介绍。</p><h1 id="整合Swagger-UI"><a href="#整合Swagger-UI" class="headerlink" title="整合Swagger-UI"></a>整合Swagger-UI</h1><p><strong>第一步</strong>，复制一份<code>shop-basic</code>源码，将其名字修改为<code>shop-swagger-ui</code>，然后对应包和文件中的信息也记得修改，本篇后续所有操作均在<code>shop-swagger-ui</code>这一Module中进行。</p><p><strong>第二步</strong>，在<code>shop-swagger-ui</code>的POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.3.7&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;!--Swagger-UI API文档--&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意，<code>mybatis-generator-core</code>的版本必须从1.3.3修改为1.3.7，否则后续在生成API文档的时候会出现异常问题，以及新生成的mapper文件无法覆盖旧文件的情况。</p><p><strong>第三步</strong>，在config包内新建一个名为Swagger2Config的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Swagger2 API文档相关配置</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2Config &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                //为当前包下controller生成API文档</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br><span class="line">                //为有@Api注解的Controller生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br><span class="line">                //为有@ApiOperation注解的方法生成API文档</span><br><span class="line">//                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;整合SwaggerUI&quot;)</span><br><span class="line">                .description(&quot;myshop-all&quot;)</span><br><span class="line">                .contact(&quot;kenbings&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，Swagger UI对生成API文档的范围有三种选择，分别如下所示：<br>（1）生成指定包下类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;com.kenbings.shop.shopswaggerui.controller&quot;))</span><br></pre></td></tr></table></figure><p>（2）生成有指定注解的类的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withClassAnnotation(Api.class))</span><br></pre></td></tr></table></figure><p>（3）生成有指定注解的方法的API文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，给需要生成的Controller类添加Swagger注解，此处选择之前使用的品牌管理PmsBrandController类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@Api(tags = &quot;PmsBrandController&quot;,description = &quot;商品品牌管理&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取所有的品牌信息&quot;)</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;添加品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;更新指定id的品牌信息&quot;)</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;删除指定id的品牌&quot;)</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;分页查询品牌列表&quot;)</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)</span><br><span class="line">            @ApiParam(&quot;页码&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)</span><br><span class="line">            @ApiParam(&quot;每页数量&quot;) Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @ApiOperation(&quot;获取指定id的品牌详情&quot;)</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们充分使用了<code>@Api</code>、<code>@ApiOperation</code>和<code>@ApiParam</code>注解，没有使用到<code>@ApiModelProperty</code>注解，那是因为<code>@ApiModelProperty</code>注解用于修饰实体类的属性，我们如果要使用它，就要修改MyBatis Generator注释的生成规则。</p><p><strong>第五步</strong>，修改MyBatis Generator注释的生成规则。在前面我们说过，<code>CommentGenerator</code>类是自定义注释生成器，我们可以修改<code>addFieldComment</code>方法，使其可以生成Swagger的<code>@ApiModelProperty</code>注解来取代原来的方法注释。同时还需要添加<code>addJavaFileComment</code>方法，使其能在import中导入<code>@ApiModelProperty</code>，否则需要手动导入该类，这在需要生成大量实体类时，是一件非常痛苦的事情。</p><p><code>CommentGenerator</code>类中的代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line">    private static final String EXAMPLE_SUFFIX=&quot;Example&quot;;</span><br><span class="line">    private static final String API_MODEL_PROPERTY_FULL_CLASS_NAME=&quot;io.swagger.annotations.ApiModelProperty&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            //数据库中特殊字符需要转义</span><br><span class="line">            if(remarks.contains(&quot;\&quot;&quot;))&#123;</span><br><span class="line">                remarks = remarks.replace(&quot;\&quot;&quot;,&quot;&#x27;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //给model的字段添加swagger注解</span><br><span class="line">            field.addJavaDocLine(&quot;@ApiModelProperty(value = \&quot;&quot;+remarks+&quot;\&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addJavaFileComment(CompilationUnit compilationUnit) &#123;</span><br><span class="line">        super.addJavaFileComment(compilationUnit);</span><br><span class="line">        //只在model中添加swagger注解类的导入</span><br><span class="line">        if(!compilationUnit.isJavaInterface()&amp;&amp;!compilationUnit.getType().getFullyQualifiedName().contains(EXAMPLE_SUFFIX))&#123;</span><br><span class="line">            compilationUnit.addImportedType(new FullyQualifiedJavaType(API_MODEL_PROPERTY_FULL_CLASS_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在<code>generatorConfig.xml</code>文件中新增一行配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--生成mapper.xml时覆盖原文件--&gt;</span><br><span class="line">&lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;</span><br></pre></td></tr></table></figure><p>注意配置项的放置位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e333f0646a2cb799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第七步</strong>，执行Generator类中的main方法，可以看到此时会重新生成mbg中的代码。</p><p>可以看到新生成的PmsBrand类里面，已经根据数据库注释自动添加了<code>@ApiModelProperty</code>注解：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7b29773035cf8a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第八步</strong>，启动项目，访问Swagger-UI接口文档地址，即浏览器访问<code>http://localhost:8080/swagger-ui.html</code>链接，效果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b7ab59b14cb1cfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击添加品牌按钮，可以看到里面已经显示从<code>@ApiModelProperty</code>文件中生成的说明信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-76a53338333057a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>点击分页查询品牌列表，可以看到返回结果也已经进行了说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ba083acf7836a3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>同时开发者可以直接在文档上进行接口测试，这里以查询id为1的品牌详情信息为例进行说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-899fc1f73cb9b6e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fa9c286cf227f08f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样本篇关于整合Swagger-UI实现在线API文档的学习就完成了，后续介绍如何整合单机版Redis实现缓存这一功能。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-swagger-ui">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文将在第一篇《项目骨架搭建》的基础上整合Swagger-UI，实现可以在线阅读API文档这一功能。&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>项目骨架搭建</title>
    <link href="http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/"/>
    <id>http://envyzhan.asia/2023/01/08/2023-1-project-skeleton-construction/</id>
    <published>2023-01-08T09:55:30.000Z</published>
    <updated>2023-03-14T06:27:04.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操作，以及通过PageHelper实现分页查询。</p><h1 id="使用的框架简介"><a href="#使用的框架简介" class="headerlink" title="使用的框架简介"></a>使用的框架简介</h1><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>一个基于Spring的快速搭建Java企业级应用的开发框架。</p><h3 id="Mybatis-generator"><a href="#Mybatis-generator" class="headerlink" title="Mybatis generator"></a>Mybatis generator</h3><p>Mybatis代码生成器，可根据数据库生成对应的model、mapper.xml、mapper接口以及Example，这样一般的单表查询不用再手写mapper。</p><h3 id="PagerHelper"><a href="#PagerHelper" class="headerlink" title="PagerHelper"></a>PagerHelper</h3><p>MyBatis分页插件，只需几行简单事务代码就能实现分页功能。如果你使用的是SpringBoot，那么只要整合了PagerHelper就自动整合了MyBatis：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">//之后进行查询操作将自动进行分页</span><br><span class="line">List&lt;PmsBrand&gt; brandList = brandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">//通过构造PageInfo对象获取分页信息，如当前页码，总页数，总条数</span><br><span class="line">PageInfo&lt;PmsBrand&gt; pageInfo = new PageInfo&lt;PmsBrand&gt;(list);</span><br></pre></td></tr></table></figure><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>阿里巴巴开源的数据库连接池，性能极佳，提供了多种特性和功能。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p><strong>第一步</strong>，使用Maven新建一个名为myshop-all的项目：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-87cd54660844c03b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，删除其中的src目录，并修改其中的pom文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;myshop-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;shop-basic&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，在myshop-all目录下，使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为shop-basic的Module：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-14744df2535d4ea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第四步</strong>，修改<code>shop-basic</code>这一web项目的pom文件内容为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kenbings.shop&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shop-basic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;shop-basic&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;项目骨架搭建&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--SpringBoot通用依赖模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--MyBatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--集成druid连接池--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MyBatis 生成器 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--Mysql数据库驱动--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，修改<code>shop-basic</code>这一web项目的application.yml配置文件为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: envy123</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations:</span><br><span class="line">    - classpath:mapper/*.xml</span><br><span class="line">    - classpath*:com/**/mapper/*.xml</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，新建<code>com.kenbings.shop.shopbasic.common.api</code>这两级目录，然后在api目录中新建IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 封装API的错误码</span><br><span class="line"> */</span><br><span class="line">public interface IErrorCode &#123;</span><br><span class="line">    long getCode();</span><br><span class="line"></span><br><span class="line">    String getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建ResultCode枚举类，需要实现之前的IErrorCode接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一些常用API操作码枚举类</span><br><span class="line"> */</span><br><span class="line">public enum ResultCode implements IErrorCode&#123;</span><br><span class="line">    SUCCESS(200, &quot;操作成功&quot;),</span><br><span class="line">    FAILED(500, &quot;操作失败&quot;),</span><br><span class="line">    VALIDATE_FAILED(404, &quot;参数检验失败&quot;),</span><br><span class="line">    UNAUTHORIZED(401, &quot;暂未登录或token已经过期&quot;),</span><br><span class="line">    FORBIDDEN(403, &quot;没有相关权限&quot;);</span><br><span class="line"></span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    private ResultCode(long code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonResult类，用于构建一个通用的返回对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通用返回对象</span><br><span class="line"> */</span><br><span class="line">public class CommonResult&lt;T&gt; &#123;</span><br><span class="line">    private long code;</span><br><span class="line">    private String message;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    public CommonResult()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public CommonResult(long code,String message,T data)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMessage(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成功返回数据</span><br><span class="line">     * @param data 返回的数据</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; success(T data,String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.SUCCESS.getCode(), message,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param errorCode 返回的错误码</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(IErrorCode errorCode)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(errorCode.getCode(),errorCode.getMessage(),null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回数据</span><br><span class="line">     * @param message 返回的提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed(String message)&#123;</span><br><span class="line">        return new CommonResult&lt;&gt;(ResultCode.FAILED.getCode(), message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; failed() &#123;</span><br><span class="line">        return failed(ResultCode.FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed() &#123;</span><br><span class="line">        return failed(ResultCode.VALIDATE_FAILED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 参数验证失败返回结果</span><br><span class="line">     * @param message 提示信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; validateFailed(String message) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.VALIDATE_FAILED.getCode(), message, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未登录返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; unauthorized(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.UNAUTHORIZED.getCode(), ResultCode.UNAUTHORIZED.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 未授权返回结果</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonResult&lt;T&gt; forbidden(T data) &#123;</span><br><span class="line">        return new CommonResult&lt;T&gt;(ResultCode.FORBIDDEN.getCode(), ResultCode.FORBIDDEN.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(long code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(T data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建CommonPage类，这是一个用于封装分页数据的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 分页数据封装类</span><br><span class="line"> */</span><br><span class="line">public class CommonPage&lt;T&gt; &#123;</span><br><span class="line">    private Integer pageNum;</span><br><span class="line">    private Integer pageSize;</span><br><span class="line">    private Integer totalPage;</span><br><span class="line">    private Long total;</span><br><span class="line">    private List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将 PageHelper 分页后的list转换为分页信息</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; CommonPage&lt;T&gt; restPage(List&lt;T&gt; list)&#123;</span><br><span class="line">        CommonPage&lt;T&gt; commonPage = new CommonPage&lt;&gt;();</span><br><span class="line">        PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(list);</span><br><span class="line">        commonPage.setPageNum(pageInfo.getPageNum());</span><br><span class="line">        commonPage.setPageSize(pageInfo.getPageSize());</span><br><span class="line">        commonPage.setTotalPage(pageInfo.getPages());</span><br><span class="line">        commonPage.setTotal(pageInfo.getTotal());</span><br><span class="line">        commonPage.setList(pageInfo.getList());</span><br><span class="line">        return commonPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageNum() &#123;</span><br><span class="line">        return pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageNum(Integer pageNum) &#123;</span><br><span class="line">        this.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getPageSize() &#123;</span><br><span class="line">        return pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPageSize(Integer pageSize) &#123;</span><br><span class="line">        this.pageSize = pageSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getTotalPage() &#123;</span><br><span class="line">        return totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotalPage(Integer totalPage) &#123;</span><br><span class="line">        this.totalPage = totalPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getList() &#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">        this.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getTotal() &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTotal(Long total) &#123;</span><br><span class="line">        this.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步</strong>，新建<code>com.kenbings.shop.shopbasic.config</code>目录，在里面定义一个名为MyBatisConfig的类，用于设置动态生成的mapper接口的路径信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis配置类</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;)</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第八步</strong>，新建<code>com.kenbings.shop.shopbasic.mbg</code>目录，在里面定义一个名为CommentGenerator的类，它需要继承DefaultCommentGenerator类，用于自定义注释生成器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义注释生成器</span><br><span class="line"> */</span><br><span class="line">public class CommentGenerator extends DefaultCommentGenerator &#123;</span><br><span class="line">    private boolean addRemarkComments = false;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *设置用户配置的参数</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addConfigurationProperties(Properties properties) &#123;</span><br><span class="line">        super.addConfigurationProperties(properties);</span><br><span class="line">        this.addRemarkComments = StringUtility.isTrue(properties.getProperty(&quot;addRemarkComments&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给字段添加注释</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addFieldComment(Field field, IntrospectedTable introspectedTable,</span><br><span class="line">                                IntrospectedColumn introspectedColumn) &#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        //根据参数和备注信息来判断是否添加备注信息</span><br><span class="line">        if (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            addFieldJavaDoc(field, remarks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给model的字段添加注释</span><br><span class="line">     */</span><br><span class="line">    private void addFieldJavaDoc(Field field, String remarks) &#123;</span><br><span class="line">        //文档注释开始</span><br><span class="line">        field.addJavaDocLine(&quot;/**&quot;);</span><br><span class="line">        //获取数据库字段的备注信息</span><br><span class="line">        String[] remarkLines = remarks.split(System.getProperty(&quot;line.separator&quot;));</span><br><span class="line">        for (String remarkLine : remarkLines) &#123;</span><br><span class="line">            field.addJavaDocLine(&quot; * &quot; + remarkLine);</span><br><span class="line">        &#125;</span><br><span class="line">        addJavadocTag(field, false);</span><br><span class="line">        //文档注释结束</span><br><span class="line">        field.addJavaDocLine(&quot; */&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步</strong>，在mbg目录下新建一个名为Generator的类，用于执行MBG的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用于执行MBG的代码</span><br><span class="line"> */</span><br><span class="line">public class Generator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // MBG 执行过程中的警告信息</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        //当生成的代码重复时，覆盖原代码</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        //读取我们的 MBG 配置文件</span><br><span class="line">        InputStream inputStream = Generator.class.getResourceAsStream(&quot;/generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser configurationParser = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = configurationParser.parseConfiguration(inputStream);</span><br><span class="line">        inputStream.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        //创建 MBG</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        //执行生成代码</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">        //输出警告信息</span><br><span class="line">        for (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步</strong>，在resources目录下新建一个名为<code>generatorConfig.xml</code>的配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;properties resource=&quot;generator.properties&quot;/&gt;</span><br><span class="line">    &lt;context id=&quot;MySqlContext&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 为模型生成序列化方法--&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;/&gt;</span><br><span class="line">        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;</span><br><span class="line">        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;/&gt;</span><br><span class="line">        &lt;!--可以自定义生成model的代码注释--&gt;</span><br><span class="line">        &lt;commentGenerator type=&quot;com.kenbings.shop.shopbasic.mbg.CommentGenerator&quot;&gt;</span><br><span class="line">            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;addRemarkComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--配置数据库连接--&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;$&#123;jdbc.driverClass&#125;&quot;</span><br><span class="line">                        connectionURL=&quot;$&#123;jdbc.connectionURL&#125;&quot;</span><br><span class="line">                        userId=&quot;$&#123;jdbc.userId&#125;&quot;</span><br><span class="line">                        password=&quot;$&#123;jdbc.password&#125;&quot;&gt;</span><br><span class="line">            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;</span><br><span class="line">            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!--指定生成model的路径--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.model&quot; targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper.xml的路径--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot; targetProject=&quot;shop-basic\src\main\resources&quot;/&gt;</span><br><span class="line">        &lt;!--指定生成mapper接口的的路径--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.kenbings.shop.shopbasic.mbg.mapper&quot;</span><br><span class="line">                             targetProject=&quot;shop-basic\src\main\java&quot;/&gt;</span><br><span class="line">        &lt;!--生成全部表tableName设为%--&gt;</span><br><span class="line">        &lt;table tableName=&quot;pms_brand&quot;&gt;</span><br><span class="line">            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MySql&quot; identity=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p><strong>第十一步</strong>，在resources目录下新建一个名为<code>generator.properties</code>的数据配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.connectionURL=jdbc:mysql://localhost:3306/shop?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">jdbc.userId=root</span><br><span class="line">jdbc.password=envy123</span><br></pre></td></tr></table></figure><p><strong>第十二步</strong>，打开数据库，执行如下SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS shop;</span><br><span class="line">CREATE DATABASE shop;</span><br><span class="line">USE shop;</span><br><span class="line">DROP TABLE IF EXISTS pms_brand;</span><br><span class="line">CREATE TABLE `pms_brand` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,</span><br><span class="line">  `first_letter` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;首字母&#x27;,</span><br><span class="line">  `sort` int DEFAULT NULL,</span><br><span class="line">  `factory_status` int DEFAULT NULL COMMENT &#x27;是否为品牌制造商：0-&gt;不是；1-&gt;是&#x27;,</span><br><span class="line">  `show_status` int DEFAULT NULL,</span><br><span class="line">  `product_count` int DEFAULT NULL COMMENT &#x27;产品数量&#x27;,</span><br><span class="line">  `product_comment_count` int DEFAULT NULL COMMENT &#x27;产品评论数量&#x27;,</span><br><span class="line">  `logo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;品牌logo&#x27;,</span><br><span class="line">  `big_pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT &#x27;专区大图&#x27;,</span><br><span class="line">  `brand_story` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT &#x27;品牌故事&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=59 DEFAULT CHARSET=utf8mb3 COMMENT=&#x27;品牌表&#x27;;</span><br></pre></td></tr></table></figure><p>此时我们项目的基本骨架如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a2e09010d13779a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十三步</strong>，执行Generator类中的main方法，可以看到此时生成后的目录结构如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3bf6f596d7e6e682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第十四步</strong>，新建<code>com.kenbings.shop.shopbasic.service</code>目录，并在里面新建一个名为PmsBrandService的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface PmsBrandService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listAllBrand();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    int createBrand(PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    int updateBrand(Long id,PmsBrand pmsBrand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    int deleteBrand(Long id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    PmsBrand getBrand(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十五步</strong>，在之前的service目录中新建一个名为impl的目录，然后在impl目录中新建一个名为PmsBrandServiceImpl的类，注意这个类需要实现PmsBrandService接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class PmsBrandServiceImpl implements PmsBrandService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandMapper pmsBrandMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listAllBrand() &#123;</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int createBrand(PmsBrand pmsBrand) &#123;</span><br><span class="line">        return pmsBrandMapper.insertSelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int updateBrand(Long id, PmsBrand pmsBrand) &#123;</span><br><span class="line">        pmsBrand.setId(id);</span><br><span class="line">        return pmsBrandMapper.updateByPrimaryKeySelective(pmsBrand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int deleteBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PmsBrand&gt; listBrand(int pageNum, int pageSize) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        return pmsBrandMapper.selectByExample(new PmsBrandExample());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PmsBrand getBrand(Long id) &#123;</span><br><span class="line">        return pmsBrandMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十六步</strong>，新建<code>com.kenbings.shop.shopbasic.controller</code>目录，并在里面新建一个名为PmsBrandController的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 品牌管理Controller</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/brand&quot;)</span><br><span class="line">public class PmsBrandController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PmsBrandService pmsBrandService;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(PmsBrandController.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/listAll&quot;)</span><br><span class="line">    public CommonResult&lt;List&lt;PmsBrand&gt;&gt; getBrandList()&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.listAllBrand());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/create&quot;)</span><br><span class="line">    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.createBrand(pmsBrand);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrand);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建成功:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌创建失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌创建失败:&#123;&#125;&quot;,pmsBrand);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改一个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/update/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult updateBrand(@PathVariable(&quot;id&quot;) Long id, @RequestBody PmsBrand pmsBrandDTO, BindingResult result)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        if(result.hasErrors())&#123;</span><br><span class="line">            commonResult = CommonResult.failed(result.getFieldError().getDefaultMessage());</span><br><span class="line">            return commonResult;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = pmsBrandService.updateBrand(id,pmsBrandDTO);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(pmsBrandDTO);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改成功:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌修改失败:&#123;&#125;&quot;,pmsBrandDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个品牌</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/delete/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult deleteBrand(@PathVariable(&quot;id&quot;) Long id)&#123;</span><br><span class="line">        CommonResult commonResult;</span><br><span class="line">        int count = pmsBrandService.deleteBrand(id);</span><br><span class="line">        if(count==1)&#123;</span><br><span class="line">            commonResult = CommonResult.success(null);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除成功:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            commonResult = CommonResult.failed(&quot;品牌修改失败&quot;);</span><br><span class="line">            LOGGER.debug(&quot;品牌删除失败:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">        return commonResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public CommonResult&lt;CommonPage&lt;PmsBrand&gt;&gt; listBrand(</span><br><span class="line">            @RequestParam(value = &quot;pageNum&quot;,defaultValue = &quot;1&quot;)Integer pageNum,</span><br><span class="line">            @RequestParam(value = &quot;pageSize&quot;,defaultValue = &quot;5&quot;)Integer pageSize</span><br><span class="line">    )&#123;</span><br><span class="line">        List&lt;PmsBrand&gt; pmsBrands = pmsBrandService.listBrand(pageNum, pageSize);</span><br><span class="line">        return CommonResult.success(CommonPage.restPage(pmsBrands));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取某个品牌信息</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public CommonResult&lt;PmsBrand&gt; getBrand(@PathVariable(&quot;id&quot;)Long id)&#123;</span><br><span class="line">        return CommonResult.success(pmsBrandService.getBrand(id));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第十七步</strong>，启动项目入口类ShopBasicApplication，打开浏览器进行测试，这里以访问id为1的品牌为例进行说明。</p><p>在浏览器地址栏中输入<code>http://localhost:8080/brand/1</code>，可以看到浏览器显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a87453b8a871d2a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样关于项目的骨架搭建就完成了，后续学习如何接入Swagger-UI实现API文档的在线使用。本篇笔记源码，可以点击 <a href="https://github.com/Envythink/myshop-all/tree/master/shop-basic">这里</a> 进行阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本文介绍如何通过SpringBoot+Mybatis来搭建一个电商系统的基本骨架，并以商品品牌管理为例来实现基本的CRUD操</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://envyzhan.asia/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的记录你的日志</title>
    <link href="http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/"/>
    <id>http://envyzhan.asia/2022/08/10/16-how-to-record-your-log-gracefully/</id>
    <published>2022-08-10T09:55:30.000Z</published>
    <updated>2022-09-12T09:07:53.909Z</updated>
    
    <content type="html"><![CDATA[<p>最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。</p><h1 id="操作日志使用场景"><a href="#操作日志使用场景" class="headerlink" title="操作日志使用场景"></a>操作日志使用场景</h1><h3 id="操作日志与系统日志区别"><a href="#操作日志与系统日志区别" class="headerlink" title="操作日志与系统日志区别"></a>操作日志与系统日志区别</h3><p>当对某个对象进行新增、修改和查询操作后，通常需要记录对象的新旧状态，这其实就是操作日志，一般而已操作日志都是给用户查阅的，因此可读性要求较高。最常见的就是物流信息的更新，这其实是针对该快递对象的更新记录，里面会告诉用户包裹转到何时何地。</p><p>而系统日志通常是作为开发人员排查和解决问题的依据，一般记录在指定的日志文件中，由于是给开发人员使用的，所以可读性要求不高，里面只记录一些重点信息，如代码当前输出的信息。</p><h3 id="操作日志分类"><a href="#操作日志分类" class="headerlink" title="操作日志分类"></a>操作日志分类</h3><p>一般来说，操作日志分类分为三类，下面依次进行简要学习：<br>（1）单纯的文本记录。举个例子，2021-12-01 10:00:00 用户登录。时间是动态但与其他内容关，其他信息都是固定值。<br>（2）简单的动态文本记录。举个例子，2021-12-01 10:00:00 用户：张三，创建订单，订单号为1000。用户名和订单号则与需要传入或者生成。<br>（3）记录对象的前后状态。举个例子，2021-12-01 10:00:00 用户：张三，修改了订单备注信息，由“微辣”修改为“中辣”。可以看到此处需要同时记录对象的前后状态。</p><p>当然实际可能修改的字段不止以上几种，可能涉及到的内容较多，但基本上和上述三类差异不大。</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h3 id="使用Canal监听数据库"><a href="#使用Canal监听数据库" class="headerlink" title="使用Canal监听数据库"></a>使用Canal监听数据库</h3><p>Canal是一款基于MySQL数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库Binglog的方式来知道具体是哪些数据发生了修改，然后根据修改的数据来记录用户操作日志。</p><p>这种方式完全不侵入原来的业务代码，但是缺点也很明显，就是只能针对数据库的更改做记录，如果涉及到其他团队的RPC调用，这无法监听数据库因此只能手动记录操作日志。举个简单的例子，用户下单后调用短信通知服务，告诉用户下单成功，毫无疑问短信通知服务肯定是公共服务，只能下单方法调用了这个RPC，那么只能在下单方法中记录给用户发送通知的操作记录。关于一部分的内容，可以参考后续文章。</p><h3 id="通过日志文件记录"><a href="#通过日志文件记录" class="headerlink" title="通过日志文件记录"></a>通过日志文件记录</h3><p>通过日志文件方式，这是最常用的方式，直接在调用的时候输出一些调用信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;用户登录&quot;);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，创建订单，订单号为&#123;&#125;&quot;,userId,orderId);</span><br><span class="line">log.info(&quot;用户：&#123;&#125;，修改了订单备注信息，由“&#123;&#125;”修改为“&#123;&#125;”&quot;,userId,oldInfo,newInfo);</span><br></pre></td></tr></table></figure><p>可以看到这里存在三个问题：（1）如何获取到用户信息；（2）操作日志如何与系统日志分开；（3）如何生成可读性高的日志信息。</p><h5 id="如何获取到用户信息"><a href="#如何获取到用户信息" class="headerlink" title="如何获取到用户信息"></a>如何获取到用户信息</h5><p>如何获取用户信息，这里有很多种方式，可以通过拦截器或者AOP方式，传入请求然后从请求中获取，并将用户信息存入MDC（Mapped Diagnostic Context，映射调试上下文）中，那么相应的伪代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserInterceptor extends HandlerInterceptor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    //获取到用户ID</span><br><span class="line">    String userId = getUserInfo(request);</span><br><span class="line">    //把用户ID放入MDC上下文中</span><br><span class="line">    MDC.put(&quot;userId&quot;, userId );</span><br><span class="line">    return super.preHandle(request, response, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private String getUserInfo(HttpServletRequest request) &#123;</span><br><span class="line">    // 通过SSO、Cookie或者Auth信息获取当前登陆的用户信息</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将用户ID格式化到日志文件中，可使用<code>%X&#123;userId&#125;</code>变量来获取MDC中的用户ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br></pre></td></tr></table></figure><h5 id="操作日志如何与系统日志分开"><a href="#操作日志如何与系统日志分开" class="headerlink" title="操作日志如何与系统日志分开"></a>操作日志如何与系统日志分开</h5><p>针对这种情况，通俗做法就是通过Log的配置文件来将操作日志放到单独的日志文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=&quot;businessLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;File&gt;logs/business.log&lt;/File&gt;</span><br><span class="line">    &lt;append&gt;true&lt;/append&gt;</span><br><span class="line">    &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;</span><br><span class="line">        &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;</span><br><span class="line">        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">        &lt;fileNamePattern&gt;logs/业务A.%d.%i.log&lt;/fileNamePattern&gt;</span><br><span class="line">        &lt;maxHistory&gt;90&lt;/maxHistory&gt;</span><br><span class="line">        &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;</span><br><span class="line">            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;&lt;/pattern&gt;</span><br><span class="line">        &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">&lt;/appender&gt;</span><br><span class="line">        </span><br><span class="line">&lt;logger name=&quot;userlogInLog&quot; additivity=&quot;false&quot; level=&quot;INFO&quot;&gt;</span><br><span class="line">    &lt;appender-ref ref=&quot;userlogInLogAppender&quot;/&gt;</span><br><span class="line">&lt;/logger&gt;</span><br></pre></td></tr></table></figure><p>之后只需在使用的时候记录一下这个日志即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//记录特定的日志类</span><br><span class="line">private final Logger userlogInLog= LoggerFactory.getLogger(&quot;userlogInLog&quot;);</span><br><span class="line"> </span><br><span class="line">//日志存储</span><br><span class="line">userlogInLog.info(&quot;用户登录&quot;);</span><br></pre></td></tr></table></figure><h5 id="如何生成可读性高的日志信息"><a href="#如何生成可读性高的日志信息" class="headerlink" title="如何生成可读性高的日志信息"></a>如何生成可读性高的日志信息</h5><p>这种一般可以使用AOP或者LogUtil方式，之后将生成的日志单独保存在一个文件中，后续通过ELK系统将其收集、过滤、存储和展示。</p><h3 id="通过LogUtil方式记录"><a href="#通过LogUtil方式记录" class="headerlink" title="通过LogUtil方式记录"></a>通过LogUtil方式记录</h3><p>可以在业务逻辑代码中调用封装好的日志记录工具类来随时记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogUtil.log(&quot;用户登录，登录人：%s&quot;,userId)</span><br><span class="line">LogUtil.log(&quot;用户：%s，创建订单，订单号为%d&quot;,userId,orderId);</span><br><span class="line">String template = &quot;用户：%s，修改了订单号%d的备注信息，由“%s”修改为“%s”&quot;;</span><br><span class="line">LogUtil.log(String.format(tempalte, &quot;张三&quot;, &quot;10001, &quot;微辣&quot;,&quot;中辣&quot;));</span><br></pre></td></tr></table></figure><p>这只是记录用户的简单操作，在实际开发过程中可能比这要复杂的多，可能针对不同的业务逻辑，记录的格式和值完全不同，更重要的是将日志这种与实际业务逻辑不相关的内容深度融合在了业务代码中。</p><h3 id="通过AOP方式记录"><a href="#通过AOP方式记录" class="headerlink" title="通过AOP方式记录"></a>通过AOP方式记录</h3><p>为了让日志与业务逻辑解耦，更多的是使用AOP配合注解方式来记录用户操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以做到完全不侵入业务代码，但是记录的日志格式不符合预期，格式是固定的，其实这个可以使用动态模板来实现。</p><h1 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h1><p>动态模板其实就是通过解析变量占位符来解析模板，进而实现通过注解记录操作日志这一目的。模板解析的方式有很多种，这里使用SpEL（Spring Expression Language）来实现，我们希望的日志记录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别看上面的日志输出格式只提到了oldRemark和newRemark这两个参数，其实隐含了两个更重要的信息，即操作人和订单id，那么这两个参数如何获取呢？同时这个方法传入的是修改值，而旧值如果用户不传入，此时还需要在业务中查询，而这个仅仅是因为操作日志记录需要，实际业务却不需要，所以使得方式不够优雅。</p><p>为了解决操作人和订单id的显示问题，我们需要将操作日志修改为如下所示格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  operator=&quot;#request.userId&quot;,bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在日志记录格式中添加了操作人和订单号，其实这种获取操作人的方式可能不太正确，一般在Web项目中，用户信息都是保存在一个线程上下文的静态方法中，所以操作人的信息一般是通过如下方式，假设获取当前登录用户信息的方法为<code>UserContext.getCurrentUserInfo()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator=&quot;#&#123;T(com.bamboo.user.UserContext).getCurrentUserInfo()&#125;&quot;</span><br></pre></td></tr></table></figure><p>但是这样获取用户信息的方式也太长了，而且并不是所有的地方都需要获取登录用户的信息，因此可以将这个operator参数的值设置为可选项，这样用户可以填写操作人，如果没填那么就可以从UserContext山下文中获取当前登录用户的信息。此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还有一个问题，就是需要添加一个旧的值oldRemark，这个值的获取非常尴尬，因为用户不传入这个参数，因此我们必须自行将这个oldRemark查询出来，然后将其放到操作日志的线程上下文中，这样后续模板在解析的时候就可以使用了。那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request,String newRemark)&#123;</span><br><span class="line">    //查询出原来的备注信息</span><br><span class="line">    Stirng oldRemark = orderService.query(reuest);</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemark&quot;,oldRemark);</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用<code>LogRecordContext</code>这个日志记录线程上下文来记录方法参数之外的变量，更重要的是它不破坏原有方法传递的参数信息。不过这种方式还是有问题的，因为它在业务代码中插入了一些实际业务逻辑不需要的代码，这一点其实可通过自定义函数来解决，后面会介绍。</p><p>经过上面的修改，此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;#oldRemark&quot;，修改为&quot;#newRemark&quot;。</span><br></pre></td></tr></table></figure><p>如果这个oldRemark和newRemark是人可读的字符串，这肯定没问题，但是如果是某种业务代码，如口味代码，那么就可能变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户修改了订单信息，将备注由&quot;101&quot;，修改为&quot;102&quot;。</span><br></pre></td></tr></table></figure><p>用户不知道这个101和102具体是指什么，用户关心的是可读的信息，所以此时还需要通过<code>LogRecordContext</code>来查询并进行替换展示。</p><p>前面说过如果开发者不想将业务逻辑和日志记录糅杂在一起，可以使用自定义函数来进行实现。可以自定义函数将oldRemark和newRemark转换成人可读的数据，那么此时操作日志的格式就变成如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderInfo&#123;#oldRemarkInfo&#125;&#125;&quot;，修改为&quot;&#123;OrderInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    //将原来的备注信息添加到日志记录线程上下文中</span><br><span class="line">    LogRecordContext.put(&quot;oldRemarkInfo&quot;,orderService.query(reuest));</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>OrderInfo</code>是自定义函数，我们使用大括号将Spring的SpEL表达式包裹起来，这样不仅可以将SpEL表达式和自定义函数区分开，便于解析；还可以在模板中不需要SpEL表达式的时候容易识别出来，减少不必要的SpEL解析，以提升性能。</p><p>看到这里，开发者完全可以将<code>LogRecordContext</code>线程上下文去掉，直接将<code>oldRemark</code>信息也通过自定义新的函数来获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecordLog(</span><br><span class="line">  content=&quot;用户修改了订单信息，将备注由&quot;&#123;OrderOldInfo&#123;#request.orderId&#125;&#125;&quot;，修改为&quot;&#123;OrderNewInfo&#123;#request.newRemark&#125;&#125;&quot;,</span><br><span class="line">  bisId=&quot;#request.orderId&quot;</span><br><span class="line">)</span><br><span class="line">public void updateOrder(HttpRequest request)&#123;</span><br><span class="line">    // 用户修改订单逻辑</span><br><span class="line">    updateOrder(request,newRemark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面这些操作，开发者就能通过自定义新函数传入订单id就能获取到之前的订单信息，当然这要求该方法的执行必须在updateOrder方法之前，这样就可以获取到对应信息，如此一来所有的目标都实现了，同时代码几乎没有任何的侵入性。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>新建项目并添加web和aop依赖，接着自定义一个注解，后续所有添加该注解的方法都会被拦截并记录对应的操作记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Retention(value = RetentionPolicy.RUNTIME )</span><br><span class="line">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface OperationRecord &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作类型</span><br><span class="line">     */</span><br><span class="line">    OperationEnum type();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 操作内容</span><br><span class="line">     */</span><br><span class="line">    String operation();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 备注</span><br><span class="line">     */</span><br><span class="line">    String remark() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于备注这个信息不是所有场景下都具有的，因此这里就给了一个默认值。同时这里的操作类型定义了一个枚举类型，所以接下来就定义这个枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作类型</span><br><span class="line"> */</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public enum OperationEnum &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 首页</span><br><span class="line">     */</span><br><span class="line">    INDEX(0),</span><br><span class="line">    /**</span><br><span class="line">     * 用户</span><br><span class="line">     */</span><br><span class="line">    USER(1),</span><br><span class="line">    /**</span><br><span class="line">     * 红包</span><br><span class="line">     */</span><br><span class="line">    REDPACKET(2),</span><br><span class="line">    /**</span><br><span class="line">     * 版本</span><br><span class="line">     */</span><br><span class="line">    APPVERSION(3),</span><br><span class="line">    /**</span><br><span class="line">     * 登录</span><br><span class="line">     */</span><br><span class="line">    LOGIN(4)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    private Integer typeId;</span><br><span class="line"></span><br><span class="line">    public Integer getTypeId() &#123;</span><br><span class="line">        return typeId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTypeId(Integer typeId) &#123;</span><br><span class="line">        this.typeId = typeId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志记录类"><a href="#自定义日志记录类" class="headerlink" title="自定义日志记录类"></a>自定义日志记录类</h3><p>由于用户的操作日志记录需要保存到数据库中，因此接下来定义数据表和对应的实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_operation_record` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `job_number` varchar(255) NOT NULL COMMENT &#x27;工号&#x27;,</span><br><span class="line">  `login_ip` varchar(255) NOT NULL COMMENT &#x27;登录IP&#x27;,</span><br><span class="line">  `type` int(11) NOT NULL COMMENT &#x27;操作类型&#x27;,</span><br><span class="line">  `operation` varchar(1000) DEFAULT NULL COMMENT &#x27;操作内容&#x27;,</span><br><span class="line">  `operate_time` datetime DEFAULT NULL COMMENT &#x27;操作时间&#x27;,</span><br><span class="line">  `remark` varchar(1000) DEFAULT NULL COMMENT &#x27;备注&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>实体类信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class TbOperationRecord &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String jobNumber;</span><br><span class="line">    private String loginIp;</span><br><span class="line">    private Integer type;</span><br><span class="line">    private String operation;</span><br><span class="line">    private Date operateTime;</span><br><span class="line">    private String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义日志Dao层"><a href="#自定义日志Dao层" class="headerlink" title="自定义日志Dao层"></a>自定义日志Dao层</h3><p>这里我们直接通过<code>mybatis-generate</code>工具来生成对应的Dao代码。</p><h3 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h3><p>接下来我们需要自定义切面类<code>AdminOperationRecordAop</code>，然后通过AOP来拦截请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">public class AdminOperationRecordAop &#123;</span><br><span class="line">    private final SpelExpressionParser parser = new SpelExpressionParser();</span><br><span class="line">    private final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();</span><br><span class="line">    @Autowired</span><br><span class="line">    private TbOperationRecordDao tbOperationRecordDao;</span><br><span class="line"></span><br><span class="line">    public static final String TYPE = &quot;type&quot;;</span><br><span class="line">    public static final String OPERATION = &quot;operation&quot;;</span><br><span class="line">    public static final String REMARK = &quot;remark&quot;;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.poly.myinterface.OperationRecord)&quot;)</span><br><span class="line">    public void myPointCut()&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @After(&quot;myPointCut()&quot;)</span><br><span class="line">    public void operationRecord(JoinPoint joinPoint)&#123;</span><br><span class="line">        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //IP地址</span><br><span class="line">        String userIp = IpUtils.getIpAddr(request);</span><br><span class="line">        //工号</span><br><span class="line">        Object jobNumber = request.getSession().getAttribute(&quot;adminId&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String, String&gt; operationRecordInfo = getOperationRecordInfo(joinPoint);</span><br><span class="line">            int type = Integer.parseInt(operationRecordInfo.get(TYPE));</span><br><span class="line">            String remark = operationRecordInfo.get(REMARK);</span><br><span class="line">            String operation = operationRecordInfo.get(OPERATION);</span><br><span class="line">            fillOperationRecord(type,remark,operation,userIp,jobNumber.toString());</span><br><span class="line">            log.info(&quot;【日志操作花费时间=&#123;&#125;秒】&quot;,(System.currentTimeMillis()-start)/1000);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">        String str = null;</span><br><span class="line">        if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">            Expression expression = parser.parseExpression(speLString);</span><br><span class="line">            //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">            EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">            //获取被注解的方法</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            //获取被注解的方法的形参</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            //获取运行时参数的名称</span><br><span class="line">            String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">            for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">                context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            str = String.valueOf(expression.getValue(context));</span><br><span class="line">            log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private Map&lt;String,String&gt; getOperationRecordInfo(JoinPoint joinPoint) throws ClassNotFoundException &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        OperationRecord annotation = method.getAnnotation(OperationRecord.class);</span><br><span class="line">        map.put(TYPE,annotation.type().getTypeId().toString());</span><br><span class="line">        map.put(REMARK,annotation.remark());</span><br><span class="line">        String operation = annotation.operation();</span><br><span class="line">        if(!operation.contains(&quot;;&quot;))&#123;</span><br><span class="line">            map.put(OPERATION,operation);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String[] strings = operation.split(&quot;;&quot;);</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            for(int i=0;i&lt;strings.length;i++)&#123;</span><br><span class="line">                String[] split = strings[i].split(&quot;#&quot;);</span><br><span class="line">                String spel =&quot;#&quot;+split[1];</span><br><span class="line">                String spelValue = getSPELValue(spel, joinPoint);</span><br><span class="line">                if(i!=strings.length-1)&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue).append(&quot;,&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    stringBuilder.append(split[0]).append(spelValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(OPERATION,stringBuilder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void fillOperationRecord(Integer type,String remark,String operation,String loginIp,String jobNumber)&#123;</span><br><span class="line">        TbOperationRecord tbOperationRecord = new TbOperationRecord();</span><br><span class="line">        tbOperationRecord.setType(type);</span><br><span class="line">        tbOperationRecord.setRemark(remark);</span><br><span class="line">        tbOperationRecord.setOperation(operation);</span><br><span class="line">        tbOperationRecord.setLoginIp(loginIp);</span><br><span class="line">        tbOperationRecord.setJobNumber(jobNumber);</span><br><span class="line">        tbOperationRecord.setOperateTime(new Date());</span><br><span class="line">        tbOperationRecordDao.insert(tbOperationRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myPointCut()</code>是一个切点，里面设置的是之前定义的<code>OperationRecord</code>注解。接着我们定义了一个<code>operationRecord</code>方法，添加后置通知，表示在被拦截的方法执行之后这个<code>operationRecord</code>方法才会执行。我们通过下面的代码获取到用户请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br></pre></td></tr></table></figure><p>之后就通过<code>IpUtils.getIpAddr(request)</code>方法来获取请求来源的IP地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   public static String getIpAddr(HttpServletRequest request) &#123;</span><br><span class="line">String ip = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line"></span><br><span class="line">ip = request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从请求携带的session中获取用户工号，之后就是获取被拦截的方法信息，从JoinPoint对象中可以得到方法签名，从方法签名中可以得到方法这个对象，然后通过字节码信息得到<code>OperationRecord</code>这个注解对象，然后就是将取出的信息放到map中进行存储。注意在获取<code>OperationRecord</code>这个注解对象的信息时，需要对传入的参数进行解析，这里使用SpEL进行解析，具体逻辑都在<code>getSPELValue</code>这个方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private String getSPELValue(String speLString,JoinPoint joinPoint)&#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    if(StringUtils.isBlank(speLString))&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        //方法中的参数解析过后的Spring表达式对象</span><br><span class="line">        Expression expression = parser.parseExpression(speLString);</span><br><span class="line">        //Spring表达式的上下文对象(有哪些占位符，以及每种占位符的值)</span><br><span class="line">        EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">        //获取被注解的方法</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        //获取被注解的方法的形参</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        //获取运行时参数的名称</span><br><span class="line">        String[] parameterNames = parameterNameDiscoverer.getParameterNames(methodSignature.getMethod());</span><br><span class="line">        for(int i=0;i&lt;parameterNames.length;i++)&#123;</span><br><span class="line">            context.setVariable(parameterNames[i],args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        str = String.valueOf(expression.getValue(context));</span><br><span class="line">        log.info(&quot;【str=&#123;&#125;】&quot;,str);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过对传入的字符串进行解析，得到里面的Spring表达式对象，之后新建Spring表达式上下文对象，这个上下文对象中包含占位符信息以及每种占位符的值。接着我们获取到被注解的方法，并从方法中得到方法的形参，然后获取到运行时参数的名词，这种方式其实得到的只是方法中传递的参数值，对于方法中值没有传递的参数，目前还没获取，这一块等有空完善一下相关逻辑。</p><p>最后在使用的时候，只需在被使用的方法上添加类似如下的注解信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@OperationRecord(type = OperationEnum.REDPACKET,operation = &quot;给用户id#userId;变更红包余额，相应的订单id#orderId;变动金额#changeBalance;变动类型#type;备注#remark&quot;,remark = &quot;变更红包金额&quot;)</span><br><span class="line">public ResultVO changeRedPacketBalance(int userId, String orderId, double changeBalance, int type, String remark) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在调用这个<code>changeRedPacketBalance</code>方法的时候就会在数据表<code>tb_operation_record</code>中新增一条对应的记录。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/JC51S_bI02npm4CE5NEEow">如何优雅地记录操作日志?</a>、<a href="https://mp.weixin.qq.com/s/JamcyrQdocnb0d0D0tSXNg">使用Aop记录带参数的复杂接口日志</a>、<a href="https://mp.weixin.qq.com/s/szhCq0tLCb_870uqAyIwPg">搞定 SpringBoot 操作日志</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在给老系统添加日志管理模块，主要记录用户的操作日志。操作日志不同于系统日志，它要求内容简洁且易读，同时日志管理要求做到三点：（1）不侵入业务逻辑；（2）可作为组件独立使用；（3）支持权限管理和可视化查询。因此本篇将从上述三个要求出发，学习和实践如何记录操作日志。&lt;/p&gt;</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot整合Canal实现数据增量同步</title>
    <link href="http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/"/>
    <id>http://envyzhan.asia/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/</id>
    <published>2022-08-02T09:55:30.000Z</published>
    <updated>2022-09-12T08:50:27.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随着业务系统的迭代、数据量的增多以及多种复杂场景下的分库分表实现，使得数据同步变得越来越具挑战性。针对这种情况，笔者决定使用阿里开源的Canal这一中间件来解决数据同步问题。</p><h1 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h1><h3 id="Canal简说"><a href="#Canal简说" class="headerlink" title="Canal简说"></a>Canal简说</h3><p>Canal是阿里巴巴开源的一款基于MySQL数据库的增量日志解析中间件，提供增量数据的订阅和消费功能。由于它是基于MySQL的日志进行的增量解析，因此对原有的业务代码完全不侵入。</p><p>Canal的工作原理是解析MySQL的binlog日志，提供增量数据的订阅和消费功能，具体包括：数据库镜像、数据库实时备份、业务缓存刷新、带业务逻辑的增量数据处理以及索引构建和实时维护（拆分异构索引和倒排索引）。</p><p>Canal官方文档，点击 <a href="https://github.com/alibaba/canal">这里</a> 进行查阅。</p><h3 id="Canal如何传输数据"><a href="#Canal如何传输数据" class="headerlink" title="Canal如何传输数据"></a>Canal如何传输数据</h3><p>下图是Canal官方展示的Canal传输数据架构图，可以看到Canal支持RabbitMQ、RocketMQ或者ES等常用的消息中间件：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-13f6424488da68e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从上图中可以知道Canal分为服务端和客户端，一般阿里开源的程序都是这个规范。其中服务端负责解析MySQL的binlog日志，并传输增量数据给客户端或者消息中间件；而客户端负责解析服务端传递过来的数据，并处理自己的业务逻辑。</p><p>当然，数据同步除了本篇学习的Canal外，还有其他一些优秀的开源工具，它们均支持MySQL，但是也存在一些区别。下面笔者将从支持实时同步、增量同步、需要编写保存变更数据的业务代码以及社区活跃度这4个方面进行对比，如下表所示：</p><table><thead><tr><th align="center"></th><th align="center">Canal</th><th align="center">Debezium</th><th align="center">DataX</th><th align="center">Databus</th><th align="center">Flinkx</th><th align="center">Bifrost</th></tr></thead><tbody><tr><td align="center">实时同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">增量同步</td><td align="center">支持</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">是否需要自己编写保存变更数据的代码</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">社区活跃度</td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">不高</td><td align="center">一般</td><td align="center">一般</td></tr></tbody></table><p>接下来将以Canal为例，来学习如何进行数据的同步。</p><h1 id="搭建服务端"><a href="#搭建服务端" class="headerlink" title="搭建服务端"></a>搭建服务端</h1><h3 id="安装Canal服务端"><a href="#安装Canal服务端" class="headerlink" title="安装Canal服务端"></a>安装Canal服务端</h3><p>点击 <a href="https://github.com/alibaba/canal/releases">这里</a> 下载Canal的服务端，即名称为<code>canal.developer</code>前缀的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-788d8d5206d6533d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>解压后的目录如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-7ae80252d4789fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>其中bin里面存放的是启动和停止脚本；conf目录存放的是配置文件；lib目录存放的是项目所依赖的包；logs目录存放的是项目运行的日志文件；plugin目录存放的是插件。其实这个canal服务端是一个SpringBoot项目，可以从其启动脚本中看出：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-3fbb162356f8fa3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="修改MySQL配置信息"><a href="#修改MySQL配置信息" class="headerlink" title="修改MySQL配置信息"></a>修改MySQL配置信息</h3><p>第一步，找到MySQL安装目录下的<code>my.ini</code>文件，在里面新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启binlog</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">#使用ROW模式</span><br><span class="line">binlog-format=ROW</span><br><span class="line"># 设置MySQL replication，注意不要和canal的slaveId重复就行</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure><p>第二步，设置Canal服务端中关于MySQL的相关配置信息，即告诉Canal应该去监听哪个数据库的哪个表的日志文件。</p><p>注意一个Canal服务端中可以监听多个MySQL实例，Canal默认自带了一个example实例（在其<code>conf/example</code>目录下有一个名为<code>instance.properties</code>的文件），本篇笔记就以example为例来进行学习。如果开发者需要增加实例，那么需要复制example文件夹中的内容到同级目录中，并在同级目录下的<code>canal.properties</code>文件中指定所添加的实例名称。这里我们就使用默认的实例即可。</p><p>修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># position info</span><br><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"># username/password</span><br><span class="line">canal.instance.dbUsername=root</span><br><span class="line">canal.instance.dbPassword=root</span><br><span class="line"># listener database name</span><br><span class="line">canal.instance.defaultDatabaseName=delaytask</span><br><span class="line"># table regex</span><br><span class="line">canal.instance.filter.regex=.*\\..*</span><br></pre></td></tr></table></figure><p>最后一行表示设置监听的数据库表信息，可以监听多个表，多个之间使用逗号进行分割，此处设置的是监听所有的表。</p><h3 id="修改RabbitMQ配置信息"><a href="#修改RabbitMQ配置信息" class="headerlink" title="修改RabbitMQ配置信息"></a>修改RabbitMQ配置信息</h3><p>由于Canal服务端默认的传输方式为tcp，因此我们需要在canal的配置文件中设置RabbitMQ相关的信息。</p><p>第一步，修改<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># tcp, kafka, rocketMQ, rabbitMQ</span><br><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line">##################################################</span><br><span class="line">#########     RabbitMQ     #############</span><br><span class="line">##################################################</span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host = /</span><br><span class="line">rabbitmq.exchange = canal.exchange</span><br><span class="line">rabbitmq.username = guest</span><br><span class="line">rabbitmq.password = guest</span><br><span class="line"># 是否持久化，2表示是</span><br><span class="line">rabbitmq.deliveryMode = 2</span><br></pre></td></tr></table></figure><p>第二步，修改<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中的如下所示信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mq config</span><br><span class="line">canal.mq.topic=canal.routing.key</span><br></pre></td></tr></table></figure><p>其实就是设置RabbitMQ路由的key，这样才能将信息准确路由到指定的队列里面。</p><p>第三步，在RabbitMQ中创建交换机和队列。接着我们需要在RabbitMQ中新建一个名为<code>canal.exchange</code>的交换机，注意这个名字必须与<code>canal.deployer-1.1.5\conf\canal.properties</code>文件中设置的<code>rabbitmq.exchange</code>选项值保持一致。</p><p>第四步，新建一个名为<code>canal.queue</code>的队列，这个队列的名称随意，不过为了区分实际业务，建议此队列还是命名为<code>canal.queue</code>。</p><p>第五步，定义交换机和队列之间的绑定键，名称为<code>canal.routing.key</code>，注意这个名字必须与<code>canal.deployer-1.1.5\conf\example\instance.properties</code>文件中设置的<code>canal.mq.topic</code>选项值保持一致：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-6bb6ed9d27412ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="启动各个服务"><a href="#启动各个服务" class="headerlink" title="启动各个服务"></a>启动各个服务</h3><p>在完成上述准备工作后，接下来我们尝试启动MySQL，之后启动Canal服务端，只需直接双击bin目录下的<code>startup.bat</code>文件。或者在Canal的bin目录下打开终端，然后输入<code>start /min startup.bat</code>命令来启动Canal服务端：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-f17fef8ee5eeba4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，这里有一个小坑，就是如果你的Java版本大于1.7，那么程序就会报错，因为此时永久代已经取消了，应该使用元空间。打开<code>startup.bat</code>文件，将其中的如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:PermSize=128m</span><br></pre></td></tr></table></figure><p>修改为如下后的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:MetaspaceSize=128m</span><br></pre></td></tr></table></figure><p>之后再重新执行<code>startup.bat</code>文件，进而启动Canal服务端。</p><h3 id="测试一下数据"><a href="#测试一下数据" class="headerlink" title="测试一下数据"></a>测试一下数据</h3><p>接下来使用如下命令往delaytask数据库中的<code>order_master</code>数据表里面新增一条信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (1, &#x27;2001&#x27;);</span><br></pre></td></tr></table></figure><p>然后查看一下RabbitMQ中的<code>canal.queue</code>队列里面的数据，可以看到里面已经有对应数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/26629887-db628944ef9fd5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这其实就是一个JSON字符串，格式化一下信息如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2001&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 14:10:07&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654495807000,</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654495807981,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个JOSN字符串中将用户执行的插入操作记录的非常清楚，如表名称、方法、参数、参数类型、参数值等。</p><p>既然服务端已经通过解析MySQL的binlog日志，并传输增量数据给消息中间件，那么接下来就是客户端监听MQ来获取JSON信息，并将其解析出来为后续业务逻辑服务。</p><h1 id="搭建客户端"><a href="#搭建客户端" class="headerlink" title="搭建客户端"></a>搭建客户端</h1><p>客户端就比较简单，就是消费Canal服务端传递过来的信息，而它传递的消息都存在了MQ中，因此客户端就只需监听<code>canal.queue</code>队列。</p><h3 id="创建消息实体类"><a href="#创建消息实体类" class="headerlink" title="创建消息实体类"></a>创建消息实体类</h3><p>由于MQ传递来的是JSON信息，因此接下来需要创建一个实体类来完成与JSON信息的数据绑定工作。新建一个名为CanalMessage的类，由于JSON中的data可能存在多种形式，因此可以将CanalMessage类定义为一个泛型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Canal消息接收实体类</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class CanalMessage&lt;T&gt; &#123;</span><br><span class="line">    @JsonProperty(&quot;data&quot;)</span><br><span class="line">    private List&lt;String&gt; data;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;database&quot;)</span><br><span class="line">    private String database;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;es&quot;)</span><br><span class="line">    private String es;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;id&quot;)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;isDdl&quot;)</span><br><span class="line">    private Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;old&quot;)</span><br><span class="line">    private List&lt;T&gt; old;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;pkNames&quot;)</span><br><span class="line">    private List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;sql&quot;)</span><br><span class="line">    private String sql;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;table&quot;)</span><br><span class="line">    private String table;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;ts&quot;)</span><br><span class="line">    private String ts;</span><br><span class="line"></span><br><span class="line">    @JsonProperty(&quot;type&quot;)</span><br><span class="line">    private String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听MQ消息"><a href="#监听MQ消息" class="headerlink" title="监听MQ消息"></a>监听MQ消息</h3><p>接下来就是监听RabbitMQ中的<code>canal.queue</code>队列了，这样只要Canal服务端有数据推送过来就可以及时的消费掉。</p><p>简单起见，这里笔者就通过<code>@RabbitListener</code>来完成RabbitMQ中交换机、队列的声明和绑定工作。新建一个名为<code>CanalRabbitMQListener</code>的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 监听RabbitMQ中信息</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class CanalRabbitMQListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(bindings=&#123;</span><br><span class="line">            @QueueBinding(</span><br><span class="line">                    value = @Queue(value = &quot;canal.queue&quot;,durable = &quot;true&quot;),</span><br><span class="line">                    exchange = @Exchange(value = &quot;canal.exchange&quot;),</span><br><span class="line">                    key = &quot;canal.routing.key&quot;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    public void handlerCanalData(String message)&#123;</span><br><span class="line">        //message则是MQ中canal.queue中的消息</span><br><span class="line">        //将message消息转换为之前定义的CanalMessage</span><br><span class="line">        CanalMessage canalMessage = JSONUtil.toBean(message, CanalMessage.class, true);</span><br><span class="line">        String databaseName = canalMessage.getDatabase();</span><br><span class="line">        String tableName = canalMessage.getTable();</span><br><span class="line">        log.info(&quot;Canal监听，&#123;&#125;数据库的&#123;&#125;数据表发生变化，变化信息为&#123;&#125;&quot;,databaseName,tableName,message);</span><br><span class="line">        //其他后续的业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你还需要配置RabbitMQ的相关信息，可以在<code>application.properties</code>配置文件中新增如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=127.0.0.1</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>接下来我们启动项目，首先往<code>order_master</code>数据表中新增一条记录，命令如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `delaytask`.`order_master`(`id`, `order_id`) VALUES (2, &#x27;2002&#x27;);</span><br></pre></td></tr></table></figure><p>可以看到此时项目控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Canal监听，delaytask数据库的order_master数据表发生变化，变化信息为：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">            &quot;order_id&quot;: &quot;2002&quot;,</span><br><span class="line">            &quot;create_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;update_time&quot;: &quot;2022-06-06 17:24:43&quot;,</span><br><span class="line">            &quot;retry_times&quot;: &quot;0&quot;,</span><br><span class="line">            &quot;order_status&quot;: &quot;0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;database&quot;: &quot;delaytask&quot;,</span><br><span class="line">    &quot;es&quot;: 1654507483000,</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;isDdl&quot;: false,</span><br><span class="line">    &quot;mysqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;bigint unsigned&quot;,</span><br><span class="line">        &quot;order_id&quot;: &quot;varchar(60)&quot;,</span><br><span class="line">        &quot;create_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;update_time&quot;: &quot;datetime&quot;,</span><br><span class="line">        &quot;retry_times&quot;: &quot;tinyint&quot;,</span><br><span class="line">        &quot;order_status&quot;: &quot;tinyint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;old&quot;: null,</span><br><span class="line">    &quot;pkNames&quot;: [</span><br><span class="line">        &quot;id&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sql&quot;: &quot;&quot;,</span><br><span class="line">    &quot;sqlType&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: -5,</span><br><span class="line">        &quot;order_id&quot;: 12,</span><br><span class="line">        &quot;create_time&quot;: 93,</span><br><span class="line">        &quot;update_time&quot;: 93,</span><br><span class="line">        &quot;retry_times&quot;: -6,</span><br><span class="line">        &quot;order_status&quot;: -6</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;table&quot;: &quot;order_master&quot;,</span><br><span class="line">    &quot;ts&quot;: 1654507483543,</span><br><span class="line">    &quot;type&quot;: &quot;INSERT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Canal客户端已经成功消费了MQ中的消息并接收到，后续开发者可根据实际业务进行后续逻辑开发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中经常会遇到需要同步数据的场景，在业务和数据量比较小的情况下，我们会在项目中通过编写一些定时任务来同步数据。但是随</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
</feed>
