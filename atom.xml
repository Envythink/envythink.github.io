<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>余思博客</title>
  
  
  <link href="http://envyzhan.asia/atom.xml" rel="self"/>
  
  <link href="http://envyzhan.asia/"/>
  <updated>2022-09-12T08:27:28.326Z</updated>
  <id>http://envyzhan.asia/</id>
  
  <author>
    <name>余思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot轻松实现接口加解密</title>
    <link href="http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/"/>
    <id>http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/</id>
    <published>2022-06-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:27:28.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开发者可以自定义过滤器，将请求和响应分别拦截并进行相应的解密与加密操作。可以看到这种方式简单粗暴，灵活度高，适应性强。不过呢，本篇决定使用另一种思录，即使用SpringMVC提供的<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理（预处理）。</p><p>本篇尝试利用<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理，并在此基础上对请求和响应进行解密和加密操作，接着将其制作成一个starter并发布到jitPack中，最后新建一个项目来尝试使用该starter。</p><h1 id="编写加解密场景启动器"><a href="#编写加解密场景启动器" class="headerlink" title="编写加解密场景启动器"></a>编写加解密场景启动器</h1><p>第一步，新建一个名为<code>encrypt-spring-boot-starter</code>的SpringBoot项目，在其POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>由于此项目用于接口的加解密，适用于Web环境，因此此处必须添加Web依赖，同时可设置scope值为provided。</p><p>第二步，新建model包，并在该包内新建一个名为ResultBean的响应结果类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class ResultBean &#123;</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatus(Integer status) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getObject() &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObject(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean(Integer status, String message, Object object) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean build()&#123;</span><br><span class="line">        return new ResultBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(200,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message)&#123;</span><br><span class="line">        return new ResultBean(200,message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(500,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message)&#123;</span><br><span class="line">        return new ResultBean(500,message,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建annotations包，并在该包内新建一个名为Decrypt的注解，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Decrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在annotations包内新建一个名为Encrypt的注解，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 加密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解其实是标记注解，其中<code>@Decrypt</code>注解用于标识解密，可用在方法和参数中；<code>@Encrypt</code>注解用于标识加密，可用在方法上。一般来说，我们是对请求或者请求中的参数进行解密，而对响应进行加密。</p><p>第四步，新建config包，并在该包内新建一个名为EncryptProperties的属性配置类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptProperties &#123;</span><br><span class="line">    private final static String DEFAULT_KEY = &quot;www.kenbings.top&quot;;</span><br><span class="line">    private String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用户可能会配置自己的加密key，因此我们需要定义EncryptProperties类，用于将用户在<code>application.properties</code>配置文件中设置的参数进行映射。注意这个加密key必须是16位的字符串，笔者的博客域名刚好满足这个条件。如果开发者没有在<code>application.properties</code>配置文件中配置自己的加密key，那么就会默认使用笔者的博客域名作为默认的加密key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kenbings.encrypt.key=www.kenbings.top</span><br></pre></td></tr></table></figure><p>第五步，新建utils包，并在该包内新建一个名为Base64Utils的工具类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Base64Utils &#123;</span><br><span class="line">    public Base64Utils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decode(byte[] data)&#123;</span><br><span class="line">        return Base64.getDecoder().decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 编码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encode(byte[] data)&#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们定义了两个方法，decode方法用于解码，因为请求或者参数是先解码，转换成可读数据字节数组，之后才进行解密。而encode方法用于编码，注意响应先是先加密，然后在编码为Base64字符串。</p><p>接着在utils包内新建一个名为AESUtils的加解密类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class AESUtils &#123;</span><br><span class="line">    private static final String AES_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个Cipher</span><br><span class="line">     * @param key</span><br><span class="line">     * @param model</span><br><span class="line">     * @return Cipher密码对象</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    private static Cipher getCipher(byte[] key,int model) throws Exception &#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = new SecretKeySpec(key,&quot;AES&quot;);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model,secretKeySpec);</span><br><span class="line">        return cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES解密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.DECRYPT_MODE);</span><br><span class="line">        return cipher.doFinal(Base64Utils.decode(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES加密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return Base64字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.ENCRYPT_MODE);</span><br><span class="line">        return Base64Utils.encode(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们选择了对称加密，且使用了AES算法，采用的是Java自带的Cipher来实现对称加密。这个<code>AES_ALGORITHM</code>变量必须是一个包含三部分的字符串，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p><p>第六步，新建request包，并在该包内新建一个名为DecryptRequest的类，该类用于对接口进行解密，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口解密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class DecryptRequest extends RequestBodyAdviceAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return methodParameter.hasMethodAnnotation(Decrypt.class)|| methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        byte[] body = new byte[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        try&#123;</span><br><span class="line">            byte[] decrypt = AESUtils.decrypt(encryptProperties.getKey().getBytes(), body);</span><br><span class="line">            final ByteArrayInputStream bais = new ByteArrayInputStream(decrypt);</span><br><span class="line">            return new HttpInputMessage() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public InputStream getBody() throws IOException &#123;</span><br><span class="line">                    return bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public HttpHeaders getHeaders() &#123;</span><br><span class="line">                    return inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return super.beforeBodyRead(inputMessage,parameter,targetType,converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>DecryptRequest</code>类继承了<code>RequestBodyAdviceAdapter</code>类，并重写了其中的<code>supports</code>和<code>beforeBodyRead</code>方法，当然了也可以实现<code>RequestBodyAdvice</code>接口，因为<code>RequestBodyAdviceAdapter</code>类其实也是实现了<code>RequestBodyAdvice</code>接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RequestBodyAdviceAdapter implements RequestBodyAdvice &#123;</span><br><span class="line">    public RequestBodyAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        return inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然实现<code>RequestBodyAdvice</code>接口或者继承<code>RequestBodyAdviceAdapter</code>类都可以，那么我们应该使用哪种方式呢？这个很简单，你就看自己需要重写什么方法，如果你只想重写<code>supports</code>和<code>beforeBodyRead</code>方法，那么只需继承<code>RequestBodyAdviceAdapter</code>类，其他方法使用父类的实现即可。<br>（2）<code>supports</code>方法用于判断哪些接口或者参数需要解密，这里的逻辑如果方法上或者方法参数中使用了<code>@Decrypt</code>注解，就表示需要进行解密。<br>（3）<code>beforeBodyRead</code>方法会在参数转换成具体的对象之前执行，这里我们先从流中加载数据，接着对数据进行解密，解密之后构造<code>HttpInputMessage</code>对象并进行返回。<br>（4）注意自定义的RequestBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对请求进行预处理。</p><p>第七步，新建response包，并在该包内新建一个名为EncryptResponse的类，该类用于对接口进行加密，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口加密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class EncryptResponse implements ResponseBodyAdvice&lt;ResultBean&gt; &#123;</span><br><span class="line">    ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ResultBean beforeBodyWrite(ResultBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">        byte[] keyBytes = encryptProperties.getKey().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        try &#123;</span><br><span class="line">            String bodyMessage = body.getMessage();</span><br><span class="line">            if(null != bodyMessage)&#123;</span><br><span class="line">                body.setMessage(AESUtils.encrypt(keyBytes,bodyMessage.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            &#125;</span><br><span class="line">            Object bodyObject = body.getObject();</span><br><span class="line">            if(null != bodyObject)&#123;</span><br><span class="line">                body.setObject(AESUtils.encrypt(keyBytes,objectMapper.writeValueAsBytes(bodyObject)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>EncryptResponse</code>类实现了<code>ResponseBodyAdvice</code>接口，并重写了其中的<code>supports</code>和<code>beforeBodyWrite</code>方法。这个<code>ResponseBodyAdvice</code>接口就不存在对应的实现类了。<br>（2）<code>supports</code>方法用于判断哪些接口需要加密，参数returnType表示返回类型，这里的逻辑如果方法上使用了<code>@Encrypt</code>注解，就表示需要进行加密。<br>（3）<code>beforeBodyWrite</code>方法会在数据响应之前执行，即先对响应数据进行处理，之后才转换为JSON数据进行返回。这里处理逻辑非常简单，如果返回的ResultBean对象中的message和object对象不为空，那么就将这些信息进行加密，状态码这个就无需加密，之后将加密后的数据设置回ResultBean对象中。<br>（4）注意自定义的ResponseBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对响应进行预处理。</p><p>第八步，回到config包中，在里面定义一个名为<code>EncryptAutoConfiguration</code>的自动配置类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类需要添加<code>@ComponentScan</code>注解，并将当前项目下的所有包都交由SpringIOC容器来管理。</p><p>第九步，定义<code>spring.factories</code>文件。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第八步定义好的<code>EncryptAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.kenbings.encrypt.config.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样我们就完成了自定义场景启动器的定义工作。</p><h1 id="项目本地打包"><a href="#项目本地打包" class="headerlink" title="项目本地打包"></a>项目本地打包</h1><p>第十步，一般来说我们会将自定义的场景启动器打包，然后上传到Maven私服，以供其他同事使用，这里笔者就不上传了，直接本地打包并安装了。点击IDEA中的Maven插件，选择Lifecycle，然后先clean一下，再install一下，这样自定义场景启动器就安装到本地仓库了。</p><h1 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h1><p>接下来我们新建一个SpringBoot项目，然后在其中引入web依赖以及上面自定义的场景启动器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.kenbings&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>接着新建一个名为Book的实体类，这样便于后续进行测试传参和解密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新建一个名为<code>BookController</code>的接口类，里面需要提供两个方法，一个是添加新书籍，另一个则是查询书籍信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(BookController.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean getBook()&#123;</span><br><span class="line">        Book book = new Book();</span><br><span class="line">        book.setName(&quot;三国演义&quot;);</span><br><span class="line">        book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">        return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean addBook(@RequestBody Book book)&#123;</span><br><span class="line">       logger.info(&quot;book is=&#123;&#125;&quot;,book);</span><br><span class="line">        return ResultBean.ok(&quot;成功添加该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就可以启动项目进行测试，先来测试一下查询书籍信息的getBook方法，可以看到返回信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0082c41d387bd908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后再来测试一下添加新书籍的addBook方法，以JSON形式传递一个Book对象，添加成功后返回如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9969f1084f8d11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来我们对上述接口进行改造。对于查询书籍信息的getBook方法，我们可以对返回的响应数据进行加密，因此在该方法上添加<code>@Encrypt</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/book&quot;)</span><br><span class="line">@Encrypt</span><br><span class="line">public ResultBean getBook()&#123;</span><br><span class="line">    Book book = new Book();</span><br><span class="line">    book.setName(&quot;三国演义&quot;);</span><br><span class="line">    book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">    return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启项目，重新访问一下该接口，可以看到页面返回信息如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8e7c265562fe10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到响应中的信息都被加密了。接下来我们再来看一下用于添加新书籍的addBook方法，该方法以JSON形式传递一个Book对象，接下来我们使用<code>@Decrypt</code>注解来对请求中的参数进行解密，这里直接将上面接口返回的object数据作为参数进行传入，可以看到方法返回结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-85aa87d0d8bd81ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这也就说明接口数据解密成功了。</p><h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p>接下来我们就来看一下前面使用的<code>AES/ECB/PKCS5Padding</code>这个算法字符串。该字符串包含三部分，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p><p>ECB模式是最简单的工作模式，它直接将明文进行分组，然后每组分别加密，这样使得每个分组独立且前后无任何关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * AES/ECB/PKCS5Padding (128)</span><br><span class="line">  * AES加密 ECB模式 PKCS5填充方式 密钥长度必须为16个字节(128位)</span><br><span class="line">  */</span><br><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">     //密钥生成器</span><br><span class="line">     KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">     //设置密钥长度128位</span><br><span class="line">     kgen.init(128, new SecureRandom());</span><br><span class="line">     //生成key</span><br><span class="line">     SecretKey key = kgen.generateKey();</span><br><span class="line"></span><br><span class="line">     //长度为16的二进制数组，密钥我们自己生成也可以.</span><br><span class="line">     byte[] keyBytes = key.getEncoded();</span><br><span class="line">     System.out.println(&quot;keyBytes长度是16 = &quot; + keyBytes.length);</span><br><span class="line"></span><br><span class="line">     //创建AES的密钥</span><br><span class="line">     SecretKeySpec aesKey = new SecretKeySpec(keyBytes, &quot;AES&quot;);</span><br><span class="line"></span><br><span class="line">     //加密 模式 填充方式</span><br><span class="line">     Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</span><br><span class="line">     cipher.init(Cipher.ENCRYPT_MODE, aesKey);</span><br><span class="line"></span><br><span class="line">     //对abc进行加密，因为明文长度不固定，所以需要先分组在加密，每一组长度16个字节</span><br><span class="line">     //不够16的需要进行填充，abc的长度是3个字节，所以要填充13个字节在进行加密</span><br><span class="line">     //所以encrypt的长度为16，因为在加密之前填充了</span><br><span class="line">     //如果长度正好为16个字节，那么也要新填充一个16长度的组，那么加密后的encrypt的长度为32</span><br><span class="line">     byte[] encrypt = cipher.doFinal(&quot;abc&quot;.getBytes());</span><br><span class="line">     System.out.println(encrypt.length);</span><br><span class="line"></span><br><span class="line">     cipher.init(Cipher.DECRYPT_MODE, aesKey);</span><br><span class="line">     byte[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">     System.out.println(new String(decrypt));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>整个加密和解密过程如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-83541dcae149f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章通过对RequestBodyAdvice和ResponseBodyAdvice的介绍让我们知道了如何对请求和响应进行预处理操作，同时结合平常使用的接口加解密需求来实践该知识点。当然了本篇所介绍的接口加解密非常简单，后续笔者会在此基础上扩展加解密方式、支持类上加解密（类中所有接口加解密）、接口动态实现加解密以及定义一个加解密可视化平台。感兴趣的小伙伴可以关注公众号“啃饼思录”，笔者会在那里更新该场景启动器的开发进度信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现图形验证码</title>
    <link href="http://envyzhan.asia/2022/06/06/13-spring-boot-implements-graphic-verification-code/"/>
    <id>http://envyzhan.asia/2022/06/06/13-spring-boot-implements-graphic-verification-code/</id>
    <published>2022-06-06T09:55:30.000Z</published>
    <updated>2022-09-12T08:25:22.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在实际生活中，我们经常会遇到在登陆的时候，需要输入图形验证码这样的场景，验证码不仅可以防止爬虫的抓取，还可以限制接口短时间内被访问的次数，可以说也是一种限流措施。本篇来学习如何在前后端分离架构下，基于SpringBoot实现图形验证码这一功能。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>verify-code</code>的SpringBoot项目，并在其POM文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="创建状态枚举类"><a href="#创建状态枚举类" class="headerlink" title="创建状态枚举类"></a>创建状态枚举类</h3><p>第二步，新建一个enums包，并在该包内新建一个名为RespCode的响应状态枚举类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public enum RespCode &#123;</span><br><span class="line">    SUCCESS(0,&quot;success&quot;),   //成功</span><br><span class="line">    ERROR(1,&quot;error&quot;),   //失败</span><br><span class="line">    ILLEGAL_ARGUMENT(2,&quot;ILLEGAL_ARGUMENT&quot;);   //参数错误</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    RespCode(int code, String desc)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RespCode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode()&#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建响应状态类"><a href="#创建响应状态类" class="headerlink" title="创建响应状态类"></a>创建响应状态类</h3><p>第三步，新建entity包，并在该包内新建一个名为RespBean的响应状态类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class RespBean&lt;T&gt; implements Serializable &#123;</span><br><span class="line">    private int status;</span><br><span class="line">    private String msg;</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">    private RespBean(int status)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean(int status, String msg)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.msg=msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean(int status, T data)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean(int status, String msg, T data)&#123;</span><br><span class="line">        this.status=status;</span><br><span class="line">        this.msg=msg;</span><br><span class="line">        this.data=data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getStatus()&#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()&#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getData()&#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok()&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(String msg)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(T data)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; ok(String msg,T data)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.SUCCESS.getCode(),msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error()&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.ERROR.getCode(),RespCode.ERROR.getDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error(String errorMessage)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(RespCode.ERROR.getCode(),errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; RespBean&lt;T&gt; error(int errorCode,String errorMessage)&#123;</span><br><span class="line">        return new RespBean&lt;T&gt;(errorCode,errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis工具类"><a href="#Redis工具类" class="headerlink" title="Redis工具类"></a>Redis工具类</h3><p>第四步，新建redis包，并在该包内新建一个名为RedisCache的工具类，该类封装了Redis对字符串类型的操作，即设置值和获取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisCache &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T getCacheObject(final String key)&#123;</span><br><span class="line">        ValueOperations&lt;String,T&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        return valueOperations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; void setCacheObject(final String key, final T value, Integer timeout, TimeUnit timeUnit)&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key,value,timeout,timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，在redis包内新建一个名为RedisConfig的配置类，该类用于重写Redis的序列化方式。一般来说我们更倾向于在SpringBoot中使用 Spring Data Redis来操作Redis，但是随着而来的则是它的序列化问题，默认使用的是<code>JdkSerializationRedisSerializer</code>，采用的是二进制方式，且会自动的给存入的key和value添加一些前缀，导致实际情况与开发者预想的不一致。针对这种情况我们可以使用<code>Jackson2JsonRedisSerializer</code>这一序列化方式，不建议使用<code>StringRedisTemplate</code>来替代<code>RedisTemplate</code>，因为它提供的数据类型和操作都有限，无法满足日常需要。</p><p>定义一个名为RedisConfig的类，该类用于重写RedisTempplate的序列化逻辑，使用<code>Jackson2JsonRedisSerializer</code>取代默认的<code>JdkSerializationRedisSerializer</code>，这样利于后续开发和使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>第六步，定义一个名为<code>application.yml</code>的配置文件，在里面定义Redis连接信息，同时自定义验证码的一些参数，如缓存中key前缀、验证码过期时间和验证码格式等信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1 # Redis服务器地址</span><br><span class="line">    database: 4 # Redis数据库索引（默认为0）</span><br><span class="line">    port: 6379 # Redis服务器连接端口</span><br><span class="line">    password: root # Redis服务器连接密码（默认为空）</span><br><span class="line">    timeout: 300ms # 连接超时时间（毫秒）</span><br><span class="line">server:</span><br><span class="line">  port: 8888</span><br><span class="line">verify:</span><br><span class="line">  code:</span><br><span class="line">    prefix: verify_code # 缓存中key前缀</span><br><span class="line">    type: jpg # 验证码格式</span><br><span class="line">    timeout: 60 # 验证码过期时间，单位秒</span><br></pre></td></tr></table></figure><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>第七步，新建config包，并在该包内新建一个名为VerifyCodeConfig的属性配置类，该类用于将用户在<code>application.yml</code>配置文件中定义的配置项与VerifyCodeConfig这一属性POJO类进行映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;verify.code&quot;)</span><br><span class="line">public class VerifyCodeConfig &#123;</span><br><span class="line">    private String prefix;</span><br><span class="line">    private String type;</span><br><span class="line">    private int timeout;</span><br><span class="line"></span><br><span class="line">    //setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建验证码工具类"><a href="#创建验证码工具类" class="headerlink" title="创建验证码工具类"></a>创建验证码工具类</h3><p>第八步，新建utils包，并在该包内新建一个名为CodeUtils的工具类，该类用于生成验证码及图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class CodeUtils &#123;</span><br><span class="line">    //验证码字符集</span><br><span class="line">    private static final char[] chars = &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,</span><br><span class="line">            &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;,&#x27;m&#x27;,&#x27;n&#x27;,&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;,&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,</span><br><span class="line">            &#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;,&#x27;G&#x27;,&#x27;H&#x27;,&#x27;I&#x27;,&#x27;J&#x27;,&#x27;K&#x27;,&#x27;L&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;P&#x27;,&#x27;Q&#x27;,&#x27;R&#x27;,&#x27;S&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">    //字符数量</span><br><span class="line">    public static final int SIZE = 4;</span><br><span class="line">    //干扰线数量</span><br><span class="line">    public static final int LINES = 4;</span><br><span class="line">    //图片宽度</span><br><span class="line">    public static final int WIDTH = 200;</span><br><span class="line">    //图片高度</span><br><span class="line">    public static final int HEIGHT = 60;</span><br><span class="line">    //字体大小</span><br><span class="line">    public static final int FONT_SIZE = 30;</span><br><span class="line"></span><br><span class="line">    public static Random random = new Random();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回验证码字符串和图片BufferedImage对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Object[] createImage()&#123;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">        //创建空白图片</span><br><span class="line">        BufferedImage image = new BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        //获取图片画笔</span><br><span class="line">        Graphics graphics = image.getGraphics();</span><br><span class="line">        //设置画笔颜色</span><br><span class="line">        graphics.setColor(Color.LIGHT_GRAY);</span><br><span class="line">        //绘制矩形背景</span><br><span class="line">        graphics.fillRect(0,0,WIDTH,HEIGHT);</span><br><span class="line">        //画随机字符</span><br><span class="line">        for (int i = 0; i &lt; SIZE; i++) &#123;</span><br><span class="line">            //获取随机字符串索引</span><br><span class="line">            int n = random.nextInt(chars.length);</span><br><span class="line">            //设置随机颜色</span><br><span class="line">            graphics.setColor(getRandomColor());</span><br><span class="line">            //设置字体大小</span><br><span class="line">            graphics.setFont(new Font(null, Font.BOLD + Font.ITALIC,FONT_SIZE));</span><br><span class="line">            //绘制字符</span><br><span class="line">            graphics.drawString(chars[n]+&quot;&quot;, i * WIDTH/SIZE, HEIGHT*2/3);</span><br><span class="line">            //记录字符</span><br><span class="line">            stringBuffer.append(chars[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        //画干扰线</span><br><span class="line">        for (int i = 0; i &lt; LINES; i++) &#123;</span><br><span class="line">            //设置随机颜色</span><br><span class="line">            graphics.setColor(getRandomColor());</span><br><span class="line">            //随机画线</span><br><span class="line">            graphics.drawLine(random.nextInt(WIDTH),random.nextInt(HEIGHT),random.nextInt(WIDTH),random.nextInt(HEIGHT));</span><br><span class="line">        &#125;</span><br><span class="line">        //返回验证码和图片</span><br><span class="line">        return new Object[]&#123;stringBuffer.toString(),image&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机取色</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Color getRandomColor()&#123;</span><br><span class="line">        Color color = new Color(random.nextInt(256),random.nextInt(256),random.nextInt(256));</span><br><span class="line">        return color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义业务处理类"><a href="#定义业务处理类" class="headerlink" title="定义业务处理类"></a>定义业务处理类</h3><p>第九步，新建service包，并在该包内新建一个名为VerifyCodeService的业务类，该类用于生成验证码及校验用户输入的验证码是否准确：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class VerifyCodeService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private VerifyCodeConfig verifyCodeConfig;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    public RespBean generateVerifyCode()&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Object[] objects = CodeUtils.createImage();</span><br><span class="line">        //验证码字符串和图片BufferedImage对象</span><br><span class="line">        //获取验证码字符串，全部转为小写</span><br><span class="line">        String codeStr = objects[0].toString().toLowerCase();</span><br><span class="line">        //获取图片BufferedImage对象</span><br><span class="line">        BufferedImage codeImg = (BufferedImage) objects[1];</span><br><span class="line">        //图片Key对象</span><br><span class="line">        String codeKey = System.currentTimeMillis() + &quot;&quot;;</span><br><span class="line">        //构造缓存Key</span><br><span class="line">        String cacheKey = verifyCodeConfig.getPrefix() + codeKey;</span><br><span class="line">        //将数据存入缓存</span><br><span class="line">        redisCache.setCacheObject(cacheKey,codeStr, verifyCodeConfig.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">        try&#123;</span><br><span class="line">            ImageIO.write(codeImg, verifyCodeConfig.getType(), baos);</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return RespBean.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        String codePic = new String(Base64.getEncoder().encode(baos.toByteArray()));</span><br><span class="line">        map.put(&quot;codeKey&quot;,codeKey);</span><br><span class="line">        map.put(&quot;codePic&quot;,codePic);</span><br><span class="line">        return RespBean.ok(&quot;验证码生成成功&quot;,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean checkVerifyCode(String codeKey,String inputCode)&#123;</span><br><span class="line">        //构造缓存Key</span><br><span class="line">        String cacheKey = verifyCodeConfig.getPrefix() + codeKey;</span><br><span class="line">        //获取缓存Value</span><br><span class="line">        String cacheValue = redisCache.getCacheObject(cacheKey);</span><br><span class="line">        if(Objects.nonNull(cacheValue) &amp;&amp; cacheValue.equalsIgnoreCase(inputCode))&#123;</span><br><span class="line">            return RespBean.ok(&quot;验证码匹配成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.error(&quot;验证码匹配失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）定义<code>generateVerifyCode()</code>方法用于生成图形验证码，然后构建一个返回Map对象，接着构造图片key对象，这个需要在用户请求成功并返回验证码的时候一并携带过去，目的就是后续可以构造缓存key进而从缓存中取出生成的验证码并与用户输入提交的验证码进行对比，进而判断用户验证码是否输入正确；<br>（2）图片key对象这里比较简单，直接采用了时间戳，开发者还可以采用UUID或者其他分布式环境下能唯一标识请求的信息；<br>（3）然后调用<code>mageIO.write()</code>方法通过IO流形式将图片写入到<code>ByteArrayOutputStream </code>中，并将其转成一个Base64字符串添加到返回Map对象中。当然如果你不是前后端分离的架构，可以将其存入Session中，然后从Session中通过<code>session.getAttribute()</code>方法来获取验证码字符串，而图片直接可通过前端显示在页面上；<br>（4）<code>checkVerifyCode()</code>方法就是从缓存中取出返给前端的图形验证码中的验证码字符串，然后与用户输入提交的字符串进行对比，如果校验通过，则说明验证码匹配成功，反之匹配失败。</p><h3 id="定义业务控制器类"><a href="#定义业务控制器类" class="headerlink" title="定义业务控制器类"></a>定义业务控制器类</h3><p>第十步，新建controller包，并在该包内新建一个名为VerifyCodeController的控制器类，该类用于提供生成验证码及校验用户输入验证码是否准确的API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class VerifyCodeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private VerifyCodeService verifyCodeService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/generateVerifyCode&quot;)</span><br><span class="line">    public RespBean generateVerifyCode()&#123;</span><br><span class="line">        return verifyCodeService.generateVerifyCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/checkVerifyCode&quot;)</span><br><span class="line">    public RespBean checkVerifyCode(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">        //获取图片key对象</span><br><span class="line">        String codeKey = map.get(&quot;codeKey&quot;);</span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">        String inputCode = map.get(&quot;inputCode&quot;);</span><br><span class="line">        return verifyCodeService.checkVerifyCode(codeKey, inputCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行项目进行测试"><a href="#运行项目进行测试" class="headerlink" title="运行项目进行测试"></a>运行项目进行测试</h3><p>第十一步，启动项目，开始进行测试。打开Postman，按照图示进行操作：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bc7bfd1a0e773b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到接口返回了成功信息，但是用户无法直接看到生成的图形验证码，只能看到Base64字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;验证码生成成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;codeKey&quot;: &quot;1653484305664&quot;,</span><br><span class="line">        &quot;codePic&quot;: &quot;/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcp&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以在Postman的Tests模块，从接口中取出返回的Base64字符串，然后构建HTML字符串模板，由于我们返回的Base64字符串中不包含<code>data:image/jpg;base64,</code>这段标志，因此需要在前面补上，最后将得到的信息设置到visualizer中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1、将接口返回数据赋值</span><br><span class="line">var data = &#123;</span><br><span class="line">    response:pm.response.json()</span><br><span class="line">&#125;</span><br><span class="line">//2、构建HTML模板字符串</span><br><span class="line">//如果base64代码中没有包含&quot;data:image/jpg;base64,&quot;，那么就需要在base64代码前添加</span><br><span class="line">var template = `&lt;html&gt;&lt;img src=&quot;data:image/jpg;base64,&#123;&#123;response.data.codePic&#125;&#125;&quot;/&gt;&lt;/html&gt;`;</span><br><span class="line"></span><br><span class="line">//3、设置visualizer数据，传入模板并进行解析</span><br><span class="line">pm.visualizer.set(template,data);</span><br></pre></td></tr></table></figure><p>注意代码的添加位置，然后再次请求一下生成图形验证码的接口，点击右侧Body区域的Visualizer，可以看到图形验证码已经出现了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3ae04d123d66d6c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着按照图示操作来校验图形验证码，在Body区域选择raw，然后以JSON形式传入之前返回的codeKey以及用户输入的inputCode：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e0974b254b925599.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到请求返回成功，并显示验证码匹配成功。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇基于SpringBoot+Redis实现了生成和校验图形验证码的功能，原理就是先生成图形验证码及验证码字符串，然后将验证码字符串存入缓存中，接着将图形验证码及字符串key返回给用户，后续用户在提交验证码时，根据字符串key及输入的验证码，从缓存中取出验证码字符串，并与用户输入提交的验证码进行对比，进而判断是否匹配成功。</p><p>在了解这种原理之后，你就可以举一反三，利用SpringBoot+Redis这一组合拳实现发送和校验短信验证码，接口防刷、防重复提交等功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;在实际生活中，我们经常会遇到在登陆的时候，需要输入图形验证码这样的场景，验证码不仅可以防止爬虫的抓取，还可以限制接口短时间内</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现定时任务</title>
    <link href="http://envyzhan.asia/2022/05/26/11-springboot-implements-timed-tasks/"/>
    <id>http://envyzhan.asia/2022/05/26/11-springboot-implements-timed-tasks/</id>
    <published>2022-05-26T09:55:30.000Z</published>
    <updated>2022-09-12T08:21:37.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中，定时任务是一个很常见的功能，如定时统计订单数、数据库备份、定时发送短信和邮件、定时统计博客访客等等，简单的定时任务可以直接通过Spring提供的<code>@Scheduled</code>注解来实现，复杂一点的定时任务则可以通过集成<code>Quartz</code>（[kwɔːts]）来实现，本篇将分别介绍如何使用这两种方式实现定时任务。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>新建一个名为<code>time-task</code>的SpringBoot项目，后续将在该项目中进行定时任务的实现。</p><h1 id="Scheduled注解方式"><a href="#Scheduled注解方式" class="headerlink" title="@Scheduled注解方式"></a><code>@Scheduled</code>注解方式</h1><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p><strong>第一步，添加依赖。</strong>在项目的POM文件中新增Web依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步，开启定时任务。</strong>在项目启动类上添加<code>@EnableScheduling</code>注解，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TimeTaskApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TimeTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步，配置定时任务。</strong>定时任务主要是通过<code>@Scheduled</code>注解来进行配置。新建一个component包，并在其中创建一个<code>FirstSchedule</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstSchedule &#123;</span><br><span class="line">    @Scheduled(fixedDelay = 1000)</span><br><span class="line">    public void fixedDelay()&#123;</span><br><span class="line">        System.out.println(&quot;fixedDelay：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(fixedRate = 2000)</span><br><span class="line">    public void fixedRate()&#123;</span><br><span class="line">        System.out.println(&quot;fixedRate：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(initialDelay = 1000,fixedRate = 2000)</span><br><span class="line">    public void initialDelay()&#123;</span><br><span class="line">        System.out.println(&quot;initialDelay：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">    @Scheduled(cron = &quot;0 * * * * ?&quot;)</span><br><span class="line">    public void cron()&#123;</span><br><span class="line">        System.out.println(&quot;cron：&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li>通过<code>@Scheduled</code>注解来标注一个定时任务，其中<code>fixedDelay=1000</code>表示在当前任务执行<strong>结束</strong>1秒后开启另一个任务；<code>fixedRate=2000</code>表示在当前任务执行2秒后开启另一个定时任务；<code>initialDelay=1000</code>则表示首次执行的延迟时间为1秒，即任务首次启动任务的延迟时间。</li><li>在<code>@Scheduled</code>注解中也可以使用cron表达式，<code>cron=&quot;0 * * * * ?&quot;</code>表示该定时任务每分钟执行一次。</li><li>以上注解值的单位默认为<code>TimeUnit.MILLISECONDS</code>，即毫秒。</li></ul><p>配置完成后，接下来启动SpringBoot项目，定时任务部分打印日志如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-90f391184cbb6ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h3><p>cron表达式由6个部分组成，从左到右分别是：秒(second)、分(minute)、时(hour)、日(day of month)、月(month)、周(day of week)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────── second (0-59)</span><br><span class="line">│ ┌───────────── minute (0 - 59)</span><br><span class="line">│ │ ┌───────────── hour (0 - 23)</span><br><span class="line">│ │ │ ┌───────────── day of the month (1 - 31)</span><br><span class="line">│ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC)</span><br><span class="line">│ │ │ │ │ ┌───────────── day of the week (0 - 7)  (0 or 7 is Sunday, or MON-SUN)</span><br><span class="line">│ │ │ │ │ │</span><br><span class="line">│ │ │ │ │ │</span><br><span class="line">* * * * * *</span><br></pre></td></tr></table></figure><p>各个部分的取值情况如下表所示：</p><table><thead><tr><th align="center">部分</th><th align="center">是否为必填项</th><th align="center">允许填写的值</th><th align="center">允许的通配符</th></tr></thead><tbody><tr><td align="center">秒(second)</td><td align="center">是</td><td align="center">0-59</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">分(minute)</td><td align="center">是</td><td align="center">0-59</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">时(hour)</td><td align="center">是</td><td align="center">0-23</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">日(day of month)</td><td align="center">是</td><td align="center">1-31</td><td align="center"><code>- * ? / L W</code></td></tr><tr><td align="center">月(month)</td><td align="center">是</td><td align="center">1-12 or JAN-DEC</td><td align="center"><code>- * /</code></td></tr><tr><td align="center">周(day of week)</td><td align="center">是</td><td align="center">0-7 or SUN-SAT</td><td align="center"><code>- * ? / L #</code></td></tr></tbody></table><p>解释一下上述通配符的含义：<br>（1）<code>?</code>表示不指定值，如果开发者不关心某个部分的取值时，就可以使用它。请注意，月份中的日期和星期可能会起冲突，因此在配置时这两个必须有一个值是<code>?</code>；</p><p>（2）<code>*</code>表示所有值，举个例子，当你在“秒”上设置<code>*</code>时，则表示每秒都会触发；</p><p>（3）<code>, </code>用于分开多个值，举个例子，当你在“周”上设置 “MON,WED,FRI”，分别表示周一，周三和周五触发；</p><p>（4）<code>-</code> 表示区间，举个例子，当你在“秒”上设置 “10-12”，则表示10,11,12秒都会触发；</p><p>（5）<code>/</code>用于递增触发，举个例子，当你在“秒”上面设置”5/15”，则表示从5秒开始，每增15秒触发(5,20,35,50)；</p><p>（6）<code>#</code>表示序号(即每月的第几个周几)，举个例子，当你在“周”上设置”6#3”，则表示在每月的第三个周六，这种可以用在母亲节和父亲节之类的动态变化节日上面。请注意，在“周”这一部分中，英文字母是不分大小写的，即MON与mon是一样的；</p><p>（7）<code>L</code>表示最后。用在“日”上，表示当月的最后一天(依据当前月份，如果是二月系统会自动判断是否是润年)。 在“周”字段上表示星期六，相当于”7”或”SAT”（周日是第一天，即每个星期的开始）。如果在”L”前加上数字，则表示该数据的最后一个。举个例子，当你在“周”上设置”6L”，则表示”本月最后一个星期五”；</p><p>（8）<code>W</code>表示离指定日期最近的工作日(周一至周五)。举个例子，如果你在“日”上设置”15W”，则表示离每月15号最近的那个工作日触发。如果15号是周六，那么找最近的周五(14号)触发，如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”，它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字，不允许区间”-“)</p><p>（9）<code>L</code>和<code>W</code>可以组合使用。举个例子，如果在“日”上设置”LW”，则表示在本月的最后一个工作日触发，一般用于发薪日。</p><h3 id="一些常用的例子"><a href="#一些常用的例子" class="headerlink" title="一些常用的例子"></a>一些常用的例子</h3><p>（1）<code>0 0 * * * *</code>，表示每天每个小时的开始，即0分0秒；<br>（2）<code>*/10 * * * * *</code>，表示每10秒钟；<br>（3）<code>0 0 8-10 * * *</code>，表示每天8点、9点和10点；<br>（4）<code>0 0 6,19 * * *</code>，表示每天早上 6:00 和晚上 7:00；<br>（5）<code>0 0/30 8-10 * * *</code>，表示每天 8:00、8:30、9:00、9:30、10:00 和 10:30；<br>（6）<code>0 0 9-17 * * MON-FRI</code>，表示工作日朝九晚五；<br>（7）<code>0 0 0 25 12 ?</code>，表示每个圣诞节的午夜；<br>（8）<code>0 0 0 L * *</code>，表示每月最后一天的午夜；<br>（9）<code>0 0 0 L-3 * *</code>，表示每月倒数第三天午夜；<br>（10）<code>0 0 0 1W * *</code>，表示每月第一个工作日的午夜；<br>（11）<code>0 0 0 LW * *</code>，表示每月最后一个工作日的午夜；<br>（12）<code>0 0 0 * * 5L</code>，表示每月最后一个星期五午夜；<br>（13）<code>0 0 0 * * THUL</code>，表示每月最后一个星期四的午夜；<br>（14）<code>0 0 0 ? * 5#2</code>，表示每月第二个星期五午夜；<br>（15）<code>0 0 0 ? * MON#1</code>，表示每月第一个星期一的午夜。</p><h1 id="Quartz-方式"><a href="#Quartz-方式" class="headerlink" title="Quartz 方式"></a>Quartz 方式</h1><h3 id="Quartz-简介"><a href="#Quartz-简介" class="headerlink" title="Quartz 简介"></a>Quartz 简介</h3><p>Quartz是一个功能丰富的开源作业调度库，它由Java编写，可以集成在任何Java应用程序中。开发者可以使用Quartz来创建简单或者复杂的执行计划，它支持数据库、集群、插件以及邮件，且支持cron表达式，具有极高的灵活性。</p><p>一般来说，除非定时任务业务非常简单，否则一般是不会使用<code>@Scheduled</code>注解方式，而是使用Quartz框架。</p><h3 id="小试牛刀-1"><a href="#小试牛刀-1" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p> <strong>第一步，添加依赖。</strong>在项目的POM文件中新增Quartz依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步，开启定时任务。</strong>在项目启动类上添加<code>@EnableScheduling</code>注解，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@EnableScheduling</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class TimeTaskApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TimeTaskApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步，配置定时任务。</strong>Quartz有三个比较重要的概念，其中JobDetail是用户要做的事情；<br>Trigger是触发器，即事情什么时候做；SchedulerFactory是调度工厂，里面包含多个触发器。</p><p>我们先要确定用户要做的事情（JobDetail），由于用户要做的可能不是一件事，因此需要先定义每件事情（Job）。定义Job有两种方式，可以直接定义Bean或者继承QuartzJobBean这一方式。</p><p>新建一个component包，如果我们选择“直接定义Bean”这一方式，那么在其中创建一个<code>FirstJob</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class FirstJob &#123;</span><br><span class="line">    public void first()&#123;</span><br><span class="line">        System.out.println(&quot;FirstJob---&gt;first:&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式比较简单，直接将这个Bean注册到Spring容器中，但是也有缺点，无法传递参数。如果开发者需要传递参数，那么可以选择“继承QuartzJobBean”这一方式，在其中创建一个<code>SecondJob</code>类，其中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SecondJob extends QuartzJobBean &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;</span><br><span class="line">        System.out.println(&quot;SecondJob---&gt;name:&quot;+new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来新建一个config包，并在其中创建<code>QuartzConfig</code>类用于对<code>JobDetail</code>和<code>Trigger</code>进行配置，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class QuartzConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    MethodInvokingJobDetailFactoryBean jobDetailOne()&#123;</span><br><span class="line">        MethodInvokingJobDetailFactoryBean bean = new MethodInvokingJobDetailFactoryBean();</span><br><span class="line">        bean.setTargetBeanName(&quot;firstJob&quot;);</span><br><span class="line">        bean.setTargetMethod(&quot;first&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JobDetailFactoryBean jobDetailTwo()&#123;</span><br><span class="line">        JobDetailFactoryBean bean = new JobDetailFactoryBean();</span><br><span class="line">        bean.setJobClass(SecondJob.class);</span><br><span class="line">        JobDataMap jobDataMap = new JobDataMap();</span><br><span class="line">        jobDataMap.put(&quot;name&quot;,&quot;kenbings&quot;);</span><br><span class="line">        bean.setJobDataMap(jobDataMap);</span><br><span class="line">        bean.setDurability(true);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SimpleTriggerFactoryBean simpleTrigger()&#123;</span><br><span class="line">        SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(jobDetailOne().getObject());</span><br><span class="line">        bean.setRepeatCount(3);</span><br><span class="line">        bean.setStartDelay(1000);</span><br><span class="line">        bean.setRepeatInterval(2000);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    CronTriggerFactoryBean cronTrigger()&#123;</span><br><span class="line">        CronTriggerFactoryBean bean = new CronTriggerFactoryBean();</span><br><span class="line">        bean.setJobDetail(jobDetailTwo().getObject());</span><br><span class="line">        bean.setCronExpression(&quot;* * * * * ?&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SchedulerFactoryBean schedulerFactory()&#123;</span><br><span class="line">        SchedulerFactoryBean bean = new SchedulerFactoryBean();</span><br><span class="line">        SimpleTrigger simpleTrigger = simpleTrigger().getObject();</span><br><span class="line">        CronTrigger cronTrigger = cronTrigger().getObject();</span><br><span class="line">        bean.setTriggers(simpleTrigger,cronTrigger);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上述代码的含义：</p><ul><li><code>JobDetail</code>的配置方式方式：第一种方式通过<code>MethodInvokingJobDetailFactoryBean</code>类配置 <code>JobDetail</code>，只需要指定Job的实例名称和要调用的方法即可，注册这种方式无法在创建 <code>JobDetail</code>时传递参数；第二种方式是通过 <code>JobDetailFactoryBean</code>来实现的，这种方式只需要指定 <code>JobClass</code>即可，当然可以通过 <code>JobDataMap</code>传递参数到Job中，Job中只需要提供属性名，并且提供一个相应的set方法即可接收到参数。</li><li><code>Trigger</code>有多种不同实现，这里展示两种最常使用的<code>Trigger</code>：<code>SimpleTrigger</code>和<code>CronTrigger</code>，这两种<code>Trigger</code>分别使用<code>SimpleTriggerFactoryBean</code>和<code>CronTriggerFactoryBean</code>进行创建。在<code>SimpleTriggerFactoryBean</code>对象中，首先设置<code>JobDetail</code>，然后通过<code>setRepeatCount</code>配置任务循环次数，<code>setStartDelay</code>配置任务启动延迟时间，<code>setRepeatInterval</code>配置任务的时间间隔。在<code>CronTriggerFactoryBean</code>对象中，则主要配置<code>JobDetail</code>和Cron表达式。</li><li>最后通过<code>SchedulerFactoryBean</code>创建<code>SchedulerFactory</code>对象，然后配置<code>Trigger</code>即可。</li></ul><p>经过这几步的配置，定时任务就配置成功了。接下来启动SpringBoot项目，可以看到控制台输出一些信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-559914325add722c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中，定时任务是一个很常见的功能，如定时统计订单数、数据库备份、定时发送短信和邮件、定时统计博客访客等等，简单的定时</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot实现JSON数据重复读取</title>
    <link href="http://envyzhan.asia/2022/05/26/12-springboot-realizes-the-repeated-reading-of-json-data/"/>
    <id>http://envyzhan.asia/2022/05/26/12-springboot-realizes-the-repeated-reading-of-json-data/</id>
    <published>2022-05-26T09:55:30.000Z</published>
    <updated>2022-09-12T08:23:24.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近遇到一个很尴尬的问题，前端传给后端的JSON数据，如果开发者对此进行了拦截并进行了消费，那么后续在controller中就无法再次获取对应数据。原因在于服务端是通过IO流来解析JSON数据，而流是一种特殊的结构，只要读完就没有了，而在某些场景下往往希望可以多次读取。</p><p>举一个非常简单的例子，接口幂等性实现，即同一个接口在规定时间内多次接收到相同参数的请求，那么此时需要拒绝这些相同请求。我们在具体实现的时候，可能会先将请求中的参数提取出来，如果参数是JOSN数据，那么由于流已经读取了，因此后续在接口是无法再次获取JSON数据的。</p><h1 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h1><p>第一步，新建一个名为<code>many-json</code>的SpringBoot项目，并在其中新增Web依赖。</p><p>第二步，新建一个interceptor包，并在该包内新建一个RequestInterceptor类，这个类需要实现HandlerInterceptor接口并重写其中的preHandle方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class RequestInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RequestInterceptor.class);</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        String line = request.getReader().readLine();</span><br><span class="line">        logger.info(&quot;读取的信息为：&#123;&#125;&quot;,line);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就简单一些，通过流将请求中的参数打印输出一下，这样流就读完了。</p><p>第三步，新建一个config包，并在该包内新建一个MyWebMvcConfig类，这个类需要实现WebMvcConfigurer接口并重写其中的addInterceptors方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new RequestInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是注册拦截器，并设置该拦截器对所有请求都进行拦截。</p><p>第四步，新建一个controller包，并在该包内新建一个KenBingsController类，然后提供一个名为test的接口，注意该接口中参数通过JSON格式来传递：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class KenBingsController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(KenBingsController.class);</span><br><span class="line">    @PostMapping(&quot;/test&quot;)</span><br><span class="line">    public String test(@RequestBody String message)&#123;</span><br><span class="line">        logger.info(&quot;用户输入的信息为：&#123;&#125;&quot;,message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，启动项目进行测试。可以看到当用户访问<code>/test</code>接口的时候，该请求被拦截器所拦截，因此preHandle方法将会执行，输入如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7a7bb65c7c8133bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>但是由于我们在test方法的参数中使用了<code>@RequestBody</code>注解，而该注解底层是通过解析IO流来解析JSON数据的，加上我们在拦截器中已经读取了流，因此后续接口中就得不到数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5d1a69b2707af08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可是现在我们希望IO流可以被多次读取，此时该如何操作呢？可以利用装饰者模式对HttpServletRequest进行增强，即拦截HttpServletRequest请求且请求参数为JOSN格式调用新的HttpServletRequest包装类。</p><h1 id="装饰者模式对HttpServletRequest进行增强"><a href="#装饰者模式对HttpServletRequest进行增强" class="headerlink" title="装饰者模式对HttpServletRequest进行增强"></a>装饰者模式对HttpServletRequest进行增强</h1><p>第一步，新建一个wrapper包，并在该包内新建一个MyRequestWrapper类，这个类需要继承HttpServletRequestWrapper类并重写其中的getInputStream和getReader方法，同时重载一下父类ServletRequestWrapper中有HttpServletRequest和HttpServletResponse对象的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义请求包装类</span><br><span class="line"> */</span><br><span class="line">public class MyRequestWrapper extends HttpServletRequestWrapper &#123;</span><br><span class="line">    private final byte[] bytes;</span><br><span class="line"></span><br><span class="line">    public MyRequestWrapper(HttpServletRequest request,HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        super(request);</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        bytes = request.getReader().readLine().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletInputStream getInputStream() throws IOException &#123;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);</span><br><span class="line">        return new ServletInputStream() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isFinished() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void setReadListener(ReadListener readListener) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int read() throws IOException &#123;</span><br><span class="line">                return bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int available() throws IOException &#123;</span><br><span class="line">                return bytes.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedReader getReader() throws IOException &#123;</span><br><span class="line">        return new BufferedReader(new InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是自定义了一个新的HttpServletRequest类，并重载了一个包含HttpServletRequest和HttpServletResponse对象的构造方法，目的就是修改请求和响应的字符编码格式以及从IO流出读取数据，然后存入一个字节数组中，并通过重写getInputStream和getReader方法分别从字节数组中获取数据并构造IO流进行返回，这样就实现了IO流的多次读取。</p><p>第二步，新建一个filter包，并在该包内新建一个MyRequestFilter类，这个类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 请求拦截器，只有JSON数据才会使用自定义的RequestWrapper</span><br><span class="line"> */</span><br><span class="line">public class MyRequestFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        if(servletRequest instanceof HttpServletRequest)&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">            if(StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE))&#123;</span><br><span class="line">                MyRequestWrapper wrapper = new MyRequestWrapper(request,(HttpServletResponse) servletResponse);</span><br><span class="line">                filterChain.doFilter(wrapper,servletResponse);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(request,servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们重写了doFilter方法，目的就是判断请求的类型，如果请求是HttpServletRequest且请求数据类型为JSON格式才会调用自定义的MyRequestWrapper，即将HttpServletRequest替换为MyRequestWrapper，走IO流可以多次读取的逻辑，之后让过滤器继续往下执行。</p><p>请注意，过滤器最好不要使用<code>@Component</code>注解交由Spring容器来管理，这样会导致每个接口都会被进行过滤，最好是开发者自己手动注册，并且配置过滤的接口。</p><p>第三步，在之前定义的MyWebMvcConfig类中将这个自定义的MyRequestFilter过滤器注册进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyWebMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new RequestInterceptor()).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FilterRegistrationBean&lt;MyRequestFilter&gt; myRequestFilterFilterRegistrationBean()&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyRequestFilter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        bean.setFilter(new MyRequestFilter());</span><br><span class="line">        bean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，启动项目进行测试。可以发现现在访问<code>/test</code>接口，Postman会返回正常数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aadc04433ce13a16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>查看一下控制台可以看到现在controller中也能获取到JSON数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c4e2fe0dda61714c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过装饰者模式对HttpServletRequest进行增强这一方式可以解决JSON重复读取问题，其本质上是对请求数据格式进行判断。如果是JOSN格式，则自定义HttpServletRequest对象，先将数据从IO流中读取，然后存入一个字节数组中，后续多次读取则是多次读取该字节数组并以IO流形式进行返回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近遇到一个很尴尬的问题，前端传给后端的JSON数据，如果开发者对此进行了拦截并进行了消费，那么后续在controller中</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Vue实现一个代码生成器</title>
    <link href="http://envyzhan.asia/2022/05/18/10-use-springboot-and-vue-to-achieve-a-code-generator/"/>
    <id>http://envyzhan.asia/2022/05/18/10-use-springboot-and-vue-to-achieve-a-code-generator/</id>
    <published>2022-05-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:20:01.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们学习了SpringBoot+Vue这一套前后端分离的优秀架构，接下来我们尝试基于此实现一个代码生成器。在平时工作中，可能我们使用比较多的还是Mybatis Generate生成器，以此来根据数据表逆向生成对应的Dao层和Mapper层代码。其实生成器的核心，是使用JDBC来获取数据库中的各种元数据信息，并基于此来实现各种功能。本篇要实现的代码生成器不仅可以生成Dao层和Mapper层代码，还可以生成Service和Controller层代码，涵盖了一些基本操作，开发者要是实现一个简单的项目，几乎可以做到不写任何一行代码。</p><h1 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h1><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0d2004dfa4526ed8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>用户在序号1/2/3分别输入数据库用户名，密码、连接地址，然后点击序号4，如果数据库可以连接得上，那么序号5就会展示连接成功的提示信息，否则展示连接失败；如果成功接着在序号6中输入要生成的包的名称，也就是<code>$&#123;groupId&#125;.$&#123;artifactId&#125;</code>，接着点击序号7来生成配置，如果成功那么序号8处就会生成对应的数据表名称、实体类名称、mapper文件名称、service名称和controller名称，开发者也可以对这些名称进行修改，之后点击序号9来生成代码，如果生成成功，那么序号10会显示代码生成成功，并在序号11处显示生成的文件地址；如果生成失败，那么序号10会显示代码生成失败，序号11没有内容。</p><h1 id="数据库连接实现"><a href="#数据库连接实现" class="headerlink" title="数据库连接实现"></a>数据库连接实现</h1><p>下图是本部分需要实现的界面，用户输入用户名、密码和连接地址，然后点击测试连接按钮，后展示后台接口返回的信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8118579f0861f86d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="数据库连接后端接口实现"><a href="#数据库连接后端接口实现" class="headerlink" title="数据库连接后端接口实现"></a>数据库连接后端接口实现</h3><p>第一步，新建一个名为<code>code-generator</code>的SpringBoot项目，在其POM文件中新增web、mysql和freemarker依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>其中web用于展示页面，mysql用于连接数据库并获取连接元数据信息，freemarker用于制作生成的代码模板。</p><p>第二步，新建controller、model、service和utils包，并在model包里面新建Db实体类，这个表示用户前端输入的用户名，密码和连接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Db &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在model包内新建一个名为RespBean的响应类，后端返给前端的所有数据结构均满足这个类的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class RespBean &#123;</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String msg;</span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public static RespBean ok(String msg, Object data)&#123;</span><br><span class="line">        return new RespBean(200,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean ok(String msg)&#123;</span><br><span class="line">        return new RespBean(200,msg,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean error(String msg, Object data)&#123;</span><br><span class="line">        return new RespBean(500,msg,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RespBean error(String msg)&#123;</span><br><span class="line">        return new RespBean(500,msg,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RespBean(Integer status, String msg, Object data) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，在utils包内新建一个名为DBUtils的工具类，用于返回一个数据库连接和初始化数据库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * DB工具类，用于获取连接信息</span><br><span class="line"> */</span><br><span class="line">public class DBUtils &#123;</span><br><span class="line">    private static Connection connection;</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Connection initDb(Db db)&#123;</span><br><span class="line">        if(null == connection)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                connection = DriverManager.getConnection(db.getUrl(),db.getUsername(), db.getPassword());</span><br><span class="line">            &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，在controller包内新建一个名为DbController的数据库类，用于提供所需要的数据库测试，信息获取等接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DbController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户设置的数据库信息</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/connect&quot;)</span><br><span class="line">    public RespBean connect(@RequestBody Db db)&#123;</span><br><span class="line">        Connection connection = DBUtils.initDb(db);</span><br><span class="line">        if(null == connection)&#123;</span><br><span class="line">            return RespBean.error(&quot;数据库连接失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;数据库连接成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样数据库连接后端的连接测试接口就已经实现了。</p><h3 id="数据库连接前端页面实现"><a href="#数据库连接前端页面实现" class="headerlink" title="数据库连接前端页面实现"></a>数据库连接前端页面实现</h3><p>在项目<code>resources/static</code>目录下新建一个名为<code>index.html</code>的文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;代码生成器&lt;/title&gt;</span><br><span class="line">    &lt;!--在导入Element之前导入Vue--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/vue@2.6.11/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入ElementUI样式--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">    &lt;!--导入Element所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/element-ui@2.13.0/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入Axios所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户名&lt;/el-tag&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.username&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户密码&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库连接地址&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.url&quot;&gt;</span><br><span class="line">                    &lt;template slot=&quot;prepend&quot;&gt;jdbc:mysql://&lt;/template&gt;</span><br><span class="line">                    &lt;template slot=&quot;append&quot;&gt;</span><br><span class="line">                        ?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">                    &lt;/template&gt;</span><br><span class="line">                &lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; :disabled=&quot;!connectBtnEnabled&quot; @click=&quot;connect&quot;&gt;测试连接&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            connect()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                this.db.url = &quot;jdbc:mysql://&quot; + this.db.url + &quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;;</span><br><span class="line">                axios.post(&#x27;/connect&#x27;, this.db)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                        //还原数据库初始信息</span><br><span class="line">                        _this.db = &#123;</span><br><span class="line">                            username: &quot;root&quot;,</span><br><span class="line">                            password: &quot;root1234&quot;,</span><br><span class="line">                            url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        //禁用按钮</span><br><span class="line">                        _this.connectBtnEnabled = false;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）导入ElementUI、Vue和网络请求Axios库，注意Vue需要在ElementUI之前进行导入；<br>（2）使用了ElementUI的栅格布局，上面三行均采用3 12 9这一布局，标签名使用<code>el-tag</code>元素；输入框使用<code>el-input</code>元素；然后由于数据库连接地址我们采用了拼接这一方式，因此需要使用<code>el-input</code>元素中的prepend和append分别表示输入框的前置和后置内容，注意这与prefix和suffix的区别，后者分别表示输入框头部和尾部内容；<br>（3）用户未点击测试连接按钮之前，该按钮可以点击，一旦点击之后该按钮就会置灰，无法再次点击，除非刷新页面。点击该按钮之后会去请求后端名为<code>/connect</code>的接口，然后从返回的数据中取出信息并进行展示，也就是图中的msg。这里我们使用axios向后端发起请求；<br>（4）请注意axios请求如果成功，那么返回的RespBean对象存在于response的data选项中，之后就可以从中取出对应的数据。这里有两个注意点，第一需要先定义一个局部变量<code>_this</code>用于指代提交前的初始值，因为用户传入的url是只含地址，不包含前缀和后缀，而你如果直接提交，不还原之前的数据，那么之后提交的URL都是错的，所以我们让用户提交之后，让数据还原。第二，点击提交之后按钮需要置灰，用户无法再次点击，这些都是ElementUI中的基本用法。</p><p>用户未点击连接按钮之前，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bde392576d326df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当用户信息输入正确，点击测试连接按钮之后，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-96f8d22fc5beff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当用户信息输入错误，点击测试连接按钮之后，页面展示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-037082ca4ae2d05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="表对应实体类-Mapper-Service-Controller名称生成实现"><a href="#表对应实体类-Mapper-Service-Controller名称生成实现" class="headerlink" title="表对应实体类/Mapper/Service/Controller名称生成实现"></a>表对应实体类/Mapper/Service/Controller名称生成实现</h1><p>下图是本部分需要实现的界面，用户输入需要生成的包的前缀，点击生成配置按钮，即可显示对应表的实体类/Mapper/Service/Controller名称：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-69d4d42d9f53d95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="实体映射后端接口实现"><a href="#实体映射后端接口实现" class="headerlink" title="实体映射后端接口实现"></a>实体映射后端接口实现</h3><p>由于我们需要根据数据库的表来生成与之对应的实体类/Mapper/Service/Controller名称，而数据表和Java实体类之间需要有映射关系，这些关系具体点就是数据表中某个字段与Java实体类对应属性的映射，因此需要先定义一个ColumnClass类来描述映射信息。</p><p>第一步，在model包中新建一个名为ColumnClass的类，用于描述数据表中字段与Java实体类中属性映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述数据表中字段与Java实体类中属性映射关系</span><br><span class="line"> */</span><br><span class="line">public class ColumnClass &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Java实体类中属性名称</span><br><span class="line">     */</span><br><span class="line">    private String propertyName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段名称</span><br><span class="line">     */</span><br><span class="line">    private String columnName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段类型</span><br><span class="line">     */</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段是否为主键</span><br><span class="line">     */</span><br><span class="line">    private Boolean isPrimary;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段是否为空</span><br><span class="line">     */</span><br><span class="line">    private Boolean isNull;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数据表中字段备注</span><br><span class="line">     */</span><br><span class="line">    private String remark;</span><br><span class="line"></span><br><span class="line">    //toString、setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，在model包中新建一个名为TableClass的类，用于描述数据表与Java中对应模块名称的映射关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 描述数据表与Java中对应模块名称的映射关系</span><br><span class="line"> */</span><br><span class="line">public class TableClass &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 数据表名称</span><br><span class="line">     */</span><br><span class="line">    private String tableName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实体类名称</span><br><span class="line">     */</span><br><span class="line">    private String modelName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Mapper名称</span><br><span class="line">     */</span><br><span class="line">    private String mapperName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Service名称</span><br><span class="line">     */</span><br><span class="line">    private String serviceName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Controller名称</span><br><span class="line">     */</span><br><span class="line">    private String controllerName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所在包的名称</span><br><span class="line">     */</span><br><span class="line">    private String packageName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 所对应的字段信息</span><br><span class="line">     */</span><br><span class="line">    private List&lt;ColumnClass&gt; columns;</span><br><span class="line"></span><br><span class="line">    //toString、setter和getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，将下来完成“生成配置”这一按钮所请求的后端接口。由于用户传入的只有包的名称，因此不建议直接定义一个对象，而是通过Map来传值，否则还需要修改axios的默认传值方式（默认是传对象）。</p><p>在之前定义的DbController类中新增一个名为config的方法，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/config&quot;)</span><br><span class="line">public RespBean config(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">    String packageName = map.get(&quot;packageName&quot;);</span><br><span class="line">    try&#123;</span><br><span class="line">        Connection connection = DBUtils.getConnection();</span><br><span class="line">        //获取数据库的元数据</span><br><span class="line">        DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">        //获取数据库中所有的表</span><br><span class="line">        ResultSet tables = metaData.getTables(connection.getCatalog(), null, null, null);</span><br><span class="line">        //将这些表都转换为之前定义的TableClass对象</span><br><span class="line">        List&lt;TableClass&gt; tableClassList = new ArrayList&lt;&gt;();</span><br><span class="line">        while (tables.next())&#123;</span><br><span class="line">            TableClass tableClass = new TableClass();</span><br><span class="line">            //获取表名称</span><br><span class="line">            String tableName = tables.getString(&quot;TABLE_NAME&quot;);</span><br><span class="line">            tableClass.setTableName(tableName);</span><br><span class="line">            tableClass.setPackageName(packageName);</span><br><span class="line">            //获取实体类名称(一般是表名驼峰法且首字母大写这一方式)</span><br><span class="line">            //表名目前是小写下划线形式，转成首字母大写驼峰形式</span><br><span class="line">            String modelName = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, tableName);</span><br><span class="line">            tableClass.setModelName(modelName);</span><br><span class="line">            tableClass.setMapperName(modelName + &quot;Mapper&quot;);</span><br><span class="line">            tableClass.setServiceName(modelName + &quot;Service&quot;);</span><br><span class="line">            tableClass.setControllerName(modelName + &quot;Controller&quot;);</span><br><span class="line">            tableClassList.add(tableClass);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;数据表信息读取成功&quot;,tableClassList);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return RespBean.error(&quot;数据表信息读取成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法就是获取数据库连接并从中得到数据库的元数据信息，然后调用<code> metaData.getTables()</code>方法得到所选择数据库的所有表，该方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet getTables(String catalog, String schemaPattern,</span><br><span class="line">          String tableNamePattern, String types[]) throws SQLException;</span><br></pre></td></tr></table></figure><p>catalog是目录名称，它必须与存储在数据库中的目录名称匹配；如果值为””，则表示检索那些没有目录的；如果值为null，则表示不使用目录名称来缩小搜索范围。</p><p>schemaPattern是模式名称模式，它必须与存储在数据库中的模式名称匹配；如果值为””，则表示检索那些没有模式的； 如果值为null，则表示不使用模式名称来缩小搜索范围。</p><p>tableNamePattern是表名模式，它必须与存储在数据库类型中的表名匹配。<code>types[]</code>是表类型列表，它必须是<code>getTableTypes()</code>方法返回的表类型列表，这样才能包括在内； 如果值为null，则表示返回所有类型。因此此处后续三个参数均使用null值。</p><p>在得到所有的数据表之后，接下来我们就可以通过<code>tables.getString(&quot;TABLE_NAME&quot;)</code>方法得到表的名称，由于表的名称是小写下划线形式，而Java实体类及其他模块都是首字母大写驼峰形式，因此需要进行转换。这里使用谷歌提供的Guava工具进行转换，开发者也可以自行进行编写转换逻辑，这个很简单的。既然使用了Guava，那么就需要在POM文件中进行依赖引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;20.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后就是设置TableClass对象对应的属性，当然了这里我们没有对它的columns属性进行设置，这里直接使用默认值，且一般数据库字段和实体类字段习惯上也是采用表默认的小写下划线形式转成首字母大写驼峰形式。</p><h3 id="实体映射前端页面实现"><a href="#实体映射前端页面实现" class="headerlink" title="实体映射前端页面实现"></a>实体映射前端页面实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;代码生成器&lt;/title&gt;</span><br><span class="line">    &lt;!--在导入Element之前导入Vue--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/vue@2.6.11/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入ElementUI样式--&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui@2.13.0/lib/theme-chalk/index.css&quot;&gt;</span><br><span class="line">    &lt;!--导入Element所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/element-ui@2.13.0/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--导入Axios所需的JS--&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户名&lt;/el-tag&gt;</span><br><span class="line">             &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.username&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库用户密码&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.password&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;el-tag size=&quot;mini&quot;&gt;数据库连接地址&lt;/el-tag&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;12&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-input size=&quot;mini&quot; v-model=&quot;db.url&quot;&gt;</span><br><span class="line">                    &lt;template slot=&quot;prepend&quot;&gt;jdbc:mysql://&lt;/template&gt;</span><br><span class="line">                    &lt;template slot=&quot;append&quot;&gt;</span><br><span class="line">                        ?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">                    &lt;/template&gt;</span><br><span class="line">                &lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; :disabled=&quot;!connectBtnEnabled&quot; @click=&quot;connect&quot;&gt;测试连接&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div style=&quot;color: red;font-weight: bold&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;6&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-tag size=&quot;mini&quot; style=&quot;width: 80px&quot;&gt;请输入包名&lt;/el-tag&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;packageName&quot; size=&quot;mini&quot; style=&quot;width: 300px&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;3&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;config&quot;&gt;生成配置&lt;/el-button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">        &lt;el-col :span=&quot;9&quot;&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                packageName: &quot;com.kenbingthoughts.test&quot;,</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            config()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                axios.post(&#x27;/config&#x27;, &#123;packageName: this.packageName&#125;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            connect()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                this.db.url = &quot;jdbc:mysql://&quot; + this.db.url + &quot;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;;</span><br><span class="line">                axios.post(&#x27;/connect&#x27;, this.db)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.msg = response.data.msg;</span><br><span class="line">                        //还原数据库初始信息</span><br><span class="line">                        _this.db = &#123;</span><br><span class="line">                            username: &quot;root&quot;,</span><br><span class="line">                            password: &quot;root1234&quot;,</span><br><span class="line">                            url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        //禁用按钮</span><br><span class="line">                        _this.connectBtnEnabled = false;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在里面添加如下代码，具体的看代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5c8eceabdd2f948f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-112e40ba1c96b85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>表中数据获取到之后，接下来就是通过表格展示数据了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">    &lt;el-row&gt;</span><br><span class="line">        &lt;el-table</span><br><span class="line">                :data=&quot;tableData&quot;</span><br><span class="line">                style=&quot;width: 100%&quot;&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;tableName&quot;</span><br><span class="line">                    label=&quot;数据表名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;modelName&quot;</span><br><span class="line">                    label=&quot;实体类名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;mapperName&quot;</span><br><span class="line">                    label=&quot;mapper名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;serviceName&quot;</span><br><span class="line">                    label=&quot;service名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">            &lt;el-table-column</span><br><span class="line">                    prop=&quot;controllerName&quot;</span><br><span class="line">                    label=&quot;controller名称&quot;</span><br><span class="line">                    width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;/el-table-column&gt;</span><br><span class="line">        &lt;/el-table&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                tableData: [],</span><br><span class="line">                packageName: &quot;com.kenbingthoughts.test&quot;,</span><br><span class="line">                msg: &quot;数据库未连接&quot;,</span><br><span class="line">                connectBtnEnabled: true,</span><br><span class="line">                db: &#123;</span><br><span class="line">                    username: &quot;root&quot;,</span><br><span class="line">                    password: &quot;root1234&quot;,</span><br><span class="line">                    url: &quot;localhost:3306/code-generator&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            config()&#123;</span><br><span class="line">                let _this = this;</span><br><span class="line">                axios.post(&#x27;/config&#x27;, &#123;packageName: this.packageName&#125;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        //response.data才是后端返回的数据</span><br><span class="line">                        //展示成功消息</span><br><span class="line">                        _this.tableData = response.data.data;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>之后重启项目，页面展示如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-290729e1fb690a9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>输入正确信息后，点击测试连接通过后，再点击右侧的生成配置按钮：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-210224ddffc0bec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们所需要的数据已经得到了，但是目前表格还不能编辑，因此我们需要对代码进行修改。其实我们要修改的只是表格中prop字段的值，因此可以使用template中的slot方式来进行替换，同时为了验证上述方式可以修改表格中的值，这里我们还定义了一个updateCode方法用于进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-row&gt;</span><br><span class="line">    &lt;el-table</span><br><span class="line">            :data=&quot;tableData&quot;</span><br><span class="line">            style=&quot;width: 100%&quot;&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                prop=&quot;tableName&quot;</span><br><span class="line">                label=&quot;数据表名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;实体类名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.modelName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;mapper名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.mapperName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;service名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.serviceName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">        &lt;el-table-column</span><br><span class="line">                label=&quot;controller名称&quot;</span><br><span class="line">                width=&quot;300&quot;&gt;</span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">                &lt;el-input v-model=&quot;scope.row.controllerName&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;el-button @click=&quot;updateCode&quot; type=&quot;success&quot;&gt;修改代码&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><p>然后在methods选项中新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">updateCode()&#123;</span><br><span class="line">    axios.post(&#x27;/updateCode&#x27;, this.tableData)</span><br><span class="line">        .then(function (response) &#123;</span><br><span class="line">             console.log(response.data);</span><br><span class="line">         &#125;)</span><br><span class="line">        .catch(function (error) &#123;</span><br><span class="line">            console.log(error);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其实这个<code>/updateCode</code>接口后端是不用提供的，这里只是为了测试用户是否真的修改了表格中的数据，只需通过查看用户提交的信息就能确定。之后启动项目，刷新一下首页，可以看到页面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-04ce7d86fcc91100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后修改出现两个数据表所对应的实体类名称，然后点击修改代码按钮，可以看到提交给后端的API中实体类名称已经是修改之后的值了，这就说明前面修改数据的方法是有效的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-cdb4704079274668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="后端表对应实体类模板生成实现"><a href="#后端表对应实体类模板生成实现" class="headerlink" title="后端表对应实体类模板生成实现"></a>后端表对应实体类模板生成实现</h1><p>下图是本部分需要实现的界面，用户输入需要生成的包的前缀，点击生成配置按钮，即可显示对应表的实体类/Mapper/Service/Controller名称，然后点击生成代码按钮，即可出现生成实体类的位置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c825e060553a7f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f07a2663b5c8add.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="后端模板生成实现"><a href="#后端模板生成实现" class="headerlink" title="后端模板生成实现"></a>后端模板生成实现</h3><p>前面我们已经得到了TableClass对象，这里面的信息就可以指导我们生成对应的模板信息，之所以有“表对应实体类/Mapper/Service/Controller名称生成实现”这一过程，是因为我们允许用户对TableClass对象进行修改，也就是说我们得到的最终对象是用户提交后的TableClass对象。接下来我们就依据这个TableClass对象来生成对应的模板文件。模板文件类型使用FreeMarker来实现，这也是比较通用的做法。</p><p>第一步，制作实体类模板，由于之前我们在ColumnClass类中定义的只是数据表中的type，而不是实体类中的type，因此这里涉及到一个类型的转换，即根据数据表中字段的类型来选择使用对应的Java数据类型。在项目的<code>resources/templates</code>目录下新建一个名为<code>Model.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.model;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class $&#123;modelName&#125; &#123;</span><br><span class="line">&lt;#if columns??&gt;</span><br><span class="line">    &lt;#list columns as column&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;VARCHAR&#x27;||column.type = &#x27;TEXT&#x27;||column.type = &#x27;CHAR&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private String $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;INT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Integer $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIGINT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Long $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DOUBLE&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Double $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DATETIME&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Date $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIT&#x27;&gt;</span><br><span class="line">            /**</span><br><span class="line">            * $&#123;column.remark&#125;</span><br><span class="line">            */</span><br><span class="line">            private Boolean $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line"></span><br><span class="line">&lt;#if columns??&gt;</span><br><span class="line">    &lt;#list columns as column&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;VARCHAR&#x27;||column.type = &#x27;TEXT&#x27;||column.type = &#x27;CHAR&#x27;&gt;</span><br><span class="line">            public String get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(String $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;INT&#x27;&gt;</span><br><span class="line">            public Integer get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Integer $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIGINT&#x27;&gt;</span><br><span class="line">            public Long get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Long $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DATETIME&#x27;&gt;</span><br><span class="line">            public Date get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Date $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;DOUBLE&#x27;&gt;</span><br><span class="line">            public Double get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Double $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">        &lt;#if column.type = &#x27;BIT&#x27;&gt;</span><br><span class="line">            public Boolean get$&#123;column.propertyName&#125;()&#123;</span><br><span class="line">                return this.$&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set$&#123;column.propertyName&#125;(Boolean $&#123;column.propertyName?uncap_first&#125;)&#123;</span><br><span class="line">                this.$&#123;column.propertyName?uncap_first&#125; = $&#123;column.propertyName?uncap_first&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/#if&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类之后就是生成的实体类，这里我们导入基本的信息，注意这里面的一些变量均来自用户传入的信息。这里我们需要对用户在数据表中的字段属性和Java中的实体类属性类型进行转换，转换的规则代码中可以看到，这里就不介绍了。</p><p>第二步，在controller包内新建一个名为UpdateCodeController的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UpdateCodeController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UpdateCodeService updateCodeService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/updateCode&quot;)</span><br><span class="line">    public RespBean updateCode(@RequestBody List&lt;TableClass&gt; tableClassList, HttpServletRequest req)&#123;</span><br><span class="line">        return updateCodeService.updateCode(tableClassList,req.getServletContext().getRealPath(&quot;/&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建service包，并在该包中新建UpdateCodeService类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UpdateCodeService &#123;</span><br><span class="line"></span><br><span class="line">    //加载FreeMarker配置文件</span><br><span class="line">    Configuration cfg = null;</span><br><span class="line">    &#123;</span><br><span class="line">        //创建当前FreeMarker对应版本的配置类</span><br><span class="line">        cfg = new Configuration(VERSION_2_3_31);</span><br><span class="line">        //设置模板的存放位置</span><br><span class="line">        cfg.setTemplateLoader(new ClassTemplateLoader(UpdateCodeService.class,&quot;/templates&quot;));</span><br><span class="line">        //设置模板的编码格式</span><br><span class="line">        cfg.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RespBean updateCode(List&lt;TableClass&gt; tableClassList, String realPath) &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //定义模板</span><br><span class="line">            Template modelTemplate = cfg.getTemplate(&quot;Model.java.ftlh&quot;);</span><br><span class="line">            //获取数据库连接</span><br><span class="line">            Connection connection = DBUtils.getConnection();</span><br><span class="line">            //获取数据库元数据，需要使用里面的表名和字段名</span><br><span class="line">            DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">            //遍历用户传进来的tableClassList信息</span><br><span class="line">            for (TableClass tableClass:tableClassList)&#123;</span><br><span class="line">                //获取指定数据表中所有的字段信息</span><br><span class="line">                ResultSet columns = metaData.getColumns(connection.getCatalog(), null, tableClass.getTableName(), null);</span><br><span class="line">                //获取指定数据表中所有的主键信息</span><br><span class="line">                ResultSet primaryKeys = metaData.getPrimaryKeys(connection.getCatalog(),null, tableClass.getTableName());</span><br><span class="line"></span><br><span class="line">                //定义一个集合用于存放某个数据表中的所有字段</span><br><span class="line">                List&lt;ColumnClass&gt; columnClassList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                //遍历数据表中所有的字段信息</span><br><span class="line">                while (columns.next())&#123;</span><br><span class="line">                    //获取字段名称</span><br><span class="line">                    String columnName = columns.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                    //字段是否是否为空，值为NO或者YES</span><br><span class="line">                    String isNullable = columns.getString(&quot;IS_NULLABLE&quot;);</span><br><span class="line">                    //数据表中字段类型</span><br><span class="line">                    String dataType = columns.getString(&quot;TYPE_NAME&quot;);</span><br><span class="line">                    //数据表中字段备注</span><br><span class="line">                    String columnComment = columns.getString(&quot;REMARKS&quot;);</span><br><span class="line"></span><br><span class="line">                    //组装字段信息</span><br><span class="line">                    ColumnClass columnClass = new ColumnClass();</span><br><span class="line">                    //数据表中字段名称</span><br><span class="line">                    columnClass.setColumnName(columnName);</span><br><span class="line">                    //Java实体类中属性名称</span><br><span class="line">                    columnClass.setPropertyName(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL,columnName));</span><br><span class="line">                    //数据表中字段是否为空</span><br><span class="line">                    if(&quot;YES&quot;.equals(isNullable))&#123;</span><br><span class="line">                        columnClass.setNull(true);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        columnClass.setNull(false);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    //数据表中字段备注</span><br><span class="line">                    columnClass.setRemark(columnComment);</span><br><span class="line">                    //数据表中字段类型</span><br><span class="line">                    columnClass.setType(dataType);</span><br><span class="line"></span><br><span class="line">                    //将主键遍历游标置为0，重新开始</span><br><span class="line">                    primaryKeys.first();</span><br><span class="line">                    while (primaryKeys.next())&#123;</span><br><span class="line">                        String pkName = primaryKeys.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                        //如果主键名称等于字段名称，那么该字段就是主键</span><br><span class="line">                        if(columnName.equals(pkName))&#123;</span><br><span class="line">                            //数据表中字段是否为主键</span><br><span class="line">                            columnClass.setPrimary(true);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    columnClassList.add(columnClass);</span><br><span class="line">                &#125;</span><br><span class="line">                tableClass.setColumns(columnClassList);</span><br><span class="line">                //将包名转换成路径地址</span><br><span class="line">                String path = realPath + &quot;/&quot; + tableClass.getPackageName().replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line">                //生成该表对应的实体类</span><br><span class="line">                update(modelTemplate,tableClass,path + &quot;/model/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return RespBean.ok(&quot;代码生成成功&quot;,realPath);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.error(&quot;代码生成失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成对应的实体类</span><br><span class="line">     * @param template 实体类模板</span><br><span class="line">     * @param tableClass 实体类对应的TableClass对象</span><br><span class="line">     * @param path 实体类存放路径</span><br><span class="line">     */</span><br><span class="line">    private void update(Template template, TableClass tableClass, String path) throws IOException, TemplateException &#123;</span><br><span class="line">        //创建文件夹</span><br><span class="line">        File folder = new File(path);</span><br><span class="line">        if(!folder.exists())&#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        //创建对应的实体类文件(xxx.java文件)</span><br><span class="line">        String fileName = path + &quot;/&quot;+ tableClass.getModelName()+ template.getName().replace(&quot;Model&quot;,&quot;&quot;).replace(&quot;ftlh&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(fileName);</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(fos);</span><br><span class="line"></span><br><span class="line">        //将数据写入模板中</span><br><span class="line">        template.process(tableClass,osw);</span><br><span class="line"></span><br><span class="line">        fos.close();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法的作用笔者已经代码中进行了详细介绍，这里就不过多介绍了。</p><p>第四步，在<code>resources/static</code>目录下的<code>index.html</code>中新增如下代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1d3c56bb0206bd61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8929f0f9f22b7e5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第五步，启动项目进行测试，刷新一下页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9e8768e56d79bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后输入正确的信息，点击测试连接按钮后，成功的话再次点击生成配置按钮，最后点击生成代码按钮，可以看到此时页面出现了生成代码的存放位置，且对应位置下确实已经生成了对应的实体类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c825e060553a7f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f07a2663b5c8add.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>本部分后端代码是整个代码生成器的核心，在了解和知悉实体类的生成原理后，其他对应模板的制作和生成差不多。</p><h1 id="后端表对应Mapper-Service-Controller模板生成实现"><a href="#后端表对应Mapper-Service-Controller模板生成实现" class="headerlink" title="后端表对应Mapper/Service/Controller模板生成实现"></a>后端表对应Mapper/Service/Controller模板生成实现</h1><h3 id="后端mapper模板实现"><a href="#后端mapper模板实现" class="headerlink" title="后端mapper模板实现"></a>后端mapper模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Mapper.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.mapper;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface $&#123;mapperName&#125; &#123;</span><br><span class="line">  List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端service模板实现"><a href="#后端service模板实现" class="headerlink" title="后端service模板实现"></a>后端service模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Service.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.service;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.mapper.$&#123;mapperName&#125;;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class $&#123;serviceName&#125; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private $&#123;mapperName&#125; $&#123;mapperName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    public List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s()&#123;</span><br><span class="line">        return $&#123;mapperName?uncap_first&#125;.getAll$&#123;modelName&#125;s();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端controller模板实现"><a href="#后端controller模板实现" class="headerlink" title="后端controller模板实现"></a>后端controller模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Controller.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package $&#123;packageName&#125;.controller;</span><br><span class="line"></span><br><span class="line">import $&#123;packageName&#125;.model.$&#123;modelName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.mapper.$&#123;mapperName&#125;;</span><br><span class="line">import $&#123;packageName&#125;.service.$&#123;serviceName&#125;;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class $&#123;controllerName&#125; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private $&#123;serviceName&#125; $&#123;serviceName?uncap_first&#125;;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/$&#123;modelName?lower_case&#125;s&quot;)</span><br><span class="line">    public List&lt;$&#123;modelName&#125;&gt; getAll$&#123;modelName&#125;s()&#123;</span><br><span class="line">        return $&#123;serviceName?uncap_first&#125;.getAll$&#123;modelName&#125;s();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端mapper-XML模板实现"><a href="#后端mapper-XML模板实现" class="headerlink" title="后端mapper XML模板实现"></a>后端mapper XML模板实现</h3><p>在项目的<code>resources/templates</code>目录下新建一个名为<code>Controller.java.ftlh</code>的FreeMarker文件，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;$&#123;packageName&#125;.mapper.$&#123;mapperName&#125;&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;$&#123;packageName&#125;.model.$&#123;modelName&#125;&quot;&gt;</span><br><span class="line">        &lt;#list columns as column&gt;</span><br><span class="line">            &lt;&lt;#if column.isPrimary??&gt;id&lt;#else&gt;result&lt;/#if&gt; column=&quot;$&#123;column.columnName&#125;&quot; property=&quot;$&#123;column.propertyName?uncap_first&#125;&quot; jdbcType=&quot;&lt;#if column.type=&#x27;INT&#x27;&gt;INTEGER&lt;#elseif column.type=&#x27;DATETIME&#x27;&gt;TIMESTAMP&lt;#elseif column.type=&#x27;TEXT&#x27;&gt;VARCHAR&lt;#else&gt;$&#123;column.type&#125;&lt;/#if&gt;&quot;/&gt;</span><br><span class="line">        &lt;/#list&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAll$&#123;modelName&#125;s&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select * from $&#123;tableName&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>可以看到这里我们生成的模板中都只提供了一个查询全部数据的方法，后续开发者可以自行进行扩展，而且service层没有定义对应的接口文件，而是直接使用了实现类，这个后续也可以进行升级和修改。</p><h3 id="更新模板生成接口"><a href="#更新模板生成接口" class="headerlink" title="更新模板生成接口"></a>更新模板生成接口</h3><p>修改service包下的<code>UpdateCodeService#updateCode()</code>方法为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public RespBean updateCode(List&lt;TableClass&gt; tableClassList, String realPath) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //定义实体类模板</span><br><span class="line">        Template modelTemplate = cfg.getTemplate(&quot;Model.java.ftlh&quot;);</span><br><span class="line">        //定义mapper接口模板</span><br><span class="line">        Template mapperTemplate = cfg.getTemplate(&quot;Mapper.java.ftlh&quot;);</span><br><span class="line">        //定义mapper XML模板</span><br><span class="line">        Template mapperXMLTemplate = cfg.getTemplate(&quot;Mapper.xml.ftlh&quot;);</span><br><span class="line">        //定义Service类模板</span><br><span class="line">        Template serviceTemplate = cfg.getTemplate(&quot;Service.java.ftlh&quot;);</span><br><span class="line">        //定义Controller类模板</span><br><span class="line">        Template controllerTemplate = cfg.getTemplate(&quot;Controller.java.ftlh&quot;);</span><br><span class="line"></span><br><span class="line">        //获取数据库连接</span><br><span class="line">        Connection connection = DBUtils.getConnection();</span><br><span class="line">        //获取数据库元数据，需要使用里面的表名和字段名</span><br><span class="line">        DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">        //遍历用户传进来的tableClassList信息</span><br><span class="line">        for (TableClass tableClass:tableClassList)&#123;</span><br><span class="line">            //获取指定数据表中所有的字段信息</span><br><span class="line">            ResultSet columns = metaData.getColumns(connection.getCatalog(), null, tableClass.getTableName(), null);</span><br><span class="line">            //获取指定数据表中所有的主键信息</span><br><span class="line">            ResultSet primaryKeys = metaData.getPrimaryKeys(connection.getCatalog(),null, tableClass.getTableName());</span><br><span class="line"></span><br><span class="line">            //定义一个集合用于存放某个数据表中的所有字段</span><br><span class="line">            List&lt;ColumnClass&gt; columnClassList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            //遍历数据表中所有的字段信息</span><br><span class="line">            while (columns.next())&#123;</span><br><span class="line">                //获取字段名称</span><br><span class="line">                String columnName = columns.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                //字段是否是否为空，值为NO或者YES</span><br><span class="line">                String isNullable = columns.getString(&quot;IS_NULLABLE&quot;);</span><br><span class="line">                //数据表中字段类型</span><br><span class="line">                String dataType = columns.getString(&quot;TYPE_NAME&quot;);</span><br><span class="line">                //数据表中字段备注</span><br><span class="line">                String columnComment = columns.getString(&quot;REMARKS&quot;);</span><br><span class="line"></span><br><span class="line">                //组装字段信息</span><br><span class="line">                ColumnClass columnClass = new ColumnClass();</span><br><span class="line">                //数据表中字段名称</span><br><span class="line">                columnClass.setColumnName(columnName);</span><br><span class="line">                //Java实体类中属性名称</span><br><span class="line">                columnClass.setPropertyName(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL,columnName));</span><br><span class="line">                //数据表中字段是否为空</span><br><span class="line">                if(&quot;YES&quot;.equals(isNullable))&#123;</span><br><span class="line">                    columnClass.setNull(true);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    columnClass.setNull(false);</span><br><span class="line">                &#125;;</span><br><span class="line">                //数据表中字段备注</span><br><span class="line">                columnClass.setRemark(columnComment);</span><br><span class="line">                //数据表中字段类型</span><br><span class="line">                columnClass.setType(dataType);</span><br><span class="line"></span><br><span class="line">                //将主键遍历游标置为0，重新开始</span><br><span class="line">                primaryKeys.first();</span><br><span class="line">                while (primaryKeys.next())&#123;</span><br><span class="line">                    String pkName = primaryKeys.getString(&quot;COLUMN_NAME&quot;);</span><br><span class="line">                    //如果主键名称等于字段名称，那么该字段就是主键</span><br><span class="line">                    if(columnName.equals(pkName))&#123;</span><br><span class="line">                        //数据表中字段是否为主键</span><br><span class="line">                        columnClass.setPrimary(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                columnClassList.add(columnClass);</span><br><span class="line">            &#125;</span><br><span class="line">            tableClass.setColumns(columnClassList);</span><br><span class="line">            //将包名转换成路径地址</span><br><span class="line">            String path = realPath + &quot;/&quot; + tableClass.getPackageName().replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line"></span><br><span class="line">            //生成该表对应的实体类</span><br><span class="line">            update(modelTemplate,tableClass,path + &quot;/model/&quot;);</span><br><span class="line">            //生成该表对应的mapper接口类</span><br><span class="line">            update(mapperTemplate,tableClass,path + &quot;/mapper/&quot;);</span><br><span class="line">            //生成该表对应的mapper XML</span><br><span class="line">            update(mapperXMLTemplate,tableClass,path + &quot;/mapper/&quot;);</span><br><span class="line">            //生成该表对应的Service类</span><br><span class="line">            update(serviceTemplate,tableClass,path + &quot;/service/&quot;);</span><br><span class="line">            //生成该表对应的Controller类</span><br><span class="line">            update(controllerTemplate,tableClass,path + &quot;/controller/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return RespBean.ok(&quot;代码生成成功&quot;,realPath);</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return RespBean.error(&quot;代码生成失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是读取上面新增的模板信息并生成对应的文件，因此实际上新增的代码只有下图所示的内容：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-da6eb7e2825c69d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e838784eb84701a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="新建测试项目"><a href="#新建测试项目" class="headerlink" title="新建测试项目"></a>新建测试项目</h3><p>运行项目，然后按照之前的操作点击生成对应的代码。接下来我们创建一个项目，来使用这个代码生成器生成的代码，看看生成的代码是否有效。注意由于你指定了包的名称，因此新建项目的包名称也就确定了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e6b06afe27e1bacb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>因此新建一个名为test的项目，前缀就是<code>com.kenbingthoughts</code>，之后在POM文件中引入Web、MySQL和Mybatis依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b0c3db0ed45a025e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后在其<code>application.properties</code>配置文件中新增如下配置项，即用户名、密码和连接地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root1234</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/code-generator?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>由于此处我们的Mapper接口和XML文件放在一起，因此需要在其POM文件中新增如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!--Mapper文件和XML放在一起需要添加--&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>接着启动项目，依次访问controller中的接口，可以看到接口返回正常值，这就说明生成的代码是正确的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64fe2999a0fb3e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇利用SpringBoot+Vue+FreeMarker实现了一个简易版的代码生成器，其实它还有很多可以改进的地方，如可以显示数据表中的字段信息详情，支持用户修改字段所对应的实体属性信息，页面布局优化，生成的地址固定等，这些等后期有空会进行升级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们学习了SpringBoot+Vue这一套前后端分离的优秀架构，接下来我们尝试基于此实现一个代码生成器。在平时工作中</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>关于Freemarker模板引擎，需要知道这些</title>
    <link href="http://envyzhan.asia/2022/04/26/9-what-you-need-to-know-about-freemarker-template-engine/"/>
    <id>http://envyzhan.asia/2022/04/26/9-what-you-need-to-know-about-freemarker-template-engine/</id>
    <published>2022-04-26T09:55:30.000Z</published>
    <updated>2022-09-12T08:18:03.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>尽管在目前企业级的应用开发中，前后端分离是趋势，但是视图层技术还是占用一席之地。SpringBoot对视图层技术也提供了很好的支持，官方推荐使用的模板引擎是Thymeleaf，但是FreeMaker也支持，当然你可以像SSM中使用JSP等，但是非常不推荐使用。</p><h1 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h1><h3 id="FreeMarker简介"><a href="#FreeMarker简介" class="headerlink" title="FreeMarker简介"></a>FreeMarker简介</h3><p>FreeMarker是一个非常古老的Java模板引擎，可以用在Web或者非Web环境中。与Thymeleaf不同的是FreeMarker需要经过解析才能够在浏览器中展示出来。FreeMarker不仅可以用来配置HTML页面模板，也可以作为电子邮箱模板、配置文件模板以及源码模板等。正是由于它可以适应不同的应用场景，因此它虽然古老但是依旧还是有人愿意使用它。</p><p>下面是一张摘自FreeMarker官网的图片：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-45e88181a0d1c2ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到FreeMarker可以将模板（Template）和数据（Java Objects）进行渲染为HTML页面。</p><h3 id="FreeMarker模板文件及存放位置"><a href="#FreeMarker模板文件及存放位置" class="headerlink" title="FreeMarker模板文件及存放位置"></a>FreeMarker模板文件及存放位置</h3><p>查看一下这个<code>spring-boot-autoconfigure</code>依赖的<code>META-INF</code>文件夹下面的<code>spring.factories</code>文件，里面有如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br></pre></td></tr></table></figure><p>然后进入查看一下这个类，源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class FreeMarkerTemplateAvailabilityProvider extends PathBasedTemplateAvailabilityProvider &#123;</span><br><span class="line">    public FreeMarkerTemplateAvailabilityProvider() &#123;</span><br><span class="line">        super(&quot;freemarker.template.Configuration&quot;, FreeMarkerTemplateAvailabilityProvider.FreeMarkerTemplateAvailabilityProperties.class, &quot;spring.freemarker&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static final class FreeMarkerTemplateAvailabilityProperties extends TemplateAvailabilityProperties &#123;</span><br><span class="line">        private List&lt;String&gt; templateLoaderPath = new ArrayList(Arrays.asList(&quot;classpath:/templates/&quot;));</span><br><span class="line"></span><br><span class="line">        FreeMarkerTemplateAvailabilityProperties() &#123;</span><br><span class="line">            super(&quot;&quot;, &quot;.ftlh&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected List&lt;String&gt; getLoaderPath() &#123;</span><br><span class="line">            return this.templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;String&gt; getTemplateLoaderPath() &#123;</span><br><span class="line">            return this.templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setTemplateLoaderPath(List&lt;String&gt; templateLoaderPath) &#123;</span><br><span class="line">            this.templateLoaderPath = templateLoaderPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到FreeMarker模板后缀为<code>ftlh</code>（FreeMarker Template Language）。FTL是一种简单专用的语言，不是编程语言，因此在模板中开发者只需专注于如何展现数据， 而数据的获取则在模板之外确定。FreeMarker模板文件的存放路径位于<code>classpath:/templates/</code>路径下，这一点需要引起注意。</p><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p><strong>第一步</strong>，新建一个名为<code>learn-freemarker</code>的SpringBoot项目，然后在POM文件中新增FreeMarker和Web依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接着继续查看这个<code>spring-boot-autoconfigure</code>依赖的<code>META-INF</code>文件夹下面的<code>spring.factories</code>文件中关于FreeMarker的自动配置类<code>FreeMarkerAutoConfiguration</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>查看一下这个<code>FreeMarkerAutoConfiguration</code>自动配置类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class&#125;)</span><br><span class="line">@EnableConfigurationProperties(&#123;FreeMarkerProperties.class&#125;)</span><br><span class="line">@Import(&#123;FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfiguration.class&#125;)</span><br><span class="line">public class FreeMarkerAutoConfiguration &#123;</span><br><span class="line">    private static final Log logger = LogFactory.getLog(FreeMarkerAutoConfiguration.class);</span><br><span class="line">    private final ApplicationContext applicationContext;</span><br><span class="line">    private final FreeMarkerProperties properties;</span><br><span class="line"></span><br><span class="line">    //有参构造方法注入ApplicationContext、FreeMarkerProperties对象</span><br><span class="line">    public FreeMarkerAutoConfiguration(ApplicationContext applicationContext, FreeMarkerProperties properties) &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">        this.checkTemplateLocationExists();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检查模板存放位置是否存在</span><br><span class="line">    public void checkTemplateLocationExists() &#123;</span><br><span class="line">        if (logger.isWarnEnabled() &amp;&amp; this.properties.isCheckTemplateLocation()) &#123;</span><br><span class="line">            List&lt;TemplateLocation&gt; locations = this.getLocations();</span><br><span class="line">            if (locations.stream().noneMatch(this::locationExists)) &#123;</span><br><span class="line">                logger.warn(&quot;Cannot find template location(s): &quot; + locations + &quot; (please add some templates, check your FreeMarker configuration, or set spring.freemarker.checkTemplateLocation=false)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取模板的位置</span><br><span class="line">    private List&lt;TemplateLocation&gt; getLocations() &#123;</span><br><span class="line">        List&lt;TemplateLocation&gt; locations = new ArrayList();</span><br><span class="line">        String[] var2 = this.properties.getTemplateLoaderPath();</span><br><span class="line">        int var3 = var2.length;</span><br><span class="line"></span><br><span class="line">        for(int var4 = 0; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">            String templateLoaderPath = var2[var4];</span><br><span class="line">            TemplateLocation location = new TemplateLocation(templateLoaderPath);</span><br><span class="line">            locations.add(location);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return locations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否存在模板位置</span><br><span class="line">    private boolean locationExists(TemplateLocation location) &#123;</span><br><span class="line">        return location.exists(this.applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从里面可以看出，当classpath下面存在<code>freemarker.template.Configuration</code>和<code>FreeMarkerConfigurationFactory</code>类时，这个自动配置类才会生效，实际上这两个类在我们引入freemarker场景启动器时就已经存在了。属性POJO类则是FreeMarkerProperties，到时候开发者需要重写配置项的时候可以从该类中进行查阅。</p><p>同时还导入了<code>FreeMarkerServletWebConfiguration</code>、<code>FreeMarkerReactiveWebConfiguration</code>和<code>FreeMarkerNonWebConfiguration</code>这三个类，由于我们使用的是普通的Web项目，因此真正用到的还是<code>FreeMarkerServletWebConfiguration</code>这个类。查看一下这个类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, FreeMarkerConfigurer.class&#125;)</span><br><span class="line">@AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class&#125;)</span><br><span class="line">class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration &#123;</span><br><span class="line">    protected FreeMarkerServletWebConfiguration(FreeMarkerProperties properties) &#123;</span><br><span class="line">        super(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(&#123;FreeMarkerConfig.class&#125;)</span><br><span class="line">    FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();</span><br><span class="line">        this.applyProperties(configurer);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    freemarker.template.Configuration freeMarkerConfiguration(FreeMarkerConfig configurer) &#123;</span><br><span class="line">        return configurer.getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(</span><br><span class="line">        name = &#123;&quot;freeMarkerViewResolver&quot;&#125;</span><br><span class="line">    )</span><br><span class="line">    @ConditionalOnProperty(</span><br><span class="line">        name = &#123;&quot;spring.freemarker.enabled&quot;&#125;,</span><br><span class="line">        matchIfMissing = true</span><br><span class="line">    )</span><br><span class="line">    FreeMarkerViewResolver freeMarkerViewResolver() &#123;</span><br><span class="line">        FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();</span><br><span class="line">        this.getProperties().applyToMvcViewResolver(resolver);</span><br><span class="line">        return resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnEnabledResourceChain</span><br><span class="line">    @ConditionalOnMissingFilterBean(&#123;ResourceUrlEncodingFilter.class&#125;)</span><br><span class="line">    FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; resourceUrlEncodingFilter() &#123;</span><br><span class="line">        FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; registration = new FilterRegistrationBean(new ResourceUrlEncodingFilter(), new ServletRegistrationBean[0]);</span><br><span class="line">        registration.setDispatcherTypes(DispatcherType.REQUEST, new DispatcherType[]&#123;DispatcherType.ERROR&#125;);</span><br><span class="line">        return registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>@Configuration</code>注解表示当前类为一个配置类，可以被Spring扫描的到；<br>（2）<code>@ConditionalOnWebApplication</code>表示当前配置类在Web环境下才生效；<br>（3）<code>@ConditionalOnClass</code>表示当前环境中只有存在Servlet和FreeMarkerConfigurer时才会生效；<br>（4）<code>@AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class&#125;)</code>表示当前自动化配置需要在WebMvcAutoConfiguration之后才会完成；<br>（5）之后这个<code>FreeMarkerServletWebConfiguration</code>提供了一个有参的构造方法，里面注入了FreeMarkerProperties所对应的属性POJO类；<br>（6）当我们没有提供<code>FreeMarkerConfig</code>实例时，系统会自动提供一个<code>FreeMarkerConfigurer</code>实例。<code>FreeMarkerConfigurer</code>是一个类，实现了<code>FreeMarkerConfig</code>接口，里面定义了Freemarker的基本配置；<br>（7）<code>FreeMarkerViewResolver</code>则是FreeMarker视图解析器，上面使用了<code>@ConditionalOnMissingBean</code>和<code>@ConditionalOnProperty</code>注解表示只有当前环境中缺失<code>FreeMarkerViewResolver</code>对象和<code>spring.freemarker.enabled</code>属性值为true，系统会自动提供一个<code>FreeMarkerViewResolver</code>实例。</p><p>接下来我们再来看一下这个<code>FreeMarkerProperties</code>属性POJO类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.freemarker&quot;</span><br><span class="line">)</span><br><span class="line">public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties &#123;</span><br><span class="line">    public static final String DEFAULT_TEMPLATE_LOADER_PATH = &quot;classpath:/templates/&quot;;</span><br><span class="line">    public static final String DEFAULT_PREFIX = &quot;&quot;;</span><br><span class="line">    public static final String DEFAULT_SUFFIX = &quot;.ftlh&quot;;</span><br><span class="line">    private Map&lt;String, String&gt; settings = new HashMap();</span><br><span class="line">    private String[] templateLoaderPath = new String[]&#123;&quot;classpath:/templates/&quot;&#125;;</span><br><span class="line">    private boolean preferFileSystemAccess;</span><br><span class="line"></span><br><span class="line">    public FreeMarkerProperties() &#123;</span><br><span class="line">        super(&quot;&quot;, &quot;.ftlh&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, String&gt; getSettings() &#123;</span><br><span class="line">        return this.settings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSettings(Map&lt;String, String&gt; settings) &#123;</span><br><span class="line">        this.settings = settings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getTemplateLoaderPath() &#123;</span><br><span class="line">        return this.templateLoaderPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isPreferFileSystemAccess() &#123;</span><br><span class="line">        return this.preferFileSystemAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPreferFileSystemAccess(boolean preferFileSystemAccess) &#123;</span><br><span class="line">        this.preferFileSystemAccess = preferFileSystemAccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTemplateLoaderPath(String... templateLoaderPaths) &#123;</span><br><span class="line">        this.templateLoaderPath = templateLoaderPaths;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>FreeMarkerProperties</code>属性POJO类中配置了FreeMarker的一些基本信息，如模板默认存放地址为<code>classpath:/templates/</code>，模板后缀为<code>.ftlh</code>，这些后续开发者可以在项目配置文件中进行覆盖。</p><p><strong>第二步</strong>，出于简单考虑，这里就不使用数据库了，直接定义一个实体类Book：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int price;</span><br><span class="line">    //getter和setter方法，无参和全参构造方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，新建BookController类，提供一个访问数据的接口<code>/books</code>，注意它返回的是视图，因此不能使用<code>@RestController</code>注解，必须使用<code>@Controller</code>注解。</p><p>ModelAndView是模型数据和逻辑视图对象，它装载了模型的数据和逻辑视图，你可以通过<code>modelAndView.addObject(&quot;key&quot;,ojbect);</code>方式来添加模型数据，然后使用<code>modelAndView.setViewName(&quot;视图名称&quot;);</code>方式来设置逻辑视图。BookController类里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @GetMapping(value = &quot;/books&quot;)</span><br><span class="line">    public ModelAndView books()&#123;</span><br><span class="line">        List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">                new Book(1, &quot;三国演义&quot;, 168),</span><br><span class="line">                new Book(2, &quot;红楼梦&quot;, 188),</span><br><span class="line">                new Book(2, &quot;西游记&quot;, 128),</span><br><span class="line">                new Book(2, &quot;水浒传&quot;, 108)</span><br><span class="line">        );</span><br><span class="line">        //实例化模型数据和逻辑视图对象</span><br><span class="line">        ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">        //添加模型数据</span><br><span class="line">        modelAndView.addObject(&quot;books&quot;,books);</span><br><span class="line">        //设置逻辑视图</span><br><span class="line">        modelAndView.setViewName(&quot;index&quot;);</span><br><span class="line">        return modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在resources目录下的templates文件夹中新建<code>index.ftlh</code>（请注意这里的index就是你在<code>modelAndView.setViewName(&quot;index&quot;)</code>中设置的逻辑视图名称，这个需要保持一致），里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;图书列表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;图书列表&lt;/h2&gt;</span><br><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books as book&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>请注意首先你需要判断model中的books不为空且books中有数据，然后才能进行遍历，接着通过遍历books集合，将集合中的数据通过表格展示出来。</p><p><strong>第五步</strong>，启动项目。在浏览器地址栏中输入<code>http://localhost:8080/books</code>即可看到运行结果，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c191dac8b552d921.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>如果开发者需要覆盖<code>FreeMarkerProperties</code>属性POJO类中的默认值，那么可以在<code>aplication.properties</code>文件中进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># HttpServletRequest的属性是否可以覆盖Controller中的model的同名项</span><br><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line"># HttpSession的属性是否可以覆盖Controller中的model的同名项</span><br><span class="line">spring.freemarker.allow-session-override=false</span><br><span class="line"># 是否开启缓存，开发时可设置为false，默认为true</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line"># 检查模板位置是否存在，默认为true</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line"># 模板文件编码</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line"># 模板文件位置</span><br><span class="line">spring.freemarker.prefix=classpath:/templates/</span><br><span class="line"># Content-Type配置</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line"># 模板文件后缀</span><br><span class="line">spring.freemarker.suffix=.ftlh</span><br><span class="line"># 是否将HttpServletRequest中的属性添加到Model中</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line"># 是否将HttpSession中的属性添加到Model中</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br></pre></td></tr></table></figure><h1 id="FreeMarker详细使用"><a href="#FreeMarker详细使用" class="headerlink" title="FreeMarker详细使用"></a>FreeMarker详细使用</h1><h3 id="插值与表达式"><a href="#插值与表达式" class="headerlink" title="插值与表达式"></a>插值与表达式</h3><h5 id="直接输出值"><a href="#直接输出值" class="headerlink" title="直接输出值"></a>直接输出值</h5><p><strong>（1）数字。</strong>在FreeMarker中使用数字有两个注意事项：（a）小数点之前的0不能省略，即<code>0.1</code>不能写成<code>.1</code>；（b）对于1、+1、和1.0而言，它们是一致的。</p><p>查看一下如下的ftlh语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=11&gt;</span><br><span class="line">&lt;div&gt;$&#123;num&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;#assign num=11&gt;</code>表示定义一个名为num的变量，值为11，然后通过<code>&lt;div&gt;$&#123;num&#125;&lt;/div&gt;</code>将其进行输出：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a3f555bbff0fa4e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者需要输出人民币，可以使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=11&gt;</span><br><span class="line">&lt;div&gt;$&#123;num?string.currency&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到数字前面就多出了一个人民币符号：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7ec18457cea5dd44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果需要展示百分数，可以使用如下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign num=0.66&gt;</span><br><span class="line">&lt;div&gt;$&#123;num?string.percent&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到数字就以百分数形式进行展示了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bdf44364e089a0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（2）字符串。</strong>在FreeMarker中可以使用如下方式直接输出字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;&quot;啃饼思录&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>可以看到文字就直接显示了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1c36a2c4780f2646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要输出一些包含特殊符号的字符串，如<code>文件磁盘D:\测试</code>，那么需要使用<code>\</code>进行转义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;&quot;文件磁盘D:\\测试&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样上述字符串才可以被显示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa0d710a9c9f8792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>不过转义这种太麻烦了，尤其是字符串中包含很多需要转义的字符，此时可以在目标字符串引号之前添加r字符，表示自然转义，那么该目标字符串就会被直接输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;r&quot;文件磁盘D:\测试&quot;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样上述字符串也是可以被显示的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa0d710a9c9f8792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（3）布尔值。</strong>在FreeMarker中布尔值可以直接定义，不需要使用引号引起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign flag=false&gt;</span><br><span class="line">&lt;div&gt;$&#123;flag?string(&quot;A&quot;,&quot;B&quot;)&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;#assign flag=false&gt;</code>表示定义一个名为flag的变量，值为false，然后通过<code>&lt;div&gt;$&#123;flag?string(&quot;A&quot;,&quot;B&quot;)&#125;&lt;/div&gt;</code>将其进行输出，它判断flag值是否为true，如果是则输出A，否则输出B：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d3d037ab0f463cb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（4）集合。</strong>在FreeMarker中开发者可以直接定义一个集合，然后遍历该集合进行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [&quot;春天&quot;, &quot;夏天&quot;, &quot;秋天&quot;, &quot;冬天&quot;] as season&gt;</span><br><span class="line">    &lt;p&gt;$&#123;season&#125;&lt;/p&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>season表示其中的每个季节，遍历输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6d8efa391c77df9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，集合中的元素也可以是一个表达式，可以是字符串，不要求这些元素的类型是一致的，如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [1+1,8-1,2*4,6/3,&quot;kenbingthoughts&quot;] as v&gt;</span><br><span class="line">    &lt;p&gt;$&#123;v&#125;&lt;/p&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>此时的遍历输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c7a74172f07ffc46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果你需要输出某些特殊的序列，如1-6这个序列，那么只需使用<code>1..6</code>来表示，而<code>6..1</code>则表示从6输出到1这个序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;顺序&lt;/p&gt;</span><br><span class="line">&lt;#list 1..6 as v1&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v1&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;倒序&lt;/p&gt;</span><br><span class="line">&lt;#list 6..1 as v2&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v2&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>此时页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-37aa74f1b07537c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了这个集合中也是可以表示Map对象，Map对象是使用大括号括起来的，就像下面的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;所有的key&lt;/p&gt;</span><br><span class="line">&lt;#list &#123;&quot;name&quot;: &quot;kenbingthoughts&quot;,&quot;nickName&quot;: &quot;kenbing&quot;&#125;?keys as k&gt;</span><br><span class="line">    &lt;text&gt;$&#123;k&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;所有的value&lt;/p&gt;</span><br><span class="line">&lt;#list &#123;&quot;name&quot;: &quot;kenbingthoughts&quot;,&quot;nickName&quot;: &quot;kenbing&quot;&#125;?values as v&gt;</span><br><span class="line">    &lt;text&gt;$&#123;v&#125;&lt;/text&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>上面这两种语法分别表示遍历Map对象的所有key和value，页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9288e318b06c6125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="输出变量"><a href="#输出变量" class="headerlink" title="输出变量"></a>输出变量</h5><p>首先我们创建一个接口，然后准备一些数据，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value = &quot;/test&quot;)</span><br><span class="line">public ModelAndView test()&#123;</span><br><span class="line">    List&lt;Book&gt; books = Arrays.asList(</span><br><span class="line">            new Book(1, &quot;三国演义&quot;, 168),</span><br><span class="line">            new Book(2, &quot;红楼梦&quot;, 188),</span><br><span class="line">            new Book(2, &quot;西游记&quot;, 128),</span><br><span class="line">            new Book(2, &quot;水浒传&quot;, 108)</span><br><span class="line">    );</span><br><span class="line">    Map&lt;String,String&gt; userMap = new HashMap&lt;&gt;();</span><br><span class="line">    userMap.put(&quot;name&quot;,&quot;kenbingthoughts&quot;);</span><br><span class="line">    userMap.put(&quot;nickName&quot;,&quot;kenbing&quot;);</span><br><span class="line">    userMap.put(&quot;website&quot;,&quot;kenbingthoughts.top&quot;);</span><br><span class="line">    ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">    modelAndView.addObject(&quot;books&quot;,books);</span><br><span class="line">    modelAndView.addObject(&quot;userMap&quot;,userMap);</span><br><span class="line">    modelAndView.addObject(&quot;address&quot;,&quot;上海&quot;);</span><br><span class="line">    modelAndView.setViewName(&quot;index&quot;);</span><br><span class="line">    return modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（1）普通变量。</strong>普通变量的展示很简单，直接通过变量名称就可以展示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;address&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-277f816f4f7fe50b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（2）集合变量。</strong>集合的展示有多种方式，如下所示，输出书籍信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e4e2d1b4ce6c86a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果你需要输出第三本书的名称（下标从0开始），只需将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;books[2].name&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-743ba6619195c750.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要输出第二和三本书的名称，即子集合，此时只需将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books[1..2] as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a43788c473dd0934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果开发者想要输出当前变量的下标，此时只需使用<code>变量名称_index</code>就可以输出下标信息，此时将代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1px&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;图书下标&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书编号&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书名称&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;图书价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;#if books ?? &amp;&amp; (books?size&gt;0) &gt;</span><br><span class="line">    &lt;#list books[1..2] as book&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book_index&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">    &lt;/#if&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9ffb9e7be7e23400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（3）Map变量。</strong>如果开发者想直接输出Map中的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap.name&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap[&#x27;name&#x27;]&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ba1bf7dd23e867b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果要获取Map中的所有key并输出对应value的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list userMap?keys as k&gt;</span><br><span class="line">        &lt;div&gt;$&#123;k&#125;--$&#123;userMap[k]&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-dc9930b0c80ac259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果只是单纯的想输出所有value的值，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list userMap?values as v&gt;</span><br><span class="line">        &lt;div&gt;$&#123;v&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-314c9d0155499af8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（4）字符串拼接。</strong>如果开发者想对字符串进行拼接，可以使用如下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;&quot;My name is $&#123;userMap.name&#125;&quot;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;&quot;My name is &quot;+ userMap.name&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-119af75f1e5b184f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（5）字符串截取。</strong>如果开发者想对字符串进行截取，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;$&#123;userMap.name[0..6]&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4a60bde2135f2308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（6）集合相加。</strong>如果开发者想对集合相加，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list [&quot;春天&quot;, &quot;夏天&quot;, &quot;秋天&quot;, &quot;冬天&quot;] + [&quot;昨天&quot;,&quot;今天&quot;,&quot;明天&quot;] as time&gt;</span><br><span class="line">        &lt;p&gt;$&#123;time&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7c8e9598127e51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>（7）Map相加。</strong>如果开发者想对Map相加，可以使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#list (userMap +&#123;&#x27;sex&#x27;: &#x27;male&#x27;&#125;)?keys as key&gt;</span><br><span class="line">        &lt;p&gt;$&#123;key&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ef6ac02a55877216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>FreeMarker支持一些常用的<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>等运算，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign num=1&gt;</span><br><span class="line">    &lt;div&gt;$&#123;num*2/2%2+2-2&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-78ae43c2cb3e6f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>FreeMarker支持一些常用的比较运算操作，举个例子：<br>（1）= 或者 == 用于判断两个值是否相等；<br>（2）!=用于 判断两个值是否不等；<br>（3）&gt; 或者 gt 用于判断左边值是否大于右边值；<br>（4）&gt;= 或者 gte用于 判断左边值是否大于等于右边值；<br>（5）&lt; 或者 lt 用于判断左边值是否小于右边值；<br>（6）&lt;= 或者 lte 用于判断左边值是否小于等于右边值。<br>建议使用后面的英文符号，不要使用比较号，这样能避免带来一些不必要的错误。一些例子如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;#assign num=1&gt;</span><br><span class="line">        &lt;#if num=1&gt; num=1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num==1&gt; num==1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num!=1&gt; num!=1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num gt 1&gt; num gt 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num gte 1&gt; num gte 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num lt 1&gt; num lt 1&lt;/#if&gt;</span><br><span class="line">        &lt;#if num lte 1&gt; num lte 1&lt;/#if&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a36534bcc210d689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>FreeMarker中有三个逻辑运算符，分别是与（<code>&amp;&amp;</code>）或（<code>||</code>）非（<code>！</code>），注意逻辑运算符只能作用于布尔值，其他类型无法使用，这个很好理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign num=1&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if num=1 &amp;&amp; 1 gt 2&gt; num=1 &amp;&amp; 1 gt 2 &lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if num=1 || 1 gt 2&gt; num=1 || 1 gt 2&lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;#if !(num=1)&gt; !(num=1)&lt;/#if&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-20549757c9901506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h5><p>为了处理变量的空值，FreeMarker提供了两个运算符<code>!</code>和<code>??</code>，其中<code>!</code>用于指定缺失变量的默认值；<code>??</code>则用于判断某个变量是否存在。</p><p>举个例子，判断hobby变量是否存在，如果不存在则设置值为reading：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;hobby!&#x27;reading&#x27;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5169b74eb48321f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>如果希望hobby变量不存在，则设置值为空字符串，那么可以有如下两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;hobby!&#125;</span><br><span class="line">        $&#123;hobby!&quot;&quot;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>也就是说如果<code>!</code>后面没有设置值，那么默认值就是空字符串。关于<code>FreeMarker</code>的更多资料可以点击 <a href="https://freemarker.apache.org/">这里</a>，或者 <a href="http://freemarker.foofun.cn/">国内翻译站</a> 。</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>由于FreeMarker内置的函数有多个，因此这里只列举几个比较常用的进行学习，具体的可以点击  <a href="http://freemarker.foofun.cn/ref_builtins.html">国内翻译站</a>  进行阅读。</p><h5 id="cap-first"><a href="#cap-first" class="headerlink" title="cap_first"></a>cap_first</h5><p><code>cap_first</code>可以让字符串的第一个字母变成大写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;kenbing&quot;?cap_first&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-7e52499da744d7fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="lower-case"><a href="#lower-case" class="headerlink" title="lower_case"></a>lower_case</h5><p><code>lower_case</code>可以让字符串转变成小写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;KENBING&quot;?lower_case&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-acae326c3126c2a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="upper-case"><a href="#upper-case" class="headerlink" title="upper_case"></a>upper_case</h5><p><code>upper_case</code>可以让字符串转变成大写，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">        $&#123;&quot;kenbing&quot;?upper_case&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-eebfbf741c1c4982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><p>FreeMarker，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign someDate = &quot;10/25/1995&quot;?date(&quot;MM/dd/yyyy&quot;)&gt;</span><br><span class="line">    &lt;#assign someTime = &quot;15:05:30&quot;?time(&quot;HH:mm:ss&quot;)&gt;</span><br><span class="line">    &lt;#assign someDatetime = &quot;1995-10-25 03:05 PM&quot;?datetime(&quot;yyyy-MM-dd hh:mm&quot;)&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someDate&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someTime&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;someDatetime&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c548b74a5b2fa822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><p><code>trim</code>可以去掉字符串前后的空白字符，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#assign str=&quot;  kenbing  &quot;&gt;</span><br><span class="line">    &lt;div&gt;$&#123;str?trim&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f81900974f23f854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p><code>int</code>可以获取数值的整数部分，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;3.1415926?int&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e306a3168c4a81e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p><code>size</code>可以获取序列中元素的个数，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;$&#123;userMap?size&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e306a3168c4a81e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h5 id="if-else-elseif"><a href="#if-else-elseif" class="headerlink" title="if, else, elseif"></a>if, else, elseif</h5><p>这是分支控制语句，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if condition&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;#elseif condition2&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;#elseif condition3&gt;</span><br><span class="line">  ...</span><br><span class="line">...</span><br><span class="line">&lt;#else&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure><p>注意这其中的condition和condition2都将被计算成布尔值的表达式，同时elseif 和else是可选的。详细使用细节可以参考 <a href="http://freemarker.foofun.cn/ref_directive_if.html">这里</a> 。</p><h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>开发者可以使用该指令来创建一个新变量或者替换一个已存在的变量。注意仅仅顶级变量可以被创建/替换 (也就是说你不能创建/替换<code>some_hash.subvar</code>， 除了<code>some_hash</code>)，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign name1=value1 name2=value2 ... nameN=valueN&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign same as above... in namespacehash&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign name&gt;</span><br><span class="line">  capture this</span><br><span class="line">&lt;/#assign&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#assign name in namespacehash&gt;</span><br><span class="line">  capture this</span><br><span class="line">&lt;/#assign&gt;</span><br></pre></td></tr></table></figure><p>关于变量的更多内容，请阅读：<a href="http://freemarker.foofun.cn/dgui_misc_var.html">模板开发指南/其它/在模板中定义变量</a></p><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>该指令用于引入一个库，即创建一个新的空命名空间， 然后在该命名空间中执行给定 path 参数中的模板， 所以模板用变量(宏，函数等)填充命名空间，之后新创建的命名空间对哈希表的调用者可用。 这个哈希表变量将会在命名空间中，由 import (就像你可以用 assign 指令来创建一样。) 的调用者被创建成一个普通变量，名字就是hash参数给定的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#import path as hash&gt;</span><br></pre></td></tr></table></figure><h6 id="switch-case-default-break"><a href="#switch-case-default-break" class="headerlink" title="switch, case, default, break"></a>switch, case, default, break</h6><p>switch, case, default, break是分支指令，有点类似于Java中的switch，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;#switch value&gt;</span><br><span class="line">  &lt;#case refValue1&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  &lt;#case refValue2&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;#case refValueN&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;#break&gt;</span><br><span class="line">  &lt;#default&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/#switch&gt;</span><br></pre></td></tr></table></figure><p>注意这里的break和default是可选的，不过笔者不太推荐使用这个指令，因为向下通过的行为容易出错，开发者可以使用 <a href="http://freemarker.foofun.cn/ref_directive_if.html#ref.directive.elseif"><code>elseif</code></a>来代替， 除非想利用向下通过这种行为。</p><h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><p>include可以包含一个外部页面，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include path&gt;</span><br><span class="line">或</span><br><span class="line">&lt;#include path options&gt;</span><br></pre></td></tr></table></figure><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include &quot;./kenbing.ftlh&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="macro-nested-return"><a href="#macro-nested-return" class="headerlink" title="macro, nested, return"></a>macro, nested, return</h5><p>macro指令用于定义一个宏，由于宏在实际工作中用的比较多，所以这里建议还是看 <a href="http://freemarker.foofun.cn/ref_directive_macro.html">官方文档</a> 最为合适。举个例子，这里我们定义一个名为book的宏，然后引用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro book&gt;</span><br><span class="line">        西游记</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;div&gt;&lt;@book/&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4a3391caa128db6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，在定义宏的时候也可以传入参数，那么此时在引入宏的时候，也需要传入对应的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;div&gt;&lt;@books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]/&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这里的bs其实就是定义的名为books的宏的参数，可以传入多个参数，所以我们在使用这个宏的时候通过集合也传入了参数。页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9608f60aab860f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>除此之外，开发者还可以使用nested指令还引入开发者自定义的标签体，这个有点类似于Vue中的slot插槽这个概念，即只是起到一个占位的作用。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">            &lt;#nested&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">    &lt;@books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">        &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">    &lt;/@books&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f01efefccd3a5ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到上面我们添加的p标签的内容就取代了books这一宏中的<code>&lt;#nested&gt;</code>标签所占据的位置。</p><p>在实际开发过程中，宏一般都是单独定义的，然后在使用的地方进行导入，定义一个名为<code>kenbing.ftlh</code>的文件，在里面定义一个名为books的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#macro books bs&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;#list bs as b&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;b&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/#list&gt;</span><br><span class="line">            &lt;#nested&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/#macro&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>之后在<code>index.ftlh</code>文件中导入这个<code>kenbing.ftlh</code>文件并使用这个名为books的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#import &quot;./kenbing.ftlh&quot; as kb&gt;</span><br><span class="line">    &lt;@kb.books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">        &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">    &lt;/@kb.books&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意宏需要先导入才能使用，否则会报找不到文件的错误。页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f01efefccd3a5ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h5><p>noparse指令顾名思义就是不解析，因此如果开发者想直接在HTML页面上展示Freemarker语法，而不被页面渲染，那么就可以将Freemarker语法使用noparse指令包括起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#noparse&gt;</span><br><span class="line">        &lt;#import &quot;./kenbing.ftlh&quot; as kb&gt;</span><br><span class="line">        &lt;@kb.books [&quot;西游记&quot;,&quot;三国演义&quot;,&quot;水浒传&quot;,&quot;红楼梦&quot;]&gt;</span><br><span class="line">            &lt;p&gt;啃饼思录&lt;/p&gt;</span><br><span class="line">        &lt;/@kb.books&gt;</span><br><span class="line">    &lt;/#noparse&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-bf6f4990eab2b0c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h5 id="function-return"><a href="#function-return" class="headerlink" title="function, return"></a>function, return</h5><p>Freemarker中也允许开发者自定义函数，且函数是可以有返回值的，格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#function name param1 param2 ... paramN&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;#return returnValue&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/#function&gt;</span><br></pre></td></tr></table></figure><p>举个例子，下面的函数用于计算两个数值的平均值，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;#function avg x y&gt;</span><br><span class="line">        &lt;#return (x+y)/2&gt;</span><br><span class="line">    &lt;/#function&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        $&#123;avg(12,18)&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>页面输出结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c8179a2f0759bbcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇对FreeMarker模板引擎有了一个较为清晰的介绍，了解和学习这些基本上能满足日常的开发需要，如果开发者需要实现更具定制化的功能，需要点击 <a href="http://freemarker.foofun.cn/">这里</a> ，阅读文档进行深度学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;尽管在目前企业级的应用开发中，前后端分离是趋势，但是视图层技术还是占用一席之地。SpringBoot对视图层技术也提供了很好</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>自定义SpringBoot中的Starter场景启动器</title>
    <link href="http://envyzhan.asia/2022/04/15/8-customize-the-starter-scenario-launcher-in-springboot/"/>
    <id>http://envyzhan.asia/2022/04/15/8-customize-the-starter-scenario-launcher-in-springboot/</id>
    <published>2022-04-15T09:55:30.000Z</published>
    <updated>2022-09-12T08:15:31.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们对SpringBoot的自动装配原理有了一个较为深刻的研究，那么接下来我们就分析一下其中的场景启动器（starter），并尝试自定义一个属于自己的场景启动器（starter）。</p><h1 id="场景启动器简介"><a href="#场景启动器简介" class="headerlink" title="场景启动器简介"></a>场景启动器简介</h1><p>场景启动器（starter），其实就是一个个的功能。SpringBoot会将用户常用的一些功能抽离出来，做成一个个的场景启动器，这些场景启动器会导入实现这些功能所需的全部依赖组件，这样开发者只需在项目中引入这些场景启动器，那么相应的依赖就会加载进来。开发者只需通过修改配置文件，就能实现使用相应功能这一目的。</p><h1 id="父场景启动器介绍"><a href="#父场景启动器介绍" class="headerlink" title="父场景启动器介绍"></a>父场景启动器介绍</h1><p>当我们新建一个SpringBoot项目时，POM文件中会自动添加一个父依赖，该依赖名称为<code>spring-boot-starter-parent</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>spring-boot-starter-parent</code>是一个场景启动器，点进去查看一下这个依赖，可以看到里面又有一个名为<code>spring-boot-dependencies</code>的依赖，用于进行项目依赖的版本管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">&lt;name&gt;spring-boot-starter-parent&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Parent pom providing dependency and plugin management for applications built with Maven&lt;/description&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">  &lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">  &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>同时里面配置了6个默认的配置信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--默认Java版本1.8--&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;!--默认资源分隔符为@--&gt;</span><br><span class="line">&lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;!--默认编码格式使用UTF-8--&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br></pre></td></tr></table></figure><p>实际上这个<code>spring-boot-starter-parent</code>还提供了默认的资源过滤和插件配置。</p><p>再来看一下这个<code>spring-boot-dependencies</code>依赖的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;activemq.version&gt;5.16.4&lt;/activemq.version&gt;</span><br><span class="line">    &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;</span><br><span class="line">    &lt;appengine-sdk.version&gt;1.9.96&lt;/appengine-sdk.version&gt;</span><br><span class="line">    &lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt;</span><br><span class="line">    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;</span><br><span class="line">    &lt;assertj.version&gt;3.21.0&lt;/assertj.version&gt;</span><br><span class="line">    ......</span><br><span class="line">  &lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>可以看到它定义了所需场景启动器的版本信息，因此开发者在需要某场景启动器时，只需导入对应的场景启动器名称，无需再指定具体的版本号，这里已经指定并解决了各个场景启动器版本之间的冲突问题。</p><h1 id="场景启动器原理"><a href="#场景启动器原理" class="headerlink" title="场景启动器原理"></a>场景启动器原理</h1><p>当开发者导入所需的starter之后，SpringBoot会将该starter所依赖的组件自动导入并自动配置，这就是我们常说的SpringBoot的自动配置。</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><h5 id="自动配置类的获取与注入"><a href="#自动配置类的获取与注入" class="headerlink" title="自动配置类的获取与注入"></a>自动配置类的获取与注入</h5><p>尽管在前一篇我们已经分析了SpringBoot的自动装配原理，但是笔者没有结合项目和一些图片来介绍，所以可能比较难以理解，这里再分析一次，可以加深理解。</p><p>首先查看一下项目的启动类源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class KenBingThoughtsApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(KenBingThoughtsApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析可以知道这个<code>@SpringBootApplication</code>注解内部的结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0288a1f2740c2ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这里面有一个非常重要的类<code>AutoConfigurationImportSelector</code>，该类的作用图中已经说清楚了，不过说一下其中一个名为<code>selectImports</code>的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它返回了一个字符串数组，下图是它的处理过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-58d20d34bccde1b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接下来再来看一下这个<code>spring.factories</code>文件，这里以<code>spring-boot-autoconfigure</code>包为例进行查阅：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5413b80eeb1a8fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这里面所有以<code>xxxAutoConfiguration</code>结尾的类都是SpringBoot官方为所有场景启动器所提供的自动配置类。这里以常用的<code>WebMvcAutoConfiguration</code>为例进行介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="line">@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)</span><br><span class="line">@AutoConfigureOrder(-2147483638)</span><br><span class="line">@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)</span><br><span class="line">public class WebMvcAutoConfiguration &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个类上使用了很多条件注解，以及配置注解表明这个类会向Spring容器中注册，同时也是有条件的生效。</p><p>【自动配置类的获取与注入原理】<br>（1）SpringBoot项目在启动时会扫描入口类所在包及其子包下的所有类并注入到Spring容器中；<br>（2）同时也会扫描类路径下<code>META-INF/spring.factories</code>文件，并从中加载所有以<code>xxxAutoConfiguration</code>结尾的自动配置类，这样就完成了自动配置类的获取与注入工作。</p><h3 id="自动配置过程"><a href="#自动配置过程" class="headerlink" title="自动配置过程"></a>自动配置过程</h3><p>前面以<code>xxxAutoConfiguration</code>结尾的自动配置类被注册到容器中后，会完成自动导入和自动配置工作。首先我们来查看一下SpringBoot中配置文件与POJO对象之间的映射关系，这也是实现自动配置的基础。</p><p>SpringBoot采用了配置集中化管理这一理念，即所有的配置信息都可以在一个名为<code>application.yml</code>或者<code>application.properties</code>的配置文件中进行设置。实际上这个配置文件可以通过<code>@ConfigurationProperties</code>注解来与定义的属性POJO类进行关联，注意POJO类的命名格式建议为<code>xxxProperties</code>，不一定非得是这样，但是无论怎样都要与在<code>@EnableConfigurationProperties(xxxProperties.class)</code>注解中设置的类名保持一致，还有这个POJO类中各个属性字段都要有默认值。这其实就是SpringBoot所推崇的约定大于配置这一理念，在尽可能减少用户配置的同时又不减少灵活性，即用户可以随心所欲的覆盖这些属性的默认值。</p><p>这里我们在配置文件中定义一个名为<code>person</code>的前缀，然后又定义了一个名为Person的实体类，那么接下来两者就可以通过<code>@ConfigurationProperties(prefix=&quot;person&quot;)</code>注解进行配置映射：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a9924a43b8b05fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，在实际使用时还需要配合<code>@EnableConfigurationProperties(&#123;person.class&#125;)</code>注解，这样才会自动将与配置文件绑定好的POJO类注入到Spring容器中。</p><p>接下来我们以最常用的<code>HttpEncodingAutoConfiguration</code>(http编码自动配置类)为例，介绍这个自动配置类进行自动配置的整个过程。先查阅<code>HttpEncodingAutoConfiguration</code>自动配置类源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//表示此类为一个配置类，可以被Spring扫描的到</span><br><span class="line">@Configuration(</span><br><span class="line">    proxyBeanMethods = false</span><br><span class="line">)</span><br><span class="line">//表示将与配置文件绑定好的ServerProperties POJO类注入到IOC容器中，使之生效</span><br><span class="line">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br><span class="line">//@Conditional是条件注解，会根据不同的判断条件，如果满足指定的条件，该配置类中的配置才会生效</span><br><span class="line">//判断是否为web应用，是的话当前配置类中的配置才会生效</span><br><span class="line">@ConditionalOnWebApplication(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line">//判断是否存在CharacterEncodingFilter这个类，如果有的话当前配置类中的配置才会生效</span><br><span class="line">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="line">//判断是否存在server.servlet.encoding.enabled属性，如果matchIfMissing = true表示即使我们不配置属性值为true，该配置类默认也会生效</span><br><span class="line">@ConditionalOnProperty(</span><br><span class="line">    prefix = &quot;server.servlet.encoding&quot;,</span><br><span class="line">    value = &#123;&quot;enabled&quot;&#125;,</span><br><span class="line">    matchIfMissing = true</span><br><span class="line">)</span><br><span class="line">public class HttpEncodingAutoConfiguration &#123;</span><br><span class="line">    //注入与配置文件属性相绑定的属性配置类</span><br><span class="line">    private final Encoding properties;</span><br><span class="line">    </span><br><span class="line">    //提供一个有参的构造方法，并在HttpEncodingAutoConfiguration对象实例化的时候注入其中</span><br><span class="line">    public HttpEncodingAutoConfiguration(ServerProperties properties) &#123;</span><br><span class="line">        this.properties = properties.getServlet().getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //当系统中没有提供CharacterEncodingFilter这一实例的时候，系统会默认提供一个CharacterEncodingFilter实例</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));</span><br><span class="line">        return filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义本地语言字符编码映射器</span><br><span class="line">    @Bean</span><br><span class="line">    public HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() &#123;</span><br><span class="line">        return new HttpEncodingAutoConfiguration.LocaleCharsetMappingsCustomizer(this.properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class LocaleCharsetMappingsCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123;</span><br><span class="line">        private final Encoding properties;</span><br><span class="line"></span><br><span class="line">        LocaleCharsetMappingsCustomizer(Encoding properties) &#123;</span><br><span class="line">            this.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void customize(ConfigurableServletWebServerFactory factory) &#123;</span><br><span class="line">            if (this.properties.getMapping() != null) &#123;</span><br><span class="line">                factory.setLocaleCharsetMappings(this.properties.getMapping());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getOrder() &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过一张图来了解自动配置的整个过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c9f8dbe1e5fe9a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>【自动配置过程】<br>（1）容器会根据当前不同注解中的条件来决定当前这个自动配置类是否生效；<br>（2）如果当前自动配置类生效，那么就会给容器中添加所需的对应组件；<br>（3）这些对应组件的属性是从对应的属性POJO类中获取，而这些属性POJO类则是与配置文件相绑定的；<br>（4）配置文件中可以配置项的项都是在属性POJO类中定义的，后续开发者可以根据名称及前缀进行判断。</p><p>一句话总结：配置文件与POJO类进行属性映射绑定，自动配置类确定是否生效，生效则添加对应的POJO类。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SpringBoot在启动时会加载大量的自动配置类，如果开发者所需要的功能在默认自动配置类中有则会进行自动导入和自动配置工作；如果没有则需要手动添加对应的组件。一般需要定义一个属性POJO类完成与<code>application.yml</code>或者<code>application.properties</code>配置文件的属性映射绑定工作，然后再定义一个以<code>xxxAutoConfiguration</code>结尾的自动配置类，根据条件来选择性的让自动配置类生效，并注入自定义的属性POJO类。</p><p>这里我们再提一下这个由<code>@Conditional</code>注解所派生出来的注解，作用是只有满足这些注解的条件，才会给容器中注入所需的组件，里面的配置内容才会生效。一些常用的由<code>@Conditional</code>派生注解如下表所示：</p><table><thead><tr><th align="center">@Conditional派生注解</th><th align="center">作用（判断是否满足指定条件）</th></tr></thead><tbody><tr><td align="center">@ConditionalOnNotWebApplication</td><td align="center">当前不是Web环境</td></tr><tr><td align="center">@ConditionalOnWebApplication</td><td align="center">当前是Web环境</td></tr><tr><td align="center">@ConditionalOnResource</td><td align="center">类路径下是否有指定资源文件</td></tr><tr><td align="center">@ConditionalOnExpression</td><td align="center">满足SPEL表达式</td></tr><tr><td align="center">@ConditionalOnMissingBean</td><td align="center">容器中不存在指定的Bean</td></tr><tr><td align="center">@ConditionalOnBean</td><td align="center">容器中存在指定的Bean</td></tr><tr><td align="center">@ConditionalOnSingleCandidate</td><td align="center">容器中只有一个指定的Bean或者这个Bean是首选Bean</td></tr><tr><td align="center">@ConditionalOnJava</td><td align="center">系统的Java版本是否满足指定</td></tr><tr><td align="center">@ConditionalOnMissingClass</td><td align="center">系统中没有指定的类</td></tr><tr><td align="center">@ConditionalOnClass</td><td align="center">系统中有指定的类</td></tr><tr><td align="center">@ConditionalOnProperty</td><td align="center">系统中指定的属性是否有指定的值</td></tr></tbody></table><p>别看上面有这么多自动配置类，但是这些配置类都需要在一定的条件下才会生效，即加载了这么多的配置类，生效的都是满足了指定条件。开发者可以通过在<code>application.yml</code>或者<code>application.properties</code>配置文件中添加<code>debug=true</code>属性来开启SpringBoot的调试类，并让控制台输出条件评估报告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//条件评估报告</span><br><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">//已启用的自动配置类（正匹配）</span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">    AopAutoConfiguration.ClassProxyingConfiguration matched:</span><br><span class="line">      - @ConditionalOnMissingClass did not find unwanted class &#x27;org.aspectj.weaver.Advice&#x27; (OnClassCondition)</span><br><span class="line">      - @ConditionalOnProperty (spring.aop.proxy-target-class=true) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   JmxAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &#x27;org.springframework.jmx.export.MBeanExporter&#x27; (OnClassCondition)</span><br><span class="line">      - @ConditionalOnProperty (spring.jmx.enabled=true) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   TaskSchedulingAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &#x27;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&#x27; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">//未启用的自动配置类（负匹配）</span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &#x27;javax.jms.ConnectionFactory&#x27; (OnClassCondition)</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">//排除的的自动配置类</span><br><span class="line">Exclusions:</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">    None</span><br><span class="line"></span><br><span class="line">//没有限定条件的自动配置类</span><br><span class="line">Unconditional classes:</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><h1 id="自定义场景启动器步骤"><a href="#自定义场景启动器步骤" class="headerlink" title="自定义场景启动器步骤"></a>自定义场景启动器步骤</h1><h3 id="starter命名约定"><a href="#starter命名约定" class="headerlink" title="starter命名约定"></a>starter命名约定</h3><p>SpringBoot遵循约定大于配置这一原则，因此对于starter的命名也有一定的约定规则，了解这些规则可便于开发者知悉这些starter功能及作用。</p><p>对于官方提供的starter而言，命名规则为：<code>spring-boot-starter-</code>+模块名，如<code>spring-boot-starter-web</code>。</p><p>对于非官方（即自定义）提供的starter而言，命名规则为：模块名+<code>spring-boot-starter</code>，如<code>mybatis-spring-boot-starter</code>。</p><h3 id="starter模块整体架构"><a href="#starter模块整体架构" class="headerlink" title="starter模块整体架构"></a>starter模块整体架构</h3><p>通过前面的分析，我们知道starter模块整体主要由<code>xxxAutoConfiguration</code>和<code>xxxProperties</code>组成。</p><p><code>xxxAutoConfiguration</code>是自动配置类，用于自动注入所需的一些组件，并使用<code>xxxProperties</code>类来获取组件相关的一些配置信息。<code>xxxProperties</code>是属性配置类，即从配置文件中获取对应的属性值以覆盖默认值。请注意，由于starter的作用只是依赖聚合，因此不建议直接在starter内部通过代码来更改属性值。</p><p>一般来说，具体的逻辑应当由其他模块来实现，然后由starter导入相应的模块，即starter只起导入依赖的作用，因此starter模块整体架构如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ab57c1ec7a5ad113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>从图中可以看到，starter模块依赖了两部分，一部分是常用依赖，另一部分则是自动配置模块所需的依赖。前面说的<code>xxxAutoConfiguration</code>和<code>xxxProperties</code>实际上则是自动配置模块的具体实现，starter通过该模块来对外提供相应功能。</p><h3 id="autoconfigure模块开发"><a href="#autoconfigure模块开发" class="headerlink" title="autoconfigure模块开发"></a>autoconfigure模块开发</h3><p>第一步，POM文件引入相应依赖。明确所有的starter都需要引入<code>spring-boot-autoconfigure</code>依赖，该依赖中包含很多与自动配置相关的注解及定义；其次还可以选择是否引入<code>spring-boot-configuration-processor</code>依赖，该依赖可以让开发者在配置文件中输入想修改的配置项信息时，能给出相应的提示信息。这里的配置文件不仅仅是以<code>.properties</code>结尾的，还可以是以<code>.yml</code>结尾的，不过SpringBoot中默认使用<code>application.yml</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>其他依赖则按需进行引入，这里就没什么好说的了。</p><p>第二步，<code>xxxAutoConfiguration</code>自动配置类实现。autoconfigure模块中<code>xxxAutoConfiguration</code>自动配置类的编写非常重要，它可以帮助开发者实现组件的自动装配与自动注入，进而让开发者更加专注于需要什么组件，如何去配置它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">@ConditionalOnxxx  //限定自动配置类生效的一些条件</span><br><span class="line">@EnableConfigurationProperties(xxxProperties.class)</span><br><span class="line">public class xxxAutoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private xxxProperties properties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public YouNeedBean youNeedBean() &#123;</span><br><span class="line">     YouNeedBean bean = new YouNeedBean()</span><br><span class="line">     bean.setField1(properties.get(field1));</span><br><span class="line">     bean.setField2(properties.get(field2));</span><br><span class="line">     bean.setField3(properties.get(field3));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在自动配置类中添加了一些自动配置类生效的条件，这些在实际开发过程中还是非常重要的。</p><p>第三步，<code>xxxProperties</code>属性配置类实现。请注意这个属性配置类的命名要与在第二步中，使用<code>@EnableConfigurationProperties(xxxProperties.class)</code>注解中配置的文件名保持一致。同时这个<code>xxxProperties</code>属性配置类用于从外部的以<code>.properties</code>或者<code>.yml</code>结尾的配置文件中读取对应的配置信息，以覆盖默认的属性值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;yourproperties&quot;) </span><br><span class="line">public class xxxProperties &#123;</span><br><span class="line"></span><br><span class="line">    private boolean enabled = true;</span><br><span class="line"></span><br><span class="line">    private String clientId;</span><br><span class="line"></span><br><span class="line">    private String beanName;</span><br><span class="line"></span><br><span class="line">    private String scanBasePackage;</span><br><span class="line"></span><br><span class="line">    private String path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用<code>@ConfigurationProperties</code>注解来绑定配置文件，并从中获取以<code>yourproperties</code>为前缀的配置项信息。</p><p>第四步，配置<code>spring.factories</code>文件。在介绍原理的时候就说过，它会扫描这个<code>spring.factories</code>文件中的<code>xxxAutoConfiguration</code>自动配置类并加载到Spring容器中。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第二步定义好的<code>xxxAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.kenbingthoughts.mystarter.xxxAutoConfiguration</span><br></pre></td></tr></table></figure><h1 id="自定义场景启动器实战"><a href="#自定义场景启动器实战" class="headerlink" title="自定义场景启动器实战"></a>自定义场景启动器实战</h1><p>第一步，使用Maven创建一个名为<code>mystarter-spring-boot-starter</code>的项目，然后在其POM文件中新增<code>spring-boot-autoconfigure</code>和<code>spring-boot-configuration-processor</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.7&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kenbingthoughts&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mystarter-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;mystarter-spring-boot-starter&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;自定义Starter启动器&lt;/description&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;11&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;11&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;11&lt;/target&gt;</span><br><span class="line">                    &lt;compilerVersion&gt;11&lt;/compilerVersion&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>当然了，由于笔者使用的JDK版本为11，同时使用了<code>spring-boot-starter-parent</code>父场景启动器，因此这里覆盖了默认的1.8版本。请注意，此项目中由于不包含main方法，因此不能添加如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>这个配置项会加载main方法，导致后续应用程序无法打包。</p><p>第二步，新建一个名为<code>KenBingProperties</code>的属性配置类。这里使用了<code>@ConfigurationProperties()</code>这一注解来实现类型安全的属性注入，即将<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的属性注入到这个类所对应的属性上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;kenbing&quot;)</span><br><span class="line">public class KenBingProperties &#123;</span><br><span class="line">    private static final String DEFAULT_NAME = &quot;啃饼思录&quot;;</span><br><span class="line">    private static final String DEFAULT_WEBSITE = &quot;啃饼网&quot;;</span><br><span class="line"></span><br><span class="line">    private String name = DEFAULT_NAME;</span><br><span class="line"></span><br><span class="line">    private String website = DEFAULT_WEBSITE;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWebsite() &#123;</span><br><span class="line">        return website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWebsite(String website) &#123;</span><br><span class="line">        this.website = website;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，自定义<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的对应配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kenbing.name=kenbingthoughts</span><br><span class="line">kenbing.website=kenbingthoughts.top</span><br></pre></td></tr></table></figure><p>第四步，定义一个用于提供实际功能的业务逻辑类<code>KenBingService</code>，这里我们逻辑比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class KenBingService &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String website;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getWebsite() &#123;</span><br><span class="line">        return website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWebsite(String website) &#123;</span><br><span class="line">        this.website = website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;hello,welcome to &quot;+this.website+&quot;,i am &quot;+ this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两个属性，然后提供对应的getter和setter方法，以及一个用于输出信息的index方法。</p><p>第五步，自定义<code>xxxAutoConfiguration</code>自动配置类。这里定义一个名为<code>KenBingServiceAutoConfiguration</code>的自动配置类，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(KenBingProperties.class)</span><br><span class="line">@ConditionalOnClass(KenBingService.class)</span><br><span class="line">public class KenBingServiceAutoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private KenBingProperties kenBingProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    KenBingService kenBingService()&#123;</span><br><span class="line">        KenBingService kenBingService = new KenBingService();</span><br><span class="line">        kenBingService.setName(kenBingProperties.getName());</span><br><span class="line">        kenBingService.setWebsite(kenBingProperties.getWebsite());</span><br><span class="line">        return kenBingService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）<code>@Configuration</code>注解表明这是一个配置类，可以被Spring容器扫描的到；<br>（2）使用<code>@EnableConfigurationProperties(KenBingProperties.class)</code>注解并绑定之前定义的属性配置类，表示让之前定义的被<code>@ConfigurationProperties(prefix = &quot;kenbing&quot;)</code>注解所修饰的KenBingProperties类生效，让从配置文件中读取的属性值可以成功的绑定到KenBingProperties类上；<br>（3）<code>@ConditionalOnClass(KenBingService.class)</code>是一个条件注解，表示只有项目当前classpath环境下存在KenBingService类时，这个类中的业务逻辑才会生效；<br>（4）使用<code>@Autowired</code>注解将业务逻辑所需要的<code>KenBingProperties</code>对象给注入进来；<br>（5）提供一个<code>KenBingService</code>对象，并将这个对象的值从<code>application.properties </code>配置文件中获取后返回。</p><p>第六步，定义<code>spring.factories</code>文件。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第五步定义好的<code>KenBingServiceAutoConfiguration</code>自动配置类的全路径放在里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.kenbingthoughts.mystarterspringbootstarter.config.KenBingServiceAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样我们就完成了自定义场景启动器的定义工作。</p><p>第七步，打包自定义场景启动器。一般来说我们会将自定义的场景启动器打包，然后上传到Maven私服，以供其他同事使用，这里笔者就不上传了，直接本地打包并安装了。点击IDEA中的Maven插件，选择Lifecycle，然后先clean一下，再install一下，这样自定义场景启动器就安装到本地仓库了。</p><p>第八步，新建一个SpringBoot项目，然后在POM文件中引入刚才自定义场景启动器<code>mystarter-spring-boot-starter</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入自定义的starter--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.kenbingthoughts&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mystarter-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后刷新一下Maven，可以看到扩展包里面已经出现了自定义的场景启动器：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c2ecf94527f9eed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第九步，测试。实际上现在项目中已经有一个默认的<code>KenBingService</code>实例，而且里面还有默认值。我们可以测试一下，出于简单考虑直接在项目测试类中进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">class LearnFreemarkerApplicationTests &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(LearnFreemarkerApplicationTests.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KenBingService kenBingService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        logger.info(kenBingService.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述测试方法，可以看到控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,welcome to 啃饼网,i am 啃饼思录</span><br></pre></td></tr></table></figure><p>这些信息可以从引入的<code>mystarter-spring-boot-starter</code>的包下一个名为<code>spring-configuration-metadata.json</code>中得到答案：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-befa03e6e93fc927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>当然了，实际上这些数据来源于KenBingConfig类中的值。不过开发者也可以通过修改<code>application.properties </code>配置文件中以<code>kenbing</code>为前缀的对应配置项来覆盖默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kenbing.name=kenbingthoughts</span><br><span class="line">kenbing.website=kenbingthoughts.top</span><br></pre></td></tr></table></figure><p>之后再重新启动一下测试类，可以看到控制台输出如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello,welcome to kenbingthoughts.top,i am kenbingthoughts</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇通过对场景启动器的深度分析，然后学习了自定义场景启动器的步骤，最后在此基础上自定义了一个自己的场景启动器。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/AfotfXlVT2HE4Q8jmkkK4A">图文并茂，Spring Boot Starter 万字详解！还有谁不会？</a>，<a href="https://blog.csdn.net/qq_45383769/article/details/119088191">@Conditional注解常规使用方法</a>，感谢大佬的解惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前面我们对SpringBoot的自动装配原理有了一个较为深刻的研究，那么接下来我们就分析一下其中的场景启动器（starte</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊SpringBoot的自动装配原理</title>
    <link href="http://envyzhan.asia/2022/04/10/7-talk-about-the-automatic-assembly-principle-of-springboot/"/>
    <id>http://envyzhan.asia/2022/04/10/7-talk-about-the-automatic-assembly-principle-of-springboot/</id>
    <published>2022-04-10T09:55:30.000Z</published>
    <updated>2022-09-12T08:13:31.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近在重构一个日志模块，需要将其从项目中抽离出来，于是考虑将其做成一个starter便于后续使用。本篇就来聊聊SpringBoot的自动装配原理，只有了解原理才知道如何将自己的项目制作为starter。</p><h1 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h1><p>当你新建一个SpringBoot项目的时候，项目入口类中自动会添加<code>@SpringBootApplication</code>，那么问题来了，这个<code>@SpringBootApplication</code>注解的作用是什么呢，查看一下该注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里注解上面除了几个常用的注解外，还有三个特别的注解：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>首先看一下<code>@SpringBootConfiguration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解上面除了元注解外，只有一个<code>@Configuration</code>注解，也就是说这个注解其实就相当于<code>@Configuration</code>注解，即标识此类为配置类，同时不仅可以注册一些额外的Bean对象，还可以导入一些额外的配置。</p><p>既然看到这里，那就再看一下<code>@Configuration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = Component.class</span><br><span class="line">    )</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>@Configuration</code>注解其核心就是<code>@Component</code>注解，这说明Spring配置类其实也是Spring容器管理的对象。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>再来看一下<code>@EnableAutoConfiguration</code>注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解用于开启自动配置功能，它其实也是一个组合注解，除了元注解外还有<code>@AutoConfigurationPackage</code>和<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解。</p><h5 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h5><p>首先分析<code>@AutoConfigurationPackage</code>注解，它表示让包中的类及子包中的类能够被自动扫描到Spring容器中。查看一下该注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个注解中除了元注解外，还是用<code>@Import</code>注解导入了Registrar这个字节码类，看一下这个Registrar对象的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现它其实是<code>AutoConfigurationPackages</code>这个抽象类中的静态内部类，里面有两个方法：<code>registerBeanDefinitions</code>和<code>determineImports</code>。<code>registerBeanDefinitions</code>方法用于获取扫描的包路径并将其注册到能被Spring容器扫描的包中，通过Debug可以看到这个<code>(new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()</code>对象其实就是项目入口类所在的包：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-42c8ee310097dd4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>那么问题来了，传入的metadata是什么呢？可以发现它就是被<code>@SpringBootApplication</code>注解所修饰的类，即项目的入口类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-95cdb3ee8c1647da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说将被<code>@SpringBootApplication</code>注解所修饰的类（项目入口类）所在的包及子包下的所有类都扫描加载到Spring容器中。这也从另一个侧面反映了项目结构，项目入口类必须放在项目的最外层目录中。</p><h5 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h5><p>再来分析<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code>注解，我们知道<code>@Import</code>注解的作用就是导入一些其他的类到Spring容器中，这里导入了<code>AutoConfigurationImportSelector</code>这个字节码对象，它是一个选择器。首先看一下这个对象的继承关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2e0db9f5d8bc103a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到<code>AutoConfigurationImportSelector</code>实现了<code>DeferredImportSelector</code>接口，而<code>DeferredImportSelector</code>接口又是实现了<code>ImportSelector</code>接口，查看一下这个<code>ImportSelector</code>接口的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ImportSelector &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    default Predicate&lt;String&gt; getExclusionFilter() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它只有两个方法，其中<code>selectImports</code>用于将所有需要导入的类以全路径方式返回，形成一个字符串数组，之后这些类就会被添加到Spring容器中。可以查看该方法的具体实现逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</span><br><span class="line">        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader)</code> 方法来将对象的加载器导入其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123;</span><br><span class="line">    return loadMetadata(classLoader, &quot;META-INF/spring-autoconfigure-metadata.properties&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它实际上调用的是<code>loadMetadata</code>方法，传入的路径是<code>META-INF/spring-autoconfigure-metadata.properties</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(path) : ClassLoader.getSystemResources(path);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">        while(urls.hasMoreElements()) &#123;</span><br><span class="line">            properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource((URL)urls.nextElement())));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return loadMetadata(properties);</span><br><span class="line">    &#125; catch (IOException var4) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析可以看到它首先判断<code>classLoader</code>是否为空，如果不为空则通过调用<code>classLoader.getResources(path)</code>方法从path路径中获取信息，而这个path就是之前传入的<code>META-INF/spring-autoconfigure-metadata.properties</code>：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-0e92b20b25d40c7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>通过定位到<code>spring-autoconfigure-metadata.properties</code>文件，可以看到其实就是加载这个文件中内容到Spring容器，而这些都是对应组件的自动配置类。有了这些自动配置类，开发者就不再需要手动编写配置类并注入Spring容器中了。</p><p>接着回到<code>selectImports</code>方法，然后执行的是如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br></pre></td></tr></table></figure><p>可以看到它调用的是<code>AutoConfigurationImportSelector#getAutoConfigurationEntry()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    if (!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return EMPTY_ENTRY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = this.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = this.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取自动配置的入口，其实就是获取到<code>spring-autoconfigure-metadata.properties</code>文件中被加载到Spring容器的自动配置类。该方法内部调用了<code>getCandidateConfigurations()</code>方法来获取系统中已经加载好的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，系统中已经加载好的类是哪些类呢？可以看到它内部其实调用的是<code>loadFactoryNames()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">            LinkedMultiValueMap result = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            while(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = new UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                while(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    int var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException var13) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它会从<code>META-INF/spring.factories</code>中获取资源，然后通过<code>PropertiesLoaderUtils.loadProperties()</code>方法来加载资源：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6ee6824fbfed2777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>也就是说SpringBoot会在启动的时候，从类路径下的<code>META-INF/spring.factories</code>文件中获取EnableAutoConfiguration设置的值（而这些设置的值都是以AutoConfiguration结尾，即自动配置类）并导入到Spring容器中，自动配置类会帮助我们进行自动配置：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-2a8fead716b6b91f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>接着我们再来看一下<code>@ComponentScan</code>注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到这个注解用于扫描包，然后将其放入Spring容器中。</p><h3 id="小结-SpringBootApplication"><a href="#小结-SpringBootApplication" class="headerlink" title="小结@SpringBootApplication"></a>小结@SpringBootApplication</h3><p>接下来我们总结一下<code>@SpringBootApplication</code>注解，该注解用于扫描项目入口类所在的包或者子包内的类，并将其导入Spring容器中，同时加载<code>META-INF/spring.factories</code>文件中的自动配置类到Spring容器中。</p><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>接下来我们再来看项目入口类的main方法，里面其实调用的是run方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(TestApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">    return run(new Class[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下实际上它所调用的run方法的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">    //定义一个计时器</span><br><span class="line">    StopWatch stopWatch = new StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = null;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();</span><br><span class="line">    this.configureHeadlessProperty();</span><br><span class="line">    //获取监听器</span><br><span class="line">    SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line"></span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    try &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        this.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = this.printBanner(environment);</span><br><span class="line">        //创建应用上下文</span><br><span class="line">        context = this.createApplicationContext();</span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        //预刷新上下文</span><br><span class="line">        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        //刷新上下文</span><br><span class="line">        this.refreshContext(context);</span><br><span class="line">        //刷新之后的上下文</span><br><span class="line">        this.afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        if (this.logStartupInfo) &#123;</span><br><span class="line">            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        this.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; catch (Throwable var10) &#123;</span><br><span class="line">        this.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        throw new IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">        //返回上下文</span><br><span class="line">        return context;</span><br><span class="line">    &#125; catch (Throwable var9) &#123;</span><br><span class="line">        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);</span><br><span class="line">        throw new IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们比较关注的是<code>refreshContext</code>这个用于刷新上下文的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">    this.refresh(context);</span><br><span class="line">    if (this.registerShutdownHook) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125; catch (AccessControlException var3) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下这个refresh方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void refresh(ApplicationContext applicationContext) &#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext)applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下这个refresh方法，其实际源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   @Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">// 准备刷新此上下文</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">// 告诉子类刷新内部的bean工厂</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">// 准备此上下文中使用的bean工厂</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 允许在此上下文子类中对bean工厂进行后处理</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">// 调用在上下文中注册为bean的工厂处理器</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 注册拦截bean创建的bean处理器</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">// 为此上下文初始化消息源</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">// 为此上下文初始化事件多播器。</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">// 初始化特定上下文子类中的其他特殊bean。</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">// 检查监听器bean并注册它们</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">               // 实例化所有剩余的（非惰性初始化）单例</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">// 最后一步：发布相应的事件</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁已经创建的单例以避免占用资源</span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line">// 重置“活动”标志</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">// 将异常传播给调用者</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finally &#123;</span><br><span class="line">// 重置 Spring 核心中的常见自省缓存，因为我们可能不再需要单例 bean 的元数据......</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这其实就是一个Spring加载Bean的过程。里面有一个用于初始化特定上下文子类中的其他特殊bean的onRefresh方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   protected void onRefresh() throws BeansException &#123;</span><br><span class="line">// For subclasses: do nothing by default.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法居然没有实现，因此可以看其实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void onRefresh() &#123;</span><br><span class="line">    super.onRefresh();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        this.createWebServer();</span><br><span class="line">    &#125; catch (Throwable var2) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;Unable to start reactive web server&quot;, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面调用了<code>createWebServer()</code>方法，用于创建Web服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void createWebServer() &#123;</span><br><span class="line">    ReactiveWebServerApplicationContext.ServerManager serverManager = this.serverManager;</span><br><span class="line">    if (serverManager == null) &#123;</span><br><span class="line">        String webServerFactoryBeanName = this.getWebServerFactoryBeanName();</span><br><span class="line">        ReactiveWebServerFactory webServerFactory = this.getWebServerFactory(webServerFactoryBeanName);</span><br><span class="line">        boolean lazyInit = this.getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit();</span><br><span class="line">        this.serverManager = ReactiveWebServerApplicationContext.ServerManager.get(webServerFactory, lazyInit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面调用了<code>getWebServerFactory()</code>方法用于创建Web容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected ReactiveWebServerFactory getWebServerFactory(String factoryBeanName) &#123;</span><br><span class="line">    return (ReactiveWebServerFactory)this.getBeanFactory().getBean(factoryBeanName, ReactiveWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回了一个<code>ReactiveWebServerFactory</code>对象，其实这是一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ReactiveWebServerFactory &#123;</span><br><span class="line">    WebServer getWebServer(HttpHandler httpHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以设计为接口，那是因为Web容器有很多种，常用的有Tomcat、Netty、Jetty和Undertow：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6f6b70724c385866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>以<code>TomcatReactiveWebServerFactory</code>这一实现类为例，其<code>getWebServer</code>方法的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public WebServer getWebServer(HttpHandler httpHandler) &#123;</span><br><span class="line">    if (this.disableMBeanRegistry) &#123;</span><br><span class="line">        Registry.disableRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tomcat tomcat = new Tomcat();</span><br><span class="line">    File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(&quot;tomcat&quot;);</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    Connector connector = new Connector(this.protocol);</span><br><span class="line">    connector.setThrowOnFailure(true);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    this.customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(false);</span><br><span class="line">    this.configureEngine(tomcat.getEngine());</span><br><span class="line">    Iterator var5 = this.additionalTomcatConnectors.iterator();</span><br><span class="line"></span><br><span class="line">    while(var5.hasNext()) &#123;</span><br><span class="line">        Connector additionalConnector = (Connector)var5.next();</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler);</span><br><span class="line">    this.prepareContext(tomcat.getHost(), servlet);</span><br><span class="line">    return this.getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是创建一个内置的Tomcat容器，然后返回，所以开发者在将项目打包成jar包以后，不需要自己再手动启动Tomcat容器。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇通过阅读源码对SpringBoot的自动装配原理有了一个较为深刻的理解，后续就可以在此基础上自定义自己的启动器（starter）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近在重构一个日志模块，需要将其从项目中抽离出来，于是考虑将其做成一个starter便于后续使用。本篇就来聊聊SpringB</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自定义参数解析器</title>
    <link href="http://envyzhan.asia/2022/03/30/6-springboot-custom-parameter-parser/"/>
    <id>http://envyzhan.asia/2022/03/30/6-springboot-custom-parameter-parser/</id>
    <published>2022-03-30T09:55:30.000Z</published>
    <updated>2022-09-12T08:11:19.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今天我们来聊一聊SpringBoot中的参数解析器，这在某些场景下非常有用。一般来说，在一个Web请求里面参数要么是放在请求地址，要么就是放在请求体里面，极个别的会放在请求头中。</p><p>如果请求参数放在请求地址中，那么通常会采用<code>@RequestParam</code>/<code>@PathVariable</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果请求参数放在请求体里面，那么通常会采用<code>@RequestBody</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果请求参数放在请求头里面，那么通常会采用<code>@RequestHeader</code>或者如下方式来获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getHeader(&quot;username&quot;);</span><br></pre></td></tr></table></figure><p>如果参数是JSON形式的，那么会从输入流中获取并解析成JSON字符串，再通过JSON工具转化为POJO对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));</span><br><span class="line">String json = reader.readLine();</span><br><span class="line">reader.close();</span><br><span class="line">User user = new ObjectMapper().readValue(json, User.class);</span><br></pre></td></tr></table></figure><p>无论参数是key-value键值对，还是JSON形式数据，以上几种方式基本上涵盖了日常开发的所有需求。</p><p>现在我们以下面的接口为例，来深度分析SpringMVC如何从请求中获取参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(String username)&#123;</span><br><span class="line">        return &quot;I am&quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问这个username参数肯定是从HttpServletRequest中获取的，那么它是如何获取的呢？</p><h1 id="方法参数解析器"><a href="#方法参数解析器" class="headerlink" title="方法参数解析器"></a>方法参数解析器</h1><h3 id="HandlerMethodArgumentResolver接口"><a href="#HandlerMethodArgumentResolver接口" class="headerlink" title="HandlerMethodArgumentResolver接口"></a>HandlerMethodArgumentResolver接口</h3><p>我们知道在SpringBoot中与Web相关的配置信息都在<code>WebMvcConfigurer</code>接口中，可以看到该接口中有一个名为<code>addArgumentResolvers</code>的默认方法，用于添加参数解析器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以看到<code>HandlerMethodArgumentResolver</code>这个其实就是具体的一些参数解析器，实际上它是一个接口。我们来看<code>HandlerMethodArgumentResolver</code>这一接口，该接口用于解析方法中的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface HandlerMethodArgumentResolver &#123;</span><br><span class="line">    boolean supportsParameter(MethodParameter parameter);</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>HandlerMethodArgumentResolver</code>接口中就两个方法，其中<code>supportsParameter()</code>方法表示是否启用该参数解析器，true表示启用，false表示不启用；<code>resolveArgument()</code>方法是具体的解析过程，即从HttpServletRequest中取出参数的过程，该方法的返回值就是接口中参数的值。所以如果开发者想自定义参数解析器，只需实现该接口并重写其中的两个方法。</p><p>由于SpringBoot采用约定大于配置这一规则，因此建议<code>HandlerMethodArgumentResolver</code>接口的实现类命名规则为“解析器对应的注解名称”+“<code>MethodArgumentResolver</code>”。</p><p>将下来我们分析几个常用的<code>HandlerMethodArgumentResolver</code>接口实现类，了解它们对于提升技能有非常大的帮助。</p><h3 id="RequestParamMethodArgumentResolver类"><a href="#RequestParamMethodArgumentResolver类" class="headerlink" title="RequestParamMethodArgumentResolver类"></a>RequestParamMethodArgumentResolver类</h3><p>通过前面的分析，可以得到这个解析器所对应的注解名称为RequestParam，因此首先我们看一下这个注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RequestParam &#123;</span><br><span class="line">    @AliasFor(&quot;name&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean required() default true;</span><br><span class="line"></span><br><span class="line">    String defaultValue() default &quot;\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>@RequestParam</code>注解有四个属性，其中name和value互为各自的别名，required表示参数是否必须传，默认是必须；defaultValue则是参数的默认值。</p><p>接着查看一下这个RequestParamMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveName</code>方法，注意它的<code>resolveArgument</code>方法名称发生了变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    if (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line">        if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">            return requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        parameter = parameter.nestedIfOptional();</span><br><span class="line">        if (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return this.useDefaultResolution ? BeanUtils.isSimpleProperty(parameter.getNestedParameterType()) : false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123;</span><br><span class="line">    HttpServletRequest servletRequest = (HttpServletRequest)request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">    Object arg;</span><br><span class="line">    if (servletRequest != null) &#123;</span><br><span class="line">        arg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line">        if (arg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line">            return arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg = null;</span><br><span class="line">    MultipartRequest multipartRequest = (MultipartRequest)request.getNativeRequest(MultipartRequest.class);</span><br><span class="line">    if (multipartRequest != null) &#123;</span><br><span class="line">        List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line">        if (!files.isEmpty()) &#123;</span><br><span class="line">            arg = files.size() == 1 ? files.get(0) : files;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (arg == null) &#123;</span><br><span class="line">        String[] paramValues = request.getParameterValues(name);</span><br><span class="line">        if (paramValues != null) &#123;</span><br><span class="line">            arg = paramValues.length == 1 ? paramValues[0] : paramValues;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，如果使用了<code>@RequestParam</code>注解且不是Map类型，或者是Map类型同时传入了name属性，又或者是没有使用<code>@RequestParam</code>和<code>@RequestPart</code>注解且这个参数有多个组成，或者使用默认的解析器且参数的嵌套是简单类型，则使用该参数解析器；<br>（2）<code>resolveName()</code>方法，首先获取<code>HttpServletRequest</code>对象，如果该对象存在，则解析请求中的多个参数并返回这些参数的值；如果该对象不存在，但是<code>MultipartRequest</code>存在，那么从这个<code>MultipartRequest</code>中通过参数的名称来得到这些参数值，如果参数值存在，那么返回参数值的信息。如果参数值不存在，那么从请求中根据参数名称来得到参数值，如果参数值存在，那么返回参数值的信息。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@RequestParam(&quot;username&quot;) String username)&#123;</span><br><span class="line">        return &quot;I am &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestParamMapMethodArgumentResolver类"><a href="#RequestParamMapMethodArgumentResolver类" class="headerlink" title="RequestParamMapMethodArgumentResolver类"></a>RequestParamMapMethodArgumentResolver类</h3><p>这个方法参数解析器所对应的注解名称同样也是RequestParam，接着查看一下这个RequestParamMapMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveArgument</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line">    return requestParam != null &amp;&amp; Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp; !StringUtils.hasText(requestParam.name());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">    ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);</span><br><span class="line">    Class valueType;</span><br><span class="line">    HttpServletRequest servletRequest;</span><br><span class="line">    Collection parts;</span><br><span class="line">    Iterator var10;</span><br><span class="line">    Part part;</span><br><span class="line">    Map parameterMap;</span><br><span class="line">    MultipartRequest multipartRequest;</span><br><span class="line">    if (!MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) &#123;</span><br><span class="line">        valueType = resolvableType.asMap().getGeneric(new int[]&#123;1&#125;).resolve();</span><br><span class="line">        if (valueType == MultipartFile.class) &#123;</span><br><span class="line">            multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line">            return multipartRequest != null ? multipartRequest.getFileMap() : new LinkedHashMap(0);</span><br><span class="line">        &#125; else if (valueType == Part.class) &#123;</span><br><span class="line">            servletRequest = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">            if (servletRequest != null &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">                parts = servletRequest.getParts();</span><br><span class="line">                LinkedHashMap&lt;String, Part&gt; result = CollectionUtils.newLinkedHashMap(parts.size());</span><br><span class="line">                var10 = parts.iterator();</span><br><span class="line"></span><br><span class="line">                while(var10.hasNext()) &#123;</span><br><span class="line">                    part = (Part)var10.next();</span><br><span class="line">                    if (!result.containsKey(part.getName())) &#123;</span><br><span class="line">                        result.put(part.getName(), part);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new LinkedHashMap(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parameterMap = webRequest.getParameterMap();</span><br><span class="line">            Map&lt;String, String&gt; result = CollectionUtils.newLinkedHashMap(parameterMap.size());</span><br><span class="line">            parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">                if (values.length &gt; 0) &#123;</span><br><span class="line">                    result.put(key, values[0]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        valueType = resolvableType.as(MultiValueMap.class).getGeneric(new int[]&#123;1&#125;).resolve();</span><br><span class="line">        if (valueType == MultipartFile.class) &#123;</span><br><span class="line">            multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line">            return multipartRequest != null ? multipartRequest.getMultiFileMap() : new LinkedMultiValueMap(0);</span><br><span class="line">        &#125; else if (valueType != Part.class) &#123;</span><br><span class="line">            parameterMap = webRequest.getParameterMap();</span><br><span class="line">            MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap(parameterMap.size());</span><br><span class="line">            parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line">                String[] var3 = values;</span><br><span class="line">                int var4 = values.length;</span><br><span class="line"></span><br><span class="line">                for(int var5 = 0; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                    String value = var3[var5];</span><br><span class="line">                    result.add(key, value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            servletRequest = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">            if (servletRequest != null &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">                parts = servletRequest.getParts();</span><br><span class="line">                LinkedMultiValueMap&lt;String, Part&gt; result = new LinkedMultiValueMap(parts.size());</span><br><span class="line">                var10 = parts.iterator();</span><br><span class="line"></span><br><span class="line">                while(var10.hasNext()) &#123;</span><br><span class="line">                    part = (Part)var10.next();</span><br><span class="line">                    result.add(part.getName(), part);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return result;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new LinkedMultiValueMap(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，如果使用了<code>@RequestParam</code>注解且参数是Map类型，同时<code>@RequestParam</code>注解中没有设置name属性，那么就可以使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，总的来说分为两种情况，一种是MultiValueMap，另一种则是其他的Map。对于MultiValueMap来说，如果它是MultipartFile或者Part类型，那么就可以处理文件上传；如果是其他的则是普通的请求参数。如果是普通的Map，那么就直接从原始请求中获取请求参数，并将这些参数放到一个LinkedMultiValueMap中并返回。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;/user&quot;)</span><br><span class="line">    public void user(@RequestParam MultiValueMap map)&#123;</span><br><span class="line">        System.out.println(map.get(&quot;username&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrincipalMethodArgumentResolver类"><a href="#PrincipalMethodArgumentResolver类" class="headerlink" title="PrincipalMethodArgumentResolver类"></a>PrincipalMethodArgumentResolver类</h3><p>查看一下<code>PrincipalMethodArgumentResolver</code>类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    return Principal.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Current request is not of type HttpServletRequest: &quot; + webRequest);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Principal principal = request.getUserPrincipal();</span><br><span class="line">        if (principal != null &amp;&amp; !parameter.getParameterType().isInstance(principal)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Current user principal is not of type [&quot; + parameter.getParameterType().getName() + &quot;]: &quot; + principal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return principal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，用于判断参数类型是否为Principal这一类型，如果是则使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，首先从原始请求中获取<code>HttpServletRequest</code>对象，如果该对象不存在则抛出异常；如果存在则从请求中获取Principal对象并返回。这个Principal对象里面包含登录的用户名称。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(Principal principal)&#123;</span><br><span class="line">        return &quot;My name is &quot; + principal.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PathVariableMethodArgumentResolver类"><a href="#PathVariableMethodArgumentResolver类" class="headerlink" title="PathVariableMethodArgumentResolver类"></a>PathVariableMethodArgumentResolver类</h3><p>通过前面的分析，可以得到这个解析器所对应的注解名称为PathVariable，因此首先我们看一下这个注解的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface PathVariable &#123;</span><br><span class="line">    @AliasFor(&quot;name&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    boolean required() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个<code>@PathVariable</code>注解有三个属性，其中name和value互为各自的别名，required表示参数是否必须传，默认是必须。</p><p>接着查看一下这个PathVariableMethodArgumentResolver类中的<code>supportsParameter</code>和<code>resolveName</code>方法，注意它的resolveArgument方法名称发生了变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">    if (!parameter.hasParameterAnnotation(PathVariable.class)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        PathVariable pathVariable = (PathVariable)parameter.getParameterAnnotation(PathVariable.class);</span><br><span class="line">        return pathVariable != null &amp;&amp; StringUtils.hasText(pathVariable.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception &#123;</span><br><span class="line">    Map&lt;String, String&gt; uriTemplateVars = (Map)request.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, 0);</span><br><span class="line">    return uriTemplateVars != null ? uriTemplateVars.get(name) : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，用于判断如果参数上使用了<code>@PathVariable</code>注解，并且参数的类型不是Map及其子类，则使用该参数解析器。或者是Map类型，则当<code>@PathVariable</code>注解中的value属性有值时，才使用该参数解析器；<br>（2）<code>resolveName()</code>方法，用于从请求中获取uriTemplateVars，如果uriTemplateVars不为空，则从uriTemplateVars根据名称来获取值并返回。</p><p>类似于这种的情况，我们会使用诸如下面的接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user/&#123;username&#125;&quot;)</span><br><span class="line">    public String user(@PathVariable(&quot;username&quot;) String username)&#123;</span><br><span class="line">        return &quot;My name is &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>假设如下接口中，我们需要获取用户传入的用户名，此时就可以使用自定义参数解析器这一方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@CurrentUserName String username)&#123;</span><br><span class="line">        return &quot;I am&quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即在方法中通过使用<code>@CurrentUserName</code>注解从HttpServletRequest中获取当前传入的用户名。要实现这个功能，步骤如下所示：</p><p>第一步，创建一个名为<code>method-resolve</code>的SpringBoot项目，然后添加<code>spring web</code>和<code>spring test</code>依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>第二步，新建一个名为<code>CurrentUserName</code>的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CurrentUserName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，新建一个名为<code>CurrentUserNameHandlerMethodArgumentResolver</code>的类，注意它需要实现<code>HandlerMethodArgumentResolver</code>接口并重写其中的上述两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CurrentUserNameHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsParameter(MethodParameter parameter) &#123;</span><br><span class="line">        return parameter.getParameterType().isAssignableFrom(String.class) &amp;&amp; parameter.hasParameterAnnotation(CurrentUserName.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        return request.getParameter(parameter.getParameterName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述方法的逻辑：<br>（1）<code>supportsParameter()</code>方法，判断当前参数类型是否为String且在参数上使用了<code>@CurrentUserName</code>注解，这有这样才使用该参数解析器；<br>（2）<code>resolveArgument()</code>方法，用于返回接口中参数的值，这里直接调用<code>request.getParameter()</code>方法传入参数名称进而得到参数的值。</p><p>第四步，注册自定义参数解析器。定义一个名为<code>WebConfig</code>的类，注意这个类需要实现<code>WebMvcConfigurer</code>接口，并重写其中的<code>addArgumentResolvers</code>默认方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;</span><br><span class="line">        resolvers.add(new CurrentUserNameHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，新建接口类。定义一个名为<code>UserController</code>的类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public String user(@CurrentUserName String username)&#123;</span><br><span class="line">        return &quot;I am &quot; + username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，启动项目，访问<code>http://localhost:8080/user?username=melody</code>链接，可以看到页面显示如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am melody</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了如何在SpringBoot中通过自定义类实现<code>HandlerMethodArgumentResolver</code>接口，并重写其中的<code>supportsParameter()</code>和<code>resolveArgument()</code>方法来实现自定义参数解析器，同时也剖析了一些常用的参数注解以及背后的原理，最后通过实战学习了如何通过自定义一个注解来实现参数解析器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;今天我们来聊一聊SpringBoot中的参数解析器，这在某些场景下非常有用。一般来说，在一个Web请求里面参数要么是放在请求</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>一个注解配合Redis实现接口限流</title>
    <link href="http://envyzhan.asia/2022/03/24/5-an-annotation-cooperates-with-redis-to-realize-interface-current-limition/"/>
    <id>http://envyzhan.asia/2022/03/24/5-an-annotation-cooperates-with-redis-to-realize-interface-current-limition/</id>
    <published>2022-03-24T09:55:30.000Z</published>
    <updated>2022-09-12T08:09:24.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近发现线上发送验证码的接口被莫名刷了，1天就把上周刚充值的1万条用完了，我内心其实是崩溃的，于是决定对该接口实现限流，这里选择使用拦截器配合Redis来实现。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>limit-redis</code>的SpringBoot项目，然后在POM文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，修改<code>application.yml</code>配置文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password: 1234</span><br><span class="line">    database: 1</span><br></pre></td></tr></table></figure><h3 id="重写RedisTempplate的序列化"><a href="#重写RedisTempplate的序列化" class="headerlink" title="重写RedisTempplate的序列化"></a>重写RedisTempplate的序列化</h3><p>第三步，重写RedisTempplate的序列化逻辑。一般来说我们更倾向于在SpringBoot中使用 Spring Data Redis来操作Redis，但是随着而来的则是它的序列化问题，默认使用的是<code>JdkSerializationRedisSerializer</code>，采用的是二进制方式，且会自动的给存入的key和value添加一些前缀，导致实际情况与开发者预想的不一致。针对这种情况我们可以使用<code>Jackson2JsonRedisSerializer</code>这一序列化方式，不建议使用<code>StringRedisTemplate</code>来替代<code>RedisTemplate</code>，因为它提供的数据类型和操作都有限，无法满足日常需要。</p><p>定义一个名为RedisConfig的类，该类用于重写RedisTempplate的序列化逻辑，使用<code>Jackson2JsonRedisSerializer</code>取代默认的<code>JdkSerializationRedisSerializer</code>，这样利于后续开发和使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        // 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化)</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(mapper);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义限流注解"><a href="#自定义限流注解" class="headerlink" title="自定义限流注解"></a>自定义限流注解</h3><p>第四步，自定义限流注解。我们要求这个限流分为两种，一种是针对某一个接口的全局限流，另一种是针对IP地址的限流：<br>（1）针对当前某一接口的全局限流。举个例子，<code>/test</code>接口可以在1分钟内访问60次；<br>（2）针对IP地址的限流。举个例子，<code>192.168.56.1</code>这一IP地址可以在1分钟内访问60次；<br>针对上述情况，可以创建一个枚举类<code>LimitType</code>，用于记录限流的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 限流类型</span><br><span class="line"> */</span><br><span class="line">public enum LimitType &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 默认类型：全局限流</span><br><span class="line">     */</span><br><span class="line">    DEFAULT,</span><br><span class="line">    /**</span><br><span class="line">     * 根据请求IP地址限流</span><br><span class="line">     */</span><br><span class="line">    IP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着自定义一个限流注解<code>RateLimiter</code>，里面设置限流key，注意这个key仅仅是一个前缀，后续我们会拼接其他的变量组成完整的key，进而存入Redis中。完整key的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:IP地址-注解所添加方法所在的类的名称-注解所添加方法的名称</span><br></pre></td></tr></table></figure><p>举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:192.168.30.10-com.melody.limitredis.controller.RateLimiterController-test</span><br></pre></td></tr></table></figure><p>time则是限流的时间，单位为秒；count则是限流的次数，默认100次；limitType则是限流的类型，默认为全局限流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface RateLimiter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 限流Key</span><br><span class="line">     */</span><br><span class="line">    String key()default &quot;rate_limit:&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流时间，单位秒</span><br><span class="line">     */</span><br><span class="line">    int time()default 60;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流次数，默认100次</span><br><span class="line">     */</span><br><span class="line">    int count()default 100;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 限流类型，默认全局限流</span><br><span class="line">     */</span><br><span class="line">    LimitType limitType()default LimitType.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样后续我们需要对某个接口进行限流，只需在该接口上添加<code>@RateLimiter</code>注解，并设置上述对应的参数即可，总的来说还是比较简单的。</p><p>第五步，编写Lua脚本。我们知道Redis的单个操作是具备原子性的，而多个操作就无法保证，但是我们可以借助于Lua脚本来实现。一般来说调用Lua脚本有两种方式：<br>（1）在Redis服务端定义Lua脚本，然后计算出一个hash值，接着在Java代码中通过这个hash值来确定需要执行的Lua脚本；<br>（2）在Java代码中将Lua脚本定义好，然后将其发送到Redis服务端，进而去执行。<br>笔者比较倾向于第二种方式，因此可以先在客户端定义好Lua脚本，然后通过Spring Data Redis提供的<code>redisTemplate.execute()</code>方法，传入脚本实例和对应的参数就可以执行对应的Lua脚本了。</p><p>在项目的resources目录下新建一个名为lua的目录，并在该lua目录下新建一个名为<code>limit.lua</code>的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]</span><br><span class="line">local count = tonumber(ARGV[1])</span><br><span class="line">local time = tonumber(ARGV[2])</span><br><span class="line">local current = redis.call(&#x27;get&#x27;, key)</span><br><span class="line">if current and tonumber(current) &gt; count then</span><br><span class="line">    return tonumber(current)</span><br><span class="line">end</span><br><span class="line">current = redis.call(&#x27;incr&#x27;, key)</span><br><span class="line">if tonumber(current) == 1 then</span><br><span class="line">    redis.call(&#x27;expire&#x27;, key, time)</span><br><span class="line">end</span><br><span class="line">return tonumber(current)</span><br></pre></td></tr></table></figure><p>这个KEYS和ARGV就是用户后续在执行该脚本时传入来的参数，tonumber方法用于将字符串转成数字，<code>redis.call()</code>方法通过传入方法名称和参数，进而实现调用不同方法的逻辑。上述脚本所要表达的含义如下：<br>（a）获取用户传递进来的key，限流次数count和限流时间time；<br>（b）调用<code>get(key)</code>方法来获取当前key的值，即当前接口在当前时间内已经访问的次数；<br>（c）如果该接口是第一次访问，那么（b）得到的结果将是nil，否则得到的是一个数字。如果是数字那么我们将判断它和限流次数count的大小，如果该数字大于count，则说明已经超过最大访问次数，需要限流了，可以直接返回当前请求的次数；<br>（d）如果得到的结果是nil，则说明是第一次访问该接口，那么给当前的key进行自增加1，并设置一个过期时间；<br>（e）最后只需将自增后的值返回即可。</p><p>第六步，在RedisConfig类中定义一个Bean来加载这个Lua脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DefaultRedisScript&lt;Long&gt; limitScript() &#123;</span><br><span class="line">    DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">    redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;lua/limit.lua&quot;)));</span><br><span class="line">    redisScript.setResultType(Long.class);</span><br><span class="line">    return redisScript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意Lua脚本的存放位置和名称需要与开发者实际存放的位置相匹配，否则后续无法成功调用该脚本。</p><h3 id="自定义切面类"><a href="#自定义切面类" class="headerlink" title="自定义切面类"></a>自定义切面类</h3><p>其实拦截请求可以有不同的实现思路，可以用拦截器或者AOP，考虑到拦截器也是AOP思想的体现，因此这里就直接使用AOP来实现。</p><p>第七步，自定义切面类<code>RateLimiterAspect</code>，该类用于拦截所有添加了<code>@RateLimiter</code>注解的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class RateLimiterAspect &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(RateLimiterAspect.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisScript&lt;Long&gt; limitScript;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;@annotation(rateLimiter)&quot;)</span><br><span class="line">    public void before(JoinPoint point, RateLimiter rateLimiter)&#123;</span><br><span class="line">        int time = rateLimiter.time();</span><br><span class="line">        int count = rateLimiter.count();</span><br><span class="line"></span><br><span class="line">        String combineKey = getCombineKey(rateLimiter,point);</span><br><span class="line">        List&lt;Object&gt; keys = Collections.singletonList(combineKey);</span><br><span class="line">        try&#123;</span><br><span class="line">            Long number = redisTemplate.execute(limitScript, keys, count, time);</span><br><span class="line">            if(number == null || number.intValue() &gt; count)&#123;</span><br><span class="line">                throw new BizException(&quot;请求过于频繁，请稍后重试&quot;,500);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(&quot;当前请求次数&#x27;&#123;&#125;&#x27;,限定次数&#x27;&#123;&#125;&#x27;&quot;, number.intValue(), count);</span><br><span class="line">        &#125;catch (BizException e)&#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;服务器限流异常，请稍候再试&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getCombineKey(RateLimiter rateLimiter, JoinPoint point) &#123;</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer(rateLimiter.key());</span><br><span class="line">        //IP限制</span><br><span class="line">        if(rateLimiter.limitType() == LimitType.IP)&#123;</span><br><span class="line">            stringBuffer.append(IpUtils.getRequestIp(((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest())).append(&quot;-&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Class&lt;?&gt; targetClass = method.getDeclaringClass();</span><br><span class="line">        stringBuffer.append(targetClass.getName()).append(&quot;-&quot;).append(method.getName());</span><br><span class="line">        logger.info(&quot;&#123;&#125;&quot;,stringBuffer.toString());</span><br><span class="line">        return stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们使用了前置通知，并在前置通知中对请求进行了处理，逻辑如下：<br>（1）获取注解中的time、count 、key和limitType这四个属性；<br>（2）调用<code>getCombineKey()</code>方法来获取一个完整的限流Key，先判断是否包含IP，如果有IP就将IP添加到里面，否则就不添加，最终完整的限流Key格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate_limit:IP地址-注解所添加方法所在的类的名称-注解所添加方法的名称</span><br></pre></td></tr></table></figure><p>（3）将限流Key放入一个集合中，因为此处我们调用的<code>redisTemplate.execute()</code>的完整方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T execute(RedisScript&lt;T&gt; script, List&lt;K&gt; keys, Object... args);</span><br></pre></td></tr></table></figure><p>里面的keys就是一个集合，所以此处就生成了一个单例模式的集合。其实这个也对应于之前我们在Lua脚本中定义的参数，即上述方法中的第二个参数keys就是脚本中的KEYS，可变长度就是脚本中的ARGV，注意值下标从1开始计数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local key = KEYS[1]</span><br><span class="line">local count = tonumber(ARGV[1])</span><br><span class="line">local time = tonumber(ARGV[2])</span><br></pre></td></tr></table></figure><p>（4）之后就是将执行Lua脚本之后的返回值与限流值count进行比较，如果值大于count则说明超出最大访问次数，应当限流，此时抛出一个异常，这里我们自定义了一个异常BizException。</p><p>第八步，定义一个用于获取用户IP地址信息的工具类<code>IpUtils</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class IpUtils &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取请求真实IP地址</span><br><span class="line">     */</span><br><span class="line">    public static String getRequestIp(HttpServletRequest request) &#123;</span><br><span class="line">        //通过HTTP代理服务器转发时添加</span><br><span class="line">        String ipAddress = request.getHeader(&quot;x-forwarded-for&quot;);</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ipAddress == null || ipAddress.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ipAddress)) &#123;</span><br><span class="line">            ipAddress = request.getRemoteAddr();</span><br><span class="line">            // 从本地访问时根据网卡取本机配置的IP</span><br><span class="line">            if (ipAddress.equals(&quot;127.0.0.1&quot;) || ipAddress.equals(&quot;0:0:0:0:0:0:0:1&quot;)) &#123;</span><br><span class="line">                InetAddress inetAddress = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    inetAddress = InetAddress.getLocalHost();</span><br><span class="line">                &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ipAddress = inetAddress.getHostAddress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过多个代理转发的情况，第一个IP为客户端真实IP，多个IP会按照&#x27;,&#x27;分割</span><br><span class="line">        if (ipAddress != null &amp;&amp; ipAddress.length() &gt; 15) &#123;</span><br><span class="line">            if (ipAddress.indexOf(&quot;,&quot;) &gt; 0) &#123;</span><br><span class="line">                ipAddress = ipAddress.substring(0, ipAddress.indexOf(&quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ipAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然了，这里只是获取了用户的IP地址，之后可以向一些网站发起请求，得到这些IP的归属地，这里笔者就不展示了。</p><h3 id="全局异常捕获"><a href="#全局异常捕获" class="headerlink" title="全局异常捕获"></a>全局异常捕获</h3><p>第九步，定义一个异常BizException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class BizException extends RuntimeException&#123;</span><br><span class="line">    private int code;</span><br><span class="line"></span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(int status) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, int code)&#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十步，针对该自定义异常，定义一个全局异常处理类<code>GlobalExceptionHandler</code>，用于处理这个异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(BizException.class)</span><br><span class="line">    public Map&lt;String,Object&gt; handler(BizException e)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;message&quot;,e.getMessage());</span><br><span class="line">        map.put(&quot;code&quot;,e.getCode());</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义测试接口"><a href="#定义测试接口" class="headerlink" title="定义测试接口"></a>定义测试接口</h3><p>第十一步，新建接口测试类<code>RateLimiterController</code>，然后在里面定义一个接口，并在该接口上添加自定义的<code>@RateLimiter</code>注解，用于测试我们的限流效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class RateLimiterController &#123;</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    @RateLimiter(time = 2,count = 5,limitType = LimitType.IP)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        return &quot;test &gt;&gt;&gt;&quot; +new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h3><p>第十二步，启动项目，访问<code>http://localhost:8080/test</code>，可以看到页面显示信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test &gt;&gt;&gt;2021-05-17 13:57:57</span><br></pre></td></tr></table></figure><p>但是当用户访问较为频繁的时候，页面会给出相应的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code: 500,</span><br><span class="line">    message: &quot;请求过于频繁，请稍后重试&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时查看IDEA的控制台，可以看到也输出了相应的日志信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6a6ffd8f0dae24b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇基于AOP思想并配合Redis实现了接口的限流功能，在项目中实际上也有提供基于拦截器的实现，这一点需要的小伙伴可以自取。本篇实现的接口限流其实非常简陋，而我们经常使用的微服务组件Sentinel则是比较完备的限流工具，因此后续有更细粒度的限流需求可以参考Sentinel的限流逻辑进行实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近发现线上发送验证码的接口被莫名刷了，1天就把上周刚充值的1万条用完了，我内心其实是崩溃的，于是决定对该接口实现限流，这里</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>可视化多数据源动态切换</title>
    <link href="http://envyzhan.asia/2022/03/20/4-dynamic-switching-of-visual-multiple-data-sources/"/>
    <id>http://envyzhan.asia/2022/03/20/4-dynamic-switching-of-visual-multiple-data-sources/</id>
    <published>2022-03-20T09:55:30.000Z</published>
    <updated>2022-09-12T08:07:26.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中我们希望实现多数据源的动态切换，而这一点我们在前面一篇文章中就已经进行了实现，但是对于业务人员来说，更多的则是希望可以通过可视化界面的方式来自己决定使用哪个数据源，进而获取对应的数据。</p><h1 id="几个思考"><a href="#几个思考" class="headerlink" title="几个思考"></a>几个思考</h1><p>前面我们多次提到<code>AbstractRoutingDataSource</code>抽象类定义了抽象的<code>determineCurrentLookupKey</code>方法，子类只需实现此方法，就可以通过一个Key从Map中获取对应的数据源实例，并执行对应的数据库操作。查看一下之前我们的<code>dynamic-multiple-ds</code>项目，本篇将在此基础上进行实现。由于我们将数据源名称存在<code>DynamicMultipleDataSourceContextHolder</code>这一ThreadLocal中，因此只需修改该变量的值就能实现这个目的。</p><p>也就是说首先我们要定义一个方法用于传入新的数据源名称，然后我们可以将这个数据源名称放在Session、Redis或者数据库中，最后在修改<code>DynamicMultipleDataSourceContextHolder</code>的时候从里面取出数据并更新ThreadLocal的值即可。</p><p>其次，用户通过页面切换的数据源应该是全局的还是局部的呢？这个应该根据实际的业务来确定，此处假设用户通过页面切换的数据源是全局的，因此后续我们在定义切面的时候不再通过注解方式进行拦截，而是直接拦截所有的业务处理类。还有如果某个拦截的类里面部分方法上，也设置了之前定义的<code>@MyDataSource</code>注解，那么此时应当以哪个为准？这个也是需要根据实际业务来确定，此处假设后者优先级高于前者，即如果某个类既被全局拦截，又添加了<code>@MyDataSource</code>注解，那么最终还是以<code>@MyDataSource</code>注解指定的数据源名称为准。</p><p>再次，我们需要提供一个界面以供用户自行切换数据源，然后展示切换数据源后的数据。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>第一步，新建Book实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer price;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    //getter、setter和toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，修改BookMapper接口的代码为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    @Select(&quot;select count(*) from book&quot;)</span><br><span class="line">    Integer number();</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from book&quot;)</span><br><span class="line">    List&lt;Book&gt; getAllBooks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，修改BookService类的代码为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">       return bookMapper.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，由于我们是将用户传入的数据源名称存在Session中，因此先定义一个Session中的Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipleDataSourceProvider &#123;</span><br><span class="line">    String DEFAULT_DATASOURCE = &quot;master&quot;;</span><br><span class="line"></span><br><span class="line">    //作为Session的存储key</span><br><span class="line">    String DS_SESSION_KEY = &quot;ds_session_key&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, DataSource&gt; loadDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，我们可以将之前<code>MyDataSourceAspect</code>这一切面类中获取<code>MyDataSource</code>注解的逻辑抽离出来，以便后续可以重复调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyDataSourceAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;</span><br><span class="line">    +&quot;||@within(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;)</span><br><span class="line">    public void myDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;myDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)throws Throwable &#123;</span><br><span class="line">        MyDataSource myDataSource = getMyDataSource(point);</span><br><span class="line">        if(Objects.nonNull(myDataSource))&#123;</span><br><span class="line">            //myDataSource存在则获取并将其存入DynamicMultipleDataSourceContextHolder中</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.setDataSourceName(myDataSource.dataSourceName());</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDataSource getMyDataSource(ProceedingJoinPoint point)&#123;</span><br><span class="line">        //获取方法签名</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        //查找方法上的注解</span><br><span class="line">        MyDataSource myDataSource = AnnotationUtils.findAnnotation(signature.getMethod(), MyDataSource.class);</span><br><span class="line">        if(myDataSource==null)&#123;</span><br><span class="line">            myDataSource = AnnotationUtils.findAnnotation(signature.getDeclaringType(), MyDataSource.class);</span><br><span class="line">        &#125;</span><br><span class="line">        return myDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，定义一个用于拦截所有业务方法的全局切面类<code>GlobalDataSourceAspect</code>，里面的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class GlobalDataSourceAspect &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private HttpSession session;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 拦截service包下面的所有类的所有方法</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(* com.melody.dynamicmultipleds.service.*.*(..))&quot;)</span><br><span class="line">    public void globalDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;globalDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)&#123;</span><br><span class="line">        String dataSourceName = (String)session.getAttribute(MultipleDataSourceProvider.DS_SESSION_KEY);</span><br><span class="line">        DynamicMultipleDataSourceContextHolder.setDataSourceName(dataSourceName);</span><br><span class="line">        try &#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            //清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第七步，定义一个名为<code>DataSourceController</code>的类，在里面提供两个方法，一个用于修改数据源名称，另一个用于查询所有的books信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DataSourceController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(DataSourceController.class);</span><br><span class="line">    /**</span><br><span class="line">     * 修改数据源名称</span><br><span class="line">     * @param dsName</span><br><span class="line">     * @param session</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(&quot;/dsName&quot;)</span><br><span class="line">    public void updateDataSourceName(String dsName, HttpSession session)&#123;</span><br><span class="line">        session.setAttribute(MultipleDataSourceProvider.DS_SESSION_KEY,dsName);</span><br><span class="line">        logger.info(&quot;数据源切换为&#123;&#125;&quot;,dsName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/books&quot;)</span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">        return bookService.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，在<code>resources/static</code>目录下新建一个名为<code>jquery-3.6.0.js</code>的js文件，里面的内容可以从 <a href="http://code.jquery.com/jquery-3.6.0.js">这里</a> 获取。接着在该目录下定义一个名为index.html的页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;多数据源可视化切换&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;jquery-3.6.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    请选择使用的数据源：</span><br><span class="line">    &lt;select name=&quot;&quot; id=&quot;&quot; onchange=&quot;dsChange(this.options[this.options.selectedIndex].value)&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;请选择&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;master&quot;&gt;master&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;slave&quot;&gt;slave&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;result&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button onclick=&quot;loadData()&quot;&gt;加载数据&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function loadData() &#123;</span><br><span class="line">        $.get(&quot;/books&quot;,function (data) &#123;</span><br><span class="line">            $(&quot;#result&quot;).html(JSON.stringify(data));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    function dsChange(value) &#123;</span><br><span class="line">        $.post(&quot;/dsName&quot;,&#123;</span><br><span class="line">            dsName: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>前端页面的代码也较为简单，即让用户手动选择数据源，然后点击下方的加载数据按钮，即可通过新的数据源来加载数据。实际上选择数据源的时候就是请求了<code>/dsName</code>这一API；而加载数据则是请求了<code>/books</code>这一API。</p><p>第九步，测试。启动项目，访问<code>http://localhost:8080/index.html</code>页面，选择“master”，可以看到控制台也输出对应信息了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-99deaadfd20a7b77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后点击加载数据按钮，可以看到首页已经将master这一数据源数据查询出来了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ea9f77904c0d0607.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e3f789e4a191d9b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着我们再选择“slave”，可以看到控制台也输出对应信息了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c64f95ce113230e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1a4df20c856fa200.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第十步，确定全局拦截和注解拦截业务顺序。由于前面说过，如果某个类既被全局拦截，又添加了<code>@MyDataSource</code>注解，那么最终还是以<code>@MyDataSource</code>注解指定的数据源名称为准。也就是说全局拦截先执行，<code>@MyDataSource</code>注解后执行才能达到既定目的，而配置Bean的顺序可以使用<code>@Order</code>注解来实现，其中<code>@Order</code>注解中设置的数字越小表示优先级越高，越先执行。所以反映到<code>@Order</code>注解上面，要想实现既定目标，那么全局拦截切面类上的<code>@Order</code>注解中设置的数字就要小于<code>@MyDataSource</code>注解所定义切面上的<code>@Order</code>注解中设置的数字值。</p><p>可以将全局拦截类<code>GlobalDataSourceAspect</code>上的<code>@Order</code>注解值设置为1；<code>@MyDataSource</code>注解所对应的切面类<code>MyDataSourceAspect</code>上的<code>@Order</code>注解值设置为2，这样就可以让<code>@MyDataSource</code>注解的优先级高于全局。然后在BookService类中的getAllBooks方法中添加<code>@MyDataSource</code>注解，指定数据源为master：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;master&quot;)</span><br><span class="line">    public List&lt;Book&gt; getAllBooks()&#123;</span><br><span class="line">       return bookMapper.getAllBooks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重启项目，可以发现此时无论用户如何切换数据源，最终用户调用的都是master这一数据源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中我们希望实现多数据源的动态切换，而这一点我们在前面一篇文章中就已经进行了实现，但是对于业务人员来说，更多的则是希</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>多数据源动态切换</title>
    <link href="http://envyzhan.asia/2022/03/18/3-dynamic-switching-of-multiple-data-sources/"/>
    <id>http://envyzhan.asia/2022/03/18/3-dynamic-switching-of-multiple-data-sources/</id>
    <published>2022-03-18T09:55:30.000Z</published>
    <updated>2022-09-12T08:05:58.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前一篇文章中我们介绍了如何在SpringBoot中整合<code>Jdbc Template</code>、<code>Mybatis</code>和<code>Spring Data JPA</code>的多数据源配置，但是很明显这些思路都是设置多个Dao层，然后手动选择使用的实例，在实际工作中可能会有需要动态切换数据源的情况，因此本篇来学习如何利用AOP来实现多数据源的动态切换功能。</p><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p><code>AbstractRoutingDataSource</code>是Spring2.0.1版本引入的一个抽象类，它提供了多数据源的支持能力。<code>AbstractRoutingDataSource</code>抽象类定义了抽象的<code>determineCurrentLookupKey</code>方法，子类只需实现此方法，进而动态确定要使用的数据源。</p><p>查看一下这个<code>AbstractRoutingDataSource</code>抽象类的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Object defaultTargetDataSource;</span><br><span class="line">    private boolean lenientFallback = true;</span><br><span class="line">    private DataSourceLookup dataSourceLookup = new JndiDataSourceLookup();</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource resolvedDefaultDataSource;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    protected DataSource determineTargetDataSource() &#123;</span><br><span class="line">        Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);</span><br><span class="line">        Object lookupKey = this.determineCurrentLookupKey();</span><br><span class="line">        DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey);</span><br><span class="line">        if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123;</span><br><span class="line">            dataSource = this.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (dataSource == null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected abstract Object determineCurrentLookupKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>determineTargetDataSource</code>方法的逻辑是先判断<code>resolvedDataSources</code>属性是否不为空，之后再调用<code>determineCurrentLookupKey</code>方法来获取数据源名称key，并从<code>resolvedDataSources</code>属性中得到对应的DataSource对象。如果找不到DataSource对象或者数据源名称key不存在则使用<code>resolvedDefaultDataSource</code>。</p><p>说白了就是开发者提前准备好多个数据源，然后将其存入一个Map中，Map的Key是对应数据源的名称，而Value则是对应的数据源。接着将Map设置到<code>AbstractRoutingDataSource</code>对象的<code>resolvedDataSources</code>属性中，然后当执行数据库操作的时候就通过一个Key来从Map中获取对应的数据源实例，并执行对应的数据库操作。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>dynamic-multiple-ds</code>的SpringBoot项目，选择<code>spring web</code>、<code>mybatis framework</code>和<code>mysql driver</code>依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-927a0caa070c04b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二步，在POM文件中新增Druid和AOP依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>第三步，修改<code>application.properties</code>配置文件信息，不过由于笔者一般喜欢使用YAML格式的写法，因此<code>application.yml</code>配置文件其实使用更为频繁，因此这里也使用<code>application.yml</code>配置文件。但是后期我们需要动态获取里面的内容，因此可以使用SpringBoot提供的profile机制来加载里面的信息。定义一个名为<code>application-multiple.yml</code>的配置文件，并在里面新增如下配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 数据源配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    # 数据源类型</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 自定义数据源</span><br><span class="line">    my-ds:</span><br><span class="line">      # 主数据源，默认为master</span><br><span class="line">      master:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds1?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">      # 从数据源，slave</span><br><span class="line">      slave:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">    # 初始连接数</span><br><span class="line">    initial-size: 5</span><br><span class="line">    # 最小连接池数量</span><br><span class="line">    min-idle: 10</span><br><span class="line">    # 最大连接池数量</span><br><span class="line">    max-active: 20</span><br><span class="line">    # 获取连接等待超时的时间</span><br><span class="line">    max-wait: 60000</span><br><span class="line">    # 检测间隔时间，检测需要关闭的空闲连接，单位毫秒</span><br><span class="line">    time-between-eviction-runs-millis: 60000</span><br><span class="line">    # 一个连接在连接池中最小的生存时间，单位毫秒</span><br><span class="line">    min-evictable-idle-time-millis: 300000</span><br><span class="line">    # 一个连接在连接池中最大的生存时间，单位毫秒</span><br><span class="line">    max-evictable-idle-time-millis: 900000</span><br><span class="line">    # 配置检测连接是否有效</span><br><span class="line">    validation-query: SELECT 1 FROM DUAL</span><br><span class="line">    # 如果为true（默认为false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的</span><br><span class="line">    test-on-borrow: false</span><br><span class="line">    # 连接返回检测</span><br><span class="line">    test-on-return: false</span><br><span class="line">    # 失效连接检测</span><br><span class="line">    test-while-idle: true</span><br><span class="line">    druid:</span><br><span class="line">      web-stat-filter:</span><br><span class="line">        enabled: true</span><br><span class="line">      stat-view-servlet:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 设置白名单，缺省为所有</span><br><span class="line">        allow:</span><br><span class="line">        url-pattern: /druid/*</span><br><span class="line">        # 登录用户名及密码</span><br><span class="line">        login-username: melody</span><br><span class="line">        login-password: melody</span><br><span class="line">      filter:</span><br><span class="line">        # 开启统计功能</span><br><span class="line">        stat:</span><br><span class="line">          enabled: true</span><br><span class="line">          # 开启慢查询功能</span><br><span class="line">          log-slow-sql: true</span><br><span class="line">          slow-sql-millis: 1000</span><br><span class="line">          # 合并多SQL</span><br><span class="line">          merge-sql: true</span><br><span class="line">        # 开启防火墙功能</span><br><span class="line">        wall:</span><br><span class="line">          enabled: true</span><br><span class="line">          config:</span><br><span class="line">            # 允许多语句同时执行</span><br><span class="line">            multi-statement-allow: true</span><br></pre></td></tr></table></figure><p>这里我们提供了两个数据源，一主一备，其实这里就是同一个连接中的不同数据库罢了。同时我们还对Druid连接池工具进行了详细配置，启用了SQL监控和SQL防火墙等功能。</p><p>然后我们需要在<code>application.yml</code>配置文件中启动上述配置文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: multiple</span><br></pre></td></tr></table></figure><h3 id="加载数据源"><a href="#加载数据源" class="headerlink" title="加载数据源"></a>加载数据源</h3><p>第四步，新建一个名为<code>MultipleDSConfiguration</code>类，显然该类是一个配置类，用于将之前定义的<code>application-multiple.yml</code>配置文件内容加载到该类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">public class MultipleDSConfiguration &#123;</span><br><span class="line">    private Map&lt;String,Map&lt;String,String&gt;&gt; myDS;</span><br><span class="line">    private int initialSize;</span><br><span class="line">    private int minIdle;</span><br><span class="line">    private int maxActive;</span><br><span class="line">    private int maxWait;</span><br><span class="line">    private int timeBetweenEvictionRunsMillis;</span><br><span class="line">    private int minEvictableIdleTimeMillis;</span><br><span class="line">    private int maxEvictableIdleTimeMillis;</span><br><span class="line">    private String validationQuery;</span><br><span class="line">    private boolean testOnBorrow;</span><br><span class="line">    private boolean testOnReturn;</span><br><span class="line">    private boolean testWhileIdle;</span><br><span class="line"></span><br><span class="line">    public DruidDataSource dataSource(DruidDataSource druidDataSource)&#123;</span><br><span class="line">        // 初始连接数</span><br><span class="line">        druidDataSource.setInitialSize(initialSize);</span><br><span class="line">        // 最小连接池数量</span><br><span class="line">        druidDataSource.setMinIdle(minIdle);</span><br><span class="line">        // 最大连接池数量</span><br><span class="line">        druidDataSource.setMaxActive(maxActive);</span><br><span class="line">        // 获取连接等待超时的时间</span><br><span class="line">        druidDataSource.setMaxWait(maxWait);</span><br><span class="line">        // 检测间隔时间，检测需要关闭的空闲连接，单位毫秒</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);</span><br><span class="line">        // 一个连接在连接池中最小的生存时间，单位毫秒</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);</span><br><span class="line">        // 一个连接在连接池中最大的生存时间，单位毫秒</span><br><span class="line">        druidDataSource.setMaxEvictableIdleTimeMillis(maxEvictableIdleTimeMillis);</span><br><span class="line">        // 配置检测连接是否有效</span><br><span class="line">        druidDataSource.setValidationQuery(validationQuery);</span><br><span class="line">        // 如果为true（默认为false），当应用向连接池申请连接时，连接池会判断这条连接是否是可用的</span><br><span class="line">        druidDataSource.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        // 连接返回检测</span><br><span class="line">        druidDataSource.setTestOnReturn(testOnReturn);</span><br><span class="line">        // 失效连接检测</span><br><span class="line">        druidDataSource.setTestWhileIdle(testWhileIdle);</span><br><span class="line">        return druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>myDS这个就是我们所定义的Map，我们将定义的多个数据源写入到该Map中。此处还定义了一个名为dataSource的方法，该方法传入一个DruidDataSource对象，其实就是给这个DruidDataSource对象设置属性。</p><p>第五步，加载数据源。有了数据源及配置文件后，接下来我们开始根据配置文件来加载数据源。定义一个名为<code>MultipleDataSourceProvider</code>的接口类，里面定义默认的数据源名称(master)以及加载数据源的抽象方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MultipleDataSourceProvider &#123;</span><br><span class="line">    String DEFAULT_DATASOURCE = &quot;master&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, DataSource&gt; loadDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们定义一个该接口的实现类<code>YmlMultipleDataSourceProvider</code>，因此它需要重写其中的<code>loadDataSource()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class YmlMultipleDataSourceProvider implements MultipleDataSourceProvider&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MultipleDSConfiguration multipleDSConfiguration;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Map&lt;String, DataSource&gt; loadDataSource() &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, String&gt;&gt; myDS = multipleDSConfiguration.getMyDS();</span><br><span class="line">        Map&lt;String,DataSource&gt; map = new HashMap&lt;&gt;(myDS.size());</span><br><span class="line">        try&#123;</span><br><span class="line">            for (String key: myDS.keySet())&#123;</span><br><span class="line">                DruidDataSource druidDataSource = (DruidDataSource)DruidDataSourceFactory.createDataSource(myDS.get(key));</span><br><span class="line">                map.put(key,multipleDSConfiguration.dataSource(druidDataSource));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们将之前的MultipleDSConfiguration对象注入进来，然后调用该对象的<code>getMyDS()</code>方法得到我们在<code>application-multiple.ym</code>l配置文件中设置的如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 数据源配置</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    my-ds:</span><br><span class="line">      # 主数据源，默认为master</span><br><span class="line">      master:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds1?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br><span class="line">      # 从数据源，slave</span><br><span class="line">      slave:</span><br><span class="line">        url: jdbc:mysql://127.0.0.1:3306/my-ds2?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">        username: root</span><br><span class="line">        password: envy123</span><br></pre></td></tr></table></figure><p>接着调用<code>DruidDataSourceFactory.createDataSource()</code>方法传入一个map，这个map中就url、username和password这三个属性，并构建为一个DruidDataSource对象，之后我们调用MultipleDSConfiguration对象的<code>dataSource()</code>方法将之前对连接设置的各种参数对此数据源进行属性设置，最后以key为数据源名称，value为对应数据源将其存入到前面所述的Map中。</p><h3 id="切换数据源"><a href="#切换数据源" class="headerlink" title="切换数据源"></a>切换数据源</h3><p>第五步，切换数据源。对于当前数据库操作应当使用哪个数据源有多种实现方式，需要说明的是当前数据库操作对数据源所做的修改不应该影响到其他的数据库操作，因此可以使用ThreadLocal来实现。将当前数据库操作所使用的数据源存入到ThreadLocal中，这样只有当前线程才能获取到该数据，保证了多线程并发情况下数据的安全性。</p><p>首先定义一个用于操作ThreadLocal的类<code>DynamicMultipleDataSourceContextHolder</code>，它主要用于往ThreadLocal中存入、获取和清除数据，注意我们其实是将数据源的名称存入ThreadLocal里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicMultipleDataSourceContextHolder &#123;</span><br><span class="line">    public static final Logger log = LoggerFactory.getLogger(DynamicMultipleDataSourceContextHolder.class);</span><br><span class="line"></span><br><span class="line">    private String dataSourceName;</span><br><span class="line"></span><br><span class="line">    private static final ThreadLocal&lt;String&gt; CURRENT_DATASOURCE_NAME = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void setDataSourceName(String dataSourceName)&#123;</span><br><span class="line">        log.info(&quot;切换到&#123;&#125;数据源&quot;,dataSourceName);</span><br><span class="line">        CURRENT_DATASOURCE_NAME.set(dataSourceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getDataSourceName()&#123;</span><br><span class="line">        return CURRENT_DATASOURCE_NAME.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clearDataSourceName()&#123;</span><br><span class="line">        CURRENT_DATASOURCE_NAME.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，标记数据源。不过现在还有一个问题，就是我们怎么知道当前使用的是哪个数据源呢？因此需要有一个标识来标记当前使用的数据源。最简单的方式就是使用注解来做标记，因此可以定义一个名为<code>MyDataSource</code>的注解，用于标记当前使用的数据源名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 标记使用数据源的名称</span><br><span class="line"> */</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyDataSource &#123;</span><br><span class="line"></span><br><span class="line">    String dataSourceName() default MultipleDataSourceProvider.DEFAULT_DATASOURCE;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;dataSourceName&quot;)</span><br><span class="line">    String value() default MultipleDataSourceProvider.DEFAULT_DATASOURCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们允许这个注解添加在方法、类、接口(包括注解类型) 或enum上，因为只加载方法表示当前方法使用该数据源，而加载类上则表示该类中的所有方法都使用该数据源。还有用户在使用这个注解的时候需要指定一个数据源名称，不指定的话默认为master。</p><p>第七步，解析自定义注解。前面我们自定义了注解来标记所使用的数据源，那么接下来就是通过AOP来解析该自定义注解。新建一个名为<code>MyDataSourceAspect</code>的类，这是一个切面类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Order(1)</span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class MyDataSourceAspect &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;@annotation(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;</span><br><span class="line">    +&quot;||@within(com.melody.dynamicmultipleds.annotation.MyDataSource)&quot;)</span><br><span class="line">    public void myDS()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;myDS()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point)throws Throwable &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature)point.getSignature();</span><br><span class="line">        MyDataSource myDataSource = AnnotationUtils.findAnnotation(signature.getMethod(), MyDataSource.class);</span><br><span class="line">        if(Objects.nonNull(myDataSource))&#123;</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.setDataSourceName(myDataSource.dataSourceName());</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            return point.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 清空数据源</span><br><span class="line">            DynamicMultipleDataSourceContextHolder.clearDataSourceName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）myDS方法定义了切入点，这里拦截所有被前面自定义的MyDataSource注解所修饰的方法或者类、接口(包括注解类型) 或enum；<br>（2）此处使用环绕通知，表示方法执行前后都进行通知。先根据切入点得到所有的方法签名，然后使用<code>AnnotationUtils.findAnnotation()</code>方法传入方法名和注解名，找到包含该注解的方法，然后得到得到该注解。注意该注解可能来自方法上，也可能来自类、接口(包括注解类型) 或enum上，不过方法上的优先级高于类上的优先级。之后判断此注解是否存在，如果存在则将该注解中的数据源名称，设置到当前线程的ThreadLocal中；如果注解不存在则直接进行方法的调用，不用设置数据源，而是使用默认的master数据源。最后当方法调用完成后，我们需要将数据源从ThreadLocal中移除。</p><h3 id="动态使用数据源"><a href="#动态使用数据源" class="headerlink" title="动态使用数据源"></a>动态使用数据源</h3><p>第七步，动态使用数据源。在完成上述操作后，接下来就是如何让Spring知道我们使用的是哪个具体数据源，因此就需要继承<code>AbstractRoutingDataSource</code>抽象类并重写其中的<code>determineTargetDataSource()</code>方法。</p><p>定义一个名为<code>DynamicMultipleDataSource</code>的类，来实现上述操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态使用数据源</span><br><span class="line"> */</span><br><span class="line">public class DynamicMultipleDataSource extends AbstractRoutingDataSource &#123;</span><br><span class="line">    //实际数据源提供者</span><br><span class="line">    YmlMultipleDataSourceProvider ymlMultipleDataSourceProvider;</span><br><span class="line"></span><br><span class="line">    public DynamicMultipleDataSource(YmlMultipleDataSourceProvider provider)&#123;</span><br><span class="line">        this.ymlMultipleDataSourceProvider = provider;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(provider.loadDataSource());</span><br><span class="line">        super.setTargetDataSources(targetDataSources);</span><br><span class="line">        super.setDefaultTargetDataSource(provider.loadDataSource().get(MultipleDataSourceProvider.DEFAULT_DATASOURCE));</span><br><span class="line">        super.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object determineCurrentLookupKey() &#123;</span><br><span class="line">        String dataSourceName = DynamicMultipleDataSourceContextHolder.getDataSourceName();</span><br><span class="line">        return dataSourceName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：<br>（1）重写<code>determineCurrentLookupKey</code>方法逻辑，该方法用于根据数据源的名称来决定调用的数据源，如前面定义的master或者slave数据源名称，得到这个数据源名称后就可以从Map中得到对应的数据源实例。<br>（2）给<code>DynamicMultipleDataSource</code>类提供了一个有参的构造方法，该方法传入一个<code>YmlMultipleDataSourceProvider</code>对象，这个是实际数据源的提供者，即所有的数据源都可以从中获取到。<br>（3）在前面分析<code>AbstractRoutingDataSource</code>抽象类源码的时候，可以看到里面有几个非空的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Object defaultTargetDataSource;</span><br><span class="line">    @Nullable</span><br><span class="line">    private Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>targetDataSources</code>表示所有的数据源，这个我们可以调用<code>YmlMultipleDataSourceProvider.loadDataSource()</code>方法来获取；defaultTargetDataSource则是默认的数据源，这个可以传入master这一数据源名称从前面所说的所有数据源中获取得到，这个master数据源是默认的，也是必须设置的数据源；最后就是调用<code>afterPropertiesSet()</code>来对前面所说的参数进行赋值和校验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">    if (this.targetDataSources == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Property &#x27;targetDataSources&#x27; is required&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.resolvedDataSources = new HashMap(this.targetDataSources.size());</span><br><span class="line">        this.targetDataSources.forEach((key, value) -&gt; &#123;</span><br><span class="line">            Object lookupKey = this.resolveSpecifiedLookupKey(key);</span><br><span class="line">            DataSource dataSource = this.resolveSpecifiedDataSource(value);</span><br><span class="line">            this.resolvedDataSources.put(lookupKey, dataSource);</span><br><span class="line">        &#125;);</span><br><span class="line">        if (this.defaultTargetDataSource != null) &#123;</span><br><span class="line">            this.resolvedDefaultDataSource = this.resolveSpecifiedDataSource(this.defaultTargetDataSource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，注解Bean。接下来我们就是将前面定义的<code>DynamicMultipleDataSource</code>对象注入到Spring容器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DynamicMultipleDataSourceConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private YmlMultipleDataSourceProvider provider;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DynamicMultipleDataSource dynamicMultipleDataSource()&#123;</span><br><span class="line">        return new DynamicMultipleDataSource(provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><p>第九步，创建对应数据表。在数据库my-ds1和my-ds2中依次创建book数据表，并给前者数据库的数据表中插入1条数据，后者插入2条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `book` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `price` int(11) DEFAULT NULL,</span><br><span class="line">  `description` varchar(500) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure><p>第十步，创建mapper层。这里简单起见没有使用XML文件，直接通过注解方式书写SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    @Select(&quot;select count(*) from book&quot;)</span><br><span class="line">    Integer number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十一步，创建service层。这里我们定义了两个方法，分别调用master和slave这两个数据源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;master&quot;)</span><br><span class="line">    public Integer master()&#123;</span><br><span class="line">        return bookMapper.number();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MyDataSource(&quot;slave&quot;)</span><br><span class="line">    public Integer slave()&#123;</span><br><span class="line">        return bookMapper.number();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十二步，创建controller层。这里我们定义了一个方法，用于输出各个数据源中表的记录条数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    public static final Logger log = LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public List&lt;Integer&gt; books()&#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        log.info(&quot;master db numbers is &#123;&#125;&quot;,bookService.master());</span><br><span class="line">        list.add(bookService.master());</span><br><span class="line">        log.info(&quot;slave db numbers is &#123;&#125;&quot;,bookService.slave());</span><br><span class="line">        list.add(bookService.slave());</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十三步，启动项目进行测试。打开浏览器，访问<code>http://localhost:8080/book</code>链接，可以看到它显示一个列表<code>[1,2]</code>，而IDEA控制台输出如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-30704bbfc8225d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这样我们就实现了多数据源的动态切换这一功能，但是美中不足的是无法通过界面来实时控制，其实只需将注解的值作为参数来传入就可以实现，关于一点会在后面的文章中进行介绍和学习。</p><p>【参考文章】 <a href="https://mp.weixin.qq.com/s/g71F3cnLtD4zqJGFCeJckQ">手把手教你玩多数据源动态切换！</a> ，感谢大佬的指导与解惑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在前一篇文章中我们介绍了如何在SpringBoot中整合&lt;code&gt;Jdbc Template&lt;/code&gt;、&lt;code&gt;M</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置多数据源</title>
    <link href="http://envyzhan.asia/2022/03/14/2-springboot-configuring-multiple-data-sources/"/>
    <id>http://envyzhan.asia/2022/03/14/2-springboot-configuring-multiple-data-sources/</id>
    <published>2022-03-14T09:55:30.000Z</published>
    <updated>2022-09-12T07:59:35.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本篇来学习SpringBoot如何配置多数据源，所谓多数据源就是一个Java EE项目中采用了不同数据库实例中的多个库，或者是同一个数据库实例中的多个不同库。一般来说，采用MyCat等分布式数据库中间件是比较好的解决方案，这样可以把数据库读写分离、分库分表、备份等操作交给中间件去做，这样Java代码只需要专注于业务即可。不过这并不意味着无法使用Java代码解决类似的问题，在Spring Famework中就可以配置多个数据源，SpringBoot作为其中的佼佼者，自然也同样支持多数据源的配置，只是配置方式有些变化而已。</p><p>下面就分别介绍使用Jdbc Template、Mybatis和SpringData JPA等不同持久层框架时的多数据源配置。</p><h1 id="Jdbc-Template多数据源"><a href="#Jdbc-Template多数据源" class="headerlink" title="Jdbc Template多数据源"></a>Jdbc Template多数据源</h1><p>Jdbc Template多数据源配置是最简单的一个，因为一个Jdbc Template就对应一个DataSource，开发者只需要提供多个DataSource，再手动配置Jdbc Template即可。具体配置如下：<br><strong>第一步，创建数据库。</strong>使用下面的SQL语句来手动创建两个数据库和表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists jdbcone;</span><br><span class="line">create database jdbcone;</span><br><span class="line">use jdbcone;</span><br><span class="line">drop table if exists book;</span><br><span class="line">create table book(</span><br><span class="line">id int(11) not null auto_increment comment &#x27;id&#x27;,</span><br><span class="line">name varchar(128) default null comment &#x27;名称&#x27;,</span><br><span class="line">author varchar(64) default null comment &#x27;作者&#x27;,</span><br><span class="line">primary key(id)</span><br><span class="line">)ENGINE=INNODB default charset=utf8;</span><br><span class="line">insert into book(id,name,author)values(1,&quot;西游记&quot;,&quot;吴承恩&quot;);</span><br><span class="line"></span><br><span class="line">drop database if exists jdbctwo;</span><br><span class="line">create database jdbctwo;</span><br><span class="line">use jdbctwo;</span><br><span class="line">drop table if exists book;</span><br><span class="line">create table book(</span><br><span class="line">id int(11) not null auto_increment comment &#x27;id&#x27;,</span><br><span class="line">name varchar(128) default null comment &#x27;名称&#x27;,</span><br><span class="line">author varchar(64) default null comment &#x27;作者&#x27;,</span><br><span class="line">primary key(id)</span><br><span class="line">)ENGINE=INNODB default charset=utf8;</span><br><span class="line">insert into book(id,name,author)values(1,&quot;红楼梦&quot;,&quot;曹雪芹&quot;);</span><br></pre></td></tr></table></figure><p>执行该SQL语句后，可以看出数据库中的信息如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa4756dd2e45df83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步，创建SpringBoot项目并添加依赖。</strong>使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为<code>jdbcmorespringboot</code>，然后在pom.xml文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加jdbc依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加数据库驱动依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加数据库连接池依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>请注意这里添加的数据库连接池依赖是<code>druid-spring-boot-starter</code>。<code>druid-spring-boot-starter</code>可以帮助开发者在SpringBoot项目中轻松集成Druid数据库连接池和监控。</p><p><strong>第三步，配置数据库连接。</strong>在<code>application.properties</code>配置文件中配置多个数据源的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 数据源1</span><br><span class="line">spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/jdbcone?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.one.username=root</span><br><span class="line">spring.datasource.one.password=1234</span><br><span class="line"># 数据源2</span><br><span class="line">spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/jdbctwo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.two.username=root</span><br><span class="line">spring.datasource.two.password=1234</span><br></pre></td></tr></table></figure><p>这里配置了两个数据源，主要区别是数据库不同，其他都是一样的。<br><strong>第四步，配置数据源。</strong>新建一个config包，并在里面创建一个<code>DataSourceConfig</code>类，用于配置数据源，这样就可以根据<code>application.properties</code>文件来生成对应的DataSource。里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.one&quot;)</span><br><span class="line">    public DataSource dsOne()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.two&quot;)</span><br><span class="line">    public DataSource dsTwo()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li>请注意DataSource是<code>javax.sql.DataSource</code>包内的；</li><li><code>DataSourceConfig</code>类中提供了两个数据源：dsOne和dsTwo，默认的方法名就是实例名。</li><li><code>@ConfigurationProperties</code>注解表示使用不同前缀的配置文件来创建不同的DataSource实例。</li></ul><p><strong>第五步，配置Jdbc Template。</strong>前面提到过，只要开发者引入了<code>spring-jdbc</code>依赖，那么若开发者没有提供<code>Jdbc Template</code>实例时，SpringBoot默认会提供一个<code>Jdbc Template</code>实例。但是现在是配置多数据源，因此这个<code>Jdbc Template</code>实例就需要开发者自己来提供了。在config包内新建一个<code>JdbcTemplateConfig</code>类，用于返回需要的<code>Jdbc Template</code>实例，相应的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JdbcTemplateConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate jdbcTemplateOne(@Qualifier(&quot;dsOne&quot;)DataSource dataSource)&#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate jdbcTemplateTwo(@Qualifier(&quot;dsTwo&quot;)DataSource dataSource)&#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li><code>JdbcTemplateConfig</code>类中提供了两个<code>JdbcTemplate</code>实例，每一个<code>JdbcTemplate</code>实例都需要提供DataSource，由于Spring容器中有两个DataSource实例，因此需要通过方法名来查找。<code>@Qualifier</code>注解表示查找不同名称的DataSource实例，并注入进来。</li></ul><p><strong>第六步，创建Book实体类和BookController类。</strong>新建pojo包，并在里面创建Book实体类，里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    //getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着新建controller包，并在里面创建<code>BookController</code>类，里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name=&quot;jdbcTemplateOne&quot;)</span><br><span class="line">    JdbcTemplate jdbcTemplateOne;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(value=&quot;jdbcTemplateTwo&quot;)</span><br><span class="line">    JdbcTemplate jdbcTemplateTwo;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        String sql = &quot;select * from book&quot;;</span><br><span class="line">        List&lt;Book&gt; booksOne = jdbcTemplateOne.query(sql,new BeanPropertyRowMapper&lt;&gt;(Book.class));</span><br><span class="line">        List&lt;Book&gt; booksTwo = jdbcTemplateTwo.query(sql,new BeanPropertyRowMapper&lt;&gt;(Book.class));</span><br><span class="line">        System.out.println(&quot;booksOne&gt;&gt;&gt;&gt;&gt;&gt;&quot;+booksOne);</span><br><span class="line">        System.out.println(&quot;booksTwo&gt;&gt;&gt;&gt;&gt;&gt;&quot;+booksTwo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li>注意这里没有定义Repository和Service层，而是直接将<code>JdbcTemplate</code>注入到了Controller中。在Controller中注入两个不同的<code>JdbcTemplate</code>有两种方式：第一种，使用<code>@Resource</code>注解，并指明name属性，然后按照name进行装配，此时会根据实例名查找相应的实例进行注入。第二种，使用<code>@Autowried</code>注解并结合<code>@Qualifier</code>注解，其实这种效果等同于使用<code>@Resource</code>注解。</li></ul><p><strong>第七步，运行项目。</strong>运行项目，在浏览器地址栏中输入<code>http://localhost:8080/test</code>，然后查看控制台的输出信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">booksOne&gt;&gt;&gt;&gt;&gt;&gt;[com.envy.jdbcmorespringboot.pojo.Book@166352ef]</span><br><span class="line">booksTwo&gt;&gt;&gt;&gt;&gt;&gt;[com.envy.jdbcmorespringboot.pojo.Book@11ed31ef]</span><br></pre></td></tr></table></figure><p>不方便查看，那就给Book实体类提供toString方法，之后再来运行一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">booksOne&gt;&gt;&gt;&gt;&gt;&gt;[Book&#123;id=1, name=&#x27;西游记&#x27;, author=&#x27;吴承恩&#x27;&#125;]</span><br><span class="line">booksTwo&gt;&gt;&gt;&gt;&gt;&gt;[Book&#123;id=1, name=&#x27;红楼梦&#x27;, author=&#x27;曹雪芹&#x27;&#125;]</span><br></pre></td></tr></table></figure><p>对比一下数据库中的数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa4756dd2e45df83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到数据已经成功取出来了，这表明JdbcTemplate配置多数据源成功。</p><h1 id="Mybatis多数据源"><a href="#Mybatis多数据源" class="headerlink" title="Mybatis多数据源"></a>Mybatis多数据源</h1><p>JdbcTemplate可以配置多数据源，同样Mybatis也是可以的，只是步骤就稍微复杂一些。</p><p><strong>第一步，创建数据库。</strong>使用下面的SQL语句来手动创建两个数据库和表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists mybatisone;</span><br><span class="line">create database mybatisone;</span><br><span class="line">use mybatisone;</span><br><span class="line">drop table if exists book;</span><br><span class="line">create table book(</span><br><span class="line">id int(11) not null auto_increment comment &#x27;id&#x27;,</span><br><span class="line">name varchar(128) default null comment &#x27;名称&#x27;,</span><br><span class="line">author varchar(64) default null comment &#x27;作者&#x27;,</span><br><span class="line">primary key(id)</span><br><span class="line">)ENGINE=INNODB default charset=utf8;</span><br><span class="line">insert into book(id,name,author)values(1,&quot;西游记&quot;,&quot;吴承恩&quot;);</span><br><span class="line"></span><br><span class="line">drop database if exists mybatistwo;</span><br><span class="line">create database mybatistwo;</span><br><span class="line">use mybatistwo;</span><br><span class="line">drop table if exists book;</span><br><span class="line">create table book(</span><br><span class="line">id int(11) not null auto_increment comment &#x27;id&#x27;,</span><br><span class="line">name varchar(128) default null comment &#x27;名称&#x27;,</span><br><span class="line">author varchar(64) default null comment &#x27;作者&#x27;,</span><br><span class="line">primary key(id)</span><br><span class="line">)ENGINE=INNODB default charset=utf8;</span><br><span class="line">insert into book(id,name,author)values(1,&quot;红楼梦&quot;,&quot;曹雪芹&quot;);</span><br></pre></td></tr></table></figure><p>执行该SQL语句后，可以看出数据库中的信息如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6cb4282527d17954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步，创建SpringBoot项目并添加依赖。</strong>使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为<code>mybatismorespringboot</code>，然后在pom.xml文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加mybatis依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加数据库驱动依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加数据库连接池依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>请注意这里添加的数据库连接池依赖是<code>druid-spring-boot-starter</code>。<code>druid-spring-boot-starter</code>可以帮助开发者在SpringBoot项目中轻松集成Druid数据库连接池和监控。</p><p><strong>第三步，配置数据库连接。</strong>在<code>application.properties</code>配置文件中配置多个数据源的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 数据源1</span><br><span class="line">spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/mybatisone?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.one.username=root</span><br><span class="line">spring.datasource.one.password=1234</span><br><span class="line"># 数据源2</span><br><span class="line">spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/mybatistwo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.two.username=root</span><br><span class="line">spring.datasource.two.password=1234</span><br></pre></td></tr></table></figure><p>这里配置了两个数据源，主要区别是数据库不同，其他都是一样的。</p><p><strong>第四步，配置数据源。</strong>新建一个config包，并在里面创建一个<code>DataSourceConfig</code>类，用于配置数据源，这样就可以根据<code>application.properties</code>文件来生成对应的DataSource。里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.one&quot;)</span><br><span class="line">    public DataSource dsOne()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.two&quot;)</span><br><span class="line">    public DataSource dsTwo()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下上述代码的含义：</p><ul><li>请注意DataSource是<code>javax.sql.DataSource</code>包内的；</li><li><code>DataSourceConfig</code>类中提供了两个数据源：dsOne和dsTwo，默认的方法名就是实例名。</li><li><code>@ConfigurationProperties</code>注解表示使用不同前缀的配置文件来创建不同的DataSource实例。</li></ul><p><strong>第五步，创建Mybatis配置。</strong>在<code>Jdbc Template</code>多数据源的配置中这一步就是用来返回<code>Jdbc Template</code>，但是Mybatis中这一步是用来提供<code>SqlSessionFactory</code>实例和<code>SqlSessionTemplate</code>实例。在config包内新建两个配置类：<code>MybatisConfigOne</code>和<code>MybatisConfigTwo</code>，分别用于返回对应数据源的<code>SqlSessionFactory</code>实例和<code>SqlSessionTemplate</code>实例。这里以<code>MybatisConfigOne</code>配置类中的代码为例进行解释说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(value = &quot;com.envy.mybatismorespringboot.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactoryBean1&quot;)</span><br><span class="line">public class MybatisConfigOne &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;dsOne&quot;)</span><br><span class="line">    DataSource dsOne;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SqlSessionFactory sqlSessionFactoryBean1() throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dsOne);</span><br><span class="line">        return factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    SqlSessionTemplate sqlSessionTemplate1() throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactoryBean1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Configuration</code>注解表明这个类是一个配置类，<code>@MapperScan</code>注解用于指名包的扫描路径，即mapper接口所在的位置。同时使用<code>sqlSessionFactoryRef</code>来指定该位置下的mapper将使用<code>SqlSessionFactory</code>实例。然后定义了一个<code>sqlSessionFactoryBean1</code>方法用于返回一个<code>SqlSessionFactory</code>对象，在这个方法中通过<code>factoryBean.setDataSource</code>方法将DataSource给注入进去，请注意这里创建的<code>SqlSessionFactory</code>实例，其实也就是<code>@MapperScan</code>注解中<code>sqlSessionFactoryRef</code>参数指定的实例。最后提供了一个<code>sqlSessionTemplate1</code>方法，该方法用于返回一个<code>SqlSessionTemplate</code>实例，这是一个线程安全类，主要用来管理Mybatis中的SqlSession操作。</p><p>MybatisConfigTwo中的代码与前面MybatisConfigOne中的差不多，这里仅仅附上代码，就不做多解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(value = &quot;com.envy.mybatismorespringboot.mapper2&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactoryBean2&quot;)</span><br><span class="line">public class MybatisConfigTwo &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;dsTwo&quot;)</span><br><span class="line">    DataSource dsTwo;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactory sqlSessionFactoryBean2() throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dsTwo);</span><br><span class="line">        return factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionTemplate sqlSessionTemplate2() throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactoryBean2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步，创建Book实体类。</strong>新建pojo包，并在里面创建Book实体类，里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    //getter、setter和toString方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步，创建数据库访问层。</strong>新建两个mapper包：mapper1和mapper2，并在里面新建对应的mapper接口和xml文件。其中mapper1包内的BookMapper.java文件中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    List&lt;Book&gt; getAllBooks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper1包内的BookMapper.xml文件中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.envy.mybatismorespringboot.mapper1.BookMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;getAllBooks&quot; resultType=&quot;com.envy.mybatismorespringboot.pojo.Book&quot;&gt;</span><br><span class="line">        select * from book</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>便于简化操作和演示，此处仅仅是配置了一个方法。mapper2包内的BookMapper2.java文件和BookMapper2.xml文件中的代码与上述非常相似，这里就不粘贴了，仅仅粘贴项目的目录结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-024a7f4ef8ab7570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第八步，配置pom.xml文件，这一步很重要。</strong>在Maven工程中，XML配置文件建议写在resources目录下，但是很明显上述的<code>BookMapper.xml</code>文件写在了mapper包内，且不在resources目录下，此时运行项目肯定会抛出mapper文件找不到的异常，因为Maven运行时会忽略包内的xml文件，因此需要在pom.xml文件中重新指明资源文件的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &lt;build&gt;</span><br><span class="line">     &lt;!--使用mybatis时需要手动指明xml的位置--&gt;</span><br><span class="line">     &lt;resources&gt;</span><br><span class="line">         &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">             &lt;includes&gt;</span><br><span class="line">                 &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">             &lt;/includes&gt;</span><br><span class="line">         &lt;/resource&gt;</span><br><span class="line">         &lt;resource&gt;</span><br><span class="line">             &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">         &lt;/resource&gt;</span><br><span class="line">     &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p><strong>第九步，创建Controller层。</strong>在controller包内新建<code>BookController</code>类，这里同样没有service层，因此是直接将Mapper注入到Controller中。里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    BookMapper2 bookMapper2;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        List&lt;Book&gt; bookList1 = bookMapper.getAllBooks();</span><br><span class="line">        List&lt;Book&gt; bookList2 = bookMapper2.getAllBooks();</span><br><span class="line">        System.out.println(&quot;【bookList1】&gt;&gt;&gt;&gt;&gt;&gt;&quot;+bookList1);</span><br><span class="line">        System.out.println(&quot;【bookList2】&gt;&gt;&gt;&gt;&gt;&gt;&quot;+bookList2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第十步，运行项目。</strong>运行项目，在浏览器地址栏中输入<code>http://localhost:8080/test</code>，然后查看控制台的输出信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【bookList1】&gt;&gt;&gt;&gt;&gt;&gt;[Book&#123;id=1, name=&#x27;西游记&#x27;, author=&#x27;吴承恩&#x27;&#125;]</span><br><span class="line">【bookList2】&gt;&gt;&gt;&gt;&gt;&gt;[Book&#123;id=1, name=&#x27;红楼梦&#x27;, author=&#x27;曹雪芹&#x27;&#125;]</span><br></pre></td></tr></table></figure><p>对比一下数据库中的数据：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-6cb4282527d17954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到数据已经成功取出来了，这表明Mybatis配置多数据源成功。</p><h1 id="Spring-Data-JPA多数据源"><a href="#Spring-Data-JPA多数据源" class="headerlink" title="Spring Data JPA多数据源"></a>Spring Data JPA多数据源</h1><p>JPA和Mybatis配置多数据源非常类似，只是JPA配置时主要提供<code>LocalContainerEntityManagerFactoryBean</code>以及事务管理器，具体的配置如下：</p><p><strong>第一步，创建数据库，不创建表。</strong>使用下面的SQL语句来手动创建两个数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists jpaone;</span><br><span class="line">create database jpaone;</span><br><span class="line"></span><br><span class="line">drop database if exists jpatwo;</span><br><span class="line">create database jpatwo;</span><br></pre></td></tr></table></figure><p>执行该SQL语句后，可以看出数据库中已经有这两个数据库了。</p><p><strong>第二步，创建SpringBoot项目并添加依赖。</strong>使用<code>spring Initializr</code>构建工具构建一个SpringBoot的Web应用，名称为<code>jpamorespringboot</code>，然后在pom.xml文件中添加如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--添加数据库驱动依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--添加数据库连接池依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--添加Spring Data JPA依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">&lt;!--添加lombok依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>请注意这里添加的数据库连接池依赖是<code>druid-spring-boot-starter</code>。<code>druid-spring-boot-starter</code>可以帮助开发者在SpringBoot项目中轻松集成Druid数据库连接池和监控。</p><p><strong>第三步，配置数据库连接。</strong>在<code>application.properties</code>配置文件中配置多个数据源及JPA的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 数据源1</span><br><span class="line">spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.one.url=jdbc:mysql://127.0.0.1:3306/jpaone?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.one.username=root</span><br><span class="line">spring.datasource.one.password=1234</span><br><span class="line"></span><br><span class="line"># 数据源2</span><br><span class="line">spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.two.url=jdbc:mysql://127.0.0.1:3306/jpatwo?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.two.username=root</span><br><span class="line">spring.datasource.two.password=1234</span><br><span class="line"></span><br><span class="line"># JPA相关配置</span><br><span class="line">spring.jpa.properties.hibernate.dialect.MySQL57InnoDBDialect</span><br><span class="line">spring.jpa.properties.database=mysql</span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">spring.jpa.properties.show-sql=true</span><br></pre></td></tr></table></figure><p>这里配置了两个数据源，主要区别是数据库不同，其他都是一样的。不过需要注意的是JPA多数据源配置与单独的JPA配置有所不同，因为后续的配置要从<code>JpaProperties</code>中的<code>getProperties</code>方法中获取所有JPA相关的配置，因此这里的属性前缀都是<code>spring.jpa.properties</code>。</p><p><strong>第四步，配置数据源。</strong>新建一个config包，并在里面创建一个<code>DataSourceConfig</code>类，用于配置数据源，这样就可以根据<code>application.properties</code>文件来生成对应的DataSource。里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.one&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource dsOne()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(&quot;spring.datasource.two&quot;)</span><br><span class="line">    public DataSource dsTwo()&#123;</span><br><span class="line">        return DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道你是否注意到，此处在dsOne方法上添加了<code>@Primary</code>注解。默认的<code>@Autowired</code>注解是依据类型进行注入，但是此处存在多个类型相同的对象，因此必须使用<code>@Primary</code>注解来指定优先注入哪个。</p><p><strong>第五步，创建Book实体类。</strong>新建pojo包，并在里面创建Book实体类，里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Entity(name = &quot;t_user&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    private String gender;</span><br><span class="line">    </span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样后续会根据实体类在数据库中创建t_user表，表中的id字段自增长。</p><p><strong>第六步，创建JPA配置。</strong>接下来是核心配置，根据两个配置好的数据源来创建两个不同的JPA配置。在config包内，新建两个JPA的配置类：<code>JpaOneConfig</code>和<code>JpaTwoConfig</code>，用于返回<code>LocalContainerEntityManagerFactoryBean</code>及事务管理器对象。下面以<code>JpaOneConfig</code>配置类中的代码为例进行解释说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@EnableJpaRepositories(basePackages = &quot;com.envy.jpamorespringboot.dao1&quot;,entityManagerFactoryRef = &quot;entityManagerFactoryBeanOne&quot;,transactionManagerRef = &quot;platformTransactionManagerOne&quot;)</span><br><span class="line">public class JpaOneConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name = &quot;dsOne&quot;)</span><br><span class="line">    DataSource dsOne;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    LocalContainerEntityManagerFactoryBean entityManagerFactoryBeanOne(EntityManagerFactoryBuilder builder)&#123;</span><br><span class="line">        return builder.dataSource(dsOne)</span><br><span class="line">                .properties(jpaProperties.getProperties())</span><br><span class="line">                .packages(&quot;com.envy.jpamorespringboot.pojo&quot;)</span><br><span class="line">                .persistenceUnit(&quot;pu1&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    PlatformTransactionManager platformTransactionManagerOne(EntityManagerFactoryBuilder builder)&#123;</span><br><span class="line">        LocalContainerEntityManagerFactoryBean factoryOne = entityManagerFactoryBeanOne(builder);</span><br><span class="line">        return new JpaTransactionManager(factoryOne.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上述代码的含义：</p><ul><li>使用<code>@Configuration</code>注解来标识这是一个配置类，接着使用<code>@EnableJpaRepositories</code>注解来进行JPA的配置，该注解中主要配置三个属性：<code>basePackages</code>、<code>entityManagerFactoryRef</code>和<code>transactionManagerRef</code>。其中<code>basePackages</code>属性用于指定Repository的所在位置，<code>entityManagerFactoryRef</code>属性用于指定实体类管理工厂Bean的名称，<code>transactionManagerRef</code>属性则用来指定事务管理器的引用名称，这里的引用名称就是JpaOneConfig类中注册的Bean的名称（默认的Bean名称为方法名）。</li><li>然后创建<code>entityManagerFactoryBeanOne</code>方法，用于生成一个<code>LocalContainerEntityManagerFactoryBean</code>对象，而该对象用来提供<code>EntityManager</code>实例，在该类的创建过程中，首先配置数据源，然后设置JPA相关配置(JpaProperties由系统自动加载)，再设置实体类所在的位置，最后配置持久化单元名，若项目中只有一个<code>EntityManagerFactory</code>，则<code>persistenceUnit</code>可以省略掉，若有多个，则必须明确指定持久化单元名。</li><li>由于项目中会提供两个<code>LocalContainerEntityManagerFactoryBean</code>实例，故需要在<code>entityManagerFactoryBeanOne</code>方法上添加<code>@Primary</code>注释，用于告诉Spring容器时优先使用该实例。</li><li><code>platformTransactionManagerOne</code>方法用于返回一个<code>PlatformTransactionManager</code>对象，实际上返回的是一个<code>JpaTransactionManager</code>对象，它提供对单个<code>EntityManagerFactory</code>的事务支持，专门用于解决JPA中的事务管理。</li></ul><p>上面是第一个JPA的配置信息，第二个JPA的配置与之相似，故这里仅仅只粘贴代码(需要注意的是第二个JPA类中的<code>entityManagerFactoryBeanOne</code>方法上不能添加<code>@Primary</code>注解)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@EnableJpaRepositories(basePackages = &quot;com.envy.jpamorespringboot.dao2&quot;,entityManagerFactoryRef = &quot;entityManagerFactoryBeanTwo&quot;,transactionManagerRef = &quot;platformTransactionManagerTwo&quot;)</span><br><span class="line">public class JpaTwoConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Resource(name = &quot;dsTwo&quot;)</span><br><span class="line">    DataSource dsTwo;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JpaProperties jpaProperties;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    LocalContainerEntityManagerFactoryBean entityManagerFactoryBeanTwo(EntityManagerFactoryBuilder builder)&#123;</span><br><span class="line">        return builder.dataSource(dsTwo)</span><br><span class="line">                .properties(jpaProperties.getProperties())</span><br><span class="line">                .packages(&quot;com.envy.jpamorespringboot.pojo&quot;)</span><br><span class="line">                .persistenceUnit(&quot;pu2&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    PlatformTransactionManager platformTransactionManagerTwo(EntityManagerFactoryBuilder builder)&#123;</span><br><span class="line">        LocalContainerEntityManagerFactoryBean factoryOne = entityManagerFactoryBeanTwo(builder);</span><br><span class="line">        return new JpaTransactionManager(factoryOne.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第七步，创建Repository。</strong>新建dao1和dao2包，并分别在其中新建UserDao和UserDao2接口文件。其中<code>UserDao.java</code>中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.envy.jpamorespringboot.dao1;</span><br><span class="line"></span><br><span class="line">import com.envy.jpamorespringboot.pojo.User;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">public interface UserDao extends JpaRepository&lt;User,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>UserDao2.java</code>中的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.envy.jpamorespringboot.dao2;</span><br><span class="line"></span><br><span class="line">import com.envy.jpamorespringboot.pojo.User;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">public interface UserDao2 extends JpaRepository&lt;User,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>UserDao</code>和<code>UserDao2</code>分别用于操作不同的数据源。这里粘贴一下此时的目录结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fe73c43a4ae9f92b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第八步，创建Controller。</strong>便于演示和简便，这里就省略Service层，将UserDao直接注入Controller层。新建controller包，并在里面新建<code>UserController.java</code>文件，里面的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao2 userDao2;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        User user1 = new User();</span><br><span class="line">        user1.setName(&quot;小明&quot;);</span><br><span class="line">        user1.setAge(20);</span><br><span class="line">        user1.setGender(&quot;男&quot;);</span><br><span class="line">        userDao.save(user1);</span><br><span class="line"></span><br><span class="line">        User user2 = new User();</span><br><span class="line">        user2.setName(&quot;小美&quot;);</span><br><span class="line">        user2.setAge(18);</span><br><span class="line">        user2.setGender(&quot;女&quot;);</span><br><span class="line">        userDao2.save(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第九步，运行项目。</strong>运行项目，在浏览器地址栏中输入<code>http://localhost:8080/test</code>，然后查看数据库是否已经有了这两条记录：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-26602896800eb293.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇学习了如何在SpringBoot中整合<code>Jdbc Template</code>、<code>Mybatis</code>和<code>Spring Data JPA</code>的多数据源配置，其中<code>Jdbc Template</code>用的不是很多，基本上不会使用了；而<code>Mybatis</code>由于其灵活性较好，能进行SQL优化，因此如果开发者需要考虑SQL的性能，建议选用这个。<code>Spring Data JPA</code>使用起来较为方便，几乎不需要书写SQL语句，特别适合快速开发一个RESTful风格的应用，这一点在实际工作中深有体会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;本篇来学习SpringBoot如何配置多数据源，所谓多数据源就是一个Java EE项目中采用了不同数据库实例中的多个库，或者</summary>
      
    
    
    
    <category term="springboot" scheme="http://envyzhan.asia/categories/springboot/"/>
    
    
    <category term="springboot" scheme="http://envyzhan.asia/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Druid数据库连接池使用体验</title>
    <link href="http://envyzhan.asia/2022/03/11/1-druid-database-connection-pool-experience/"/>
    <id>http://envyzhan.asia/2022/03/11/1-druid-database-connection-pool-experience/</id>
    <published>2022-03-11T09:55:30.000Z</published>
    <updated>2022-09-11T09:59:13.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在实际工作中我们我们使用较多的则是Spring默认的HikariDataSource数据库连接池，但是它无法提供可视化监控SQL这一能力，而这在很多场景下往往又是我们需要的功能，因此今天来学习阿里开源的一款优秀的数据库连接池—Druid。Druid能够提供强大的SQL监控和功能扩展能力，允许开发者根据需要进行二次开发。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>首先我们使用传统的方式，快速搭建一个具备查询用户信息的简单项目。</p><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>第一步，新建一个名为<code>druid-sql</code>的SpringBoot项目，选择<code>spring web</code>、<code>mybatis framework</code>和<code>mysql driver</code>依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-927a0caa070c04b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>第二步，修改<code>application.properties</code>配置文件信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></table></figure><p>第三步，创建<code>book</code>这一数据表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USE druid_sql;</span><br><span class="line">DROP TABLE IF EXISTS book;</span><br><span class="line">CREATE TABLE book ( </span><br><span class="line">id INT auto_increment PRIMARY KEY, </span><br><span class="line">name VARCHAR ( 255 ), </span><br><span class="line">price INT, </span><br><span class="line">description VARCHAR ( 500 )</span><br><span class="line">) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;</span><br></pre></td></tr></table></figure><p>第四步，创建Book实体类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer price;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    //省略getter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，创建BookMapper的接口文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    List&lt;Book&gt; selectBookByName(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步，创建BookMapper的XML文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.melody.druidsql.mapper.BookMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectBookByName&quot; resultType=&quot;com.melody.druidsql.entity.Book&quot;&gt;</span><br><span class="line">        select * from book where name=#&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>第七步，新建BookService类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookMapper bookMapper;</span><br><span class="line">    </span><br><span class="line">    public List&lt;Book&gt; selectBookByName(String name)&#123;</span><br><span class="line">        return bookMapper.selectBookByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第八步，新建BookController类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public List&lt;Book&gt; selectBookByName(String name)&#123;</span><br><span class="line">        return bookService.selectBookByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第九步，添加数据进行测试，这些都是比较常规的操作了。通过查看源码，可以发现它使用的是HikariDataSource数据库连接池：</p><h3 id="接入Druid"><a href="#接入Druid" class="headerlink" title="接入Druid"></a>接入Druid</h3><p>第一步，在POM文件中新增如下依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>第二步，修改<code>application.properties</code>配置文件信息。首先配置WebStatFilter，它用于采集<code>web-jdbc</code>所关联的监控数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Druid相关配置</span><br><span class="line"># 开启WebStatFilter</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line"># 配置拦截规则，这里设置所有</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line"># 排除一些不会涉及到 SQL 查询的 URL</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line"># 开启 session 统计功能</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line"># 缺省 sessionStatMaxCount 值为 1000 ，开发者可按需进行配置</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=1000</span><br></pre></td></tr></table></figure><p>其次，配置StatViewServlet相关配置项，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 配置StatViewServlet</span><br><span class="line"># 启用内置的监控页面</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line"># 内置监控页面的 URL 地址</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line"># 开启 Reset All 功能，注意值设置为false，按钮会显示，但是点击没有反应</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line"># 设置监控页面登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=melody</span><br><span class="line"># 设置监控页面登录密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=melody</span><br><span class="line"># 设置白名单（如果allow没有配置或者为空，表示允许所有访问）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=127.0.0.1</span><br><span class="line"># 黑名单（注意 deny 的优先级高于 allow，即只有在 deny 列表中，那么即使在 allow 列表中，也会被拒绝）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.deny=</span><br></pre></td></tr></table></figure><p>最后设置过滤器， stat 过滤器用于监控 SQL 执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 过滤器设置</span><br><span class="line">spring.datasource.druid.filters=stat</span><br></pre></td></tr></table></figure><p>第三步，启动项目进行测试。首先访问<code>http://localhost:8080/druid/login.html</code>链接，页面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-03744985a23bf3db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后输入刚才设置的melody/melody信息进行登录，登录界面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e4a2e4f739b4df75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到Druid自带了很多功能，如：数据源、SQL监控、SQL防火墙、Web应用、URI监控、Session监控、Spring监控和JSON API等。</p><p>先不管这些功能，我们先尝试访问一下如下链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/book?name=java</span><br></pre></td></tr></table></figure><p>可以看到页面已经可以显示数据了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-5fc1a6112dd47f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再看一下SQL监控，这里也将我们刚才调用接口执行SQL的执行过程给记录了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>以上就是Druid的初体验了，接下来我们来分析Druid首页导航栏上的各个模块。</p><h1 id="Druid连接池介绍"><a href="#Druid连接池介绍" class="headerlink" title="Druid连接池介绍"></a>Druid连接池介绍</h1><h3 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h3><p>Druid连接池是阿里巴巴开源的数据库连接池项目。Druid连接池为监控而生，内置强大的监控功能，监控特性不影响性能。功能强大，能防SQL注入，内置Loging能诊断Hack应用行为。</p><h3 id="竞品对比"><a href="#竞品对比" class="headerlink" title="竞品对比"></a>竞品对比</h3><p><img src="https://upload-images.jianshu.io/upload_images/8964398-28d99044bf93c0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看出，Druid连接池在性能、监控、诊断、安全、扩展性这些方面远远超出竞品。</p><p>对于连接池来说，连接池本身的性能消耗在整个调用链路中通常占比不大，连接池的性能关键点是，连接是否LRU的方式重用，是否支持PSCache<code>（PreparedStatementCache）</code>才是性能的关键点。当然DruidDataSource在没有使用Filter没有打开testOnBorrow的情况下，裸测也是极好。</p><h3 id="为监控而生"><a href="#为监控而生" class="headerlink" title="为监控而生"></a>为监控而生</h3><p>Druid连接池最初就是为监控系统采集jdbc运行信息而生的，它内置了StatFilter功能，能采集非常完备的连接池执行信息。</p><p>Druid连接池内置了能和Spring/Servlet关联监控的实现，使得监控Web应用特别方便。</p><p>Druid连接池内置了一个监控页面，提供了非常完备的监控信息，可以快速诊断系统的瓶颈。</p><h5 id="监控信息采集的StatFilter"><a href="#监控信息采集的StatFilter" class="headerlink" title="监控信息采集的StatFilter"></a>监控信息采集的StatFilter</h5><p>Druid连接池的监控信息主要是通过StatFilter采集的，采集的信息非常全面，包括SQL执行、并发、慢查、执行时间区间分布等。</p><h5 id="监控不影响性能"><a href="#监控不影响性能" class="headerlink" title="监控不影响性能"></a>监控不影响性能</h5><p>Druid增加StatFilter之后，能采集大量统计信息，同时对性能基本没有影响。StatFilter对CPU和内存的消耗都极小，对系统的影响可以忽略不计。监控不影响性能是Druid连接池的重要特性。</p><h5 id="SQL参数化合并监控"><a href="#SQL参数化合并监控" class="headerlink" title="SQL参数化合并监控"></a>SQL参数化合并监控</h5><p>实际业务中，如果SQL不是走<code>PreparedStatement</code>，SQL没有参数化，这时SQL需要参数化合并监控才能真实反映业务情况。如下SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id = 1</span><br><span class="line">select * from t where id = 2</span><br><span class="line">select * from t where id = 3</span><br></pre></td></tr></table></figure><p>参数化后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where id = ?</span><br></pre></td></tr></table></figure><p>参数化合并监控是基于<code>SQL Parser</code>语法解析实现的，是Druid连接池独一无二的功能。</p><h5 id="执行次数、返回行数、更新行数和并发监控"><a href="#执行次数、返回行数、更新行数和并发监控" class="headerlink" title="执行次数、返回行数、更新行数和并发监控"></a>执行次数、返回行数、更新行数和并发监控</h5><p>StatFilter能采集到每个SQL的执行次数、返回行数总和、更新行数总和、执行中次数和和最大并发。并发监控的统计是在SQL执行开始对计数器加一，结束后对计数器减一实现的。可以采集到每个SQL的当前并发和采集期间的最大并发。</p><h5 id="慢查监控"><a href="#慢查监控" class="headerlink" title="慢查监控"></a>慢查监控</h5><p>缺省执行耗时超过3秒的被认为是慢查，统计项中有包括每个SQL的最后发生的慢查的耗时和发生时的参数。</p><h5 id="Exception监控"><a href="#Exception监控" class="headerlink" title="Exception监控"></a>Exception监控</h5><p>如果SQL执行时抛出了Exception，SQL统计项上会Exception有最后的发生时间、堆栈和Message，根据这些信息可以很容易定位错误原因。</p><h5 id="区间分布"><a href="#区间分布" class="headerlink" title="区间分布"></a>区间分布</h5><p>SQL监控项上，执行时间、读取行数、更新行数都有区间分布，将耗时分布成8个区间：</p><ul><li>0 - 1 耗时0到1毫秒的次数</li><li>1 - 10 耗时1到10毫秒的次数</li><li>10 - 100 耗时10到100毫秒的次数</li><li>100 - 1,000 耗时100到1000毫秒的次数</li><li>1,000 - 10,000 耗时1到10秒的次数</li><li>10,000 - 100,000 耗时10到100秒的次数</li><li>100,000 - 1,000,000 耗时100到1000秒的次数</li><li>1,000,000 - 耗时1000秒以上的次数</li></ul><p>记录耗时区间的发生次数，通过区间分布，可以很方便看出SQL运行的极好、普通和极差的分布。 耗时区分分布提供了“执行+RS时分布”，是将执行时间+ResultSet持有时间合并监控，这个能方便诊断返回行数过多的查询。</p><h3 id="诊断支持"><a href="#诊断支持" class="headerlink" title="诊断支持"></a>诊断支持</h3><p>Druid连接池内置了LogFilter，将Connection/Statement/ResultSet相关操作的日志输出，可以用于诊断系统问题，也可以用于Hack一个不熟悉的系统。</p><p>LogFilter可以输出连接申请/释放，事务提交回滚，Statement的<code>Create/Prepare/Execute/Close</code>，ResultSet的<code>Open/Next/Close</code>，通过LogFilter可以详细诊断一个系统的Jdbc行为。同时LogFilter有Log4j、Log4j2、Slf4j、CommsLog等实现。</p><h3 id="防SQL注入"><a href="#防SQL注入" class="headerlink" title="防SQL注入"></a>防SQL注入</h3><p>SQL注入攻击是黑客对数据库进行攻击的常用手段，Druid连接池内置了WallFilter提供防SQL注入功能，在不影响性能的同时防御SQL注入攻击。</p><h5 id="基于语意的防SQL注入"><a href="#基于语意的防SQL注入" class="headerlink" title="基于语意的防SQL注入"></a>基于语意的防SQL注入</h5><p>Druid连接池内置了一个功能完备的SQL Parser，能够完整解析mysql、sql server、oracle、postgresql的语法，通过语意分析能够精确识别SQL注入攻击。</p><h5 id="极低的漏报率和误报率"><a href="#极低的漏报率和误报率" class="headerlink" title="极低的漏报率和误报率"></a>极低的漏报率和误报率</h5><p>基于SQL语意分析，大量应用和反馈，使得Druid的防SQL注入拥有极低的漏报率和误报率。</p><h5 id="防注入对性能影响极小"><a href="#防注入对性能影响极小" class="headerlink" title="防注入对性能影响极小"></a>防注入对性能影响极小</h5><p>内置参数化后的Cache、高性能手写的Parser，使得打开防SQL注入对应用的性能基本不受影响。</p><p>更多Druid的详细介绍，可以参考 <a href="https://github.com/alibaba/druid/wiki/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D">这里</a> ，了解更多。</p><h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>Druid内置提供了一个StatViewServlet用于展示Druid的统计信息，这个StatViewServlet的用途包括：（1）提供监控信息展示的html页面；（2）提供监控信息的JSON API。</p><p>首先我们查看一下这个StatViewServlet类的信息，可以发现它是一个静态内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class StatViewServlet &#123;</span><br><span class="line">    private boolean enabled;</span><br><span class="line">    private String urlPattern;</span><br><span class="line">    private String allow;</span><br><span class="line">    private String deny;</span><br><span class="line">    private String loginUsername;</span><br><span class="line">    private String loginPassword;</span><br><span class="line">    private String resetEnable;</span><br><span class="line"></span><br><span class="line">    //setter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果我们要配置StatViewServlet，启用内置的监控页面，首先需要在<code>application.properties</code>文件中新增如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br></pre></td></tr></table></figure><p>其次设置监控页面的访问URL地址，可通过urlPattern属性设置，如下设置时的内置监控页面的首页是<code>/druid/index.html</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br></pre></td></tr></table></figure><p>开发者可以通过loginUsername和loginPassword属性来设置登录信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.login-username=melody</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=melody</span><br></pre></td></tr></table></figure><p>由于StatViewSerlvet展示出来的监控信息是系统运行的内部情况，因此数据比较敏感，如果开发者想要实现访问控制，可以配置allow和deny这两个属性。</p><p>allow用于设置白名单（如果allow没有配置或者为空，表示允许所有访问），而deny用于设置黑名单，注意 deny 的优先级高于 allow，如果在deny列表中，就算在allow列表中，也会被拒绝：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.allow=127.0.0.1</span><br><span class="line">spring.datasource.druid.stat-view-servlet.deny=</span><br></pre></td></tr></table></figure><p>在StatViewSerlvet输出的html页面中，有一个功能是Reset All，即执行这个操作后，会清零所有计数器，并重新计数。开发者你可通过resetEnable属性来实现该功能的启用与否：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br></pre></td></tr></table></figure><p>如果开发者想要配置Web关联监控，那么可以查看后面关于 <strong>URI监控</strong> 模块内容；配置Spring关联监控，那么可以查看后面关于 <strong>Web应用</strong> 模块内容。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE">这里</a> ，了解更多。</p><h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><p>数据源详细记录了当前项目所使用的数据源信息，如登录用户名、地址、数据库类型、驱动类型、filter类名、连接设置、事务设置等内容：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-464c8a4260f09661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><code>DruidDataSource</code>是数据源属性配置类，查看一下该类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource, MBeanRegistration &#123;</span><br><span class="line">    private static final Log LOG = LogFactory.getLog(DruidDataSource.class);</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private volatile long recycleErrorCount;</span><br><span class="line">    private long connectCount;</span><br><span class="line">    private long closeCount;</span><br><span class="line">    private volatile long connectErrorCount;</span><br><span class="line">    private long recycleCount;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该类继承自DruidAbstractDataSource类，这个类是数据源属性的抽象类，之所以将数据源定义为抽象类是为了让其他子类可以在此基础上进行扩展，因为DruidDataSource大部分属性都是参考DBCP的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-ac78acbe6c121104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>一般来说，开发者只需配置url（并不是此处看到的jdbcUrl），username、password和max-active这四项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.druid.username=root</span><br><span class="line">spring.datasource.druid.password=root</span><br><span class="line">spring.datasource.druid.max-active=20</span><br></pre></td></tr></table></figure><p>当然了，Druid也会根据URL来自动识别驱动类名称，无须开发者手动添加。举个例子，如果使用的是常见数据库如MySQL，可以使用旧的连接信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///druid_sql?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br></pre></td></tr></table></figure><p>不需要在加一层druid前缀，这一点还是很方便的。如果连接的数据库是非常见数据库，那么必须添加driverClassName属性。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE">这里</a> ，了解更多。</p><h1 id="SQL监控"><a href="#SQL监控" class="headerlink" title="SQL监控"></a>SQL监控</h1><p>请注意，要想使用SQL监控，首先必须设置对应的过滤器，这些过滤器都需要实现<code>com.alibaba.druid.filter</code>接口，可以看到它也有很多子类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e62cb3e239f1e317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>由于此处是监控SQL，因此需要配置StatFilter，即在<code>application.properties</code>文件中新增如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=stat</span><br></pre></td></tr></table></figure><p>如果你想使用后续的SQL防火墙，就需要使用wall这一配置项，自然想使用log4j2，就配置这一项，这些在数据源模块的Filter类名中就可以得到体现：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8116c204dac6432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>SQL监控模块主要用于监控SQL，并展示SQL的执行数、执行时间、最慢、事务执行、错误数、更新行数、读取行数、执行中、最大并发、执行时间分布、执行+RS时分布、读取行分布和更新行分布等信息，其实这就是让开发者对整个项目中执行的SQL都有一个全局的了解：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-310a138006ffaa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>StatFilter的别名是stat，这个别名映射配置信息保存在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>文件中。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilte">这里</a> ，了解更多。</p><h1 id="内置Filter的别名"><a href="#内置Filter的别名" class="headerlink" title="内置Filter的别名"></a>内置Filter的别名</h1><p>在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>文件中配置了如下Filter的别名，因为我们是通过对应Filter的类名来设置对应的Filter别名，多个Filter可以组合使用：</p><table><thead><tr><th>Filter的类名</th><th>Filter别名</th></tr></thead><tbody><tr><td>default</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>stat</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>mergeStat</td><td>com.alibaba.druid.filter.stat.MergeStatFilter</td></tr><tr><td>counter</td><td>com.alibaba.druid.filter.stat.StatFilter</td></tr><tr><td>encoding</td><td>com.alibaba.druid.filter.encoding.EncodingConvertFilter</td></tr><tr><td>log4j</td><td>com.alibaba.druid.filter.logging.Log4jFilter</td></tr><tr><td>log4j2</td><td>com.alibaba.druid.filter.logging.Log4j2Filter</td></tr><tr><td>slf4j</td><td>com.alibaba.druid.filter.logging.Slf4jLogFilter</td></tr><tr><td>commonlogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr><tr><td>commonLogging</td><td>com.alibaba.druid.filter.logging.CommonsLogFilter</td></tr><tr><td>wall</td><td>com.alibaba.druid.wall.WallFilter</td></tr><tr><td>config</td><td>com.alibaba.druid.filter.config.ConfigFilter</td></tr><tr><td>haRandomValidator</td><td>com.alibaba.druid.pool.ha.selector.RandomDataSourceValidateFilter</td></tr></tbody></table><h1 id="SQL防火墙"><a href="#SQL防火墙" class="headerlink" title="SQL防火墙"></a>SQL防火墙</h1><p>WallFilter用于实现SQL防火墙，首先我们查看一下这个WallFilter类的信息，可以发现它是一个类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WallFilter extends FilterAdapter implements WallFilterMBean &#123;</span><br><span class="line">    private static final Log LOG = LogFactory.getLog(WallFilter.class);</span><br><span class="line">    private boolean inited = false;</span><br><span class="line">    private WallProvider provider;</span><br><span class="line">    private String dbTypeName;</span><br><span class="line">    private WallConfig config;</span><br><span class="line">    private volatile boolean logViolation = false;</span><br><span class="line">    private volatile boolean throwException = true;</span><br><span class="line">    public static final String ATTR_SQL_STAT = &quot;wall.sqlStat&quot;;</span><br><span class="line">    public static final String ATTR_UPDATE_CHECK_ITEMS = &quot;wall.updateCheckItems&quot;;</span><br><span class="line">    private static final ThreadLocal&lt;List&lt;Integer&gt;&gt; tenantColumnsLocal = new ThreadLocal();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开发者想要启用这个WallFilter，那么需要在<code>application.properties</code>配置文件中通过Filter类名来进行设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=wall</span><br></pre></td></tr></table></figure><p>当然了，还可以结合其他Filter一起使用，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=wall,stat</span><br></pre></td></tr></table></figure><p>但是这样设置会造成拦截检测的时间不在StatFilter统计的SQL执行时间内，所以如果希望拦截检测的时间在StatFilter统计的SQL执行时间内，需要调整两者的执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.filters=stat,wall</span><br></pre></td></tr></table></figure><p>SQL防火墙主要分为5大部分：防御统计、表访问统计、函数调用统计、SQL防御统计的黑白名单。</p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter">这里</a> ，了解更多。</p><h1 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h1><p>它可以展示当前应用中的相关信息，如ContextPath、最大并发、请求次数、Jdbc执行数、读取行数和更新行数等一系列信息。</p><h1 id="URI监控"><a href="#URI监控" class="headerlink" title="URI监控"></a>URI监控</h1><p>WebStatFilter用于采集<code>web-jdbc</code>关联监控的数据，首先我们查看一下这个WebStatFilter类的信息，可以发现它是一个静态内部类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static class WebStatFilter &#123;</span><br><span class="line">    private boolean enabled;</span><br><span class="line">    private String urlPattern;</span><br><span class="line">    private String exclusions;</span><br><span class="line">    private String sessionStatMaxCount;</span><br><span class="line">    private String sessionStatEnable;</span><br><span class="line">    private String principalSessionName;</span><br><span class="line">    private String principalCookieName;</span><br><span class="line">    private String profileEnable;</span><br><span class="line"></span><br><span class="line">    //setter和setter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们首先需要在<code>application.properties</code>配置文件中开启WebStatFilter：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br></pre></td></tr></table></figure><p>如果开发者想要针对部分URL进行拦截，那么可以使用如下配置，此处拦截所有，即所有的API访问都会被记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br></pre></td></tr></table></figure><p>当然了有些不会涉及到 SQL 查询的API，我们是希望可以排除掉，那么可以配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br></pre></td></tr></table></figure><p>当我们需要开启session统计功能时，可以使用如下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br></pre></td></tr></table></figure><p>想要设置sessionStatMaxCount的值时，可以使用如下配置项，该值缺省为1000：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=1000</span><br></pre></td></tr></table></figure><p>如果开发者想让Druid知道当前的session的用户是谁，可以配置<code>principalSessionName</code>，注意这个参数的值是user信息保存在session中的 <code>sessionName</code>，如果你session中保存的是非string类型的对象，那么需要重载toString方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.principal-session-name=</span><br></pre></td></tr></table></figure><p>如果你的user信息是存在cookie中，那么可以使用下面的方式同样可以配置<code>principalSessionName</code>，进而也能让Druid知道当前的session的用户是谁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.principal-cookie-name=</span><br></pre></td></tr></table></figure><p>自Druid0.2.7版本开始就支持profile，配置profileEnable就能够监控单个url调用的sql列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.web-stat-filter.profile-enable=</span><br></pre></td></tr></table></figure><p>可以开启一下profile试试，然后多次调用book这一API，结果如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9001756a15eae1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>更多详细配置项，可以参考 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter">这里</a> ，了解更多。</p><h1 id="Spring监控"><a href="#Spring监控" class="headerlink" title="Spring监控"></a>Spring监控</h1><p>Druid提供了Spring和Jdbc的关联监控，在使用的时候需要先阅读文档然后进行相应的配置，可点击 <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_Druid%E5%92%8CSpring%E5%85%B3%E8%81%94%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE">这里</a> 进行阅读。</p><h1 id="JSON-API"><a href="#JSON-API" class="headerlink" title="JSON API"></a>JSON API</h1><p>如果开发者觉得此处展示的数据不太美观，那么可以根据提供的API来获取信息后自行展示。</p><h1 id="去除广告"><a href="#去除广告" class="headerlink" title="去除广告"></a>去除广告</h1><p>一般来说为了支持开源，不建议随便把广告去掉，但是在企业里面这个广告实在是有损形象，所以考虑再三还是决定去掉广告。</p><p>首先F12查看源码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4c2f1511e7e14519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后分析发现广告是由<code>commons.js</code>文件带出来的，该文件存放于<code>ruid-xxx.jar!/support/http/resources/js/common.js</code>文件中，可以访问<code>http://localhost:8080/druid/js/common.js</code>链接进行确认：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-64924e3ef6aaae90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-982331f760d53d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>再来查看一下该网页的源代码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-caa0e16dc86036ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p> 调用的是init方法，再阅读一下源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init : function() &#123;</span><br><span class="line"> this.buildFooter();</span><br><span class="line"> druid.lang.init();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">buildFooter : function() &#123;</span><br><span class="line"> var html =&#x27;&#x27;;</span><br><span class="line"> $(document.body).append(html);</span><br><span class="line">&#125;,,</span><br></pre></td></tr></table></figure><p>确认一下，也就说这个buildFooter方法用于显示页面底部的广告，而这个方法则是在init方法中调用的：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-244a08d9a9c460d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>所以要想去除广告，不调用这个buildFooter方法即可，但是源码这种除非反编译，否则是无法修改的。不过可以换种实现方式，可以写一个过滤器，先过滤对于<code>commons.js</code>文件的请求，之后再读取<code>commons.js</code>文件内容，并将<code>this.buildFooter();</code>这行代码用空字符串取代，最后再将这个文件返回就行。</p><h3 id="手动注册方式"><a href="#手动注册方式" class="headerlink" title="手动注册方式"></a>手动注册方式</h3><p>定义一个filter包，并在里面定义一个DeleteADFilter类需要实现Filter接口并重写其中的doFilter方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(urlPatterns =&quot;/druid/js/common.js&quot;)</span><br><span class="line">public class DeleteADFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        servletResponse.resetBuffer();</span><br><span class="line">        String content =  Utils.readFromResource(&quot;support/http/resources/js/common.js&quot;);</span><br><span class="line">        content =  content.replace(&quot;this.buildFooter();&quot;,&quot;&quot;);</span><br><span class="line">        servletResponse.getWriter().write(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意过滤的url地址必须和原地址保持一致，然后在项目启动类上扫描一下我们添加的DeleteADFilter类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan(&quot;com.melody.druidsql.filter&quot;)</span><br><span class="line">public class DruidSqlApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DruidSqlApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动项目，访问首页或者其他页面，可以发现广告已经去掉了：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-195ad4c95546559a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>注意不能将项目启动类上的<code>@ServletComponentScan(&quot;com.melody.druidsql.filter&quot;)</code>注解去掉，转而在DeleteADFilter类上添加<code>@Component</code>，因为前者是注册，后者则是扫描，作用不同。相反如果你使用了<code>@ServletComponentScan</code>注解，那么Servlet可以直接通过<code>@WebServlet</code>注解自动注册；Filter可以直接通过<code>@WebFilter</code>注解自动注册；Listener可以直接通过<code>@WebListener</code>注解自动注册。</p><h3 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h3><p>当然了除了上面的手动注册方式外，我们还可以使用自动注册的方式。只需定义一个<code>DruidSqlConfiguration</code>类，然后提供一个<code>FilterRegistrationBean</code>实例即可，我们可以在该方法中书写拦截广告的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DruidSqlConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnProperty(name = &#123;&quot;spring.datasource.druid.stat-view-servlet.enabled&quot;&#125;,havingValue = &quot;true&quot;)</span><br><span class="line">    public FilterRegistrationBean removeAdFilterRegistrationBean(DruidStatProperties druidStatProperties)&#123;</span><br><span class="line">        //获取Web监控页面的参数</span><br><span class="line">        DruidStatProperties.StatViewServlet statViewServlet = druidStatProperties.getStatViewServlet();</span><br><span class="line">        //提取common.js的配置路径</span><br><span class="line">        String urlPattern = statViewServlet.getUrlPattern() != null? statViewServlet.getUrlPattern():&quot;/druid/*&quot;;</span><br><span class="line">        String commonJsPattern = urlPattern.replaceAll(&quot;\\*&quot;,&quot;js/common.js&quot;);</span><br><span class="line">        //定义过滤器</span><br><span class="line">        Filter filter = new Filter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">                String content = Utils.readFromResource(&quot;support/http/resources/js/common.js&quot;);</span><br><span class="line">                content =  content.replace(&quot;this.buildFooter();&quot;,&quot;&quot;);</span><br><span class="line">                servletResponse.getWriter().write(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        FilterRegistrationBean registrationBean = new FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(filter);</span><br><span class="line">        registrationBean.addUrlPatterns(commonJsPattern);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这种方式相比于前面那种更为巧妙，尤其是在当还需要往Spring容器主注册其他Bean的时候。</p><p>当然了，还有许多功能，如数据库多数据源、配置数据库加密、保存Druid的监控记录等等，这些都将会在后续文章中进行介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;在实际工作中我们我们使用较多的则是Spring默认的HikariDataSource数据库连接池，但是它无法提供可视化监控S</summary>
      
    
    
    
    <category term="mysql" scheme="http://envyzhan.asia/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://envyzhan.asia/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+OAuth2实现单点登录</title>
    <link href="http://envyzhan.asia/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/"/>
    <id>http://envyzhan.asia/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/</id>
    <published>2021-01-15T11:23:04.000Z</published>
    <updated>2021-03-01T03:52:15.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我们知道分布式系统由多个不同的子系统组成，但是我们希望在使用系统的时只需登录一次就能访问该系统，而不用多次登录，因此单点登录是一个很常见的需求。</p><p>在《OAuth2.0+JWT实现单点登录》一文中，我们使用<code>OAuth2+JWT</code>这一技术实现了单点登录，其实正确来说我们实现的是无状态登录，只是这种无状态登录满足单点登录的要求。</p><p>前面也说了无状态存在一些缺点，因此接下来我们尝试使用另一种技术，使用SpringBoot+OAuth2.0并结合<code>@EnableOAuth2Sso</code>注解这一方式来实现单点登录。</p><p>请注意上述两种实现方案都有其比较适合的场景，因此具体选择哪种需要结合实际情况来进行选择。</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>前面我们都是将授权服务器和资源服务器分开搭建，本篇出于简单考虑，就直接将两者放在一个服务器上，名称统一为“统一认证中心”。此案例除了授权服务器外，还需要多个客户端应用，这里就提供两个。各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器+资源服务器</td><td align="center">2019</td></tr><tr><td align="center">client-app1</td><td align="center">客户端1</td><td align="center">2020</td></tr><tr><td align="center">client-app2</td><td align="center">客户端2</td><td align="center">2021</td></tr></tbody></table><p>可以看到此处的<code>auth-server</code>项目充当授权服务器和资源服务器的角色，<code>client-app1</code>和<code>client-app2</code>项目分别扮演子系统角色，之后当用户从<code>client-app1</code>上登录成功后，此时也能访问到<code>client-app2</code>，这样我们就能验证单点登录功能配置成功了。</p><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>oauth2-sso</code>，之后我们将在这个父工程中搭建子项目。</p><h3 id="统一认证中心搭建"><a href="#统一认证中心搭建" class="headerlink" title="统一认证中心搭建"></a>统一认证中心搭建</h3><p>在<code>oauth2-sso</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security下的Cloud Security和Cloud OAuth2：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-52eb10c01bb4d121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一步</strong>，将<strong>父工程<code>oauth2-sso</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;oauth2-sso&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;oauth2-sso&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;SpringBoot+OAuth2实现单点登录&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，由于此项目需要充当授权服务器和资源服务器的角色，因此需要在这个项目的启动类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class AuthServerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AuthServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，接下来我们开始对授权服务器进行配置，由于此处的资源服务器和授权服务器放在一起，因此对于授权服务器的配置非常简单。新建一个config包，并在该包内新建一个<code>AuthServerConfig</code>类，注意它需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthServerConfig extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.inMemory().withClient(&quot;envythink&quot;)</span><br><span class="line">                .secret(passwordEncoder.encode(&quot;1234&quot;))</span><br><span class="line">                .autoApprove(true)</span><br><span class="line">                .redirectUris(&quot;http://127.0.0.1:2020/login&quot;,&quot;http://127.0.0.1:2021/login&quot;)</span><br><span class="line">                .scopes(&quot;user&quot;)</span><br><span class="line">                .accessTokenValiditySeconds(7200)</span><br><span class="line">                .authorizedGrantTypes(&quot;authorization_code&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处我们只是简单的配置了客户端的信息，且配置的非常简单，直接将客户端信息保存在内存中。<br><strong>第四步</strong>，在config包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Order(1)</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        web.ignoring().antMatchers(&quot;/login.html&quot;,&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/images/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.requestMatchers()</span><br><span class="line">                .antMatchers(&quot;/login&quot;)</span><br><span class="line">                .antMatchers(&quot;/oauth/authorize&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(&quot;/login.html&quot;)</span><br><span class="line">                .loginProcessingUrl(&quot;/login&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;envy&quot;)</span><br><span class="line">                .password(passwordEncoder().encode(&quot;1234&quot;))</span><br><span class="line">                .roles(&quot;admin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们首先提供了一个返回<code>BCryptPasswordEncoder</code>实例的方法，之后重写了<code>configure(WebSecurity web)</code>方法，该方法用户放开对静态资源的访问权限。接着重写了<code>configure(HttpSecurity http)</code>方法，在该方法中我们对认证相关的端点进行放行，同时自定义了登录页面和登录接口。然后重写了<code>configure(AuthenticationManagerBuilder auth)</code>方法，我们在该方法中定义了一个用户，该用户信息均保存在内存中。最后还有一个非常重要的地方，需要在配置类上添加<code>@Order(1)</code>注解，用于提升Spring Security框架的优先级，默认数字越小，优先级越大。</p><p><strong>第五步</strong>，由于上面定义的<code>SecurityConfig</code>和<code>AuthServerConfig</code>都是授权服务器提供的，因此我们还需要提供一个暴露用户信息的接口。（此处由于授权服务器和资源服务器放在一起，因此可直接定义。但是当授权服务器和资源服务器是分开搭建时，此时由资源服务器提供该接口。）</p><p>在<code>auth-server</code>项目内新建一个controller包，并在该包内新建一个<code>UserController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public Principal getCurrentUser(Principal principal)&#123;</span><br><span class="line">        return principal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第六步</strong>，在项目<code>resource/static</code>目录下新建一个<code>login.html</code>文件，具体内容可以下载本项目源码进行查看。</p><p><strong>第七步</strong>，在项目的<code>application.properties</code>配置文件内配置项目的端口号，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=2019</span><br></pre></td></tr></table></figure><p>这样我们就搭建完成了统一认证中心。</p><h3 id="客户端搭建"><a href="#客户端搭建" class="headerlink" title="客户端搭建"></a>客户端搭建</h3><p>接下来我们开始搭建客户端，在<code>oauth2-sso</code>父工程中新建一个子模块，名称为<code>client-app1</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security下的Cloud Security和Cloud OAuth2：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-80c702da9ea04b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aeec8c9e8a206a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一步</strong>，将新创建的<code>client-app1</code>项目配置到父工程<code>oauth2-sso</code>项目的pom.xml依赖文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app1&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，新建一个config包，并在该包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableOAuth2Sso</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码非常简单，表示<code>client-app1</code>项目中所有的接口都需要经过认证之后才能访问，同时还需要在该类上添加<code>@EnableOAuth2Sso</code>注解，表示开启单点登录功能。</p><p><strong>第三步</strong>，新建一个controller包，并在该包内新建一个<code>HelloController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        return authentication.getName()+ Arrays.toString(authentication.getAuthorities().toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们定义了一个<code>/hello</code>接口，该接口的作用是返回当前登录用户的姓名和角色信息。</p><p><strong>第四步</strong>，在项目的<code>application.properties</code>配置文件内配置项目的端口号和OAuth2的相关信息，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">security.oauth2.client.client-secret=1234</span><br><span class="line">security.oauth2.client.client-id=envythink</span><br><span class="line">security.oauth2.client.user-authorization-uri=http://127.0.0.1:2019/oauth/authorize</span><br><span class="line">security.oauth2.client.access-token-uri=http://127.0.0.1:2019/oauth/token</span><br><span class="line">security.oauth2.resource.user-info-uri=http://127.0.0.1:2019/user</span><br><span class="line"></span><br><span class="line">server.port=2020</span><br><span class="line">server.servlet.session.cookie.name=s1</span><br></pre></td></tr></table></figure><p>在上面的配置中，<code>client-secret</code>表示客户端密码；<code>client-id</code>表示客户端ID；<code>user-authorization-uri</code>表示用户授权的端点；<code>access-token-uri</code>表示获取令牌的端点；<code>user-info-uri</code>表示从资源服务器上获取信息的接口；之后就是配置项目端口号和cookie的名称，这样我们就完成了客户端1的配置。</p><p><strong>由于客户端1和客户端2的配置完成一致，只有最后项目名称和端口以及cookie的不同，因此关于客户端2的创建工作就省略。</strong></p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>接下来分别启动项目，开始进行测试。首先我们在浏览器中输入<code>http://127.0.0.1:2020/hello</code>链接，尝试去访问客户端1中的hello接口，此时页面会跳转到统一认证中心进行认证：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-50090f4eea535698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>之后用户以envy/1234进行登录，此时页面会跳转到<code>http://127.0.0.1:2020/hello</code>链接，并显示以下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-fba9ee4092d3dbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时当开发者直接去访问客户端2的hello接口时，也就是<code>http://127.0.0.1:2021/hello</code>链接，可以看到页面显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-461349ad25c650d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到用户不需要再次登录，也能访问到客户端2中的hello接口，这样我们就实现了单点登录这一功能。</p><h1 id="请求流程分析"><a href="#请求流程分析" class="headerlink" title="请求流程分析"></a>请求流程分析</h1><p>为了更好的对上述内容进行分析，接下来我们将通过请求流程来进一步分析：</p><p>（1）当我们访问<code>client-app1</code>项目的hello接口时，由于此接口被保护，只有通过认证后才能访问，因此此时我们的请求会被拦截下来，系统会将我们重定向到<code>client-app1</code>项目的login接口，也就是登录页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-8b19c69f207e626a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>（2）当我们去访问<code>client-app1</code>项目的login接口时，由于我们配置了<code>@EnableOAuth2Sso</code>注解，因此请求会被再次拦截下来，单点登录拦截器会根据我们在<code>application.properties</code>配置文件中的配置，自动发起请求去获取授权码：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-448a24a30974081d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>（3）由于（2）发送的请求是请求<code>auth-server</code>授权服务器上的内容，因此这个请求也需要先登录才能访问，所以会再次重定向到<code>auth-server</code>授权服务器的登录页面，也就是我们看到的统一认证中心页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-099325fcf486b516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>（4）在统一认证中心用户成功登录之后，会继续执行（2）中的请求，此时就能获取到授权码了。</p><p>（5）在获取到授权码之后，此时会重定向到<code>client-app1</code>项目的login页面，而实际上<code>client-app1</code>项目是没有登录页面的，因此这个请求依旧会被拦截，此时拦截到的地址中包含授权码。拿着授权码在<code>OAuth2ClientAuthenticationProcessingFilter</code>类中向<code>auth-server</code>发起请求请求就能得到<code>access_token</code>了。</p><p>（6）在获取到<code>access_token</code>之后，接下来就向我们配置的<code>user-info-uri</code>地址发送请求，来获取登录的用户信息。在拿到用户信息之后，接下来会在<code>client-app1</code>项目上重写执行一次Spring Security的登录流程，这样完成了接口信息的获取。</p><p>以上就是如何使用Spring Boot+OAuth2.0来实现单点登录这一功能的相关分析。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;我们知道分布式系统由多个不同的子系统组成，但是我们希望在使用系统的时只需登录一次就能访问该系统，而不用多次登录，因此单点登录</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0+JWT实现单点登录</title>
    <link href="http://envyzhan.asia/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/"/>
    <id>http://envyzhan.asia/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/</id>
    <published>2021-01-12T11:23:04.000Z</published>
    <updated>2021-03-01T03:51:50.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>通过前面几篇的学习，我们对OAuth2.0中的四种授权模式有了较为清晰的认识，同时可以发现这些文章都是侧重于OAuth2.0的登录流程，而对于登录的一些细节并没有过多的深究，其实这些细节在实际开发过程中也非常重要，因此接下来开始对登录中的一些细节进行深度分析。</p><p>我们知道传统的Web应用都是采用Session来记录用户认证信息，这一方式可以理解为是一种有状态的登录，实际上还可以采用无状态这种方式来实现这一目的，最为代表的就是JWT。无状态登录很容易实现单点登录这一功能，因此对于无状态登录的研究对于提升自身技术水平有非常大的帮助。</p><h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>所谓的有状态服务是指服务端需要记录每次会话的客户信息，并据此识别客户端身份，验证通过后根据客户端身份进行请求处理，如Tomcat中的session就是此类的具体实现。当用户登录成功后，会将用户的信息保存在服务端的Session中，并将sessionId放在Cookie中用于返回给用户。等到用户下次访问的时候，用户会携带含有Cookie信息的请求到服务器，服务器会验证sessionId是否合法，当验证无误通过后会据此找到用户信息。</p><p>但是这种方式存在一些缺陷，当时间不断累计，服务端会保存大量的数据，这势必会增加服务端压力，还有由于服务器中保存的是用户的状态，因此对于集群化部署不太友好，极易造成用户信息访问断层现象。</p><p><strong>基于有状态实现的登录流程：</strong><br>1、用户输入用户名和密码，点击提交；<br>2、调用 login()命令, 后端程序会根据用户名密码生成sessionId并保存在数据库中；<br>3、用户登录之后，需要通过这个sessionId取出相关的基本信息。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>说完了有状态，接下来学习无状态，单纯的介绍无状态似乎意义不大，因此结合目前流行的微服务架构来讲显得更有说服力。</p><p>我们知道微服务集群中每个服务对外都使用RESTful风格的接口，而RESTful风格有一个重要的规范就是“服务无状态性”。怎么理解这个“服务无状态性”呢？这里有两点需要注意：（1）服务端不保存客户端请求发起者的信息；（2）客户端的每次请求中必须包含描述发送者的信息，以便服务端通过这些信息唯一确定其身份。</p><p>那么问题来了，无状态相比于有状态有哪些优势呢？首先由于客户端发起的请求中已经包含了其发送者的描述信息，因此并不要求多次发送请求访问的必须是同一台服务器，这使得服务器集群化成为可能；其次，由于存在集群化部署，极大地降低了服务端的压力。</p><p><strong>基于无状态实现的登录流程：</strong><br>1、用户输入用户名和密码，点击提交；<br>2、调用 login()命令, 后端程序会将用户信息加密并编码成一个token，之后将其返回给客户端；<br>3、此后客户端每次发送请求都需要携带token，服务端对该token进行解密和验证，确认通过后即能获取用户基本信息。</p><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h3 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h3><p><a href="https://jwt.io/">JWT</a>，全称为Json Web Token，它是一种JSON风格、轻量级的授权和身份认证规范，可以实现无状态、分布式的Web应用授权：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c941d19cc6deed69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>JWT作为一种规范，并没有和语言进行绑定，因此不同的语言对此都有具体的实现。常用的Java语言实现是jjwt，其开源地址为<code>https://github.com/jwtk/jjwt</code>。</p><h3 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h3><p>JWT的原理是，服务端认证以后，生成一个 SON对象并返回给用户，就像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;envy&quot;,</span><br><span class="line">  &quot;role&quot;: &quot;admin&quot;,</span><br><span class="line">  &quot;expires&quot;: &quot;2021-01-02 10:01:06&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后用户与服务端进行通信的时候，都需要携带这个JSON对象。服务端完全靠这个JSON对象来确定用户身份。当然了，为了防止用户篡改数据，服务端会在生成这个JSON对象的时候，会加上签名，这一点后续会介绍。这样服务端无需保存任何session数据，也就是说此时服务端变成无状态了，进而比较容易实现扩展。</p><h3 id="JWT数据格式"><a href="#JWT数据格式" class="headerlink" title="JWT数据格式"></a>JWT数据格式</h3><p>首先看一下实际的JWT实例，如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f675af1bfe72e7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到这个JWT是一个非常长的字符串，中间用点号<code>(.)</code>分隔成三部分。请注意，实际的JWT内部是没有换行的，此处只是为了便于展示才将它写成了四行。</p><p>JWT包含三部分数据，一是Header（头部）、二是Playload（载荷）、三是Signature（签名）。写成一行就是<code>Header.Payload.Signature</code>这一格式，也就是如下所示的格式：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-b2bd42188a16f39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一部分</strong>：Header（头部），它是一个JSON对象，用于描述JWT的元数据。举个例子，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它通常包括两个部分：(1)加密算法，这个开发者可以自定义；(2)声明类型，此处就是JWT。在上面代码中，alg属性表示签名的算法（algorithm），默认是HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。通常我们会对头部使用Base64URL进行编码，进而得到第一部分数据，但是这种编码方式是可逆的，安全性不高。</p><p><strong>第二部分</strong>：Playload（载荷），它也是一个JSON对象，用于存放实际需要传递的数据，说白了就是有效数据。在其官方文档(RFC7519)中规定了7个可供选择的字段，如下所示：<br>(1)iss(issuer)表示签发人；(2)exp(expiration time)表示token过期时间；(3)sub(subject)表示主题；(4)aud(audience)表示受众；(5)nbf(Not Before)表示生效时间；(6)iat(Issued At)表示签发时间；(7)jti(JWT ID)表示编号。</p><p>当然，除了官方字段，开发者还可以在此部分定义私有字段，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Envy Think&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，JWT默认是不加密的，任何人都可以读到，因此不能把私密信息存放在此部分。同样我们会对其使用Base64URL进行编码，进而得到第二部分数据。</p><p><strong>第三部分</strong>：Signature（签名），Signature部分是对前两部分的签名，用于防止数据篡改。</p><p>首先需要在服务器上指定一个密钥（secret），该密钥只有服务器才知道，不能泄露给用户，之后使用<code>Header</code>里面指定的签名算法（默认是<code>HMAC SHA256</code>）来按照下面的公式产生签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>在计算出签名之后，将<code>Header</code>、<code>Payload</code>、<code>Signature</code>这三部分拼成一个字符串，注意各个部分之间使用点号<code>(.)</code>进行分割，之后就可以返回给用户。</p><p>在前面我们多次提到，Header和Payload串型化均采用了Base64URL算法，该算法和Base64算法基本类似，但是存在一些不同的地方。我们知道JWT作为一个令牌（token），在某些场景下会放在URL中，如<code>https://api.example.com/?token=xxx</code>。Base64中存在三个特殊字符<code>+</code>、<code>/</code>和<code>=</code>，由于它们在URL中有特殊含义，因此要被替换掉，其中<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code>，这就是Base64URL算法。</p><h3 id="JWT数据流转"><a href="#JWT数据流转" class="headerlink" title="JWT数据流转"></a>JWT数据流转</h3><p>下面是JWT数据流转的示意图：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-63c740a0519c7652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>乍一看可能觉得JWT模式与四种授权模式中的密码模式非常相似，其实两者是存在一个较为明显的区别。JWT模式下服务端不保存用户信息，且不要求客户端对于服务端高度信任。也正是由于JWT签发的令牌token中已经包含了用户身份信息，且每次请求时都会携带上，因此服务端无需保存用户信息，毫无疑问这是非常符合RESTful的无状态要求。</p><h3 id="JWT缺点"><a href="#JWT缺点" class="headerlink" title="JWT缺点"></a>JWT缺点</h3><p>尽管JWT存在上述所列的优点，但是JWT也存在一些问题，具体如下所示：<br>（1）续签问题。这也是JWT被许多人嗤之以鼻的原因，我们知道传统的cookie+session方案支持续签，但是JWT由于服务端不保存用户信息，因此很难解决续签问题。当然开发者可以引入Redis来解决这个问题，但是这并不是单纯的使用JWT。<br>（2）注销问题。尽管JWT模式下的服务端不保存用户信息，但是开发者可以通过修改secret来实现注销，当服务端的secret被修改后，请注意已经颁发的未过期的令牌token就会认证失败，进而实现注销这一目的，但是这种方式肯定没有传统注销那样简单。<br>（3）密码重置问题。请注意当用户将密码进行重置后，之前的令牌token依旧可以访问系统，此时就需要强制修改secret。<br>（4）由于注销问题和密码重置问题，因此一般建议不同的用户采用不同的secret，以增强安全性。</p><h3 id="OAuth2中存在的问题"><a href="#OAuth2中存在的问题" class="headerlink" title="OAuth2中存在的问题"></a>OAuth2中存在的问题</h3><p>在《一个完整的授权码模式实例》一文中我们知道，当授权服务器派发了access_token之后，客户端便拿着access_token去资源服务器请求资源，此时资源服务器需要校验access_token信息，因此我们需要在资源服务器上配置<code>RemoteTokenServices</code>，进而让资源服务器进行校验，如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RemoteTokenServices tokenServices()&#123;</span><br><span class="line">    RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">    services.setCheckTokenEndpointUrl(&quot;http://127.0.0.1:8080/oauth/check_token&quot;);</span><br><span class="line">    services.setClientId(&quot;envythink&quot;);</span><br><span class="line">    services.setClientSecret(&quot;1234&quot;);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问这段代码在高并发情况下执行是有问题的，如果使用JWT将用户信息保持在JWT中，那么就能解决上述问题。</p><h1 id="密码模式使用JWT"><a href="#密码模式使用JWT" class="headerlink" title="密码模式使用JWT"></a>密码模式使用JWT</h1><p>前面也提到JWT模式和密码模式流程非常相似，因此这里就以密码模式为例来进行升级改造。</p><h3 id="授权服务器改造"><a href="#授权服务器改造" class="headerlink" title="授权服务器改造"></a>授权服务器改造</h3><p>首先打开<code>auth_server</code>授权服务器，找到其中的<code>AccessTokenConfig</code>类，将里面的代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    private String SIGNING_KEY = &quot;envythink&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JwtAccessTokenConverter jwtAccessTokenConverter()&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        return converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore()&#123;</span><br><span class="line">        return new JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处我们在tokenStore方法中提供的是一个<code>JwtTokenStore</code>实例。如果不采用JWT模式，那么之前我们将access_token无论是存储在内存还是Redis中，最后都是需要将access_token保存下来的，这样当客户端携带access_token请求服务端的时候，服务端还需要对其进行校验。但是如果我们采用了JWT这一模式，那么服务端就无需保存access_token，因为用户信息都保存在jwt中，因此此处配置的JwtTokenStore其实并不是用于存储access_token。</p><p>在<code>JwtTokenStore</code>实例化的过程中我们还传入了一个<code>JwtAccessTokenConverter</code>对象，这个<code>JwtAccessTokenConverter</code>对象可以实现用户信息和JWT字符串的相互转换，也就是可以从JWT字符串中取出用户信息或者将用户信息转为JWT字符串。需要说明的是，在JWT字符串生成的时候，我们还需要生成一个签名，这个签名非常重要。</p><p>注意JWT默认生成的信息主要包含用户角色、名称等，当开发者希望在生成的JWT字符串中包含其他信息，那么可以自定义一个类，然后实现<code>TokenEnhancer</code>接口即可。新建一个<code>CustomAdditionalInformation</code>类，并实现<code>TokenEnhancer</code>接口，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomAdditionalInformation implements TokenEnhancer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OAuth2AccessToken enhance(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication) &#123;</span><br><span class="line">        Map&lt;String,Object&gt; info = oAuth2AccessToken.getAdditionalInformation();</span><br><span class="line">        info.put(&quot;author&quot;,&quot;余思&quot;);</span><br><span class="line">        ((DefaultOAuth2AccessToken)oAuth2AccessToken).setAdditionalInformation(info);</span><br><span class="line">        return oAuth2AccessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到笔者自定义了一个<code>CustomAdditionalInformation</code>类，实现了<code>TokenEnhancer</code>接口，并重写了该接口的enhance方法。请注意，enhance方法中的<code>OAuth2AccessToken</code>对象其实就是已经生成的access_token信息，我们可以从<code>OAuth2AccessToken</code>对象中取出已经生成的额外信息，并在此基础上添加自己所添加的信息即可。需要说明的是，我们在<code>AccessTokenConfig</code>类中配置的<code>JwtAccessTokenConverter</code>，它也是一个<code>TokenEnhancer</code>实例。</p><p>接下来需要修改<code>AuthorizationServerConfig</code>类，主要是对tokenServices方法进行修改，修改后的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private CustomAdditionalInformation customAdditionalInformation;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">AuthorizationServerTokenServices tokenServices()&#123;</span><br><span class="line">    DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService);</span><br><span class="line">    services.setSupportRefreshToken(true);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">    services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line"></span><br><span class="line">    TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();</span><br><span class="line">    tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter,customAdditionalInformation));</span><br><span class="line">    services.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们只是实例化了一个<code>TokenEnhancerChain</code>对象，并将之前定义的<code>jwtAccessTokenConverter</code>、<code>customAdditionalInformation</code>两个实例注入进来并构成一个集合，最后将其作为<code>TokenEnhancerChain</code>对象的属性进行设置。</p><h3 id="资源服务器改造"><a href="#资源服务器改造" class="headerlink" title="资源服务器改造"></a>资源服务器改造</h3><p>在完成了对授权服务器的改造之后，接下来我们开始对资源服务器进行改造。首先打开<code>user-server</code>资源服务器，我们将<code>auth_server</code>授权服务器中的<code>AccessTokenConfig</code>类复制一份到其config包中，之后我们在资源服务器上就不再需要配置远程校验地址，只需配置一个<code>TokenStore</code>即可。打开config包下面的<code>ResourceServerConfig</code>类，将其中的代码修改为如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span><br><span class="line">        resources.resourceId(&quot;res1&quot;).tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到此处我们将之前在<code>AccessTokenConfig</code>类中配置的tokenStore实例注入进来，这样系统会自动调用<code>JwtAccessTokenConverter</code>对象将jwt进行解析，jwt中由于已经保存了用户的基本信息，因此就不需要服务端来校验access_token了。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在完成对授权服务器和资源服务器的改造之后，注意此时我们无需关注应用端，因此对其无需进行改造，同时处于测试方便的考虑，这里使用Postman来对项目进行测试。</p><p>启动授权服务器和资源服务器，首先我们向授权服务器请求access_token：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-93e5d9b1508d1521.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到我们获取到了jwt字符串，也就是此处的access_token，同时可以看到我们之前自定义的author字段也已经有值了。当然如果开发者想验证access_token中包含的信息是否是之前介绍过的内容，此时可以利用Base64URL解码工具来进行解码，也可以使用<code>check_token</code>接口来进行解析：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-d1e196b99a7d7053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>此时就能看到jwt字符串中保存的用户信息了。在获取到<code>access_token</code>之后，接下来我们就可以去访问资源服务器中的资源了，如访问<code>hello</code>接口，注意此时需要在请求头中携带<code>access_token</code>信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-3151c8c4663d64a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到此时我们就获取到了hello接口中的信息，也就是通过上面的配置我们成功的将OAuth2.0和JWT结合起来进行使用了。</p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>现在问题来了，前面介绍的access_token是如何变成了jwt呢？jwt和认证信息又是如何实现自动转换的呢？接下来我们通过阅读源码来解答这些疑问。</p><p>首先思考一个问题，acess_token是在什么地方生成的？此时就需要回到auth-server授权服务器的<code>AuthorizationServerConfig</code>类中，可以看到我们定义了一个<code>tokenServices</code>方法，在该方法中我们构建了一个<code>DefaultTokenServices</code>对象，查看<code>DefaultTokenServices</code>类的源码，可以看到里面有一个名为<code>createAccessToken</code>的方法，该方法的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private OAuth2AccessToken createAccessToken(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken) &#123;</span><br><span class="line">    DefaultOAuth2AccessToken token = new DefaultOAuth2AccessToken(UUID.randomUUID().toString());</span><br><span class="line">    int validitySeconds = this.getAccessTokenValiditySeconds(authentication.getOAuth2Request());</span><br><span class="line">    if (validitySeconds &gt; 0) &#123;</span><br><span class="line">        token.setExpiration(new Date(System.currentTimeMillis() + (long)validitySeconds * 1000L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token.setRefreshToken(refreshToken);</span><br><span class="line">    token.setScope(authentication.getOAuth2Request().getScope());</span><br><span class="line">    return (OAuth2AccessToken)(this.accessTokenEnhancer != null ? this.accessTokenEnhancer.enhance(token, authentication) : token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析一下该方法：<br>（1）可以看到默认生成的<code>access_token</code>其实是一个UUID字符串；<br>（2）调用<code>getAccessTokenValiditySeconds()</code>方法来获取<code>access_token</code>的有效期。查看一下这个<code>getAccessTokenValiditySeconds()</code>方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected int getAccessTokenValiditySeconds(OAuth2Request clientAuth) &#123;</span><br><span class="line">    if (this.clientDetailsService != null) &#123;</span><br><span class="line">        ClientDetails client = this.clientDetailsService.loadClientByClientId(clientAuth.getClientId());</span><br><span class="line">        Integer validity = client.getAccessTokenValiditySeconds();</span><br><span class="line">        if (validity != null) &#123;</span><br><span class="line">            return validity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.accessTokenValiditySeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它首先通过客户端Id去数据库中查询得到客户端信息，其次调用客户端的<code>getAccessTokenValiditySeconds()</code>方法来得到有效期，其实这个就是我们之前配置的<code>access_token</code>的有效期，注意单位为秒。<br>（3）回到<code>createAccessToken()</code>方法中，接着判断<code>access_token</code>设置的有效期是否大于0，如果大于0则调用<code>setExpiration()</code>方法来设置过期时间，过期时间就是在系统当前时间的基础上加上用户设置的过期时间，由于用户设置的过期时间单位为秒，因此需要乘以1000，将其转换为毫秒。<br>（4）接着调用<code>setRefreshToken()</code>方法来设置刷新token，同时调用<code>setScope()</code>方法来设置授权范围scope。请注意，刷新token的生成过程也是在<code>createAccessToken()</code>方法中完成的，这个过程和<code>access_token</code>生成的过程类似，因此就跳过介绍。<br>（5）在return语句中会对<code>accessTokenEnhancer</code>是否存在进行判断，如果不为空，则调用<code>accessTokenEnhancer.enhance()</code>方法对其进行处理，其实这就是将<code>access_token</code>转换为jwt字符串的过程。</p><p>前面也说了此处<code>accessTokenEnhancer</code>的实现类为<code>TokenEnhancerChain</code>，查看一下其源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TokenEnhancerChain implements TokenEnhancer &#123;</span><br><span class="line">    private List&lt;TokenEnhancer&gt; delegates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    public TokenEnhancerChain() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTokenEnhancers(List&lt;TokenEnhancer&gt; delegates) &#123;</span><br><span class="line">        this.delegates = delegates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">        OAuth2AccessToken result = accessToken;</span><br><span class="line"></span><br><span class="line">        TokenEnhancer enhancer;</span><br><span class="line">        for(Iterator var4 = this.delegates.iterator(); var4.hasNext(); result = enhancer.enhance(result, authentication)) &#123;</span><br><span class="line">            enhancer = (TokenEnhancer)var4.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面定义了一个delegates属性，里面保存了我们定义的<code>TokenEnhancer</code>，前面也说了我们在<code>auth-server</code>授权服务器中定义了<code>jwtAccessTokenConverter</code>和<code>customAdditionalInformation</code>，也就是说<code>access_token</code>信息其实就是在这两个类中进行二次处理。处理的顺序是依照集合中保存的顺序，也就是先在<code>jwtAccessTokenConverter</code>中进行处理，之后在<code>customAdditionalInformation</code>中进行处理，这个顺序不能发生颠倒，这也就意味着开发人员在<code>auth-server</code>授权服务器中应当首先注入<code>JwtAccessTokenConverter</code>对象，之后才注入<code>CustomAdditionalInformation</code>对象。</p><p>需要说明的是，无论是<code>JwtAccessTokenConverter</code>，还是<code>CustomAdditionalInformation</code>，其中核心的方法都是enhance方法。首先查看一下<code>JwtAccessTokenConverter</code>类中enhance方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">    DefaultOAuth2AccessToken result = new DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">    Map&lt;String, Object&gt; info = new LinkedHashMap(accessToken.getAdditionalInformation());</span><br><span class="line">    String tokenId = result.getValue();</span><br><span class="line">    if (!info.containsKey(&quot;jti&quot;)) &#123;</span><br><span class="line">        info.put(&quot;jti&quot;, tokenId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tokenId = (String)info.get(&quot;jti&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.setAdditionalInformation(info);</span><br><span class="line">    result.setValue(this.encode(result, authentication));</span><br><span class="line">    OAuth2RefreshToken refreshToken = result.getRefreshToken();</span><br><span class="line">    if (refreshToken != null) &#123;</span><br><span class="line">        DefaultOAuth2AccessToken encodedRefreshToken = new DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">        encodedRefreshToken.setValue(refreshToken.getValue());</span><br><span class="line">        encodedRefreshToken.setExpiration((Date)null);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String, Object&gt; claims = this.objectMapper.parseMap(JwtHelper.decode(refreshToken.getValue()).getClaims());</span><br><span class="line">            if (claims.containsKey(&quot;jti&quot;)) &#123;</span><br><span class="line">                encodedRefreshToken.setValue(claims.get(&quot;jti&quot;).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IllegalArgumentException var11) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; refreshTokenInfo = new LinkedHashMap(accessToken.getAdditionalInformation());</span><br><span class="line">        refreshTokenInfo.put(&quot;jti&quot;, encodedRefreshToken.getValue());</span><br><span class="line">        refreshTokenInfo.put(&quot;ati&quot;, tokenId);</span><br><span class="line">        encodedRefreshToken.setAdditionalInformation(refreshTokenInfo);</span><br><span class="line">        DefaultOAuth2RefreshToken token = new DefaultOAuth2RefreshToken(this.encode(encodedRefreshToken, authentication));</span><br><span class="line">        if (refreshToken instanceof ExpiringOAuth2RefreshToken) &#123;</span><br><span class="line">            Date expiration = ((ExpiringOAuth2RefreshToken)refreshToken).getExpiration();</span><br><span class="line">            encodedRefreshToken.setExpiration(expiration);</span><br><span class="line">            token = new DefaultExpiringOAuth2RefreshToken(this.encode(encodedRefreshToken, authentication), expiration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.setRefreshToken((OAuth2RefreshToken)token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码较长，但是逻辑较为清晰：<br>（1）首先实例化一个<code>DefaultOAuth2AccessToken</code>对象，之后调用<code>getAdditionalInformation()</code>方法将<code>accessToken</code>中的额外信息提取出来，注意<code>accessToken</code>默认是没有附加信息的；<br>（2）调用<code>result.getValue()</code>方法得到之前生成的UUID字符串，并判断（1）得到的附加信息中是否包含<code>jti</code>，如果不包含则将其放入其中，如果包含则直接获取其信息，并将其值作为tokenId的值。之后就是将获取到的额外信息和值添加到result中。<br>（3）调用<code>encode()</code>方法来对result对象进行编码，并将结果作为新的access_token，注意这个编码的过程其实就是将用户信息转换为jwt字符串的过程。<br>（4）接下来就是设置token的刷新问题，首先判断<code>refreshToken</code>是否不为空，如果不为空，同时token为jwt字符串，那么就需要一个解码操作，否则直接刷新token。请注意，如果<code>refreshToken</code>为<code>ExpiringOAuth2RefreshToken</code>的实例，那么就说明<code>refreshToken</code>已经过期了，此时需要重新生成一个<code>refreshToken</code>。</p><p>在（3）中我们提到，会调用<code>encode()</code>方法来对result对象进行编码，而这个也是将用户信息转换为jwt字符串的过程。查看一下该方法的源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected String encode(OAuth2AccessToken accessToken, OAuth2Authentication authentication) &#123;</span><br><span class="line">    String content;</span><br><span class="line">    try &#123;</span><br><span class="line">        content = this.objectMapper.formatMap(this.tokenConverter.convertAccessToken(accessToken, authentication));</span><br><span class="line">    &#125; catch (Exception var5) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Cannot convert access token to JSON&quot;, var5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String token = JwtHelper.encode(content, this.signer).getEncoded();</span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它首先会将<code>accessToken</code>和用户信息<code>authentication</code>生成一个字符串，之后调用<code>JwtHelper.encode()</code>方法来对生成的字符串进行编码，最后就返回了一个jwt字符串。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;通过前面几篇的学习，我们对OAuth2.0中的四种授权模式有了较为清晰的认识，同时可以发现这些文章都是侧重于OAuth2.0</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>授权码模式实例优化</title>
    <link href="http://envyzhan.asia/2021/01/09/oauth2-7-authorization-code-pattern-optimization/"/>
    <id>http://envyzhan.asia/2021/01/09/oauth2-7-authorization-code-pattern-optimization/</id>
    <published>2021-01-09T11:23:04.000Z</published>
    <updated>2021-03-01T03:51:23.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>一般来说，<code>access_token</code>令牌肯定不会像之前那样存在内存中，通常我们都会将其存入Redis数据库中。在实际开发过程中，不仅仅是令牌，对于客户端信息，我们同样需要将其存入数据库中，还有对于第三方应用而言，前面的配置都显得过于臃肿，因此接下来就尝试对上述一些问题进行细致分析。</p><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><p>同样由于授权码模式的完整性，这里依旧选择使用授权码模式进行分析。授权码模式中各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h3 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h3><p>使用Maven新建一个空白的父工程，名称为<code>authorization-code-redis</code>，之后我们将在这个父工程中搭建子项目。</p><h3 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h3><p>在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下五个依赖：Web、Spring Cloud Security、Spring Cloud OAuth2、Redis、MySQL依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>可以看到既然是需要将令牌存入Redis，客户端信息存入MySQL，那么就需要添加对应的依赖。<br><strong>第一步</strong>，将<strong>父工程<code>authorization-code-redis</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;authorizationcoderedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;authorization-code-redis&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0令牌持久化&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;envy&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;admin&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;hello&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().formLogin()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。</p><h1 id="Redis存储令牌"><a href="#Redis存储令牌" class="headerlink" title="Redis存储令牌"></a>Redis存储令牌</h1><p>完成了用户的基本信息配置后，接下来开始配置授权服务器。在前面授权码模式一文中，对于授权码我们使用<code>InMemoryAuthorizationCodeServices</code>存储在内存中；对于令牌我们使用<code>InMemoryTokenStore</code>存储在内存中。对于授权码来说，使用一次之后就会失效，因此将其存在内存中是可以的，但是令牌一般都是有使用期限的，在该期限内是可以多次使用的，因此将其也存在内存中并不是最佳的方式。</p><p><code>TokenStore</code>用于将生成的token存放在何处，这是一个接口，查看该接口的实现类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到它提供了多种方式来存储令牌：<br>（1）<code>InMemoryTokenStore</code>，这是系统默认的存储方式。顾名思义就是将令牌<code>access_token</code>存入内存中，在单体应用中是没有任何问题，但是在分布式环境下就会出现很多问题。<br>（2）<code>JdbcTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入数据库中，这样便于在多应用之间共享令牌数据。<br>（3）<code>JwkTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入JSON Web Key中。<br>（4）<code>JwtTokenStore</code>，请注意，这个其实并不是存储，因为使用jwt之后，生成的jwt中就存有用户的所有信息。因为服务端是不用保存令牌，也就是无状态登录。<br>（5）<code>RedisTokenStore</code>，看名字就知道这种方式是将令牌<code>access_token</code>存入Redis中。</p><p>尽管系统提供了5种存储令牌的方式，但是在实际开发过程中用的多的还是<code>RedisTokenStore</code>和<code>JwtTokenStore</code>这两种。<code>JwtTokenStore</code>这种方式非常复杂，后续会进行学习。这里主要学习使用<code>RedisTokenStore</code>来存储令牌。</p><p><strong>第三步</strong>，在<code>application.properties</code>配置文件中添加Redis配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br><span class="line"></span><br><span class="line">spring.redis.host=192.168.59.100</span><br><span class="line">spring.redis.port=6371</span><br><span class="line">spring.redis.database=0</span><br><span class="line">spring.redis.password=envy123</span><br></pre></td></tr></table></figure><p><strong>第四步</strong>，在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore()&#123;</span><br><span class="line">        return new RedisTokenStore(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们提供一个<code>TokenStore</code>实例，准确来说是<code>RedisTokenStore</code>实例，该实例表示将生成的token存放在Redis中。</p><h1 id="客户端信息入库"><a href="#客户端信息入库" class="headerlink" title="客户端信息入库"></a>客户端信息入库</h1><p>在前面我们都是使用了类似于下面的代码，将客户端信息存储在了内存中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">    clients.inMemory()</span><br><span class="line">            .withClient(&quot;envythink&quot;).secret(new BCryptPasswordEncoder().encode(&quot;1234&quot;))</span><br><span class="line">            .resourceIds(&quot;res1&quot;).authorizedGrantTypes(&quot;authorization_code&quot;,&quot;refresh_token&quot;)</span><br><span class="line">            .scopes(&quot;all&quot;).redirectUris(&quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际工作中绝不会这么操作，一是这里直接将客户端信息在代码中固定化了，不利于后续维护；二是客户端信息是比较多的，直接将其存储在内存中会占用大量的内存资源，这是极为不可取的，因此正确的做法是将其存储在数据库中。</p><p>与用户相关的UserDetailsService接口相类似，客户端信息主要与ClientDetailsService接口相关。查看一下该接口的实现类：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-a3c7f7cb4699fd18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到它有两个实现类，分别是<code>InMemoryClientDetailsService</code>和<code>JdbcClientDetailsService</code>。显然前者用于将数据存入内存中，后者用于存入数据库中。查看一下<code>JdbcClientDetailsService</code>的源码，可以发现它很长，这里主要关注它无参数的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public JdbcClientDetailsService(DataSource dataSource) &#123;</span><br><span class="line">    this.updateClientDetailsSql = DEFAULT_UPDATE_STATEMENT;</span><br><span class="line">    this.updateClientSecretSql = &quot;update oauth_client_details set client_secret = ? where client_id = ?&quot;;</span><br><span class="line">    this.insertClientDetailsSql = &quot;insert into oauth_client_details (client_secret, resource_ids, scope, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove, client_id) values (?,?,?,?,?,?,?,?,?,?,?)&quot;;</span><br><span class="line">    this.selectClientDetailsSql = &quot;select client_id, client_secret, resource_ids, scope, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove from oauth_client_details where client_id = ?&quot;;</span><br><span class="line">    this.passwordEncoder = NoOpPasswordEncoder.getInstance();</span><br><span class="line">    Assert.notNull(dataSource, &quot;DataSource required&quot;);</span><br><span class="line">    this.jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">    this.listFactory = new DefaultJdbcListFactory(new NamedParameterJdbcTemplate(this.jdbcTemplate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面其实就是对系统自带的<code>oauth_client_details</code>表进行了增改查操作，因此我们完全可以从这个方法中推断出这个<code>oauth_client_details</code>表的创建语法，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `oauth_client_details`;</span><br><span class="line">CREATE TABLE  `oauth_client_details`(</span><br><span class="line">  `client_id` varchar(48) NOT NULL,</span><br><span class="line">  `client_secret` varchar(256) DEFAULT NULL,</span><br><span class="line">  `resource_ids` varchar(256) DEFAULT NULL,</span><br><span class="line">  `scope` varchar(256) DEFAULT NULL,</span><br><span class="line">  `authorized_grant_types` varchar(256) DEFAULT NULL,</span><br><span class="line">  `web_server_redirect_uri` varchar(256) DEFAULT NULL,</span><br><span class="line">  `authorities` varchar(256) DEFAULT NULL,</span><br><span class="line">  `access_token_validity` int(11) DEFAULT NULL,</span><br><span class="line">  `refresh_token_validity` int(11) DEFAULT NULL,</span><br><span class="line">  `additional_information` varchar(4096) DEFAULT NULL,</span><br><span class="line">  `autoapprove` varchar(256) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY(`client_id`)</span><br><span class="line">)ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，新建一个名为oauth2的数据库，之后运行上述创建数据表的SQL。</p><p><strong>第六步</strong>，在<code>application.properties</code>配置文件中添加MySQL配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.url=jdbc:mysql:///oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.main.allow-bean-definition-overriding=true</span><br></pre></td></tr></table></figure><p>注意最后需要添加<code>spring.main.allow-bean-definition-overriding=true</code>这一行代码，因为我们既然是自定义ClientDetailsService，那么就需要设置允许将自定义的实例覆盖系统默认的实例。</p><p><strong>第七步</strong>，在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    ClientDetailsService clientDetailsService()&#123;</span><br><span class="line">        return new JdbcClientDetailsService(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices()&#123;</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService());</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;</span><br><span class="line">        security.checkTokenAccess(&quot;permitAll()&quot;)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.withClientDetails(clientDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //授权码依旧存在内存中</span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices()&#123;</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，我们将其配置在MySQL数据库中。<br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h3 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h3><p><strong>请注意此处资源服务器搭建和授权码模式时的步骤完全一样，这里将之前搭建的过程给搬运过来而已。</strong></p><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>authorization-code-redis</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices()&#123;</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(&quot;http://127.0.0.1:8080/oauth/check_token&quot;);</span><br><span class="line">        services.setClientId(&quot;envythink&quot;);</span><br><span class="line">        services.setClientSecret(&quot;1234&quot;);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span><br><span class="line">        resources.resourceId(&quot;res1&quot;).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;admin/hello&quot;)</span><br><span class="line">    public String admin()&#123;</span><br><span class="line">        return &quot;admin&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h3 id="客户端（第三方应用）优化"><a href="#客户端（第三方应用）优化" class="headerlink" title="客户端（第三方应用）优化"></a>客户端（第三方应用）优化</h3><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>authorization-code-redis</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下两个依赖：Web和Thymeleaf依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>authorization-code-redis</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 授权码模式实例优化&lt;/h1&gt;</span><br><span class="line">&lt;a href=&quot;http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html&quot;&gt;第三方登录&lt;/a&gt;</span><br><span class="line">&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>该页面的意思是点击超链接，就可以实现第三方登录，超链接中的参数如下所示：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为code，表示响应一个授权码。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scop</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个h1标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在h1标签中显示出来。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    TokenTask tokenTask;</span><br><span class="line">    @GetMapping(&quot;/index.html&quot;)</span><br><span class="line">    public String hello(String code, Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;msg&quot;, tokenTask.getData(code));</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在此处的HelloController类中定义了一个hello方法，该方法用于访问<code>/index.html</code>接口。可以看到此时我们是通过调用<code>tokenTask.getData()</code>方法来获取对应的信息。</p><p>接着我们新建一个component包，并在该包内新建一个TokenTask类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TokenTask &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public String access_token = &quot;&quot;;</span><br><span class="line">    public String refresh_token = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public String getData(String code) &#123;</span><br><span class="line">        if (&quot;&quot;.equals(access_token) &amp;&amp; code != null) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(&quot;code&quot;, code);</span><br><span class="line">            map.add(&quot;client_id&quot;, &quot;envythink&quot;);</span><br><span class="line">            map.add(&quot;client_secret&quot;, &quot;1234&quot;);</span><br><span class="line">            map.add(&quot;redirect_uri&quot;, &quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">            map.add(&quot;grant_type&quot;, &quot;authorization_code&quot;);</span><br><span class="line">            Map&lt;String, String&gt; resp = restTemplate.postForObject(&quot;http://127.0.0.1:8080/oauth/token&quot;, map, Map.class);</span><br><span class="line">            access_token = resp.get(&quot;access_token&quot;);</span><br><span class="line">            refresh_token = resp.get(&quot;refresh_token&quot;);</span><br><span class="line">            return loadDataFromResServer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return loadDataFromResServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String loadDataFromResServer() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HttpHeaders headers = new HttpHeaders();</span><br><span class="line">            headers.add(&quot;Authorization&quot;, &quot;Bearer &quot; + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(&quot;http://127.0.0.1:8081/admin/hello&quot;, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            return entity.getBody();</span><br><span class="line">        &#125; catch (RestClientException e) &#123;</span><br><span class="line">            return &quot;未加载&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Scheduled(cron = &quot;0 55 0/1 * * ？&quot;)</span><br><span class="line">    public void tokenTask() &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add(&quot;client_id&quot;, &quot;envythink&quot;);</span><br><span class="line">        map.add(&quot;client_secret&quot;, &quot;1234&quot;);</span><br><span class="line">        map.add(&quot;refresh_token&quot;, refresh_token);</span><br><span class="line">        map.add(&quot;grant_type&quot;, &quot;refresh_token&quot;);</span><br><span class="line">        Map&lt;String, String&gt; resp = restTemplate.postForObject(&quot;http://127.0.0.1:8080/oauth/token&quot;, map, Map.class);</span><br><span class="line">        access_token = resp.get(&quot;access_token&quot;);</span><br><span class="line">        refresh_token = resp.get(&quot;refresh_token&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析，在<code>getData()</code>方法中，当<code>access_token</code>为空字符串且code不为空时，说明此时是刚拿到授权码的时候，准备去申请令牌了。在拿到令牌之后，将<code>access_token</code>和<code>refresh_token</code>分别赋值给全局变量，之后调用<code>loadDataFromResServer()</code>方法去资源服务器请求资源。</p><p>除此之外，这里还定义了一个<code>tokenTask()</code>方法，这是一个定时任务，每隔115分钟去刷新<code>access_token</code>，注意笔者将<code>access_token</code>的有效期设置为120分钟了。</p><p>之后就是启动项目进行测试了，由于这个过程较为简单，因此这里就直接跳过。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;一般来说，&lt;code&gt;access_token&lt;/code&gt;令牌肯定不会像之前那样存在内存中，通常我们都会将其存入Redis</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的客户端模式实例</title>
    <link href="http://envyzhan.asia/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/"/>
    <id>http://envyzhan.asia/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/</id>
    <published>2021-01-07T11:23:04.000Z</published>
    <updated>2021-03-01T03:50:55.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究客户端模式，深入理解其中的各个流程。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>客户端模式又称为凭证式模式，当某些应用是纯后端应用没有前端时，就可以使用客户端模式，即在命令行下请求令牌。客户端模式是指客户端使用自己的名义而不是用户的名义向服务器提供者申请授权。严格来说，客户端模式并不能算作OAuth协议要解决的问题的一种解决方案，但是对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是较为方便的。它涉及到资源所有者、客户端（第三方应用）、授权服务器和资源服务器这三个角色。客户端模式涉及到的各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>client</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>client</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一步</strong>，将<strong>父工程<code>client</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;client&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0客户端模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;envy&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;admin&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;hello&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时对其他页面访问我们没有进行权限控制。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore()&#123;</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices()&#123;</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;</span><br><span class="line">        security.checkTokenAccess(&quot;permitAll()&quot;)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(&quot;envythink&quot;).secret(new BCryptPasswordEncoder().encode(&quot;1234&quot;))</span><br><span class="line">                .resourceIds(&quot;res1&quot;).authorizedGrantTypes(&quot;refresh_token&quot;,&quot;client_credentials&quot;)</span><br><span class="line">                .scopes(&quot;all&quot;).redirectUris(&quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices()&#123;</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>client_credentials</code>。</strong><br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>client</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>client</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices()&#123;</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(&quot;http://127.0.0.1:8080/oauth/check_token&quot;);</span><br><span class="line">        services.setClientId(&quot;envythink&quot;);</span><br><span class="line">        services.setClientSecret(&quot;1234&quot;);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span><br><span class="line">        resources.resourceId(&quot;res1&quot;).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;admin/hello&quot;)</span><br><span class="line">    public String admin()&#123;</span><br><span class="line">        return &quot;admin&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>client</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下三个依赖：Web和Thymeleaf依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>client</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 客户端模式实例&lt;/h1&gt;</span><br><span class="line">&lt;a href=&quot;http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html&quot;&gt;第三方登录&lt;/a&gt;</span><br><span class="line">&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>该页面的意思是点击超链接，就可以实现第三方登录，超链接中的参数如下所示：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为code，表示响应一个授权码。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scop</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个h1标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在h1标签中显示出来。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/index.html&quot;)</span><br><span class="line">    public String hello(String code, Model model)&#123;</span><br><span class="line">        if(code!=null)&#123;</span><br><span class="line">            MultiValueMap&lt;String,String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(&quot;code&quot;,code);</span><br><span class="line">            map.add(&quot;client_id&quot;, &quot;envythink&quot;);</span><br><span class="line">            map.add(&quot;client_secret&quot;,&quot;1234&quot;);</span><br><span class="line">            map.add(&quot;redirect_uri&quot;,&quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">            map.add(&quot;grant_type&quot;,&quot;authorization_code&quot;);</span><br><span class="line">            Map&lt;String,String&gt; respMap= restTemplate.postForObject(&quot;http://127.0.0.1:8080/oauth/token&quot;,map, Map.class);</span><br><span class="line">            String access_token = respMap.get(&quot;access_token&quot;);</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line"></span><br><span class="line">            HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">            httpHeaders.add(&quot;Authorization&quot;,&quot;Bearer&quot;+access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(httpHeaders);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(&quot;http://127.0.0.1:8081/admin/hello&quot;, HttpMethod.GET,httpEntity,String.class);</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,entity.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在此处的HelloController类中先定义了一个hello方法，该方法用于访问<code>/login.html</code>接口。接着定义了一个login方法，该方法用于处理<code>/login</code>接口，它通过使用restTemplate对象来发送一个POST请求，请注意在此POST请求中的<code>grant_type</code>参数的值为client_credentials，表示此为客户端模式。通过这个POST请求，我们可以获取授权服务器返回的<code>access_token</code>信息。之后我们就提取出<code>access_token</code>信息，并再次使用restTemplate对象来发送一个GET请求去访问资源服务器，并将获取到的数据放在model中进行返回。</p><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></table></figure><p>请注意，如果在上面提示缺少一个<code>RestTemplate</code>对象，那么就需要开发者自行提供一个Bean方法用于返回一个<code>RestTemplate</code>实例。以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来在<code>client-app</code>项目的测试文件中新建一个contextLoads方法，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class ClientAppApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add(&quot;client_id&quot;, &quot;envythink&quot;);</span><br><span class="line">        map.add(&quot;client_secret&quot;, &quot;1234&quot;);</span><br><span class="line">        map.add(&quot;grant_type&quot;, &quot;client_credentials&quot;);</span><br><span class="line">        Map&lt;String, String&gt; resp = restTemplate.postForObject(&quot;http://127.0.0.1:8080/oauth/token&quot;, map, Map.class);</span><br><span class="line">        String access_token = resp.get(&quot;access_token&quot;);</span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        headers.add(&quot;Authorization&quot;, &quot;Bearer &quot; + access_token);</span><br><span class="line">        HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(headers);</span><br><span class="line">        ResponseEntity&lt;String&gt; entity = restTemplate.exchange(&quot;http://127.0.0.1:8081/hello&quot;, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">        System.out.println(entity.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再运行该方法，当控制台输出hello字样时，则表明项目测试通过了。这样就说明我们的授权码模式实例就配置成功了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究客户端模式，深入理解其中的各个流程。&lt;/</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的密码模式实例</title>
    <link href="http://envyzhan.asia/2021/01/05/oauth2-5-a-complete-example-of-password-pattern/"/>
    <id>http://envyzhan.asia/2021/01/05/oauth2-5-a-complete-example-of-password-pattern/</id>
    <published>2021-01-05T11:23:04.000Z</published>
    <updated>2021-03-01T03:50:28.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究密码模式，深入理解其中的各个流程。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>密码模式是用户把用户密码直接告诉客户端（第三方应用），客户端使用这些信息向授权服务器申请令牌。这就需要用户对客户端高度信任，如客户端和服务提供商是同一家公司。它涉及到资源所有者、客户端（第三方应用）、授权服务器和资源服务器这四个角色。由于用户就是笔者，因此无需提供项目实例，而其他三者这里就提供各自的项目实例，各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>password</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>password</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一步</strong>，将<strong>父工程<code>password</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;password&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;password&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0密码模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception &#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;envy&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;admin&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;hello&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and().formLogin()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时此处提供了一个<code>authenticationManagerBean()</code>方法，该方法用于返回一个<code>AuthenticationManager</code>对象，因为使用了密码模式就要求用户输入密码，那么就需要对密码进行验证。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore()&#123;</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@EnableAuthorizationServer</span><br><span class="line">@Configuration</span><br><span class="line">public class AuthorizationServerConfig  extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices()&#123;</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;</span><br><span class="line">        security.checkTokenAccess(&quot;permitAll()&quot;)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(&quot;envythink&quot;).secret(new BCryptPasswordEncoder().encode(&quot;1234&quot;))</span><br><span class="line">                .resourceIds(&quot;res1&quot;).authorizedGrantTypes(&quot;password&quot;,&quot;refresh_token&quot;)</span><br><span class="line">                .scopes(&quot;all&quot;).redirectUris(&quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>password</code>，表示使用密码模式。</strong><br>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。<strong>首先注入之前在<code>SecurityConfig</code>类中定义的<code>AuthenticationManager</code>实例对象，接着去掉之前在授权码模式中添加的<code>AuthorizationCodeServices</code>配置，采用刚刚注入的<code>AuthenticationManager</code>实例对象。先调用<code>authenticationManager()</code>方法将注入的<code>AuthenticationManager</code>实例对象设置进去。</strong>接着调用<code>tokenServices()</code>方法，来配置token的存储位置。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>在完成了授权服务器的搭建工作之后，接下来开始搭建资源服务器。如果用户的项目属于中小型时，那么通常都会将资源服务器和授权服务器放在一起，但是如果是大型项目，那么都会将两者进行分离。因此本篇就假设用户正在开发的是大型项目，就将两者进行分离。</p><p>资源服务器，顾名思义就是用来存放用户的资源，这里就是用户的基本信息，如使用微信登录，那么就可能是头像、姓名、openid等信息。用户从授权服务器上获取到<code>access_token</code>之后，接着就会通过<code>access_token</code>去资源服务器上获取数据。</p><p><strong>第一步</strong>，在<code>password</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>password</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>user-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices()&#123;</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(&quot;http://127.0.0.1:8080/oauth/check_token&quot;);</span><br><span class="line">        services.setClientId(&quot;envythink&quot;);</span><br><span class="line">        services.setClientSecret(&quot;1234&quot;);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span><br><span class="line">        resources.resourceId(&quot;res1&quot;).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<br><strong>第四步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。在项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;admin/hello&quot;)</span><br><span class="line">    public String admin()&#123;</span><br><span class="line">        return &quot;admin&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p><strong>第一步</strong>，在<code>password</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择如下两个依赖：Web和Thymeleaf依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>password</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/templates</code>目录下新建一个<code>login.html</code>文件，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=&quot;text-align: center&quot;&gt;</span><br><span class="line">    &lt;h1&gt;你好余思！&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;用户名：&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;密码：&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;button type=&quot;submit&quot; value=&quot;登录&quot;&gt;登录&lt;/button&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看到此处定义了一个登陆页面，内容非常简单，因此就不过多介绍。<br><strong>第四步</strong>，回到子模块<code>client-app</code>中，在其项目目录下新建一个controller包，并在该包内新建一个<code>HelloController</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/index.html&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/login&quot;)</span><br><span class="line">    public String login(String username, String password, Model model)&#123;</span><br><span class="line">        MultiValueMap&lt;String,String&gt; map =new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        map.add(&quot;username&quot;,username);</span><br><span class="line">        map.add(&quot;password&quot;,password);</span><br><span class="line">        map.add(&quot;client_secret&quot;,&quot;1234&quot;);</span><br><span class="line">        map.add(&quot;client_id&quot;,&quot;envythink&quot;);</span><br><span class="line">        map.add(&quot;grant_type&quot;,&quot;password&quot;);</span><br><span class="line">        Map&lt;String,String&gt; respMap= restTemplate.postForObject(&quot;http://127.0.0.1:8080/oauth/token&quot;,map, Map.class);</span><br><span class="line">        String access_token = respMap.get(&quot;access_token&quot;);</span><br><span class="line">        System.out.println(access_token);</span><br><span class="line"></span><br><span class="line">        HttpHeaders httpHeaders = new HttpHeaders();</span><br><span class="line">        httpHeaders.add(&quot;Authorization&quot;,&quot;Bearer&quot;+access_token);</span><br><span class="line">        HttpEntity&lt;Object&gt; httpEntity = new HttpEntity&lt;&gt;(httpHeaders);</span><br><span class="line">        ResponseEntity&lt;String&gt; entity = restTemplate.exchange(&quot;http://127.0.0.1:8081/admin/hello&quot;, HttpMethod.GET,httpEntity,String.class);</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,entity.getBody());</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在此处的HelloController类中先定义了一个hello方法，该方法用于访问<code>/login.html</code>接口。接着定义了一个login方法，该方法用于处理<code>/login</code>接口，也就是之前提交表单之后的逻辑。也就是先获取用户提交的信息，然后通过使用restTemplate对象来发送一个POST请求，请注意在此POST请求中的<code>grant_type</code>参数的值为password，表示此为密码模式。通过这个POST请求，我们可以获取授权服务器返回的<code>access_token</code>信息，就像下面这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;access_token=2c54bdde-0f8b-4af0-98f2-39d381972fcd,token_type=bearer,refresh_token=9r82beif-9e6h-5y8i-93f6-93gy77uiw59d,expires_in=7199,scope=all&#125;</span><br></pre></td></tr></table></figure><p>之后我们就提取出<code>access_token</code>信息，并再次使用restTemplate对象来发送一个GET请求去访问资源服务器，并将获取到的数据放在model中进行返回。<br><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></table></figure><p>请注意，如果在上面提示缺少一个<code>RestTemplate</code>对象，那么就需要开发者自行提供一个Bean方法用于返回一个<code>RestTemplate</code>实例。以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来打开浏览器，访问<code>http://127.0.0.1:8082/index.html</code>链接，此时页面显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c0d21b4be6cf5b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后用户输入在授权服务器中配置的用户信息，之后点击登录按钮进行登录，登录成功后的页面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f6043832eea1d876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到其下方多出了一个admin字段，这其实就是<code>/admin/hello</code>接口提供的信息。这样就说明我们的密码模式实例就配置成功了。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们对OAuth2.0中四种授权模式进行了学习，接下来将通过一个完整的实例来研究密码模式，深入理解其中的各个流程。&lt;/p</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>一个完整的简化模式实例</title>
    <link href="http://envyzhan.asia/2021/01/03/oauth2-4-a-complete-example-of-simple-pattern/"/>
    <id>http://envyzhan.asia/2021/01/03/oauth2-4-a-complete-example-of-simple-pattern/</id>
    <published>2021-01-03T11:23:04.000Z</published>
    <updated>2021-03-01T03:47:38.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前面我们搭建了一个完整的授权码模式实例，接下来就尝试搭建另一个完整的模式实例—简化模式。考虑到后续学习的方便性，这里选择从零开始搭建，而非在此前授权码模式的基础上进行修改，这样能更加直观感受到简化模式和授权码模式的区别。注意所有加粗的地方均表示简化模式与授权码模式的区别，也就是不同之处。</p><h1 id="实例架构"><a href="#实例架构" class="headerlink" title="实例架构"></a>实例架构</h1><p>简化模式又称为隐藏式模式，当某些Web应用是纯前端应用没有后端时，就可以使用简化模式。简化模式允许授权服务器直接向前端颁发令牌，这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。它的特点就是通过客户端的服务器与授权服务器进行交互，涉及到资源所有者（用户）、客户端（第三方应用）、授权服务器和资源服务器这四个角色。由于用户就是笔者，因此无需提供项目实例，而其他三者这里就提供各自的项目实例，各实例项目名称、角色名称和端口如下表所示：</p><table><thead><tr><th align="center">项目名称</th><th align="center">角色名称</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">auth-server</td><td align="center">授权服务器</td><td align="center">8080</td></tr><tr><td align="center">user-server</td><td align="center">资源服务器</td><td align="center">8081</td></tr><tr><td align="center">client-app</td><td align="center">客户端（第三方应用）</td><td align="center">8082</td></tr></tbody></table><h1 id="空Maven父工程搭建"><a href="#空Maven父工程搭建" class="headerlink" title="空Maven父工程搭建"></a>空Maven父工程搭建</h1><p>使用Maven新建一个空白的父工程，名称为<code>implicit</code>，之后我们将在这个父工程中搭建子项目。</p><h1 id="授权服务器搭建"><a href="#授权服务器搭建" class="headerlink" title="授权服务器搭建"></a>授权服务器搭建</h1><p>在<code>implicit</code>父工程中新建一个子模块，名称为<code>auth-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-e699e9ca7c147de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-37a39f2a694b7aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第一步</strong>，将<strong>父工程<code>implicit</code>项目</strong>的pom.xml依赖文件修改为如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.envy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;implicit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;implicit&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;OAuth2.0简化模式实例&lt;/description&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>，回到子模块<code>auth-server</code>中，在其项目目录下新建一个config包，之后在该类中新建一个<code>SecurityConfig</code>类，注意这个类需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;envy&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;admin&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;hello&quot;).password(new BCryptPasswordEncoder().encode(&quot;1234&quot;)).roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意由于本系列笔记主要是学习如何使用OAuth2.0，因此不会详细介绍Spring Security的相关知识。这里出于简单起见，并没有将用户存入数据库中，而是直接存在内存中。此处首先提供了一个密码加密PasswordEncoder类的实例，之后在其中定义了两个用户，并定义了他们的用户名、密码和对应角色。接着还使用了系统默认的登录表单，这样便于后续用户登录。举个例子，开发者想让微信登录第三方网站，那么这有一个前提就是得让用户先登录微信，而登录微信需要用户名和密码，因此此处配置的其实就是用户登录所需的信息。<strong>同时对其他页面访问我们没有进行权限控制。</strong></p><p><strong>第三步</strong>，在完成了用户的基本信息配置后，接下来开始配置授权服务器。在config包内新建一个<code>AccessTokenConfig</code>类，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AccessTokenConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    TokenStore tokenStore()&#123;</span><br><span class="line">        return new InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里我们需要提供一个<code>TokenStore</code>实例，该实例表示将生成的token存放在何处，可以将其存在Redis中，内存中，也可以将其存储在数据库中。其实这个<code>TokenStore</code>是一个接口，它有很多实现类，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-c3bf6cecf52a2847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>出于简单考虑，这里依旧将其存入内存中，故选择使用<code>InMemoryTokenStore</code>这一实现类。</p><p>接着在config包内新建一个<code>AuthorizationServerConfig</code>类，注意这个类需要继承<code>AuthorizationServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer</span><br><span class="line">public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TokenStore tokenStore;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationServerTokenServices tokenServices()&#123;</span><br><span class="line">        DefaultTokenServices services = new DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(true);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(60*60*2);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(60*60*24*3);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;</span><br><span class="line">        security.checkTokenAccess(&quot;permitAll()&quot;)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(&quot;envythink&quot;).secret(new BCryptPasswordEncoder().encode(&quot;1234&quot;))</span><br><span class="line">                .resourceIds(&quot;res1&quot;).authorizedGrantTypes(&quot;refresh_token&quot;,&quot;implicit&quot;)</span><br><span class="line">                .scopes(&quot;all&quot;).redirectUris(&quot;http://127.0.0.1:8082/index.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    AuthorizationCodeServices authorizationCodeServices()&#123;</span><br><span class="line">        return new InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices()).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>AuthorizationServerConfig</code>类，并继承<code>AuthorizationServerConfigurerAdapter</code>类，用来对授权服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableAuthorizationServer</code>注解，表示开启授权服务器的自动化配置。<br>（2）在自定义的<code>AuthorizationServerConfig</code>类中重写三个方法，这些方法分别用于对令牌端点安全、客户端信息、令牌访问端点和服务等内容进行详细配置。<br>（3）重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>方法，该方法用于配置令牌端点的安全约束，即这个端点谁能访问，谁不能访问。接着我们调用<code>checkTokenAccess()</code>方法，里面设置值为<code>permitAll()</code>，表示该端点可以直接访问（后面当资源服务器收到token之后，需要校验token是否合法，此时就会访问这个端点）。查看源码可以知道该值默认为<code>denyAll()</code>表示都拒绝。<br>（4）重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，该方法用于配置客户端的详细信息。在前面我们说过，授权服务器会进行两个方面的校验，一是校验客户端；而是校验用户。我们知道Spring Security与用户存储相关的类是<code>UserDetailsService</code>，由于我们将用户直接保持在内存中，因此系统默认就会通过这个类去校验用户。那么接下来就是校验客户端，需要注入<code>ClientDetailsService</code>对象。这里其实就是配置客户端的信息，同样出于简单考虑，这里依旧将其配置到内存中。此处配置了客户端的id、secret、资源id、授权类型、授权范围以及重定向URL。<strong>可以看到此处的<code>authorizedGrantTypes</code>参数的值已经变成了<code>implicit</code>。</strong></p><p>（5）重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法，该方法用于配置令牌的访问端点和令牌服务。首先调用<code>authorizationCodeServices</code>方法来配置授权码的存储位置，由于我们是存储在内存中，因此需要提供一个返回<code>AuthorizationCodeServices</code>实例的方法，当然了更准确的说我们是返回一个<code>InMemoryAuthorizationCodeServices</code>对象。接着调用<code>tokenServices()</code>方法，来配置token的存储位置。授权码(<code>authorization_code</code>)和令牌(<code>token</code>)是有区别的，授权码用于获取令牌，使用一次就会失效；而令牌则用来获取资源。<br>（6）请注意，前面我们定义了<code>tokenStore()</code>方法，该方法仅仅是配置了token的存储位置，但是对于token并没有进行设置。接下来需要提供一个<code>AuthorizationServerTokenServices</code>实例，开发者可以在该实例中配置token的基本信息，如token是否支持刷新、token的存储位置、token的过期时间以及刷新token的有效期。所谓的“刷新token的有效期”是指当token快要过期的时候，我们肯定是需要获取一个新的token，而在获取新的token的时候，需要有一个凭证信息，注意这个凭证信息不是旧的token，而是另外一个<code>refresh_token</code>，而这个<code>refresh_token</code>也是有有效期的。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>以上就是授权服务器的搭建工作，那么接下来就启动该授权服务器。</p><h1 id="资源服务器搭建"><a href="#资源服务器搭建" class="headerlink" title="资源服务器搭建"></a>资源服务器搭建</h1><p>由于简化模式不存在服务端，因此我们只能通过使用js来请求资源服务器上的数据，故资源服务器需要支持跨域。</p><p><strong>第一步</strong>，在<code>implicit</code>父工程中新建一个子模块，名称为<code>user-server</code>，在选择依赖的时候选择如下三个依赖：Web、Spring Cloud Security和Spring Cloud OAuth2依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-f638d7ab13642611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-92d8f12fdc4f420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>implicit</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，既然是资源服务器，那么我们就需要提供资源，这里提供两个接口。回到子模块<code>user-server</code>中，在其项目目录下新建一个controller包，之后在该类中新建一个<code>HelloController</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@CrossOrigin(value = &quot;*&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;admin/hello&quot;)</span><br><span class="line">    public String admin()&#123;</span><br><span class="line">        return &quot;admin&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到此处在<code>HelloController</code>类上添加了<code>@CrossOrigin(value = &quot;*&quot;)</code>注解，表示在Spring Boot中对访问该类下所有接口都允许跨域，注意允许任何域访问。</strong><br><strong>第四步</strong>，其项目目录下新建一个config包，之后在该类中新建一个<code>ResourceServerConfig</code>类，注意这个类需要继承<code>ResourceServerConfigurerAdapter</code>类，里面的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">public class ResourceServerConfig  extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    RemoteTokenServices tokenServices()&#123;</span><br><span class="line">        RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(&quot;http://127.0.0.1:8080/oauth/check_token&quot;);</span><br><span class="line">        services.setClientId(&quot;envythink&quot;);</span><br><span class="line">        services.setClientSecret(&quot;1234&quot;);</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resources) throws Exception &#123;</span><br><span class="line">        resources.resourceId(&quot;res1&quot;).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对上述代码进行分析：<br>（1）自定义<code>ResourceServerConfig</code>类，并继承<code>ResourceServerConfigurerAdapter</code>类，用来对资源服务器做更为详细的配置。请注意，此时需要在该类上添加<code>@EnableResourceServer</code>注解，表示开启资源服务器的自动化配置。<br>（2）在自定义的<code>ResourceServerConfig</code>类中重写两个方法，这些方法分别用于对资源信息和页面访问等内容进行详细配置。<br>（3）重写<code>configure(ResourceServerSecurityConfigurer resources)</code>方法，该方法用于对资源进行配置。这里配置了资源的id，同时调用<code>tokenServices()</code>来配置token的存储位置。由于此处将资源服务器和授权服务器进行了分离，因此需要提供一个<code>RemoteTokenServices</code>对象，言外之意就是当资源服务器和授权服务器放在一起时，就不必提供一个<code>RemoteTokenServices</code>对象。<br>（4）我们定义了一个<code>tokenServices()</code>方法，该方法用于返回（3）中所需要的<code>RemoteTokenServices</code>对象，在<code>RemoteTokenServices</code>对象中，我们配置了<code>access_token</code>的的校验地址、客户端id，客户端秘钥等，其实这就是授权服务器的地址信息。这样当用户来资源服务器请求资源时，会携带一个<code>access_token</code>，通过此处的配置，它就能检验这个token是否正确。<br>（5）重写<code>configure(HttpSecurity http)</code>方法，该方法用于对访问页面进行配置。其实就是对资源进行拦截，这里就是判断当用户访问URL是以<code>/admin</code>开头的时候，需要用户具备admin角色才能访问。<strong>同时添加了<code>.cors()</code>选项用于开始Spring Security对于跨域的支持。（此处的SpringSecurity跨域配置是在Spring Boot支持跨域的基础上进行的。）</strong><br><strong>第五步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>以上就是资源服务器的搭建工作，那么接下来就启动该资源服务器。</p><h1 id="客户端（第三方应用）搭建"><a href="#客户端（第三方应用）搭建" class="headerlink" title="客户端（第三方应用）搭建"></a>客户端（第三方应用）搭建</h1><p>请注意，客户端（第三方应用）并非必须的，开发者可以使用诸如Postman等测试工具来进行测试。此处为了案例的完整性，依旧搭建了一个普通的Spring Boot项目。</p><p>前面也说了由于简化模式不存在服务端，因此第三方应用就只能通过使用js来请求资源服务器上的数据。</p><p><strong>第一步</strong>，在<code>implicit</code>父工程中新建一个子模块，名称为<code>client-app</code>，在选择依赖的时候选择Web依赖：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-4dfd7292f52e05d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><strong>第二步</strong>，在父工程<code>implicit</code>项目的pom.xml依赖文件中新增如下所示配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">    &lt;module&gt;auth-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;user-server&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;client-app&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure><p><strong>第三步</strong>，回到子模块<code>client-app</code>中，在其<code>resources/static</code>目录下新建一个<code>index.html</code>文件，其中的代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;/jquery-3.5.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎来到OAth2.0 简化模式实例&lt;/h1&gt;</span><br><span class="line">&lt;a href=&quot;http://127.0.0.1:8080/oauth/authorize?client_id=envythink&amp;response_type=token&amp;scope=all&amp;redirect_uri=http://127.0.0.1:8082/index.html&quot;&gt;第三方登录(简化模式)&lt;/a&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var hash = window.location.hash;//提取出参数，类似这种格式#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582&amp;token_type=bearer&amp;expires_in=7199</span><br><span class="line">    if(hash &amp;&amp; hash.length&gt;0)&#123;</span><br><span class="line">        var params = hash.substring(1).split(&quot;&amp;&quot;);//#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582</span><br><span class="line">        var token = params[0].split(&quot;=&quot;);//[access_token,b1740984-3d4a-4b64-8509-9891a4d6a582]</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &#x27;get&#x27;,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                &#x27;Authorization&#x27;: &#x27;Bearer&#x27;+ token[1]</span><br><span class="line">            &#125;,</span><br><span class="line">            url: &#x27;http://127.0.0.1:8081/admin/hello&#x27;,</span><br><span class="line">            success: function (msg)&#123;</span><br><span class="line">                $(&quot;#app&quot;).html(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>请注意<code>resources/static</code>目录下的文件是不需要经过控制器就能访问的。接下来解释该页面代码的含义：<br>（1）<code>client_id</code>表示客户端id，这个需要开发者根据授权服务器中的实际配置来进行设置。<br>（2）<code>response_type</code>表示响应类型，此处设置为token，表示响应一个令牌。<br>（3）<code>redirect_uri</code>表示授权成功后的重定向地址，这里设置了跳转到第三方应用的首页。<br>（4）<code>scope</code>表示授权的范围，此处值为all。<br>可以看到上述html页面中还存在一个id为app的标签，注意该标签中的数据来源于资源服务器。当授权服务器通过后，我们就可以通过ajax拿着<code>access_token</code>去资源服务器上请求数据，去加载资源，这样加载到的数据就会在id为app的标签中显示出来。</p><p>也就是说当用户登录成功后，会自动重定向到<code>http://127.0.0.1:8082/index.html</code>页面，并在该链接中添加一个锚点参数，类似于如下所示的URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8082/index.html#access_token=b1740984-3d4a-4b64-8509-9891a4d6a582&amp;token_type=bearer&amp;expires_in=7199</span><br></pre></td></tr></table></figure><p>因此我们需要使用js来提取出<code>#</code>后面的参数，并进一步解析出<code>access_token</code>参数的值。之后我们将<code>access_token</code>参数放在请求头中，并发起一个ajax请求，并将获取到的数据在id为app的标签中显示出来。</p><p><strong>第四步</strong>，在项目<code>application.properties</code>配置文件中新增如下用于配置项目端口的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8082</span><br></pre></td></tr></table></figure><p>以上就是客户端（第三方应用）的搭建工作，那么接下来就启动该客户端（第三方应用）。</p><h1 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h1><p>在确认三个项目都已经正确启动之后，接下来打开浏览器，访问<code>http://127.0.0.1:8082/index.html</code>链接，此时页面显示如下信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-1a0bece75b048efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>接着点击第三方登录这一超链接，之后页面会跳转到授权服务器的默认登录页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-666a83f8434afd40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>然后用户输入在授权服务器中配置的用户信息，之后点击登录按钮进行登录，登录成功后的页面如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-aa58d40fe2c976b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在上述页面中出现了一个提示，询问是否授权“envythink”这一用户去访问被保护的资源。我们点击Approve也就是批准，之后点击下方的Authorize按钮，此时页面就会自动跳转到第三方页面中：</p><p><img src="https://upload-images.jianshu.io/upload_images/8964398-9413bd760e69932c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>注意看，可以发现此时的地址栏中多了锚点参数，里面包含了<code>access_token</code>，之后就携带这个<code>access_token</code>参数向资源服务器发起ajax请求来获取<code>/admin/hello</code>接口的信息，页面就会显示出一个admin信息。</p><p>（完）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;前面我们搭建了一个完整的授权码模式实例，接下来就尝试搭建另一个完整的模式实例—简化模式。考虑到后续学习的方便性，这里选择从零</summary>
      
    
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/categories/OAuth2/"/>
    
    
    <category term="OAuth2" scheme="http://envyzhan.asia/tags/OAuth2/"/>
    
  </entry>
  
</feed>
