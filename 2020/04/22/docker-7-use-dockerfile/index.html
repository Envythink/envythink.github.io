<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>使用Dockerfile | 余思博客</title><meta name="keywords" content="docker"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面在前面我们简单提到了如何使用Dockerfile文件来创建镜像，鉴于这种方式在日常工作中使用的较为频繁，因此这里专门拿出一篇文章来研究如何使用Dockerfile配置文件来创建镜像。这里会介绍Dockerfile比较典型的基本结构及其支持的众多指令，然后通过这些指令来编写定制镜像的Dockerfile文件，接着便使用该Dockerfile文件来生成镜像，最后会结合笔者自身工作经验来谈谈一些">
<meta property="og:type" content="article">
<meta property="og:title" content="使用Dockerfile">
<meta property="og:url" content="http://envyzhan.asia/2020/04/22/docker-7-use-dockerfile/index.html">
<meta property="og:site_name" content="余思博客">
<meta property="og:description" content="写在前面在前面我们简单提到了如何使用Dockerfile文件来创建镜像，鉴于这种方式在日常工作中使用的较为频繁，因此这里专门拿出一篇文章来研究如何使用Dockerfile配置文件来创建镜像。这里会介绍Dockerfile比较典型的基本结构及其支持的众多指令，然后通过这些指令来编写定制镜像的Dockerfile文件，接着便使用该Dockerfile文件来生成镜像，最后会结合笔者自身工作经验来谈谈一些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png">
<meta property="article:published_time" content="2020-04-22T11:23:04.000Z">
<meta property="article:modified_time" content="2020-11-01T13:14:39.834Z">
<meta property="article:author" content="余思">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://envyzhan.asia/2020/04/22/docker-7-use-dockerfile/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用Dockerfile',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-01 21:14:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="余思博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">249</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">余思博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用Dockerfile</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-22T11:23:04.000Z" title="发表于 2020-04-22 19:23:04">2020-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-01T13:14:39.834Z" title="更新于 2020-11-01 21:14:39">2020-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/docker/">docker</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们简单提到了如何使用Dockerfile文件来创建镜像，鉴于这种方式在日常工作中使用的较为频繁，因此这里专门拿出一篇文章来研究如何使用Dockerfile配置文件来创建镜像。这里会介绍Dockerfile比较典型的基本结构及其支持的众多指令，然后通过这些指令来编写定制镜像的Dockerfile文件，接着便使用该Dockerfile文件来生成镜像，最后会结合笔者自身工作经验来谈谈一些使用Dockerfile的最佳实践。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile是一个由一组指令组成的文本格式的配置文件，其中的每条指令对应Linux中的一条命令，它可以利用给定的指令描述基于某个父镜像来创建新镜像。Dockerfile是由一行行命令语句组成，并且支持以<code>#</code>号开头的注释行。</p>
<p>一般来说，Dockerfile主体内容分为4个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>
<p>下面是一个开源的名为renren-fast的项目构建使用的Dockerfile文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD renren-fast.jar  /app.jar</span><br><span class="line">RUN bash -c &#x27;touch /app.jar&#x27;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>
<h1 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h1><p>Dockerfile中指令的格式一般为<code>INSTRUCTION arguments</code>，它包括“配置指令”（配置镜像信息）和“操作指令”（执行具体操作）这两部分，如下表所示：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>配置指令</td>
<td>ARG</td>
<td>定义创建镜像过程中使用的变量</td>
</tr>
<tr>
<td>配置指令</td>
<td>FROM</td>
<td>指定所创建镜像的基础镜像</td>
</tr>
<tr>
<td>配置指令</td>
<td>LABEL</td>
<td>为生成的镜像添加元数据标签信息</td>
</tr>
<tr>
<td>配置指令</td>
<td>EXPOSE</td>
<td>声明镜像内服务监听的端口</td>
</tr>
<tr>
<td>配置指令</td>
<td>ENV</td>
<td>指定环境变量</td>
</tr>
<tr>
<td>配置指令</td>
<td>ENTRYPOINT</td>
<td>指定镜像的默认入口命令</td>
</tr>
<tr>
<td>配置指令</td>
<td>VOLUME</td>
<td>创建一个数据卷挂载点</td>
</tr>
<tr>
<td>配置指令</td>
<td>USER</td>
<td>指定运行容器时的用户名或UID</td>
</tr>
<tr>
<td>配置指令</td>
<td>WORKDIR</td>
<td>配置工作目录</td>
</tr>
<tr>
<td>配置指令</td>
<td>ONBUILD</td>
<td>创建子镜像时指定自动执行的操作指令</td>
</tr>
<tr>
<td>配置指令</td>
<td>STOPSIGNAL</td>
<td>指定退出的信号值</td>
</tr>
<tr>
<td>配置指令</td>
<td>HEALTHCHECK</td>
<td>配置所启动容器如何进行健康检查</td>
</tr>
<tr>
<td>配置指令</td>
<td>SHELL</td>
<td>指定默认shell类型</td>
</tr>
<tr>
<td>操作指令</td>
<td>RUN</td>
<td>运行指定命令</td>
</tr>
<tr>
<td>操作指令</td>
<td>CMD</td>
<td>启动容器时指定默认执行的命令</td>
</tr>
<tr>
<td>操作指令</td>
<td>ADD</td>
<td>添加内容到镜像</td>
</tr>
<tr>
<td>操作指令</td>
<td>COPY</td>
<td>复制内容到镜像</td>
</tr>
</tbody></table>
<p>由于这些指令在实际工作中使用的概率非常大，因此接下来将对上述指令进行更为细致的介绍。</p>
<h3 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h3><h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>ARG用于定义创建镜像过程中使用的变量，其对应格式为<code>ARG &lt;name&gt;[=&lt;default value&gt;]</code>。</p>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG envy</span><br><span class="line">ARG name=envythink</span><br></pre></td></tr></table></figure>
<p>当然开发者也可以在执行<code>docker build</code>命令时，通过使用<code>--build-arg=variable</code>参数来为变量赋值。请注意，当镜像编译成功后，ARG指定的变量将不再存在（但是ENV指定的变量依旧存在于镜像中）。</p>
<p>Docker内置了一些镜像创建变量，用户可以直接使用而无须声明，包括（不区分大小写）：HTTP_PROXY、HTTPS_PROXY、FTP_PROXY、NO_PROXY。</p>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>FROM用于指定所创建镜像的基础镜像，其对应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;images&gt; [AS &lt;name&gt;]</span><br><span class="line">FROM &lt;images&gt;:&lt;tag&gt; [AS &lt;name&gt;]</span><br><span class="line">FROM &lt;images&gt;@&lt;digest&gt; [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>上面命令格式中的tag和digest是可选的，开发者如果不使用这两个值时，则默认使用latest版本的基础镜像。</p>
<p><strong>请注意，在任何Dockerfile文件中，FROM必须是第一个指令，而且如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令，但是每个镜像只能使用一次。</strong></p>
<p>举个例子，通常为了保证镜像精简，都会使用体积较小的镜像，如Alpine或者Debian作为基础镜像，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG VERSION=9.6</span><br><span class="line">FROM debian:$&#123;VERSION&#125;</span><br></pre></td></tr></table></figure>
<p>再举个例子，使用MySQL：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM mysql:5.7.21</span><br></pre></td></tr></table></figure>
<h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><p>LABEL用于为生成的镜像添加元数据标签信息，这些信息可以用来辅助过滤出特定的镜像。其对应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;余思博客&quot;</span><br></pre></td></tr></table></figure>
<p>请注意，在使用LABEL指令指定元数据时，一条LABEL指令可以指定一或多条元数据。在指定多条元数据时，不同元数据之间通过空格进行分隔，笔者推荐将所有的元数据通过一条LABEL指令来指定，避免生成过多的中间镜像。</p>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>EXPOSE用于声明镜像内服务监听的端口（或者说指定与外界交互的端口），其对应格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80 443</span><br><span class="line">EXPOSE 8080</span><br><span class="line">EXPOSE 1181/tcp 1181/udp</span><br></pre></td></tr></table></figure>
<p>请注意，该指令只是起到声明作用，并不会自动完成端口映射。如果要将端口映射出来，那么就可以在启动容器的时候使用<code>-P</code>(大写)参数（此时Docker主机会自动分配一个宿主机也就是虚拟机的临时端口），或者使用<code>-p HOST_PORT:CONTAINER_PORT</code>（小写）参数（用于具体指定所映射的本地端口）。</p>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>ENV用于指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在（前面介绍的ARG仅仅存在于镜像创建之前这一过程）。</p>
<p>它有两种格式，之间有一些不同之处。对于下面这种格式来说，<key>之后的所有内容均会被视为其<value>的组成部分，因此一次只能设置一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;  </span><br></pre></td></tr></table></figure>
<p>而对于下面这种格式，由于每个变量采用了<code>&lt;key&gt;=&lt;value&gt;</code>键值对形式，因此可以设置多个变量。如果<key>中包含空格，可以使用<code>\</code>来进行转义，也可以通过””来进行标示，另外反斜线也可以用于续连：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt;=&lt;value&gt; ... </span><br></pre></td></tr></table></figure>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV APP_HOME=/usr/local/app</span><br><span class="line">ENV PATH $PATH:/usr/local/bin</span><br></pre></td></tr></table></figure>
<p>当然上述通过ENV指定的环境变量，可以在运行时被覆盖掉，如<code>docker run --env &lt;key&gt;=&lt;value&gt; envythink_image</code>。</p>
<p>请注意，当一条ENV指令同时为多个环境变量赋值，并且值也是从环境变量中读取时，会为变量都赋值后再更新。举个例子，如下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV key1=value2</span><br><span class="line">ENV key1=value1 key2=$&#123;key1&#125;</span><br></pre></td></tr></table></figure>
<p>此时最终结果为<code>key1=value1 key2=value2</code>。</p>
<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>ENTRYPOINT用于指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令来执行，所有传入值作为该命令的参数。</p>
<p>它有两种命令格式，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec调用执行， 优先)</span><br><span class="line">ENTRYPOINT command param1 param2 (shell内部命令，在shell中执行)</span><br></pre></td></tr></table></figure>
<p>此时CMD指令指定值将作为根命令的参数。</p>
<p>请注意，每个Dockerfile中只能有一个ENTRYPOINT，当指定多个时，只有最后一个才生效。ENTRYPOINT中设置的参数可以在运行时被<code>--entrypoint</code>参数覆盖掉，如<code>docker run --entrypoint</code>。</p>
<p>ENTRYPOINT与CMD非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖ENTRYPOINT，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。</p>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>VOLUME用于创建一个数据卷挂载点或者说是指定一个数据持久化目录。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/path/to/dir&quot;]</span><br></pre></td></tr></table></figure>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br><span class="line">VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache&quot;, &quot;/etc/apache&quot;]</span><br></pre></td></tr></table></figure>
<p>运行容器时，可以从本地主机或者其他容器挂载数据卷，一般用来存放数据库和需要保存的数据。数据卷可以容器间共享和重用；容器不一定要和其他容器共享卷；修改数据卷后会立即生效；对数据卷的修改不会对镜像产生影响；卷会一直存在，直到没有任何容器在使用它。</p>
<h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>USER用于指定运行容器时的用户名或UID，注意后续的RUN等指令也会使用指定的用户身份。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure>
<p>请注意，使用USER指定用户时，可以使用用户名、UID、GID或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在Dockerfile中创建所需要的用户。</p>
<p>举个例子来说，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r envythink &amp;&amp; useradd --no-log-init -r -g envythink envythink </span><br></pre></td></tr></table></figure>
<p>如果需要临时获取管理员权限可以使用gosu命令。</p>
<p>使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过<code>docker run</code>命令运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>WORKDIR用于为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure>
<p>开发者可以使用多个WORKDIR指令，后续命令如果是相对路径，则会基于之前命令指定的路径。举个例子，如下所示；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>那么上面最终会输出路径为<code>/a/b/c</code>，因此为了避免出现路径错误，建议在WORKDIR指令中只使用绝对路径。</p>
<h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>ONBUILD指定当基于所生成镜像创建子镜像时，自动执行的操作指令。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<p>举个例子，使用如下的Dockerfile来创建父镜像ParentImage，此时可以指定ONBUILD指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfile for ParentImage</span><br><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>使用<code>docker build</code>命令创建子镜像ChildImage时（FROM ParentImage），会首先执行ParentImage中配置的ONBUILD指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfile for ChildImage</span><br><span class="line">FROM ParentImage</span><br></pre></td></tr></table></figure>
<p>其实上面就相当于在ChildImage的Dockerfile文件中添加了下面的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Automatically run the following when building ChildImage</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>
<p>由于ONBUILD指令是隐式执行的，因此推荐在使用它的镜像标签中进行标注。举个例子，如<code>ruby:2.2-onbuild</code>。</p>
<p>ONBUILD指令在创建专门用于自动编译、检查等操作的基础镜像时，可以发挥最大作用。</p>
<h5 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h5><p>STOPSIGNAL用于指定所创建镜像启动的容器接收退出的信号值。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>
<h5 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h5><p>HEALTHCHECK用于配置所启动容器如何进行健康检查，即如何判断健康与否，这个是Docker自1.12开始就支持的。它有两种格式，第一种是<code>HEALTHCHECK [OPTIONS] CMD command</code>，可根据所执行命令的返回值是否为0来进行判断；第二种是<code>HEALTHCHECK NONE</code>，用于禁止基础镜像中的健康检查。</p>
<p>需要说明的是，其中的OPTIONS支持如下参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 过多久检查一次</span><br><span class="line">-interval=DURATION（default：30s）</span><br><span class="line"># 每次检查等待结果的超时</span><br><span class="line">-timeout=DURATION（default：30s）</span><br><span class="line"># 如果失败了，重试几次才最终确定失败</span><br><span class="line">-retries=N（default：3）</span><br></pre></td></tr></table></figure>
<h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><p>SHELL所示配置指令中最后一个指令，用于指定其他命令使用shell时的默认shell类型。其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;,&quot;parameters]</span><br></pre></td></tr></table></figure>
<p>其默认值为[“/bin/bash”,”-c”]。请注意，对于Windows系统来说，SHELL路径中使用了<code>\</code>作为分隔符，建议在Dockerfile开头添加`# escape=’``来指定转义符。</p>
<h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>RUN指令用于在镜像容器中执行命令，其对应的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br></pre></td></tr></table></figure>
<p>请注意下面那种指令会被解析为JOSN数组，因此必须使用双引号。前者默认将在SHELL终端中运行命令，也就是<code>/bin/sh -c</code>；后者则使用exec命令来执行，它不会启动SHELL环境。言外之意，如果开发者想指定其他终端类型，那么可以使用后者，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像层。当命令较长时，可以使用<code>\</code>来换行。</strong></p>
<p>请注意，RUN指令创建的中间镜像会被缓存，并在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时添加<code>--no-cache</code>参数。举个例子，如<code>docker build --no-cache</code>这一命令。</p>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>CMD指令在构建容器后调用，用于指定启动容器时默认执行的命令。它支持三种格式，如下所示：<br>（1）<code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>，其实就相当于执行<code>executable param1 param2</code>命令，推荐使用这种方式。<br>（2）<code>CMD command param1 param2</code>，直接在默认的SHELL中执行，提供给需要交互的应用；<br>（3）<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>，提供给ENTRYPOINT的默认参数。</p>
<p>请注意，每个Dockerfile只能有一条CMD命令，如果指定了多条命令，那么只会执行最后一条。如果用户在启动容器的时候，手动指定了运行的命令，也就是作为run命令的参数，那么将会覆盖掉CMD指定的命令。</p>
<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>ADD命令用于添加内容到镜像。其对应的格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>也就是复制指定的<src>路径下的内容到容器中的<dest>路径下，注意后者支持包含空格的路径。</p>
<p>其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；可以是一个URL；也可以是一个tar文件（注意它会被自动解压为目录）。<dest>可以是镜像内的绝对路径，或者相对于工作目录（WORKHOME）的相对路径。</p>
<p>举个例子，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> # 添加所有以&quot;hom&quot;开头的文件</span><br><span class="line">ADD hom* /mydir/</span><br><span class="line"># ? 替代一个单字符,例如：&quot;home.txt&quot;</span><br><span class="line">ADD hom?.txt /mydir/</span><br><span class="line"># 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/</span><br><span class="line">ADD test relativeDir/</span><br><span class="line"># 添加 &quot;test&quot; 到 /absoluteDir/</span><br><span class="line">ADD test /absoluteDir/</span><br></pre></td></tr></table></figure>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>COPY命令用于复制内容到镜像。其对应的格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt; &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>也就是复制本地主机<src>（这里的<src>是Dockerfile所在目录的相对路径，可以是文件或者目录）路径下的内容到容器中的<dest>路径下，当目标路径不存在时就会自动创建。它同样支持正则表达式，可以发现COPY和ADD的指令功能非常相似，当本地目录为源目录，即<src>目录时，推荐使用COPY指令。</p>
<h1 id="Dockfile常用操作指令总结"><a href="#Dockfile常用操作指令总结" class="headerlink" title="Dockfile常用操作指令总结"></a>Dockfile常用操作指令总结</h1><p>接下来对前面介绍的一些常用Dockerfile操作指令进行总结，如下表所示：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FROM镜像</td>
<td>用于指定新镜像所基于的镜像，注意它必须是第一条指令</td>
</tr>
<tr>
<td>MAINTAINER 名字</td>
<td>新镜像的维护人信息</td>
</tr>
<tr>
<td>RUN 命令</td>
<td>在所基于的镜像上执行命令，并提交到新镜像中</td>
</tr>
<tr>
<td>EXPOSE端口号</td>
<td>指定新镜像加载到Docker时开启的端口号</td>
</tr>
<tr>
<td>ENV 环境变量 变量值</td>
<td>设置一个环境变量的值，之后的RUN会使用</td>
</tr>
<tr>
<td>ADD 源文件/目录 目标文件/目录</td>
<td>将源文件复制到目标文件，源文件要与Docker位于同一目录下，或者为一个URL</td>
</tr>
<tr>
<td>COPY 源文件/目录 目标文件/目录</td>
<td>将本地主机上的源文件/目录复制到目标地点，源文件/目录要与Dockerfile在同一目录下</td>
</tr>
<tr>
<td>VOLUME[“目录”]</td>
<td>在容器中创建一个挂载点</td>
</tr>
<tr>
<td>USER 用户名 /UID</td>
<td>指定运行容器时的用户</td>
</tr>
<tr>
<td>WORKDIR 路径</td>
<td>为后续的RUN、CMD、ENTRYPOINT指定工作目录</td>
</tr>
<tr>
<td>ONBUILD命令</td>
<td>指定所生成的镜像作为一个基础镜像时所要运行的命令</td>
</tr>
<tr>
<td>CMD[“要运行的程序”，”参数1”，”参数2”]</td>
<td>指定启动容器时运行的命令或脚本，只能有一条CMD命令，多条时只有最后一条被执行</td>
</tr>
</tbody></table>
<p>举个例子，接下来通过介绍基于envyubuntu:latest镜像来安装Python3，进而构成一个新的<code>python:3</code>镜像，相应的操作如下：</p>
<p>第一步，创建镜像工作目录并切换至该目录，在<code>/home/envythink</code>目录下新建pyhello目录，然后切换至该目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[envythink@localhost ~]$ mkdir pyhello</span><br><span class="line">[envythink@localhost ~]$ cd pyhello/</span><br></pre></td></tr></table></figure>
<p>第二步，在pyhello目录下新建Dockerfile文件，并在里面添加配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#基于ubuntu:latest镜像</span><br><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">#维护人的信息</span><br><span class="line">LABEL version=&quot;1.0&quot; maintainer=&quot;docker envy &lt;envyzhan@aliyun.com&gt;&quot;</span><br><span class="line"></span><br><span class="line">#创建镜像时执行的脚本文件</span><br><span class="line">RUN yum update &amp;&amp; yum install -y python3</span><br></pre></td></tr></table></figure>
<p>第三步，创建镜像。开发者可以使用<code>docker build [image] .</code>命令来创建镜像，编译成功后本地将多出一个<code>python:3</code>的镜像，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t python:3 .</span><br></pre></td></tr></table></figure>
<p>这样我们就通过上述命令创建出一个<code>python:3</code>的镜像。请注意该命令最后面有一个<code>.</code>号，请注意这个<code>.</code>号不是用来指定Dockerfile文件的所在位置，实际上使用<code>-f</code>参数来指定Dockerfile的路径。那么问题来了这个<code>.</code>号的作用是什么？</p>
<p>其实Docker在运行时分为Docker引擎（服务器守护进程）和客户端工具，而当我们使用docker各种命令的时候，其实就是在使用客户端工具与Docker引擎进行交互，而我们在使用<code>docker build</code>命令构建镜像时，其实这个过程是在Docker引擎内完成的，而不是在本地客户端。那么问题来了，如果开发者在Dockerfile中使用了类似于COPY、ADD等指令来操作文件时，Docker引擎是如何获取这些文件呢？</p>
<p>因此这里就有一个镜像构建上下文的概念，当构建镜像的时候，用户来指定构建镜像的上下文路径，而<code>docker build</code>命令会将这个路径下所有的文件都打包上传给Docker引擎，之后Docker引擎将这些内容展开，就能获取到所有指定上下文中的文件。</p>
<p>还记得前面在介绍COPY指令的时候，特别要求源文件要与Dockerfile在同一目录下，如<code>COPY ./hello.txt /test</code>命令，该命令并不是复制本地当前目录下的hello.txt文件，而是docker引擎中展开的构建上下文中的文件，所以如果复制的文件超出了docker引擎中展开的构建上下文的范围，那么docker引擎是无法找到那些文件。综上所述，上述<code>docker build .</code>命令中的<code>.</code>号是指在指定镜像构建过程中的上下文环境的目录。</p>
<p>在理解了这个镜像构建上下文以后，接下来思考这个<code>.dockerignore</code>文件的作用，如果你之前有使用过git，那么肯定可以知道<code>.gitignore</code>文件的作用，它用来配置需要忽略上传的文件或者文件夹信息，因此接着这个设计理念自然可以猜到这个<code>.dockerignore</code>文件就是用于指定在构建镜像过程中的上下文环境目录需要忽略的文件或者文件夹。</p>
<h3 id="Dockerfile文件实例"><a href="#Dockerfile文件实例" class="headerlink" title="Dockerfile文件实例"></a>Dockerfile文件实例</h3><p>下面举一个创建Nginx镜像的例子，完整的Dockerfile文件内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># The Example  Dockerfile For Nginx</span><br><span class="line"># Version 1.0</span><br><span class="line"></span><br><span class="line"># Base images 基础镜像</span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">#MAINTAINER 维护者信息</span><br><span class="line">MAINTAINER envythink</span><br><span class="line"></span><br><span class="line">#ENV 设置环境变量</span><br><span class="line">ENV PATH /usr/local/nginx/sbin:$PATH</span><br><span class="line"></span><br><span class="line">#ADD  将nginx文件放在当前目录下，添加到容器中时会自动解压</span><br><span class="line">ADD nginx-1.8.0.tar.gz /usr/local/  </span><br><span class="line">ADD epel-release-latest-7.noarch.rpm /usr/local/  </span><br><span class="line"></span><br><span class="line">#RUN 执行以下命令 </span><br><span class="line">RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm</span><br><span class="line">RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean all</span><br><span class="line">RUN useradd -s /sbin/nologin -M envy</span><br><span class="line"></span><br><span class="line">#WORKDIR 相当于cd命令</span><br><span class="line">WORKDIR /usr/local/nginx-1.8.0 </span><br><span class="line"></span><br><span class="line">#RUN 执行以下命令 </span><br><span class="line">RUN ./configure --prefix=/usr/local/nginx --user=envy --group=envy --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">#RUN 执行以下命令 </span><br><span class="line">RUN echo &quot;daemon off;&quot; &gt;&gt; /etc/nginx.conf</span><br><span class="line"></span><br><span class="line">#EXPOSE 映射端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">#CMD 运行如下命令</span><br><span class="line">CMD [&quot;nginx&quot;]</span><br></pre></td></tr></table></figure>
<p>我从网上找了一张比较详细的图片，可以帮助记忆Dockerfile文件的组成结构：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-dd086cc0b8310245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这样关于如何使用Dockerfile的学习就先学习到这，后续开始学习如何使用Dockerfile来创建出自定义镜像。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://envyzhan.asia">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.asia/2020/04/22/docker-7-use-dockerfile/">http://envyzhan.asia/2020/04/22/docker-7-use-dockerfile/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.asia" target="_blank">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/23/docker-8-build-images-base-on-dockerfile/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于Dockerfile创建镜像</div></div></a></div><div class="next-post pull-right"><a href="/2020/04/20/docker-6-port-mapping-and-container-linking/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">端口映射与容器互联</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/04/15/docker-4-docker-and-repository/" title="Docker仓库"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-15</div><div class="title">Docker仓库</div></div></a></div><div><a href="/2020/04/20/docker-6-port-mapping-and-container-linking/" title="端口映射与容器互联"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-20</div><div class="title">端口映射与容器互联</div></div></a></div><div><a href="/2020/04/23/docker-8-build-images-base-on-dockerfile/" title="基于Dockerfile创建镜像"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-23</div><div class="title">基于Dockerfile创建镜像</div></div></a></div><div><a href="/2020/04/01/docker-1-docker-and-container/" title="Docker与容器"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-01</div><div class="title">Docker与容器</div></div></a></div><div><a href="/2020/04/05/docker-2-use-docker-images/" title="使用Docker镜像"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-05</div><div class="title">使用Docker镜像</div></div></a></div><div><a href="/2020/04/09/docker-3-operate-docker-container/" title="操作Docker容器"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-09</div><div class="title">操作Docker容器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">余思</div><div class="author-info__description">记录成长路上的点滴</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">249</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:envyzhan@aliyun.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问余思博客，一个技术博主的成长试验田！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile"><span class="toc-number">2.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-number">3.</span> <span class="toc-text">指令说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.1.</span> <span class="toc-text">配置指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ARG"><span class="toc-number">3.0.1.0.1.</span> <span class="toc-text">ARG</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM"><span class="toc-number">3.0.1.0.2.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LABEL"><span class="toc-number">3.0.1.0.3.</span> <span class="toc-text">LABEL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXPOSE"><span class="toc-number">3.0.1.0.4.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV"><span class="toc-number">3.0.1.0.5.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">3.0.1.0.6.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VOLUME"><span class="toc-number">3.0.1.0.7.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#USER"><span class="toc-number">3.0.1.0.8.</span> <span class="toc-text">USER</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR"><span class="toc-number">3.0.1.0.9.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ONBUILD"><span class="toc-number">3.0.1.0.10.</span> <span class="toc-text">ONBUILD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STOPSIGNAL"><span class="toc-number">3.0.1.0.11.</span> <span class="toc-text">STOPSIGNAL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HEALTHCHECK"><span class="toc-number">3.0.1.0.12.</span> <span class="toc-text">HEALTHCHECK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SHELL"><span class="toc-number">3.0.1.0.13.</span> <span class="toc-text">SHELL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN"><span class="toc-number">3.0.2.0.1.</span> <span class="toc-text">RUN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMD"><span class="toc-number">3.0.2.0.2.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD"><span class="toc-number">3.0.2.0.3.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY"><span class="toc-number">3.0.2.0.4.</span> <span class="toc-text">COPY</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockfile%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">Dockfile常用操作指令总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text">Dockerfile文件实例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/01/2023-100-practice-of-function-switch-in-business/" title="功能开关在业务中的实践"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="功能开关在业务中的实践"/></a><div class="content"><a class="title" href="/2023/03/01/2023-100-practice-of-function-switch-in-business/" title="功能开关在业务中的实践">功能开关在业务中的实践</a><time datetime="2023-03-01T09:55:30.000Z" title="发表于 2023-03-01 17:55:30">2023-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/" title="使用Jenkins+Gitlab一键打包部署SpringBoot应用"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Jenkins+Gitlab一键打包部署SpringBoot应用"/></a><div class="content"><a class="title" href="/2023/02/26/2023-12-use-jenkins-gitlab-to-package-and-deploy-the-springboot-application/" title="使用Jenkins+Gitlab一键打包部署SpringBoot应用">使用Jenkins+Gitlab一键打包部署SpringBoot应用</a><time datetime="2023-02-26T14:55:30.000Z" title="发表于 2023-02-26 22:55:30">2023-02-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/" title="使用Docker Compose部署SpringBoot应用"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Docker Compose部署SpringBoot应用"/></a><div class="content"><a class="title" href="/2023/02/24/2023-11-use-docker-compose-to-deploy-springboot-application/" title="使用Docker Compose部署SpringBoot应用">使用Docker Compose部署SpringBoot应用</a><time datetime="2023-02-24T02:55:30.000Z" title="发表于 2023-02-24 10:55:30">2023-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/" title="使用Dockerfile为SpringBoot应用构建Docker镜像"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Dockerfile为SpringBoot应用构建Docker镜像"/></a><div class="content"><a class="title" href="/2023/02/23/2023-10-use-dockerfil-to-build-docker-image-for-springboot-application/" title="使用Dockerfile为SpringBoot应用构建Docker镜像">使用Dockerfile为SpringBoot应用构建Docker镜像</a><time datetime="2023-02-23T10:15:33.000Z" title="发表于 2023-02-23 18:15:33">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/" title="使用Maven插件为SpringBoot应用构建Docker镜像"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Maven插件为SpringBoot应用构建Docker镜像"/></a><div class="content"><a class="title" href="/2023/02/20/2023-9-use-maven-plug-in-to-build-docker-image-for-springboot-application/" title="使用Maven插件为SpringBoot应用构建Docker镜像">使用Maven插件为SpringBoot应用构建Docker镜像</a><time datetime="2023-02-20T03:51:30.000Z" title="发表于 2023-02-20 11:51:30">2023-02-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023  余思博客,记录成长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '9996b44b488f2fc52124',
      clientSecret: '6bec0f8e9c032eeae6211a5d4cffa3c97e2d4a64',
      repo: 'blogcomment',
      owner: 'Envythink',
      admin: ['Envythink'],
      id: '796aa9d81abff4da93a22f4d93044898',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>