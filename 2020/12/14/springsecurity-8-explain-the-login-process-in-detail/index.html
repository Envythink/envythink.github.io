<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>详解登录流程 | 余思博客</title><meta name="keywords" content="springsecurity"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面在前面学习前后端分离模式下的回调和注销时，提到了密码擦除，当时没有对SpringSecurity的登录流程进行梳理，那么本篇就来详细学习登录流程。 场景描述现在有一个场景，用户在服务端安全管理选择了SpringSecurity，那么用户登录成功后，SpringSecurity会将用户信息保存在Session中，但是具体保存的位置，就目前而言开发者是不知道的，但是现在就是想知道这个信息的保存">
<meta property="og:type" content="article">
<meta property="og:title" content="详解登录流程">
<meta property="og:url" content="http://envyzhan.asia/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/index.html">
<meta property="og:site_name" content="余思博客">
<meta property="og:description" content="写在前面在前面学习前后端分离模式下的回调和注销时，提到了密码擦除，当时没有对SpringSecurity的登录流程进行梳理，那么本篇就来详细学习登录流程。 场景描述现在有一个场景，用户在服务端安全管理选择了SpringSecurity，那么用户登录成功后，SpringSecurity会将用户信息保存在Session中，但是具体保存的位置，就目前而言开发者是不知道的，但是现在就是想知道这个信息的保存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2020-12-14T11:23:04.000Z">
<meta property="article:modified_time" content="2021-03-01T08:04:29.213Z">
<meta property="article:author" content="余思">
<meta property="article:tag" content="springsecurity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://envyzhan.asia/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '详解登录流程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-01 16:04:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="余思博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">214</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-html5"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/CSS"><i class="fa-fw /categories/html/"></i><span> 0</span></a></li><li><a class="site-page child" href="/JavaScript"><i class="fa-fw /categories/javascript/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Vue.js"><i class="fa-fw /categories/vuejs/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Java"><i class="fa-fw /categories/java/"></i><span> 0</span></a></li><li><a class="site-page child" href="/SSM"><i class="fa-fw /categories/ssm/"></i><span> 1</span></a></li><li><a class="site-page child" href="/SpringBoot"><i class="fa-fw /categories/springboot/"></i><span> 2</span></a></li><li><a class="site-page child" href="/SpringCloud"><i class="fa-fw /categories/springcloud/"></i><span> 3</span></a></li><li><a class="site-page child" href="/SpringSecurity"><i class="fa-fw /categories/springsecurity/"></i><span> 4</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Python"><i class="fa-fw /categories/pythonbase/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Golang"><i class="fa-fw /categories/go/"></i><span> 1</span></a></li><li><a class="site-page child" href="/DevOps"><i class="fa-fw /categories/devops/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/MySQL"><i class="fa-fw /categories/mysql/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Nginx"><i class="fa-fw /categories/nginx/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Redis"><i class="fa-fw /categories/redis/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><i class="fa-fw /categories/datastructs/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%AE%97%E6%B3%95%E5%BB%BA%E6%A8%A1"><i class="fa-fw /categories/algorithm/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><i class="fa-fw /categories/tools/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94"><i class="fa-fw /categories/onenote/"></i><span> 0</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">余思博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-html5"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/HTML/CSS"><i class="fa-fw /categories/html/"></i><span> 0</span></a></li><li><a class="site-page child" href="/JavaScript"><i class="fa-fw /categories/javascript/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Vue.js"><i class="fa-fw /categories/vuejs/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Java"><i class="fa-fw /categories/java/"></i><span> 0</span></a></li><li><a class="site-page child" href="/SSM"><i class="fa-fw /categories/ssm/"></i><span> 1</span></a></li><li><a class="site-page child" href="/SpringBoot"><i class="fa-fw /categories/springboot/"></i><span> 2</span></a></li><li><a class="site-page child" href="/SpringCloud"><i class="fa-fw /categories/springcloud/"></i><span> 3</span></a></li><li><a class="site-page child" href="/SpringSecurity"><i class="fa-fw /categories/springsecurity/"></i><span> 4</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Python"><i class="fa-fw /categories/pythonbase/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Golang"><i class="fa-fw /categories/go/"></i><span> 1</span></a></li><li><a class="site-page child" href="/DevOps"><i class="fa-fw /categories/devops/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/MySQL"><i class="fa-fw /categories/mysql/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Nginx"><i class="fa-fw /categories/nginx/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Redis"><i class="fa-fw /categories/redis/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><i class="fa-fw /categories/datastructs/"></i><span> 0</span></a></li><li><a class="site-page child" href="/%E7%AE%97%E6%B3%95%E5%BB%BA%E6%A8%A1"><i class="fa-fw /categories/algorithm/"></i><span> 1</span></a></li><li><a class="site-page child" href="/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><i class="fa-fw /categories/tools/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94"><i class="fa-fw /categories/onenote/"></i><span> 0</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">详解登录流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-14T11:23:04.000Z" title="发表于 2020-12-14 19:23:04">2020-12-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-01T08:04:29.213Z" title="更新于 2021-03-01 16:04:29">2021-03-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/springsecurity/">springsecurity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="详解登录流程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面学习前后端分离模式下的回调和注销时，提到了密码擦除，当时没有对SpringSecurity的登录流程进行梳理，那么本篇就来详细学习登录流程。</p>
<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>现在有一个场景，用户在服务端安全管理选择了SpringSecurity，那么用户登录成功后，SpringSecurity会将用户信息保存在Session中，但是具体保存的位置，就目前而言开发者是不知道的，但是现在就是想知道这个信息的保存位置，以便当用户在前端修改了自己的信息，在不重新登录的情况下，开发者如何获取到用户的最新信息？这个场景在实际工作中是很常见的。</p>
<h3 id="Authentication对象"><a href="#Authentication对象" class="headerlink" title="Authentication对象"></a>Authentication对象</h3><p>如果你之前使用过Shiro框架，那么就知道在Shiro框架中与用户认证相关的信息都在AuthenticationToken接口中，查看一下这个接口的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationToken extends Serializable &#123;</span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它只有两个方法，一个获取用户名，一个获取用户密码。而我们常用于认证的UsernamePasswordToken类就是实现了这个接口，这个UsernamePasswordToken类中包含username、password、rememberMe和host这四个属性以及对应的getter和setetr方法。</p>
<p>其实SpringSecurity框架也存在类似的代码，所不同的是SpringSecurity框架中与认证相关的是Authentication接口，查看一下这个接口的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable &#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line"></span><br><span class="line">    Object getDetails();</span><br><span class="line"></span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line"></span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看是不是有一种似曾相似的感觉？是的，前一篇《Spring Data JPA操作数据库》一文中在自定义UserDetails时，实现了UserDetails接口，查看一下这个UserDetails接口的源码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetails extends Serializable &#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    String getPassword();</span><br><span class="line"></span><br><span class="line">    String getUsername();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonLocked();</span><br><span class="line"></span><br><span class="line">    boolean isCredentialsNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isEnabled();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常相似，第一个都是获取角色信息，之后是获取用户名和密码等信息。</p>
<p>回到Authentication接口中来，前面说过这个接口只有六个方法，分别用于获取角色信息、用户名、用户信息、密码、是否验证、设置验证等，因此开发者可以在需要使用的地方注入Authentication对象，进而获取当前登录用户的信息。顺便查看一下这个接口的实现类：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-38f6f541ac4792bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到它存在6个实现类，如下所示：<code>AbstractAuthenticationToken</code>、<code>AnonymousAuthenticationToken</code>、<code>JaasAuthenticationToken</code>、<code>PreAuthenticatedAuthenticationToken</code>、<code>RememberMeAuthenticationToken</code>、<code>TestingAuthenticationToken</code>和<code>UsernamePasswordAuthenticationToken</code>等，同样我们常用于认证的就是<code>UsernamePasswordAuthenticationToken</code>类，查看一下这个<code>UsernamePasswordAuthenticationToken</code>类的源码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken &#123;</span><br><span class="line">    private static final long serialVersionUID = 540L;</span><br><span class="line">    private final Object principal;</span><br><span class="line">    private Object credentials;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123;</span><br><span class="line">        super((Collection)null);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.credentials = credentials;</span><br><span class="line">        this.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;</span><br><span class="line">        super(authorities);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.credentials = credentials;</span><br><span class="line">        super.setAuthenticated(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getCredentials() &#123;</span><br><span class="line">        return this.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPrincipal() &#123;</span><br><span class="line">        return this.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123;</span><br><span class="line">        Assert.isTrue(!isAuthenticated, &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;);</span><br><span class="line">        super.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eraseCredentials() &#123;</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">        this.credentials = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类中有两个有参的构造方法、两个属性及其对应的getter/setter方法，这么看似鸡肋的类，其实主要功能还得看它继承的AbstractAuthenticationToken类。这两个属性principal和credentials其实就是用户名和密码，因此开发者是完全可以从这个类中获取用户名和密码。但是到现在为止，我们还是不知道登录信息是如何保存到这两个对象中的，仅仅知道可以从这个类中获取登录信息，为此我们需要对登录流程进行全面梳理。</p>
<h3 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h3><p>在Shiro框架中认证和授权的校验都是在一系列的过滤器链中完成的，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager)&#123;</span><br><span class="line">    System.out.println(&quot;******shiroFilter******&quot;);</span><br><span class="line">    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</span><br><span class="line">    shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">    //设置拦截器</span><br><span class="line">    Map&lt;String,String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">    //配置不会被拦截的链接，此时会按照顺序进行判断</span><br><span class="line">    //anon是匿名访问，authc是通过认证后才能访问</span><br><span class="line">    filterChainDefinitionMap.put(&quot;/static/**&quot;,&quot;anon&quot;);</span><br><span class="line">    //配置退出过滤器，具体已经由Shiro实现了</span><br><span class="line">    filterChainDefinitionMap.put(&quot;/logout&quot;,&quot;logout&quot;);</span><br><span class="line">    //配置过滤链，它会从上到下顺序执行，因此一般将/**放在最下面</span><br><span class="line">    filterChainDefinitionMap.put(&quot;/**&quot;,&quot;authc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果不设置，则默认会自动寻找Web工程根目录下的login.html页面</span><br><span class="line">    shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);</span><br><span class="line">    //设置登录成功后需要跳转的链接</span><br><span class="line">    shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);</span><br><span class="line"></span><br><span class="line">    //设置未授权页面</span><br><span class="line">    shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);</span><br><span class="line">    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">    return shiroFilterFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与此类似的，SpringSecurity的认证与授权也是在一系列的过滤器链中完成的，其中与认证相关的过滤器为<code>UsernamePasswordAuthenticationFilter</code>，查看一下这个类的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line">    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;</span><br><span class="line">    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;</span><br><span class="line">    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;);</span><br><span class="line">    private String usernameParameter = &quot;username&quot;;</span><br><span class="line">    private String passwordParameter = &quot;password&quot;;</span><br><span class="line">    private boolean postOnly = true;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationFilter() &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</span><br><span class="line">            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String username = this.obtainUsername(request);</span><br><span class="line">            username = username != null ? username : &quot;&quot;;</span><br><span class="line">            username = username.trim();</span><br><span class="line">            String password = this.obtainPassword(request);</span><br><span class="line">            password = password != null ? password : &quot;&quot;;</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            this.setDetails(request, authRequest);</span><br><span class="line">            return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainPassword(HttpServletRequest request) &#123;</span><br><span class="line">        return request.getParameter(this.passwordParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainUsername(HttpServletRequest request) &#123;</span><br><span class="line">        return request.getParameter(this.usernameParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) &#123;</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsernameParameter(String usernameParameter) &#123;</span><br><span class="line">        Assert.hasText(usernameParameter, &quot;Username parameter must not be empty or null&quot;);</span><br><span class="line">        this.usernameParameter = usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPasswordParameter(String passwordParameter) &#123;</span><br><span class="line">        Assert.hasText(passwordParameter, &quot;Password parameter must not be empty or null&quot;);</span><br><span class="line">        this.passwordParameter = passwordParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPostOnly(boolean postOnly) &#123;</span><br><span class="line">        this.postOnly = postOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String getUsernameParameter() &#123;</span><br><span class="line">        return this.usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String getPasswordParameter() &#123;</span><br><span class="line">        return this.passwordParameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个类在前面学习“自定义登录参数名称”的时候就已经简单学习过了，接下来对登录流程进行分析：<br><strong>（1）</strong>调用<code>attemptAuthentication</code>方法来进行尝试验证；<br><strong>（2）</strong>之后（1）中通过<code>obtainUsername</code>和<code>obtainPassword</code>方法获取请求中的用户名和密码，其底层使用了<code>request.getParameter()</code>方法。也就是说这两个方法都是从表单控件中获取登录信息，即需要通过key/value键值对来传递参数。请注意不能使用JOSN来传递参数，开发者如果想通过JOSN来传递参数，那么就需要修改此处逻辑。<br><strong>（3）</strong>接着（1）传入username和password参数来构造一个<code>UsernamePasswordAuthenticationToken</code>对象，查看一下这个对象的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123;</span><br><span class="line">       super((Collection)null);</span><br><span class="line">       this.principal = principal;</span><br><span class="line">       this.credentials = credentials;</span><br><span class="line">       this.setAuthenticated(false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说这里的username其实就对应于<code>UsernamePasswordAuthenticationToken</code>对象中的principal属性，password对应于<code>UsernamePasswordAuthenticationToken</code>对象中的credentials属性。<br><strong>（4）</strong>接下来（1）中调用setDetails方法，将request和<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入进去，但是细心的你可能发现这个<code>UsernamePasswordAuthenticationToken</code>对象是没有details这个属性的，它没有这个属性，那就查看一下它的父类<code>AbstractAuthenticationToken</code>，可以发现它的父类是有的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Object details;</span><br><span class="line"></span><br><span class="line">public Object getDetails() &#123;</span><br><span class="line">        return this.details;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDetails(Object details) &#123;</span><br><span class="line">        this.details = details;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在问题来了，这个details对象中保存的是什么呢？查看一下<code>UsernamePasswordAuthenticationFilter</code>类中setDetails方法的源码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) &#123;</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现此处调用了<code>authenticationDetailsSource</code>的<code>buildDetails()</code>方法，查看一下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationDetailsSource&lt;C, T&gt; &#123;</span><br><span class="line">    T buildDetails(C var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说最后得到的其实是一个<code>WebAuthenticationDetails</code>对象，这个对象主要描述了请求的remoteAddress和sessionId信息。关于这一部分内容，会在后面《获取登录额外信息》一文中进行详细介绍。<br><strong>（5）</strong>最后（1）中调用<code>authenticate()</code>方法去做认证。</p>
<p>可以看到这里所说的登录流程，其实就是<code>attemptAuthentication</code>方法的执行过程。</p>
<h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><p>说完了前面的登录流程，再来看后面的认证过程。我们从<code>attemptAuthentication</code>方法的最后一步来进行分析。它首先需要获取到一个<code>AuthenticationManager</code>对象， 这个<code>AuthenticationManager</code>接口有5个实现类，这里使用的是<code>ProviderManager</code>类。之后调用<code>ProviderManager</code>类的<code>authenticate()</code>方法，因此接下来查看这个<code>authenticate()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">    Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = null;</span><br><span class="line">    AuthenticationException parentException = null;</span><br><span class="line">    Authentication result = null;</span><br><span class="line">    Authentication parentResult = null;</span><br><span class="line">    int currentPosition = 0;</span><br><span class="line">    int size = this.providers.size();</span><br><span class="line">    Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">    while(var9.hasNext()) &#123;</span><br><span class="line">        AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">        if (provider.supports(toTest)) &#123;</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                Log var10000 = logger;</span><br><span class="line">                String var10002 = provider.getClass().getSimpleName();</span><br><span class="line">                ++currentPosition;</span><br><span class="line">                var10000.trace(LogMessage.format(&quot;Authenticating request with %s (%d/%d)&quot;, var10002, currentPosition, size));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                result = provider.authenticate(authentication);</span><br><span class="line">                if (result != null) &#123;</span><br><span class="line">                    this.copyDetails(authentication, result);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InternalAuthenticationServiceException | AccountStatusException var14) &#123;</span><br><span class="line">                this.prepareException(var14, authentication);</span><br><span class="line">                throw var14;</span><br><span class="line">            &#125; catch (AuthenticationException var15) &#123;</span><br><span class="line">                lastException = var15;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result == null &amp;&amp; this.parent != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            parentResult = this.parent.authenticate(authentication);</span><br><span class="line">            result = parentResult;</span><br><span class="line">        &#125; catch (ProviderNotFoundException var12) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125; catch (AuthenticationException var13) &#123;</span><br><span class="line">            parentException = var13;</span><br><span class="line">            lastException = var13;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result != null) &#123;</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentResult == null) &#123;</span><br><span class="line">            this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (lastException == null) &#123;</span><br><span class="line">            lastException = new ProviderNotFoundException(this.messages.getMessage(&quot;ProviderManager.providerNotFound&quot;, new Object[]&#123;toTest.getName()&#125;, &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (parentException == null) &#123;</span><br><span class="line">            this.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法中包含的代码非常多，因为几乎所有关于认证的逻辑都在这个方法中。接下来开始分析这个方法：<br><strong>（1）</strong>调用<code>authentication.getClass()</code>方法来获取当前的Class信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>（2）</strong>通过<code>getProviders().iterator()</code>方法来得到一个迭代器对象，其类型都是<code>AuthenticationProvider</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">while(var9.hasNext()) &#123;</span><br><span class="line">   AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）</strong>判断当前provider对象是否支持（1）中authentication对象。如果支持，则调用provider的 <code>authenticate()</code>方法开始认证校验，校验完成后会返回一个新的 <code>Authentication</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (provider.supports(toTest)) &#123;</span><br><span class="line">  ......</span><br><span class="line">  try &#123;</span><br><span class="line">         result = provider.authenticate(authentication);</span><br><span class="line">         if (result != null) &#123;</span><br><span class="line">              this.copyDetails(authentication, result);</span><br><span class="line">              break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（4）</strong>当（3）中返回的对象不为空，则调用<code>copyDetails()</code>方法将旧<code>AbstractAuthenticationToken</code>对象中的details属性复制到新的<code>AbstractAuthenticationToken</code>对象中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void copyDetails(Authentication source, Authentication dest) &#123;</span><br><span class="line">       if (dest instanceof AbstractAuthenticationToken &amp;&amp; dest.getDetails() == null) &#123;</span><br><span class="line">           AbstractAuthenticationToken token = (AbstractAuthenticationToken)dest;</span><br><span class="line">           token.setDetails(source.getDetails());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>（5）</strong>当（3）中返回的对象为空，且<code>AuthenticationManager</code>对象不为空，则调用<code>AuthenticationManager</code>对象的<code>authenticate()</code>方法来进行认证校验。<br><strong>（6）</strong>之后调用<code>eraseCredentials</code>方法将凭证信息擦除掉，这里的凭证信息就是用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (result != null) &#123;</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123;</span><br><span class="line">              ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">          &#125;</span><br><span class="line">          if (parentResult == null) &#123;</span><br><span class="line">              this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">          &#125;</span><br><span class="line">            return result;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>它首先判断（3）中的返回对象不为空，且对象是<code>CredentialsContainer</code>的实例，为什么需要判断？那是因为只有这个<code>CredentialsContainer</code>接口中才存在擦除凭证信息的<code>eraseCredentials()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CredentialsContainer &#123;</span><br><span class="line">    void eraseCredentials();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这是一个接口，那么接下看一下它的实现类，可以发现一个比较熟悉的身影<code>UsernamePasswordAuthenticationToken</code>，这里面的<code>eraseCredentials()</code>方法进行了实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void eraseCredentials() &#123;</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">        this.credentials = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它擦除凭证的逻辑非常简单，就是将<code>UsernamePasswordAuthenticationToken</code>对象中的<code>credentials</code>属性设置为null，其实就是密码设置为空。<br><strong>（7）</strong>通过调用<code>MessageSourceAccessor</code>对象的<code>publishAuthenticationSuccess()</code>方法将（3）中成功返回的对象广播出去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (result != null) &#123;</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123;</span><br><span class="line">              ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">          &#125;</span><br><span class="line">          if (parentResult == null) &#123;</span><br><span class="line">              this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">          &#125;</span><br><span class="line">            return result;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>以上就是认证的整个流程，第一遍看的时候非常容易晕，这是正常现象，第一次看源码很正常，看多了就习惯了。</p>
<p>这里再捋一下上面的逻辑，首先得到当前Authentication对象的Class信息，接着通过<code>getProviders().iterator()</code>方法得到一个迭代器对象，之后遍历这个迭代器对象，请注意不是所有的<code>AuthenticationProvider</code>对象都支持<code>Authentication</code>，如<code>AnonymousAuthenticationProvider</code>就不支持，因此它调用<code>AuthenticationManager</code>接口对象（代码中的parent）的<code>authenticate()</code>方法进行认证校验。而这个<code>AuthenticationManager</code>接口对象的实现类是<code>ProviderManager</code>，因此又回到了此处的<code>authenticate</code>方法中。不过此时的provider就变成了<code>DaoAuthenticationProvider</code>，这个provider是支持<code>Authentication</code>的（如<code>UsernamePasswordAuthenticationToken</code>），因此会进入到<code>DaoAuthenticationProvider</code>类的<code>authenticate</code>方法中执行，但是笔者并没有在<code>DaoAuthenticationProvider</code>类中发现<code>authenticate</code>方法：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-3f8e25a83a724d05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>老规矩，它没有就去查看它实现的接口或者继承的类，可以发现在它继承的<code>AbstractUserDetailsAuthenticationProvider</code>类中就发现了<code>authenticate</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123;</span><br><span class="line">            return this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        String username = this.determineUsername(authentication);</span><br><span class="line">        boolean cacheWasUsed = true;</span><br><span class="line">        UserDetails user = this.userCache.getUserFromCache(username);</span><br><span class="line">        if (user == null) &#123;</span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            &#125; catch (UsernameNotFoundException var6) &#123;</span><br><span class="line">                this.logger.debug(&quot;Failed to find user &#x27;&quot; + username + &quot;&#x27;&quot;);</span><br><span class="line">                if (!this.hideUserNotFoundExceptions) &#123;</span><br><span class="line">                    throw var6;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        &#125; catch (AuthenticationException var7) &#123;</span><br><span class="line">            if (!cacheWasUsed) &#123;</span><br><span class="line">                throw var7;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line">            user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.postAuthenticationChecks.check(user);</span><br><span class="line">        if (!cacheWasUsed) &#123;</span><br><span class="line">            this.userCache.putUserInCache(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object principalToReturn = user;</span><br><span class="line">        if (this.forcePrincipalAsString) &#123;</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>仔细查看上述代码的逻辑：<br><strong>（1）</strong>判断<code>authentication</code>对象是否是<code>UsernamePasswordAuthenticationToken</code>类型的实例，如果是的话则从Authentication中获取当前登录用户的用户名；<br><strong>（2）</strong>从缓存中通过用户名来获取用户信息，如果获取不到用户信息则说明缓存未启用；反之得到用户信息；<br><strong>（3）</strong>调用retrieveUser方法，将得到的用户名和之前的<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入，查看一下这个retrieveUser方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;</span><br><span class="line">        this.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            if (loadedUser == null) &#123;</span><br><span class="line">                throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return loadedUser;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (UsernameNotFoundException var4) &#123;</span><br><span class="line">            this.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            throw var4;</span><br><span class="line">        &#125; catch (InternalAuthenticationServiceException var5) &#123;</span><br><span class="line">            throw var5;</span><br><span class="line">        &#125; catch (Exception var6) &#123;</span><br><span class="line">            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它首先调用<code>getUserDetailsService()</code>方法得到一个<code>UserDetailsService</code>对象，之后调用它的<code>loadUserByUsername()</code>方法来获取<code>UserDetails</code>对象，注意到了么，这个就是之前我们自定义的<code>UserDetailService</code>类中的<code>loadUserByUsername()</code>方法，也就是说此处返回的<code>UserDetails</code>对象其实就是登录对象User：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyUserDetailService implements UserDetailsService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;</span><br><span class="line">        User user = userRepository.findUserByUsername(username);</span><br><span class="line">        if(user==null)&#123;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（4）</strong>调用<code>preAuthenticationChecks.check(user)</code>方法来检查User对象的各个属性是否正常。查看一下这个check方法，发现它存在于<code>UserDetailsChecker</code>接口中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsChecker &#123;</span><br><span class="line">    void check(UserDetails var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了弄清楚这个check方法的执行逻辑，这里需要查看<code>UserDetailsChecker</code>接口的实现类<code>AccountStatusUserDetailsChecker</code>，在这个实现类中就有check方法的具体实现逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void check(UserDetails user) &#123;</span><br><span class="line">      if (!user.isAccountNonLocked()) &#123;</span><br><span class="line">          this.logger.debug(&quot;Failed to authenticate since user account is locked&quot;);</span><br><span class="line">          throw new LockedException(this.messages.getMessage(&quot;AccountStatusUserDetailsChecker.locked&quot;, &quot;User account is locked&quot;));</span><br><span class="line">      &#125; else if (!user.isEnabled()) &#123;</span><br><span class="line">          this.logger.debug(&quot;Failed to authenticate since user account is disabled&quot;);</span><br><span class="line">          throw new DisabledException(this.messages.getMessage(&quot;AccountStatusUserDetailsChecker.disabled&quot;, &quot;User is disabled&quot;));</span><br><span class="line">      &#125; else if (!user.isAccountNonExpired()) &#123;</span><br><span class="line">          this.logger.debug(&quot;Failed to authenticate since user account is expired&quot;);</span><br><span class="line">          throw new AccountExpiredException(this.messages.getMessage(&quot;AccountStatusUserDetailsChecker.expired&quot;, &quot;User account has expired&quot;));</span><br><span class="line">      &#125; else if (!user.isCredentialsNonExpired()) &#123;</span><br><span class="line">          this.logger.debug(&quot;Failed to authenticate since user account credentials have expired&quot;);</span><br><span class="line">          throw new CredentialsExpiredException(this.messages.getMessage(&quot;AccountStatusUserDetailsChecker.credentialsExpired&quot;, &quot;User credentials have expired&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里主要对用户的账户是否未锁住、是否可用、是否未过期、密码是否过期等进行判断，满足其中任意一个都会抛出异常。<br><strong>（5）</strong>接着调用<code>additionalAuthenticationChecks()</code>方法来对用户密码进行判断，查看这个方法的源码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void additionalAuthenticationChecks(UserDetails var1, UsernamePasswordAuthenticationToken var2) throws AuthenticationException;</span><br></pre></td></tr></table></figure>
<p>这是一个抽象方法，得找一个这个抽象类的具体实现才行，又回到了<code>DaoAuthenticationProvider</code>这个类，可以发现这个类中的<code>additionalAuthenticationChecks</code>方法就提供了具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123;</span><br><span class="line">       if (authentication.getCredentials() == null) &#123;</span><br><span class="line">           this.logger.debug(&quot;Failed to authenticate since no credentials provided&quot;);</span><br><span class="line">           throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">           if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">               this.logger.debug(&quot;Failed to authenticate since password does not match stored value&quot;);</span><br><span class="line">               throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。以<code>BCryptPasswordEncoder</code>类中的matches方法为例，查看一下密码的匹配逻辑，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;</span><br><span class="line">        if (rawPassword == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;rawPassword cannot be null&quot;);</span><br><span class="line">        &#125; else if (encodedPassword != null &amp;&amp; encodedPassword.length() != 0) &#123;</span><br><span class="line">            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">                this.logger.warn(&quot;Encoded password does not look like BCrypt&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.logger.warn(&quot;Empty encoded password&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中rawPassword是获取到的用户密码，而encodedPassword则是数据库中查询到的密码，密码匹配逻辑其实较为简单。</p>
<p><strong>（6）</strong>回到<code>AbstractUserDetailsAuthenticationProvider</code>类的<code>authenticate</code>方法中，密码验证通过后，接下来调用<code>postAuthenticationChecks.check(user)</code>方法来检查密码是否过期。</p>
<p><strong>（7）</strong>之后判断forcePrincipalAsString属性是否为true，该属性是强制将Principal(用户名)转换为String(字符串)对象。其实在<code>UsernamePasswordAuthenticationFilter</code>类中就已经将principal(用户名)设置为字符串，但是在默认情况下，当用户登录成功后，这个属性的值就成了当前用户，也就是UserDetails对象。需要说明的是，这个<code>forcePrincipalAsString</code>属性默认值为false，其实开发者不需要管这个参数，因为没转成字符串，反而更利于后续获取用户信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object principalToReturn = user;</span><br><span class="line">if (this.forcePrincipalAsString) &#123;</span><br><span class="line">    principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line">return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></table></figure>
<p><strong>（8）</strong>最后调用<code>createSuccessAuthentication()</code>方法来构造一个<code>Authentication</code>对象，准确来说是<code>UsernamePasswordAuthenticationToken</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) &#123;</span><br><span class="line">       UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">       result.setDetails(authentication.getDetails());</span><br><span class="line">       this.logger.debug(&quot;Authenticated user&quot;);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上就是用户的登录流程和认证过程，但是我们依旧不知道登录的用户信息是在哪个环节被保存的，只有搞清楚这个才算真的搞清楚了用户登录。</p>
<h3 id="保存用户信息"><a href="#保存用户信息" class="headerlink" title="保存用户信息"></a>保存用户信息</h3><p>我们重新捋一下思路，想想上面的登录是从哪来开始执行的，或者说是触发的？</p>
<p>回到<code>UsernamePasswordAuthenticationFilter</code>类，这个类非常重要，登录流程就是从这开始的，查看一下它的父类<code>AbstractAuthenticationProcessingFilter</code>，请注意这个类以后会经常使用，当开发者需要在SpringSecurity中自定义一个登录验证码或者将登录参数修改为JSON的时候，此时都需要自定义自己的Filter类，并继承这个<code>AbstractAuthenticationProcessingFilter</code>类。</p>
<p>如果你之前使用过Servlet，那么肯定对Filter不陌生，在需要对某些资源进行过滤拦截并进行处理，之后返回处理过的内容，就需要自定义Filter类并实现Filter接口，可以点击 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zlbx/p/4888312.html">这里</a> 进行了解。这个接口中有一个doFilter方法，当拦截到需要执行的请求时，doFilter方法就会执行，开发者可以在这个方法里面书写对请求和响应的预处理逻辑。</p>
<p>在<code>AbstractAuthenticationProcessingFilter</code>这个抽象类中，我们也发现它也存在名为doFilter的方法，源码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        if (!this.requiresAuthentication(request, response)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Authentication authenticationResult = this.attemptAuthentication(request, response);</span><br><span class="line">                if (authenticationResult == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">                if (this.continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">                    chain.doFilter(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                this.successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">            &#125; catch (InternalAuthenticationServiceException var5) &#123;</span><br><span class="line">                this.logger.error(&quot;An internal error occurred while trying to authenticate the user.&quot;, var5);</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var5);</span><br><span class="line">            &#125; catch (AuthenticationException var6) &#123;</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var6);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>仔细阅读上述方法的源码，可以发现首先调用<code>requiresAuthentication(request, response)</code>方法来判断是否需要验证，如果不需要就直接执行<code>chain.doFilter()</code>方法；如果需要验证，那么会调用<code>attemptAuthentication()</code>方法，看到没有，原来是在此处调用了<code>UsernamePasswordAuthenticationFilter#attemptAuthentication()</code>方法；且当用户登录成功时，就调用<code>successfulAuthentication()</code>方法，失败则调用<code>unsuccessfulAuthentication()</code>方法。</p>
<p>接下来看一下登录成功时所调用的<code>successfulAuthentication()</code>方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">        if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">            this.logger.debug(LogMessage.format(&quot;Set SecurityContextHolder to %s&quot;, authResult));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">        if (this.eventPublisher != null) &#123;</span><br><span class="line">            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这里面第一行代码<code>SecurityContextHolder.getContext().setAuthentication(authResult);</code>，它的作用是获取上下文，并将之前的验证结果赋值给Authentication属性，原来成功的登录信息都会被保存在这里，因此当我们需要获取用户的登录信息时，可以直接从<code>SecurityContextHolder.getContext();</code>中获取，这其实是一个<code>SecurityContext</code>对象。当然如果想修改用户信息，也只需修改这个<code>SecurityContext</code>对象。</p>
<p>回到上面的<code>successfulAuthentication</code>方法中，继续往下读源码，之后会调用<code>rememberMeServices.loginSuccess()</code>方法，将登录信息写入“记住我”中，这个是当用户使用了“记住我”这个功能才有效。接着判断是否存在事件广播者，如果存在则将用户登录成功的信息发布出去。如果不存在则调用<code>successHandler.onAuthenticationSuccess()</code>方法，而这个方法就是我们之前在MySecurityConfig类中配置登录成功时的回调方法，原来那个方法是在这里被触发的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-1d8d28bd49a86e0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>再来看一下登录失败时所调用的<code>unsuccessfulAuthentication()</code>方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        this.logger.trace(&quot;Failed to process authentication request&quot;, failed);</span><br><span class="line">        this.logger.trace(&quot;Cleared SecurityContextHolder&quot;);</span><br><span class="line">        this.logger.trace(&quot;Handling authentication failure&quot;);</span><br><span class="line">        this.rememberMeServices.loginFail(request, response);</span><br><span class="line">        this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样注意这里面的第一行代码<code>SecurityContextHolder.clearContext();</code>，它的作用是获取上下文，并将上下文内容清空。之后调用<code>rememberMeServices.loginFail()</code>方法来说明“记住我”也是登录失败的。最后调用<code>failureHandler.onAuthenticationFailure()</code>方法，而这个方法同样也是之前我们在MySecurityConfig类中配置登录失败时的回调方法，原来那个方法是在这里被触发的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-a92f292e451beda7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>看到这里我们就对登录流程和认证过程有了清晰的认识，也知道了原来数据保存在<code>SecurityContextHolder.getContext();</code>中，当开发者需要获取和修改登录信息时，只需对该<code>SecurityContext</code>对象进行操作即可。</p>
<p>ok，那么本篇关于登录流程的详细分析就到此为止，后续学习其他内容。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://envyzhan.asia">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.asia/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/">http://envyzhan.asia/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.asia" target="_blank">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springsecurity/">springsecurity</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/15/springsecurity-9-add-login-verfication-code/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">添加登录验证码</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/13/springsecurity-7-spring-data-jpa-operation-database/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Data JPA操作数据库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/12/07/springsecurity-1-quick-learn/" title="快速入门"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-07</div><div class="title">快速入门</div></div></a></div><div><a href="/2020/12/16/springsecurity-10-fill-the-pit-separate-the-front-and-back-end-login-in-json-format/" title="填坑，前后端分离JSON格式登录实现"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-16</div><div class="title">填坑，前后端分离JSON格式登录实现</div></div></a></div><div><a href="/2020/12/26/springsecurity-19-defending-against-fixed-session-attacks/" title="防御固定会话攻击"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-26</div><div class="title">防御固定会话攻击</div></div></a></div><div><a href="/2020/12/08/springsecurity-2-custom-information/" title="自定义信息"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-08</div><div class="title">自定义信息</div></div></a></div><div><a href="/2020/12/09/springsecurity-3-the-front-and-back-end-do-not-separate-the-callback-and-logout-login/" title="前后端不分离回调和注销登录"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-09</div><div class="title">前后端不分离回调和注销登录</div></div></a></div><div><a href="/2020/12/11/springsecurity-5-memory-based-authorization-operation/" title="基于内存的授权操作"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-11</div><div class="title">基于内存的授权操作</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">余思</div><div class="author-info__description">记录成长路上的点滴</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">214</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Envythink" target="_blank" title=""><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/u/2809144261" target="_blank" title=""><i class="fa fa-weibo"></i></a><a class="social-icon" href="mailto:envyzhan@aliyun.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.0.1.</span> <span class="toc-text">场景描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authentication%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.2.</span> <span class="toc-text">Authentication对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.4.</span> <span class="toc-text">认证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.5.</span> <span class="toc-text">保存用户信息</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/11/1-druid-database-connection-pool-experience/" title="Druid数据库连接池使用体验"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Druid数据库连接池使用体验"/></a><div class="content"><a class="title" href="/2022/03/11/1-druid-database-connection-pool-experience/" title="Druid数据库连接池使用体验">Druid数据库连接池使用体验</a><time datetime="2022-03-11T09:55:30.000Z" title="发表于 2022-03-11 17:55:30">2022-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/" title="SpringBoot+OAuth2实现单点登录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot+OAuth2实现单点登录"/></a><div class="content"><a class="title" href="/2021/01/15/oauth2-9-oauth2-and-springboot-to-sso/" title="SpringBoot+OAuth2实现单点登录">SpringBoot+OAuth2实现单点登录</a><time datetime="2021-01-15T11:23:04.000Z" title="发表于 2021-01-15 19:23:04">2021-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/" title="OAuth2.0+JWT实现单点登录"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OAuth2.0+JWT实现单点登录"/></a><div class="content"><a class="title" href="/2021/01/12/oauth2-8-oauth2-and-jwt-to-sso/" title="OAuth2.0+JWT实现单点登录">OAuth2.0+JWT实现单点登录</a><time datetime="2021-01-12T11:23:04.000Z" title="发表于 2021-01-12 19:23:04">2021-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/09/oauth2-7-authorization-code-pattern-optimization/" title="授权码模式实例优化"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="授权码模式实例优化"/></a><div class="content"><a class="title" href="/2021/01/09/oauth2-7-authorization-code-pattern-optimization/" title="授权码模式实例优化">授权码模式实例优化</a><time datetime="2021-01-09T11:23:04.000Z" title="发表于 2021-01-09 19:23:04">2021-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/" title="一个完整的客户端模式实例"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一个完整的客户端模式实例"/></a><div class="content"><a class="title" href="/2021/01/07/oauth2-6-a-complete-example-of-client-pattern/" title="一个完整的客户端模式实例">一个完整的客户端模式实例</a><time datetime="2021-01-07T11:23:04.000Z" title="发表于 2021-01-07 19:23:04">2021-01-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 余思</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>