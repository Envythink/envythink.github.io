<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>详解登录流程 | 余思博客</title><meta name="description" content="详解登录流程"><meta name="keywords" content="springsecurity"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="详解登录流程"><meta name="twitter:description" content="详解登录流程"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="详解登录流程"><meta property="og:url" content="http://envyzhan.top/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/"><meta property="og:site_name" content="余思博客"><meta property="og:description" content="详解登录流程"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://envyzhan.top/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/"><link rel="prev" title="添加登录验证码" href="http://envyzhan.top/2020/12/15/springsecurity-9-add-login-verfication-code/"><link rel="next" title="Spring Data JPA操作数据库" href="http://envyzhan.top/2020/12/13/springsecurity-7-spring-data-jpa-operation-database/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://envythink.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: 余思","link":"链接: http://envyzhan.top/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/","source":"来源: 余思博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">余思博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-html5" aria-hidden="true"></i><span> 前端</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> Java</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 运维</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 中间件</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/nginx/"><i class="fa-fw fa fa-location-arrow"></i><span> Nginx</span></a></li><li><a class="site-page" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bell" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 数据结构</span></a></li><li><a class="site-page" href="/categories/algorithm/"><i class="fa-fw fa fa-plane"></i><span> 算法建模</span></a></li><li><a class="site-page" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-address-book" aria-hidden="true"></i><span> 生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">213</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-html5" aria-hidden="true"></i><span> 前端</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> Java</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 运维</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 中间件</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/nginx/"><i class="fa-fw fa fa-location-arrow"></i><span> Nginx</span></a></li><li><a class="site-page" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bell" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 数据结构</span></a></li><li><a class="site-page" href="/categories/algorithm/"><i class="fa-fw fa fa-plane"></i><span> 算法建模</span></a></li><li><a class="site-page" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-address-book" aria-hidden="true"></i><span> 生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#写在前面"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">写在前面</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#场景描述"><span class="toc_mobile_items-number">1.0.1.</span> <span class="toc_mobile_items-text">场景描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Authentication对象"><span class="toc_mobile_items-number">1.0.2.</span> <span class="toc_mobile_items-text">Authentication对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#登录流程"><span class="toc_mobile_items-number">1.0.3.</span> <span class="toc_mobile_items-text">登录流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#认证过程"><span class="toc_mobile_items-number">1.0.4.</span> <span class="toc_mobile_items-text">认证过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#保存用户信息"><span class="toc_mobile_items-number">1.0.5.</span> <span class="toc_mobile_items-text">保存用户信息</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景描述"><span class="toc-number">1.0.1.</span> <span class="toc-text">场景描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Authentication对象"><span class="toc-number">1.0.2.</span> <span class="toc-text">Authentication对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#登录流程"><span class="toc-number">1.0.3.</span> <span class="toc-text">登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#认证过程"><span class="toc-number">1.0.4.</span> <span class="toc-text">认证过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存用户信息"><span class="toc-number">1.0.5.</span> <span class="toc-text">保存用户信息</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">详解登录流程</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-14</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/springsecurity/">springsecurity</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 21 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面学习前后端分离模式下的回调和注销时，提到了密码擦除，当时没有对SpringSecurity的登录流程进行梳理，那么本篇就来详细学习登录流程。</p>
<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>现在有一个场景，用户在服务端安全管理选择了SpringSecurity，那么用户登录成功后，SpringSecurity会将用户信息保存在Session中，但是具体保存的位置，就目前而言开发者是不知道的，但是现在就是想知道这个信息的保存位置，以便当用户在前端修改了自己的信息，在不重新登录的情况下，开发者如何获取到用户的最新信息？这个场景在实际工作中是很常见的。</p>
<h3 id="Authentication对象"><a href="#Authentication对象" class="headerlink" title="Authentication对象"></a>Authentication对象</h3><p>如果你之前使用过Shiro框架，那么就知道在Shiro框架中与用户认证相关的信息都在AuthenticationToken接口中，查看一下这个接口的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationToken extends Serializable {</span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>它只有两个方法，一个获取用户名，一个获取用户密码。而我们常用于认证的UsernamePasswordToken类就是实现了这个接口，这个UsernamePasswordToken类中包含username、password、rememberMe和host这四个属性以及对应的getter和setetr方法。</p>
<p>其实SpringSecurity框架也存在类似的代码，所不同的是SpringSecurity框架中与认证相关的是Authentication接口，查看一下这个接口的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable {</span><br><span class="line">    Collection<!--? extends GrantedAuthority--> getAuthorities();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line"></span><br><span class="line">    Object getDetails();</span><br><span class="line"></span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line"></span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>乍一看是不是有一种似曾相似的感觉？是的，前一篇《Spring Data JPA操作数据库》一文中在自定义UserDetails时，实现了UserDetails接口，查看一下这个UserDetails接口的源码，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetails extends Serializable {</span><br><span class="line">    Collection<!--? extends GrantedAuthority--> getAuthorities();</span><br><span class="line"></span><br><span class="line">    String getPassword();</span><br><span class="line"></span><br><span class="line">    String getUsername();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isAccountNonLocked();</span><br><span class="line"></span><br><span class="line">    boolean isCredentialsNonExpired();</span><br><span class="line"></span><br><span class="line">    boolean isEnabled();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>是不是非常相似，第一个都是获取角色信息，之后是获取用户名和密码等信息。</p>
<p>回到Authentication接口中来，前面说过这个接口只有六个方法，分别用于获取角色信息、用户名、用户信息、密码、是否验证、设置验证等，因此开发者可以在需要使用的地方注入Authentication对象，进而获取当前登录用户的信息。顺便查看一下这个接口的实现类：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-38f6f541ac4792bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-38f6f541ac4792bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>可以看到它存在6个实现类，如下所示：<code>AbstractAuthenticationToken</code>、<code>AnonymousAuthenticationToken</code>、<code>JaasAuthenticationToken</code>、<code>PreAuthenticatedAuthenticationToken</code>、<code>RememberMeAuthenticationToken</code>、<code>TestingAuthenticationToken</code>和<code>UsernamePasswordAuthenticationToken</code>等，同样我们常用于认证的就是<code>UsernamePasswordAuthenticationToken</code>类，查看一下这个<code>UsernamePasswordAuthenticationToken</code>类的源码，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {</span><br><span class="line">    private static final long serialVersionUID = 540L;</span><br><span class="line">    private final Object principal;</span><br><span class="line">    private Object credentials;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {</span><br><span class="line">        super((Collection)null);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.credentials = credentials;</span><br><span class="line">        this.setAuthenticated(false);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<!--? extends GrantedAuthority--> authorities) {</span><br><span class="line">        super(authorities);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.credentials = credentials;</span><br><span class="line">        super.setAuthenticated(true);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getCredentials() {</span><br><span class="line">        return this.credentials;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getPrincipal() {</span><br><span class="line">        return this.principal;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {</span><br><span class="line">        Assert.isTrue(!isAuthenticated, "Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead");</span><br><span class="line">        super.setAuthenticated(false);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void eraseCredentials() {</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">        this.credentials = null;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这个类中有两个有参的构造方法、两个属性及其对应的getter/setter方法，这么看似鸡肋的类，其实主要功能还得看它继承的AbstractAuthenticationToken类。这两个属性principal和credentials其实就是用户名和密码，因此开发者是完全可以从这个类中获取用户名和密码。但是到现在为止，我们还是不知道登录信息是如何保存到这两个对象中的，仅仅知道可以从这个类中获取登录信息，为此我们需要对登录流程进行全面梳理。</p>
<h3 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h3><p>在Shiro框架中认证和授权的校验都是在一系列的过滤器链中完成的，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager){</span><br><span class="line">    System.out.println("******shiroFilter******");</span><br><span class="line">    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</span><br><span class="line">    shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">    //设置拦截器</span><br><span class="line">    Map<string,string> filterChainDefinitionMap = new LinkedHashMap<>();</string,string></span><br><span class="line">    //配置不会被拦截的链接，此时会按照顺序进行判断</span><br><span class="line">    //anon是匿名访问，authc是通过认证后才能访问</span><br><span class="line">    filterChainDefinitionMap.put("/static/**","anon");</span><br><span class="line">    //配置退出过滤器，具体已经由Shiro实现了</span><br><span class="line">    filterChainDefinitionMap.put("/logout","logout");</span><br><span class="line">    //配置过滤链，它会从上到下顺序执行，因此一般将/**放在最下面</span><br><span class="line">    filterChainDefinitionMap.put("/**","authc");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果不设置，则默认会自动寻找Web工程根目录下的login.html页面</span><br><span class="line">    shiroFilterFactoryBean.setLoginUrl("/login");</span><br><span class="line">    //设置登录成功后需要跳转的链接</span><br><span class="line">    shiroFilterFactoryBean.setSuccessUrl("/index");</span><br><span class="line"></span><br><span class="line">    //设置未授权页面</span><br><span class="line">    shiroFilterFactoryBean.setUnauthorizedUrl("/unauthorized");</span><br><span class="line">    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">    return shiroFilterFactoryBean;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>与此类似的，SpringSecurity的认证与授权也是在一系列的过滤器链中完成的，其中与认证相关的过滤器为<code>UsernamePasswordAuthenticationFilter</code>，查看一下这个类的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {</span><br><span class="line">    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = "username";</span><br><span class="line">    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = "password";</span><br><span class="line">    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher("/login", "POST");</span><br><span class="line">    private String usernameParameter = "username";</span><br><span class="line">    private String passwordParameter = "password";</span><br><span class="line">    private boolean postOnly = true;</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationFilter() {</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public UsernamePasswordAuthenticationFilter(AuthenticationManager authenticationManager) {</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {</span><br><span class="line">        if (this.postOnly && !request.getMethod().equals("POST")) {</span><br><span class="line">            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());</span><br><span class="line">        } else {</span><br><span class="line">            String username = this.obtainUsername(request);</span><br><span class="line">            username = username != null ? username : "";</span><br><span class="line">            username = username.trim();</span><br><span class="line">            String password = this.obtainPassword(request);</span><br><span class="line">            password = password != null ? password : "";</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            this.setDetails(request, authRequest);</span><br><span class="line">            return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainPassword(HttpServletRequest request) {</span><br><span class="line">        return request.getParameter(this.passwordParameter);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainUsername(HttpServletRequest request) {</span><br><span class="line">        return request.getParameter(this.usernameParameter);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setUsernameParameter(String usernameParameter) {</span><br><span class="line">        Assert.hasText(usernameParameter, "Username parameter must not be empty or null");</span><br><span class="line">        this.usernameParameter = usernameParameter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setPasswordParameter(String passwordParameter) {</span><br><span class="line">        Assert.hasText(passwordParameter, "Password parameter must not be empty or null");</span><br><span class="line">        this.passwordParameter = passwordParameter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setPostOnly(boolean postOnly) {</span><br><span class="line">        this.postOnly = postOnly;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public final String getUsernameParameter() {</span><br><span class="line">        return this.usernameParameter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public final String getPasswordParameter() {</span><br><span class="line">        return this.passwordParameter;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>其实这个类在前面学习“自定义登录参数名称”的时候就已经简单学习过了，接下来对登录流程进行分析：<br><strong>（1）</strong>调用<code>attemptAuthentication</code>方法来进行尝试验证；<br><strong>（2）</strong>之后（1）中通过<code>obtainUsername</code>和<code>obtainPassword</code>方法获取请求中的用户名和密码，其底层使用了<code>request.getParameter()</code>方法。也就是说这两个方法都是从表单控件中获取登录信息，即需要通过key/value键值对来传递参数。请注意不能使用JOSN来传递参数，开发者如果想通过JOSN来传递参数，那么就需要修改此处逻辑。<br><strong>（3）</strong>接着（1）传入username和password参数来构造一个<code>UsernamePasswordAuthenticationToken</code>对象，查看一下这个对象的构造方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {</span><br><span class="line">       super((Collection)null);</span><br><span class="line">       this.principal = principal;</span><br><span class="line">       this.credentials = credentials;</span><br><span class="line">       this.setAuthenticated(false);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p>也就是说这里的username其实就对应于<code>UsernamePasswordAuthenticationToken</code>对象中的principal属性，password对应于<code>UsernamePasswordAuthenticationToken</code>对象中的credentials属性。<br><strong>（4）</strong>接下来（1）中调用setDetails方法，将request和<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入进去，但是细心的你可能发现这个<code>UsernamePasswordAuthenticationToken</code>对象是没有details这个属性的，它没有这个属性，那就查看一下它的父类<code>AbstractAuthenticationToken</code>，可以发现它的父类是有的：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Object details;</span><br><span class="line"></span><br><span class="line">public Object getDetails() {</span><br><span class="line">        return this.details;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public void setDetails(Object details) {</span><br><span class="line">        this.details = details;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>现在问题来了，这个details对象中保存的是什么呢？查看一下<code>UsernamePasswordAuthenticationFilter</code>类中setDetails方法的源码，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以发现此处调用了<code>authenticationDetailsSource</code>的<code>buildDetails()</code>方法，查看一下源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationDetailsSource<c, t> {</c,></span><br><span class="line">    T buildDetails(C var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>也就是说最后得到的其实是一个<code>WebAuthenticationDetails</code>对象，这个对象主要描述了请求的remoteAddress和sessionId信息。关于这一部分内容，会在后面《获取登录额外信息》一文中进行详细介绍。<br><strong>（5）</strong>最后（1）中调用<code>authenticate()</code>方法去做认证。</p>
<p>可以看到这里所说的登录流程，其实就是<code>attemptAuthentication</code>方法的执行过程。</p>
<h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><p>说完了前面的登录流程，再来看后面的认证过程。我们从<code>attemptAuthentication</code>方法的最后一步来进行分析。它首先需要获取到一个<code>AuthenticationManager</code>对象， 这个<code>AuthenticationManager</code>接口有5个实现类，这里使用的是<code>ProviderManager</code>类。之后调用<code>ProviderManager</code>类的<code>authenticate()</code>方法，因此接下来查看这个<code>authenticate()</code>方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">    Class<!--? extends Authentication--> toTest = authentication.getClass();</span><br><span class="line">    AuthenticationException lastException = null;</span><br><span class="line">    AuthenticationException parentException = null;</span><br><span class="line">    Authentication result = null;</span><br><span class="line">    Authentication parentResult = null;</span><br><span class="line">    int currentPosition = 0;</span><br><span class="line">    int size = this.providers.size();</span><br><span class="line">    Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">    while(var9.hasNext()) {</span><br><span class="line">        AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">        if (provider.supports(toTest)) {</span><br><span class="line">            if (logger.isTraceEnabled()) {</span><br><span class="line">                Log var10000 = logger;</span><br><span class="line">                String var10002 = provider.getClass().getSimpleName();</span><br><span class="line">                ++currentPosition;</span><br><span class="line">                var10000.trace(LogMessage.format("Authenticating request with %s (%d/%d)", var10002, currentPosition, size));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                result = provider.authenticate(authentication);</span><br><span class="line">                if (result != null) {</span><br><span class="line">                    this.copyDetails(authentication, result);</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            } catch (InternalAuthenticationServiceException | AccountStatusException var14) {</span><br><span class="line">                this.prepareException(var14, authentication);</span><br><span class="line">                throw var14;</span><br><span class="line">            } catch (AuthenticationException var15) {</span><br><span class="line">                lastException = var15;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (result == null && this.parent != null) {</span><br><span class="line">        try {</span><br><span class="line">            parentResult = this.parent.authenticate(authentication);</span><br><span class="line">            result = parentResult;</span><br><span class="line">        } catch (ProviderNotFoundException var12) {</span><br><span class="line">            ;</span><br><span class="line">        } catch (AuthenticationException var13) {</span><br><span class="line">            parentException = var13;</span><br><span class="line">            lastException = var13;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (result != null) {</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (parentResult == null) {</span><br><span class="line">            this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    } else {</span><br><span class="line">        if (lastException == null) {</span><br><span class="line">            lastException = new ProviderNotFoundException(this.messages.getMessage("ProviderManager.providerNotFound", new Object[]{toTest.getName()}, "No AuthenticationProvider found for {0}"));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (parentException == null) {</span><br><span class="line">            this.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        throw lastException;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这个方法中包含的代码非常多，因为几乎所有关于认证的逻辑都在这个方法中。接下来开始分析这个方法：<br><strong>（1）</strong>调用<code>authentication.getClass()</code>方法来获取当前的Class信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class<!--? extends Authentication--> toTest = authentication.getClass();</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（2）</strong>通过<code>getProviders().iterator()</code>方法来得到一个迭代器对象，其类型都是<code>AuthenticationProvider</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">while(var9.hasNext()) {</span><br><span class="line">   AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（3）</strong>判断当前provider对象是否支持（1）中authentication对象。如果支持，则调用provider的 <code>authenticate()</code>方法开始认证校验，校验完成后会返回一个新的 <code>Authentication</code>对象：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (provider.supports(toTest)) {</span><br><span class="line">  ......</span><br><span class="line">  try {</span><br><span class="line">         result = provider.authenticate(authentication);</span><br><span class="line">         if (result != null) {</span><br><span class="line">              this.copyDetails(authentication, result);</span><br><span class="line">              break;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（4）</strong>当（3）中返回的对象不为空，则调用<code>copyDetails()</code>方法将旧<code>AbstractAuthenticationToken</code>对象中的details属性复制到新的<code>AbstractAuthenticationToken</code>对象中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void copyDetails(Authentication source, Authentication dest) {</span><br><span class="line">       if (dest instanceof AbstractAuthenticationToken && dest.getDetails() == null) {</span><br><span class="line">           AbstractAuthenticationToken token = (AbstractAuthenticationToken)dest;</span><br><span class="line">           token.setDetails(source.getDetails());</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（5）</strong>当（3）中返回的对象为空，且<code>AuthenticationManager</code>对象不为空，则调用<code>AuthenticationManager</code>对象的<code>authenticate()</code>方法来进行认证校验。<br><strong>（6）</strong>之后调用<code>eraseCredentials</code>方法将凭证信息擦除掉，这里的凭证信息就是用户密码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (result != null) {</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {</span><br><span class="line">              ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">          }</span><br><span class="line">          if (parentResult == null) {</span><br><span class="line">              this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">          }</span><br><span class="line">            return result;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure></div>
<p>它首先判断（3）中的返回对象不为空，且对象是<code>CredentialsContainer</code>的实例，为什么需要判断？那是因为只有这个<code>CredentialsContainer</code>接口中才存在擦除凭证信息的<code>eraseCredentials()</code>方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface CredentialsContainer {</span><br><span class="line">    void eraseCredentials();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>但是这是一个接口，那么接下看一下它的实现类，可以发现一个比较熟悉的身影<code>UsernamePasswordAuthenticationToken</code>，这里面的<code>eraseCredentials()</code>方法进行了实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void eraseCredentials() {</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">        this.credentials = null;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到它擦除凭证的逻辑非常简单，就是将<code>UsernamePasswordAuthenticationToken</code>对象中的<code>credentials</code>属性设置为null，其实就是密码设置为空。<br><strong>（7）</strong>通过调用<code>MessageSourceAccessor</code>对象的<code>publishAuthenticationSuccess()</code>方法将（3）中成功返回的对象广播出去：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (result != null) {</span><br><span class="line">        if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {</span><br><span class="line">              ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">          }</span><br><span class="line">          if (parentResult == null) {</span><br><span class="line">              this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">          }</span><br><span class="line">            return result;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure></div>
<p>以上就是认证的整个流程，第一遍看的时候非常容易晕，这是正常现象，第一次看源码很正常，看多了就习惯了。</p>
<p>这里再捋一下上面的逻辑，首先得到当前Authentication对象的Class信息，接着通过<code>getProviders().iterator()</code>方法得到一个迭代器对象，之后遍历这个迭代器对象，请注意不是所有的<code>AuthenticationProvider</code>对象都支持<code>Authentication</code>，如<code>AnonymousAuthenticationProvider</code>就不支持，因此它调用<code>AuthenticationManager</code>接口对象（代码中的parent）的<code>authenticate()</code>方法进行认证校验。而这个<code>AuthenticationManager</code>接口对象的实现类是<code>ProviderManager</code>，因此又回到了此处的<code>authenticate</code>方法中。不过此时的provider就变成了<code>DaoAuthenticationProvider</code>，这个provider是支持<code>Authentication</code>的（如<code>UsernamePasswordAuthenticationToken</code>），因此会进入到<code>DaoAuthenticationProvider</code>类的<code>authenticate</code>方法中执行，但是笔者并没有在<code>DaoAuthenticationProvider</code>类中发现<code>authenticate</code>方法：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-3f8e25a83a724d05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-3f8e25a83a724d05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>老规矩，它没有就去查看它实现的接口或者继承的类，可以发现在它继承的<code>AbstractUserDetailsAuthenticationProvider</code>类中就发现了<code>authenticate</code>方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -> {</span><br><span class="line">            return this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports", "Only UsernamePasswordAuthenticationToken is supported");</span><br><span class="line">        });</span><br><span class="line">        String username = this.determineUsername(authentication);</span><br><span class="line">        boolean cacheWasUsed = true;</span><br><span class="line">        UserDetails user = this.userCache.getUserFromCache(username);</span><br><span class="line">        if (user == null) {</span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            } catch (UsernameNotFoundException var6) {</span><br><span class="line">                this.logger.debug("Failed to find user '" + username + "'");</span><br><span class="line">                if (!this.hideUserNotFoundExceptions) {</span><br><span class="line">                    throw var6;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        } catch (AuthenticationException var7) {</span><br><span class="line">            if (!cacheWasUsed) {</span><br><span class="line">                throw var7;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line">            user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.postAuthenticationChecks.check(user);</span><br><span class="line">        if (!cacheWasUsed) {</span><br><span class="line">            this.userCache.putUserInCache(user);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Object principalToReturn = user;</span><br><span class="line">        if (this.forcePrincipalAsString) {</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>仔细查看上述代码的逻辑：<br><strong>（1）</strong>判断<code>authentication</code>对象是否是<code>UsernamePasswordAuthenticationToken</code>类型的实例，如果是的话则从Authentication中获取当前登录用户的用户名；<br><strong>（2）</strong>从缓存中通过用户名来获取用户信息，如果获取不到用户信息则说明缓存未启用；反之得到用户信息；<br><strong>（3）</strong>调用retrieveUser方法，将得到的用户名和之前的<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入，查看一下这个retrieveUser方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        this.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            if (loadedUser == null) {</span><br><span class="line">                throw new InternalAuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");</span><br><span class="line">            } else {</span><br><span class="line">                return loadedUser;</span><br><span class="line">            }</span><br><span class="line">        } catch (UsernameNotFoundException var4) {</span><br><span class="line">            this.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            throw var4;</span><br><span class="line">        } catch (InternalAuthenticationServiceException var5) {</span><br><span class="line">            throw var5;</span><br><span class="line">        } catch (Exception var6) {</span><br><span class="line">            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到它首先调用<code>getUserDetailsService()</code>方法得到一个<code>UserDetailsService</code>对象，之后调用它的<code>loadUserByUsername()</code>方法来获取<code>UserDetails</code>对象，注意到了么，这个就是之前我们自定义的<code>UserDetailService</code>类中的<code>loadUserByUsername()</code>方法，也就是说此处返回的<code>UserDetails</code>对象其实就是登录对象User：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MyUserDetailService implements UserDetailsService {</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {</span><br><span class="line">        User user = userRepository.findUserByUsername(username);</span><br><span class="line">        if(user==null){</span><br><span class="line">            throw new UsernameNotFoundException("用户不存在");</span><br><span class="line">        }</span><br><span class="line">        return user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（4）</strong>调用<code>preAuthenticationChecks.check(user)</code>方法来检查User对象的各个属性是否正常。查看一下这个check方法，发现它存在于<code>UserDetailsChecker</code>接口中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsChecker {</span><br><span class="line">    void check(UserDetails var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>为了弄清楚这个check方法的执行逻辑，这里需要查看<code>UserDetailsChecker</code>接口的实现类<code>AccountStatusUserDetailsChecker</code>，在这个实现类中就有check方法的具体实现逻辑：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void check(UserDetails user) {</span><br><span class="line">      if (!user.isAccountNonLocked()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is locked");</span><br><span class="line">          throw new LockedException(this.messages.getMessage("AccountStatusUserDetailsChecker.locked", "User account is locked"));</span><br><span class="line">      } else if (!user.isEnabled()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is disabled");</span><br><span class="line">          throw new DisabledException(this.messages.getMessage("AccountStatusUserDetailsChecker.disabled", "User is disabled"));</span><br><span class="line">      } else if (!user.isAccountNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is expired");</span><br><span class="line">          throw new AccountExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.expired", "User account has expired"));</span><br><span class="line">      } else if (!user.isCredentialsNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account credentials have expired");</span><br><span class="line">          throw new CredentialsExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.credentialsExpired", "User credentials have expired"));</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这里主要对用户的账户是否未锁住、是否可用、是否未过期、密码是否过期等进行判断，满足其中任意一个都会抛出异常。<br><strong>（5）</strong>接着调用<code>additionalAuthenticationChecks()</code>方法来对用户密码进行判断，查看这个方法的源码，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void additionalAuthenticationChecks(UserDetails var1, UsernamePasswordAuthenticationToken var2) throws AuthenticationException;</span><br></pre></td></tr></tbody></table></figure></div>
<p>这是一个抽象方法，得找一个这个抽象类的具体实现才行，又回到了<code>DaoAuthenticationProvider</code>这个类，可以发现这个类中的<code>additionalAuthenticationChecks</code>方法就提供了具体实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">       if (authentication.getCredentials() == null) {</span><br><span class="line">           this.logger.debug("Failed to authenticate since no credentials provided");</span><br><span class="line">           throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">       } else {</span><br><span class="line">           String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">           if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {</span><br><span class="line">               this.logger.debug("Failed to authenticate since password does not match stored value");</span><br><span class="line">               throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。以<code>BCryptPasswordEncoder</code>类中的matches方法为例，查看一下密码的匹配逻辑，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) {</span><br><span class="line">        if (rawPassword == null) {</span><br><span class="line">            throw new IllegalArgumentException("rawPassword cannot be null");</span><br><span class="line">        } else if (encodedPassword != null && encodedPassword.length() != 0) {</span><br><span class="line">            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {</span><br><span class="line">                this.logger.warn("Encoded password does not look like BCrypt");</span><br><span class="line">                return false;</span><br><span class="line">            } else {</span><br><span class="line">                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">            }</span><br><span class="line">        } else {</span><br><span class="line">            this.logger.warn("Empty encoded password");</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>其中rawPassword是获取到的用户密码，而encodedPassword则是数据库中查询到的密码，密码匹配逻辑其实较为简单。</p>
<p><strong>（6）</strong>回到<code>AbstractUserDetailsAuthenticationProvider</code>类的<code>authenticate</code>方法中，密码验证通过后，接下来调用<code>postAuthenticationChecks.check(user)</code>方法来检查密码是否过期。</p>
<p><strong>（7）</strong>之后判断forcePrincipalAsString属性是否为true，该属性是强制将Principal(用户名)转换为String(字符串)对象。其实在<code>UsernamePasswordAuthenticationFilter</code>类中就已经将principal(用户名)设置为字符串，但是在默认情况下，当用户登录成功后，这个属性的值就成了当前用户，也就是UserDetails对象。需要说明的是，这个<code>forcePrincipalAsString</code>属性默认值为false，其实开发者不需要管这个参数，因为没转成字符串，反而更利于后续获取用户信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object principalToReturn = user;</span><br><span class="line">if (this.forcePrincipalAsString) {</span><br><span class="line">    principalToReturn = user.getUsername();</span><br><span class="line">}</span><br><span class="line">return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（8）</strong>最后调用<code>createSuccessAuthentication()</code>方法来构造一个<code>Authentication</code>对象，准确来说是<code>UsernamePasswordAuthenticationToken</code>对象：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) {</span><br><span class="line">       UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">       result.setDetails(authentication.getDetails());</span><br><span class="line">       this.logger.debug("Authenticated user");</span><br><span class="line">       return result;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p>以上就是用户的登录流程和认证过程，但是我们依旧不知道登录的用户信息是在哪个环节被保存的，只有搞清楚这个才算真的搞清楚了用户登录。</p>
<h3 id="保存用户信息"><a href="#保存用户信息" class="headerlink" title="保存用户信息"></a>保存用户信息</h3><p>我们重新捋一下思路，想想上面的登录是从哪来开始执行的，或者说是触发的？</p>
<p>回到<code>UsernamePasswordAuthenticationFilter</code>类，这个类非常重要，登录流程就是从这开始的，查看一下它的父类<code>AbstractAuthenticationProcessingFilter</code>，请注意这个类以后会经常使用，当开发者需要在SpringSecurity中自定义一个登录验证码或者将登录参数修改为JSON的时候，此时都需要自定义自己的Filter类，并继承这个<code>AbstractAuthenticationProcessingFilter</code>类。</p>
<p>如果你之前使用过Servlet，那么肯定对Filter不陌生，在需要对某些资源进行过滤拦截并进行处理，之后返回处理过的内容，就需要自定义Filter类并实现Filter接口，可以点击 <a href="https://www.cnblogs.com/zlbx/p/4888312.html" target="_blank" rel="noopener">这里</a> 进行了解。这个接口中有一个doFilter方法，当拦截到需要执行的请求时，doFilter方法就会执行，开发者可以在这个方法里面书写对请求和响应的预处理逻辑。</p>
<p>在<code>AbstractAuthenticationProcessingFilter</code>这个抽象类中，我们也发现它也存在名为doFilter的方法，源码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {</span><br><span class="line">        if (!this.requiresAuthentication(request, response)) {</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        } else {</span><br><span class="line">            try {</span><br><span class="line">                Authentication authenticationResult = this.attemptAuthentication(request, response);</span><br><span class="line">                if (authenticationResult == null) {</span><br><span class="line">                    return;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                this.sessionStrategy.onAuthentication(authenticationResult, request, response);</span><br><span class="line">                if (this.continueChainBeforeSuccessfulAuthentication) {</span><br><span class="line">                    chain.doFilter(request, response);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                this.successfulAuthentication(request, response, chain, authenticationResult);</span><br><span class="line">            } catch (InternalAuthenticationServiceException var5) {</span><br><span class="line">                this.logger.error("An internal error occurred while trying to authenticate the user.", var5);</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var5);</span><br><span class="line">            } catch (AuthenticationException var6) {</span><br><span class="line">                this.unsuccessfulAuthentication(request, response, var6);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>仔细阅读上述方法的源码，可以发现首先调用<code>requiresAuthentication(request, response)</code>方法来判断是否需要验证，如果不需要就直接执行<code>chain.doFilter()</code>方法；如果需要验证，那么会调用<code>attemptAuthentication()</code>方法，看到没有，原来是在此处调用了<code>UsernamePasswordAuthenticationFilter#attemptAuthentication()</code>方法；且当用户登录成功时，就调用<code>successfulAuthentication()</code>方法，失败则调用<code>unsuccessfulAuthentication()</code>方法。</p>
<p>接下来看一下登录成功时所调用的<code>successfulAuthentication()</code>方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">        if (this.logger.isDebugEnabled()) {</span><br><span class="line">            this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authResult));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line">        if (this.eventPublisher != null) {</span><br><span class="line">            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>注意这里面第一行代码<code>SecurityContextHolder.getContext().setAuthentication(authResult);</code>，它的作用是获取上下文，并将之前的验证结果赋值给Authentication属性，原来成功的登录信息都会被保存在这里，因此当我们需要获取用户的登录信息时，可以直接从<code>SecurityContextHolder.getContext();</code>中获取，这其实是一个<code>SecurityContext</code>对象。当然如果想修改用户信息，也只需修改这个<code>SecurityContext</code>对象。</p>
<p>回到上面的<code>successfulAuthentication</code>方法中，继续往下读源码，之后会调用<code>rememberMeServices.loginSuccess()</code>方法，将登录信息写入“记住我”中，这个是当用户使用了“记住我”这个功能才有效。接着判断是否存在事件广播者，如果存在则将用户登录成功的信息发布出去。如果不存在则调用<code>successHandler.onAuthenticationSuccess()</code>方法，而这个方法就是我们之前在MySecurityConfig类中配置登录成功时的回调方法，原来那个方法是在这里被触发的：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-1d8d28bd49a86e0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-1d8d28bd49a86e0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>再来看一下登录失败时所调用的<code>unsuccessfulAuthentication()</code>方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {</span><br><span class="line">        SecurityContextHolder.clearContext();</span><br><span class="line">        this.logger.trace("Failed to process authentication request", failed);</span><br><span class="line">        this.logger.trace("Cleared SecurityContextHolder");</span><br><span class="line">        this.logger.trace("Handling authentication failure");</span><br><span class="line">        this.rememberMeServices.loginFail(request, response);</span><br><span class="line">        this.failureHandler.onAuthenticationFailure(request, response, failed);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>同样注意这里面的第一行代码<code>SecurityContextHolder.clearContext();</code>，它的作用是获取上下文，并将上下文内容清空。之后调用<code>rememberMeServices.loginFail()</code>方法来说明“记住我”也是登录失败的。最后调用<code>failureHandler.onAuthenticationFailure()</code>方法，而这个方法同样也是之前我们在MySecurityConfig类中配置登录失败时的回调方法，原来那个方法是在这里被触发的：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-a92f292e451beda7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-a92f292e451beda7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>看到这里我们就对登录流程和认证过程有了清晰的认识，也知道了原来数据保存在<code>SecurityContextHolder.getContext();</code>中，当开发者需要获取和修改登录信息时，只需对该<code>SecurityContext</code>对象进行操作即可。</p>
<p>ok，那么本篇关于登录流程的详细分析就到此为止，后续学习其他内容。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.top/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/">http://envyzhan.top/2020/12/14/springsecurity-8-explain-the-login-process-in-detail/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.top">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springsecurity/">springsecurity    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/12/15/springsecurity-9-add-login-verfication-code/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>添加登录验证码</span></div></a></div><div class="next-post pull_right"><a href="/2020/12/13/springsecurity-7-spring-data-jpa-operation-database/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Spring Data JPA操作数据库</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/28/springsecurity-20-spring-security-procesing-session-in-cluster-environment/" title="集群环境下SpringSecurity处理Session"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">集群环境下SpringSecurity处理Session</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/26/springsecurity-19-defending-against-fixed-session-attacks/" title="防御固定会话攻击"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">防御固定会话攻击</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/24/springsecurity-18-bring-your-own-firewall-to-learn/" title="自带防火墙学习"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">自带防火墙学习</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/23/springsecurity-17-front-and-back-end-separation-jpa-automatically-kick-off-login-users/" title="前后端分离+JPA+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">前后端分离+JPA+自动踢掉登录用户</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/22/springsecurity-16-traditional-way-jpa-automaticallly-kick-off-login-users/" title="传统方式+JPA+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">传统方式+JPA+自动踢掉登录用户</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/21/springsecurity-15-save-users-in-memory-and-automatically-kick-off-login-users/" title="内存保存用户+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">内存保存用户+自动踢掉登录用户</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '9996b44b488f2fc52124',
  clientSecret: '6bec0f8e9c032eeae6211a5d4cffa3c97e2d4a64',
  repo: 'blogcomment',
  owner: 'Envythink',
  admin: 'Envythink',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">Copyright &copy;2017-2021 余思博客, 版权所有</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>