<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>自定义认证逻辑 | 余思博客</title><meta name="description" content="自定义认证逻辑"><meta name="keywords" content="springsecurity"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="自定义认证逻辑"><meta name="twitter:description" content="自定义认证逻辑"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="自定义认证逻辑"><meta property="og:url" content="http://envyzhan.top/2020/12/19/springsecurity-13-custom-authentication-logic/"><meta property="og:site_name" content="余思博客"><meta property="og:description" content="自定义认证逻辑"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://envyzhan.top/2020/12/19/springsecurity-13-custom-authentication-logic/"><link rel="prev" title="获取登录额外信息" href="http://envyzhan.top/2020/12/20/springsecurity-14-get-additional-login-information/"><link rel="next" title="令牌持久化和二次验证" href="http://envyzhan.top/2020/12/18/springsecurity-12-token-persistence-and-secondary-verfication/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://envythink.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: 余思","link":"链接: http://envyzhan.top/2020/12/19/springsecurity-13-custom-authentication-logic/","source":"来源: 余思博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">余思博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-html5" aria-hidden="true"></i><span> 前端</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> Java</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 运维</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 中间件</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/nginx/"><i class="fa-fw fa fa-location-arrow"></i><span> Nginx</span></a></li><li><a class="site-page" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bell" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 数据结构</span></a></li><li><a class="site-page" href="/categories/algorithm/"><i class="fa-fw fa fa-plane"></i><span> 算法建模</span></a></li><li><a class="site-page" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-address-book" aria-hidden="true"></i><span> 生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">213</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-html5" aria-hidden="true"></i><span> 前端</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> Java</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 运维</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 中间件</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page" href="/categories/nginx/"><i class="fa-fw fa fa-location-arrow"></i><span> Nginx</span></a></li><li><a class="site-page" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-bell" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 数据结构</span></a></li><li><a class="site-page" href="/categories/algorithm/"><i class="fa-fw fa fa-plane"></i><span> 算法建模</span></a></li><li><a class="site-page" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-address-book" aria-hidden="true"></i><span> 生活</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#写在前面"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">写在前面</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#知识回顾"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">知识回顾</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#认证流程分析"><span class="toc_mobile_items-number">2.0.1.</span> <span class="toc_mobile_items-text">认证流程分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#authenticate方法分析"><span class="toc_mobile_items-number">2.0.1.0.1.</span> <span class="toc_mobile_items-text">authenticate方法分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#supports方法分析"><span class="toc_mobile_items-number">2.0.1.0.2.</span> <span class="toc_mobile_items-text">supports方法分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#additionalAuthenticationChecks方法分析"><span class="toc_mobile_items-number">2.0.1.0.3.</span> <span class="toc_mobile_items-text">additionalAuthenticationChecks方法分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#自定义认证"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">自定义认证</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代码实现"><span class="toc_mobile_items-number">3.0.1.</span> <span class="toc_mobile_items-text">代码实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#创建工程"><span class="toc_mobile_items-number">3.0.1.0.1.</span> <span class="toc_mobile_items-text">创建工程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#提供一个验证码实例"><span class="toc_mobile_items-number">3.0.1.0.2.</span> <span class="toc_mobile_items-text">提供一个验证码实例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#提供一个返回验证码接口"><span class="toc_mobile_items-number">3.0.1.0.3.</span> <span class="toc_mobile_items-text">提供一个返回验证码接口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#提供一个AuthenticationProvider类"><span class="toc_mobile_items-number">3.0.1.0.4.</span> <span class="toc_mobile_items-text">提供一个AuthenticationProvider类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#提供一个响应类对象"><span class="toc_mobile_items-number">3.0.1.0.5.</span> <span class="toc_mobile_items-text">提供一个响应类对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#自定义SecurityConfig类"><span class="toc_mobile_items-number">3.0.1.0.6.</span> <span class="toc_mobile_items-text">自定义SecurityConfig类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#项目测试"><span class="toc_mobile_items-number">3.0.1.0.7.</span> <span class="toc_mobile_items-text">项目测试</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#知识回顾"><span class="toc-number">2.</span> <span class="toc-text">知识回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认证流程分析"><span class="toc-number">2.0.1.</span> <span class="toc-text">认证流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#authenticate方法分析"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">authenticate方法分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#supports方法分析"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">supports方法分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#additionalAuthenticationChecks方法分析"><span class="toc-number">2.0.1.0.3.</span> <span class="toc-text">additionalAuthenticationChecks方法分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义认证"><span class="toc-number">3.</span> <span class="toc-text">自定义认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码实现"><span class="toc-number">3.0.1.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建工程"><span class="toc-number">3.0.1.0.1.</span> <span class="toc-text">创建工程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提供一个验证码实例"><span class="toc-number">3.0.1.0.2.</span> <span class="toc-text">提供一个验证码实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提供一个返回验证码接口"><span class="toc-number">3.0.1.0.3.</span> <span class="toc-text">提供一个返回验证码接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提供一个AuthenticationProvider类"><span class="toc-number">3.0.1.0.4.</span> <span class="toc-text">提供一个AuthenticationProvider类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提供一个响应类对象"><span class="toc-number">3.0.1.0.5.</span> <span class="toc-text">提供一个响应类对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#自定义SecurityConfig类"><span class="toc-number">3.0.1.0.6.</span> <span class="toc-text">自定义SecurityConfig类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#项目测试"><span class="toc-number">3.0.1.0.7.</span> <span class="toc-text">项目测试</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">自定义认证逻辑</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-12-19</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/springsecurity/">springsecurity</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 20 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/12/19/springsecurity-13-custom-authentication-logic/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在前面我们对SpringSecurity中的登录流程进行了较为详细的分析，但是采用的都是系统默认的认证逻辑，这种方式在学习中尚能使用，但是在实际工作中一般都会自定义登录逻辑。笔者结合自己实际工作中的一些应用来介绍一种比较常用的自定义认证逻辑。</p>
<h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><p>前面我们在《添加登录验证码》和《前后端分离JSON格式登录实现》两篇文章中，通过自定义过滤器，并在过滤器中实现了相应的逻辑，这些也是自定义认证逻辑的范畴，只不过是最为基础罢了，但是它们都存在一些问题，如下面的例子所述的那样。</p>
<p>假设现在有一个系统，我们给它添加了一个验证码，同时为了校验验证码，需要自定义一个过滤器，并将该过滤器放入SpringSecurity的过滤器链中，之后每次请求都会通过该过滤器。这样的逻辑看似没有问题，但是你仔细想就会发现，我们仅仅需要登录的请求经过该过滤器，其他请求是无需经过的，因此如果你对性能有较为严苛的要求，那么就有必要对上述逻辑进行修改。</p>
<h3 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h3><p>首先阅读《详解登录流程》一文，之后再来阅读本部分内容会容易很多。</p>
<p>通过查阅<code>ProviderManager#authenticate()</code>方法中的源码可以知道，<code>AuthenticationProvider</code>接口定义了SpringSecurity中的验证逻辑，查看一下该接口的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface AuthenticationProvider {</span><br><span class="line">    Authentication authenticate(Authentication var1) throws AuthenticationException;</span><br><span class="line"></span><br><span class="line">    boolean supports(Class<!--?--> var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>从中可以知道它提供了两个方法，其中authenticate方法用于验证用户身份，supports方法用于判断当前<code>AuthenticationProvider</code>对象是否支持对应的Authentication。Authentication非常重要，里面包含了当前登录用户的信息，查看一下它的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Authentication extends Principal, Serializable {</span><br><span class="line">    Collection<!--? extends GrantedAuthority--> getAuthorities();</span><br><span class="line"></span><br><span class="line">    Object getCredentials();</span><br><span class="line"></span><br><span class="line">    Object getDetails();</span><br><span class="line"></span><br><span class="line">    Object getPrincipal();</span><br><span class="line"></span><br><span class="line">    boolean isAuthenticated();</span><br><span class="line"></span><br><span class="line">    void setAuthenticated(boolean var1) throws IllegalArgumentException;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以发现它是一个接口，其中有6个方法：<br>（1）<code>getAuthorities()</code>方法用来获取用户的权限；<br>（2）<code>getCredentials()</code>方法用来获取用户的凭证，通常这里的凭证就是用户密码；<br>（3）<code>getDetails()</code>方法用来获取用户携带的详细信息；<br>（4）<code>getPrincipal()</code>方法用来获取当前用户，注意它可能是用户名，也可能是用户对象本身；<br>（5）<code>isAuthenticated()</code>方法用来判断当前用户是否认证成功；<br>（6）<code>setAuthenticated()</code>方法用来设置当前用户是否认证。</p>
<p>Authentication接口包含了一些获取用户信息的基本方法，它有很多实现类，如下所示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-cb43680808b900ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-cb43680808b900ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>在上述实现类中，我们用的较多的就是<code>UsernamePasswordAuthenticationToken</code>类，该类用于处理用户名和密码相关的认证逻辑。  请注意每一个<code>Authentication</code>都有与之匹配的<code>AuthenticationProvider</code>去处理校验逻辑，这也是<code>AuthenticationProvider</code>接口提供<code>supports()</code>方法的原因。</p>
<p>那么问题来了，我怎么知道哪个<code>Authentication</code>与哪个<code>AuthenticationProvider</code>相匹配呢？可以查看这个<code>AuthenticationProvider</code>接口的子类信息，如下所示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-f2ac6fb962d9e147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-f2ac6fb962d9e147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>根据它的子类名称就能猜出相应的匹配关系，如上面的<code>UsernamePasswordAuthenticationToken</code>类所对应的<code>AuthenticationProvider</code>就是<code>DaoAuthenticationProvider</code>类。</p>
<p>通过《详解登录流程》一文的学习，我们知道在一次完整的认证中，可能包含多个<code>AuthenticationProvider</code>，而这些<code>AuthenticationProvider</code>都由<code>ProviderManager</code>来进行统一管理。</p>
<p>接下来重点研究之前提到过的<code>DaoAuthenticationProvider</code>，当我们需要使用用户名+密码这一方式进行登录时就会使用到它。<code>DaoAuthenticationProvider</code>类的父类为<code>AbstractUserDetailsAuthenticationProvider</code>类，<code>AbstractUserDetailsAuthenticationProvider</code>类实现了前面所说的<code>AuthenticationProvider</code>接口，且对该接口中的<code>authenticate</code>和<code>supports</code>这两个方法提供了具体的实现，因此我们来看<code>AbstractUserDetailsAuthenticationProvider</code>类中那两个实现的方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -> {</span><br><span class="line">            return this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports", "Only UsernamePasswordAuthenticationToken is supported");</span><br><span class="line">        });</span><br><span class="line">        String username = this.determineUsername(authentication);</span><br><span class="line">        boolean cacheWasUsed = true;</span><br><span class="line">        UserDetails user = this.userCache.getUserFromCache(username);</span><br><span class="line">        if (user == null) {</span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            } catch (UsernameNotFoundException var6) {</span><br><span class="line">                this.logger.debug("Failed to find user '" + username + "'");</span><br><span class="line">                if (!this.hideUserNotFoundExceptions) {</span><br><span class="line">                    throw var6;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        } catch (AuthenticationException var7) {</span><br><span class="line">            if (!cacheWasUsed) {</span><br><span class="line">                throw var7;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cacheWasUsed = false;</span><br><span class="line">            user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            this.preAuthenticationChecks.check(user);</span><br><span class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        this.postAuthenticationChecks.check(user);</span><br><span class="line">        if (!cacheWasUsed) {</span><br><span class="line">            this.userCache.putUserInCache(user);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Object principalToReturn = user;</span><br><span class="line">        if (this.forcePrincipalAsString) {</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">public boolean supports(Class<!--?--> authentication) {</span><br><span class="line">        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<h5 id="authenticate方法分析"><a href="#authenticate方法分析" class="headerlink" title="authenticate方法分析"></a>authenticate方法分析</h5><p>前面多次提到authenticate方法用于用户认证相关的逻辑，接下来分析一下该方法的执行流程：<br><strong>（1）</strong>判断当前Authentication对象是否是<code>UsernamePasswordAuthenticationToken</code>类的实例，如果是，那么就能使用当前的<code>AbstractUserDetailsAuthenticationProvider</code>。<br><strong>（2）</strong>调用<code>determineUsername()</code>方法从登录信息中获取用户名。查看一下这个<code>determineUsername()</code>方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String determineUsername(Authentication authentication) {</span><br><span class="line">        return authentication.getPrincipal() == null ? "NONE_PROVIDED" : authentication.getName();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>这个方法的逻辑非常清晰，就是从Authentication中获取用户身份，这里就是用户名。<br><strong>（3）</strong>从缓存中通过用户名来获取用户信息，如果获取不到用户信息则说明缓存未启用；反之得到用户信息；<br><strong>（4）</strong>调用retrieveUser方法，将得到的用户名和之前的<code>UsernamePasswordAuthenticationToken</code>对象作为参数传入，查看一下这个retrieveUser方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        this.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            if (loadedUser == null) {</span><br><span class="line">                throw new InternalAuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");</span><br><span class="line">            } else {</span><br><span class="line">                return loadedUser;</span><br><span class="line">            }</span><br><span class="line">        } catch (UsernameNotFoundException var4) {</span><br><span class="line">            this.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            throw var4;</span><br><span class="line">        } catch (InternalAuthenticationServiceException var5) {</span><br><span class="line">            throw var5;</span><br><span class="line">        } catch (Exception var6) {</span><br><span class="line">            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到它首先调用<code>getUserDetailsService()</code>方法得到一个<code>UserDetailsService</code>对象，之后调用它的<code>loadUserByUsername()</code>方法来获取<code>UserDetails</code>对象，而这个就是之前我们自定义<code>UserDetailService</code>类时所定义的<code>loadUserByUsername()</code>方法。<br><strong>（5）</strong>调用<code>preAuthenticationChecks.check(user)</code>方法来检查User对象的各个属性是否正常。查看一下这个check方法，发现它存在于<code>UserDetailsChecker</code>接口中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDetailsChecker {</span><br><span class="line">    void check(UserDetails var1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>为了弄清楚这个check方法的执行逻辑，这里需要查看<code>UserDetailsChecker</code>接口的实现类<code>AccountStatusUserDetailsChecker</code>，在这个实现类中就有check方法的具体实现逻辑：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void check(UserDetails user) {</span><br><span class="line">      if (!user.isAccountNonLocked()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is locked");</span><br><span class="line">          throw new LockedException(this.messages.getMessage("AccountStatusUserDetailsChecker.locked", "User account is locked"));</span><br><span class="line">      } else if (!user.isEnabled()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is disabled");</span><br><span class="line">          throw new DisabledException(this.messages.getMessage("AccountStatusUserDetailsChecker.disabled", "User is disabled"));</span><br><span class="line">      } else if (!user.isAccountNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account is expired");</span><br><span class="line">          throw new AccountExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.expired", "User account has expired"));</span><br><span class="line">      } else if (!user.isCredentialsNonExpired()) {</span><br><span class="line">          this.logger.debug("Failed to authenticate since user account credentials have expired");</span><br><span class="line">          throw new CredentialsExpiredException(this.messages.getMessage("AccountStatusUserDetailsChecker.credentialsExpired", "User credentials have expired"));</span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这里主要对用户的账户是否未锁住、是否可用、是否未过期、密码是否过期等进行判断，满足其中任意一个都会抛出异常。<br><strong>（6）</strong>接着调用<code>additionalAuthenticationChecks()</code>方法来对用户密码进行判断，查看这个方法的源码，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected abstract void additionalAuthenticationChecks(UserDetails var1, UsernamePasswordAuthenticationToken var2) throws AuthenticationException;</span><br></pre></td></tr></tbody></table></figure></div>
<p>这是一个抽象方法，它的具体实现是<code>AbstractUserDetailsAuthenticationProvider</code>类的子类。其实非常好理解，因为<code>AbstractUserDetailsAuthenticationProvider</code>是一个较为通用的父类，用于处理一些通用的逻辑。但是请注意，并不是任何时候的登录都需要输入用户密码，因此这里的<code>additionalAuthenticationChecks()</code>方法最好就是抽象方法，具体的实例逻辑交由<code>AbstractUserDetailsAuthenticationProvider</code>类的子类来实现。</p>
<p>对于此处而言就是<code>DaoAuthenticationProvider</code>这个类，可以发现这个类中的<code>additionalAuthenticationChecks</code>方法就提供了具体实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">       if (authentication.getCredentials() == null) {</span><br><span class="line">           this.logger.debug("Failed to authenticate since no credentials provided");</span><br><span class="line">           throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">       } else {</span><br><span class="line">           String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">           if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {</span><br><span class="line">               this.logger.debug("Failed to authenticate since password does not match stored value");</span><br><span class="line">               throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。以<code>BCryptPasswordEncoder</code>类中的matches方法为例，查看一下密码的匹配逻辑，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(CharSequence rawPassword, String encodedPassword) {</span><br><span class="line">        if (rawPassword == null) {</span><br><span class="line">            throw new IllegalArgumentException("rawPassword cannot be null");</span><br><span class="line">        } else if (encodedPassword != null && encodedPassword.length() != 0) {</span><br><span class="line">            if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {</span><br><span class="line">                this.logger.warn("Encoded password does not look like BCrypt");</span><br><span class="line">                return false;</span><br><span class="line">            } else {</span><br><span class="line">                return BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">            }</span><br><span class="line">        } else {</span><br><span class="line">            this.logger.warn("Empty encoded password");</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>其中rawPassword是获取到的用户密码，而encodedPassword则是数据库中查询到的密码，密码匹配逻辑其实较为简单。<br><strong>（7）</strong>回到<code>AbstractUserDetailsAuthenticationProvider</code>类的<code>authenticate</code>方法中，密码验证通过后，接下来调用<code>postAuthenticationChecks.check(user)</code>方法来检查密码是否过期。<br><strong>（8）</strong>之后判断<code>forcePrincipalAsString</code>属性是否为true，该属性是强制将Principal(用户名)转换为String(字符串)对象。其实在<code>UsernamePasswordAuthenticationFilter</code>类中就已经将principal(用户名)设置为字符串，但是在默认情况下，当用户登录成功后，这个属性的值就成了当前用户，也就是UserDetails对象。需要说明的是，这个<code>forcePrincipalAsString</code>属性默认值为false，其实开发者不需要管这个参数，因为没转成字符串，反而更利于后续获取用户信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object principalToReturn = user;</span><br><span class="line">if (this.forcePrincipalAsString) {</span><br><span class="line">    principalToReturn = user.getUsername();</span><br><span class="line">}</span><br><span class="line">return this.createSuccessAuthentication(principalToReturn, authentication, user);</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>（9）</strong>最后调用<code>createSuccessAuthentication()</code>方法来构造一个<code>Authentication</code>对象，准确来说是<code>UsernamePasswordAuthenticationToken</code>对象：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) {</span><br><span class="line">       UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">       result.setDetails(authentication.getDetails());</span><br><span class="line">       this.logger.debug("Authenticated user");</span><br><span class="line">       return result;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<h5 id="supports方法分析"><a href="#supports方法分析" class="headerlink" title="supports方法分析"></a>supports方法分析</h5><p>接下来再来看那个supports方法的作用，这里再次贴一下该方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean supports(Class<!--?--> authentication) {</span><br><span class="line">        return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到该方法的逻辑非常简单，就是判断当前<code>Authentication</code>对象是否是<code>UsernamePasswordAuthenticationToken</code>对象。</p>
<h5 id="additionalAuthenticationChecks方法分析"><a href="#additionalAuthenticationChecks方法分析" class="headerlink" title="additionalAuthenticationChecks方法分析"></a>additionalAuthenticationChecks方法分析</h5><p>由于<code>AbstractUserDetailsAuthenticationProvider</code>抽象类已经实现了authenticate和supports方法，因此在<code>AbstractUserDetailsAuthenticationProvider</code>的子类DaoAuthenticationProvider中，我们着重关注<code>additionalAuthenticationChecks</code>这个方法，而这个方法在前面我们就对它进行了分析，这里再次贴上它的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        if (authentication.getCredentials() == null) {</span><br><span class="line">            this.logger.debug("Failed to authenticate since no credentials provided");</span><br><span class="line">            throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">        } else {</span><br><span class="line">            String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">            if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {</span><br><span class="line">                this.logger.debug("Failed to authenticate since password does not match stored value");</span><br><span class="line">                throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>在这个方法中首先会判断用户密码是否为空，如果为空则抛出异常；不为空则得到当前登录用户的密码，之后调用<code>passwordEncoder.matches()</code>方法将之前获取到的密码与数据库中存储的密码是否一致，不一致则抛出异常。</p>
<p>从前面《详解登录流程》一文中可以知道，<code>AuthenticationProvider</code>都是通过<code>ProviderManager#authenticate()</code>方法来调用的，因此这里有必要再次粘贴该方法的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException {</span><br><span class="line">       Class<!--? extends Authentication--> toTest = authentication.getClass();</span><br><span class="line">       AuthenticationException lastException = null;</span><br><span class="line">       AuthenticationException parentException = null;</span><br><span class="line">       Authentication result = null;</span><br><span class="line">       Authentication parentResult = null;</span><br><span class="line">       int currentPosition = 0;</span><br><span class="line">       int size = this.providers.size();</span><br><span class="line">       Iterator var9 = this.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">       while(var9.hasNext()) {</span><br><span class="line">           AuthenticationProvider provider = (AuthenticationProvider)var9.next();</span><br><span class="line">           if (provider.supports(toTest)) {</span><br><span class="line">               if (logger.isTraceEnabled()) {</span><br><span class="line">                   Log var10000 = logger;</span><br><span class="line">                   String var10002 = provider.getClass().getSimpleName();</span><br><span class="line">                   ++currentPosition;</span><br><span class="line">                   var10000.trace(LogMessage.format("Authenticating request with %s (%d/%d)", var10002, currentPosition, size));</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               try {</span><br><span class="line">                   result = provider.authenticate(authentication);</span><br><span class="line">                   if (result != null) {</span><br><span class="line">                       this.copyDetails(authentication, result);</span><br><span class="line">                       break;</span><br><span class="line">                   }</span><br><span class="line">               } catch (InternalAuthenticationServiceException | AccountStatusException var14) {</span><br><span class="line">                   this.prepareException(var14, authentication);</span><br><span class="line">                   throw var14;</span><br><span class="line">               } catch (AuthenticationException var15) {</span><br><span class="line">                   lastException = var15;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       if (result == null && this.parent != null) {</span><br><span class="line">           try {</span><br><span class="line">               parentResult = this.parent.authenticate(authentication);</span><br><span class="line">               result = parentResult;</span><br><span class="line">           } catch (ProviderNotFoundException var12) {</span><br><span class="line">               ;</span><br><span class="line">           } catch (AuthenticationException var13) {</span><br><span class="line">               parentException = var13;</span><br><span class="line">               lastException = var13;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       if (result != null) {</span><br><span class="line">           if (this.eraseCredentialsAfterAuthentication && result instanceof CredentialsContainer) {</span><br><span class="line">               ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           if (parentResult == null) {</span><br><span class="line">               this.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       } else {</span><br><span class="line">           if (lastException == null) {</span><br><span class="line">               lastException = new ProviderNotFoundException(this.messages.getMessage("ProviderManager.providerNotFound", new Object[]{toTest.getName()}, "No AuthenticationProvider found for {0}"));</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           if (parentException == null) {</span><br><span class="line">               this.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           throw lastException;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div>
<p>几乎所有关于认证的逻辑都在这个方法中，详细的流程分析这里就不再赘述，可以知道这个方法里面会遍历所有的<code>AuthenticationProvider</code>对象，并调用它的<code>authenticate()</code>方法来进行用户认证。</p>
<h1 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h1><p>通过上面的知识回顾，我们已经知道之前通过自定义过滤器，然后将过滤器添加到SpringSecurity过滤器链中，进而实现添加验证码这一功能，这种方式其实是有问题的，它破坏了原有的过滤器链，使得一些非登录请求也需要经过上述配置的验证码过滤器，无形中降低了系统的性能。</p>
<p>因此我们需要对上述方式进行改进，改进的思路也很简单，不过在此之前需要捋一下登录请求的思路，将上面分析的几个方法给串起来。首先调用<code>attemptAuthentication</code>方法来进行尝试验证，之后调用<code>AbstractUserDetailsAuthenticationProvider#authenticate</code>方法来进行登录认证，在这个认证方法中又会调用<code>DaoAuthenticationProvider#additionalAuthenticationChecks</code>方法来校验用户登录密码。因此，我们的思路就是自定义一个<code>AuthenticationProvider</code>类并重写其中的<code>additionalAuthenticationChecks</code>方法，进而替换此处用于密码校验的<code>DaoAuthenticationProvider#additionalAuthenticationChecks</code>方法。</p>
<p>这样做的好处就是既能实现自定义功能，又能保持原有过滤器链的完整性。常见的手机号码动态登录也可以使用这种方式来认证，这一部分内容将在下一篇中介绍。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处同样是实现验证码登录，但是就不再自己定义生成验证码的逻辑了，而是直接使用网上现成的<a href="https://github.com/penggle/kaptcha" target="_blank" rel="noopener">kaptcha</a>，这个项目是Google项目的复制品，可以直接使用，非常方便。</p>
<h5 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h5><p>使用IDEA创建一个名为<code>customize-kaptcha</code>的SpringBoot工程：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-6a00e15cf104addb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-6a00e15cf104addb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>当然也可以在创建项目的时候不添加任何依赖，而是在后续pom.xml依赖文件中添加如下依赖：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><dependencies></dependencies></span><br><span class="line">    <dependency></dependency></span><br><span class="line">        <groupid>org.springframework.boot</groupid></span><br><span class="line">        <artifactid>spring-boot-starter-security</artifactid></span><br><span class="line">    </span><br><span class="line">    <dependency></dependency></span><br><span class="line">        <groupid>org.springframework.boot</groupid></span><br><span class="line">        <artifactid>spring-boot-starter-web</artifactid></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <dependency></dependency></span><br><span class="line">        <groupid>org.springframework.boot</groupid></span><br><span class="line">        <artifactid>spring-boot-starter-test</artifactid></span><br><span class="line">    </span><br><span class="line">    <dependency></dependency></span><br><span class="line">        <groupid>org.springframework.security</groupid></span><br><span class="line">        <artifactid>spring-security-test</artifactid></span><br><span class="line">        <scope>test</scope></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <dependency></dependency></span><br><span class="line">        <groupid>com.github.penggle</groupid></span><br><span class="line">        <artifactid>kaptcha</artifactid></span><br><span class="line">        <version>2.3.2</version></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div>
<h5 id="提供一个验证码实例"><a href="#提供一个验证码实例" class="headerlink" title="提供一个验证码实例"></a>提供一个验证码实例</h5><p>新建config包，并在该包内新建一个<code>VerifyCodeConfig</code>类，其中的代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class VerifyCodeConfig {</span><br><span class="line">    @Bean</span><br><span class="line">    DefaultKaptcha verifyCode(){</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        //定义生成验证码图片的宽度</span><br><span class="line">        properties.setProperty("kaptcha.image.width","150");</span><br><span class="line">        //定义生成验证码图片的高度</span><br><span class="line">        properties.setProperty("kaptcha.image.height","50");</span><br><span class="line">        //定义生成验证码中字符的取值范围</span><br><span class="line">        properties.setProperty("kaptcha.textproducer.char.string", "0123456789");</span><br><span class="line">        //定义验证码中字符的个数,此处为4个</span><br><span class="line">        properties.setProperty("kaptcha.textproducer.char.length", "4");</span><br><span class="line"></span><br><span class="line">        Config config = new Config(properties);</span><br><span class="line">        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        return defaultKaptcha;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>这个类中定义了一个<code>verifyCode()</code>方法，用于返回一个<code>DefaultKaptcha</code>对象，里面设置了验证码的宽度、高度、字符取值范围、字符个数等信息。</p>
<h5 id="提供一个返回验证码接口"><a href="#提供一个返回验证码接口" class="headerlink" title="提供一个返回验证码接口"></a>提供一个返回验证码接口</h5><p>新建controller包，并在该包内新建一个<code>VerifyCodeController</code>类，其中的代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class VerifyCodeController {</span><br><span class="line">    @Autowired</span><br><span class="line">    private DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = "/vercode.jpg")</span><br><span class="line">    public void getVerifyCode(HttpServletResponse response, HttpSession session){</span><br><span class="line">        response.setContentType("image/jpeg");</span><br><span class="line">        String text = defaultKaptcha.createText();</span><br><span class="line">        session.setAttribute("verify_code",text);</span><br><span class="line">        BufferedImage image = defaultKaptcha.createImage(text);</span><br><span class="line">        try {</span><br><span class="line">            ServletOutputStream out = response.getOutputStream();</span><br><span class="line">            ImageIO.write(image,"jpg",out);</span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>请注意上面<code>setContentType()</code>方法中的<code>image/jpeg</code>为固定格式，不能将其修改为<code>image/jpg</code>。上面代码的含义非常简单，就是将生成的验证码中的字符串添加到session中，并将生成的验证码以图片形式展示在页面上。</p>
<h5 id="提供一个AuthenticationProvider类"><a href="#提供一个AuthenticationProvider类" class="headerlink" title="提供一个AuthenticationProvider类"></a>提供一个AuthenticationProvider类</h5><p>新建provider包，并在该包内新建一个<code>MyAuthenticationProvider</code>类，其中的代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyAuthenticationProvider extends DaoAuthenticationProvider {</span><br><span class="line">    @Override</span><br><span class="line">    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {</span><br><span class="line">        //获取当前请求</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        //获取当前响应</span><br><span class="line">        //HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line"></span><br><span class="line">        //获取用户通过表单输入的验证码字符串</span><br><span class="line">        String formCaptcha =request.getParameter("code");</span><br><span class="line">        //获取生成的验证码字符串（从session中获取)</span><br><span class="line">        String genCaptcha = (String) request.getSession().getAttribute("verify_code");</span><br><span class="line"></span><br><span class="line">        if(formCaptcha ==null || genCaptcha ==null || !formCaptcha.equals(genCaptcha)){</span><br><span class="line">            throw new AuthenticationServiceException("验证码错误!");</span><br><span class="line">        }</span><br><span class="line">        super.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这个自定义的<code>AuthenticationProvider</code>类需要继承<code>DaoAuthenticationProvider</code>类，并重写其中的<code>additionalAuthenticationChecks()</code>方法。该方法的逻辑分析如下：<br>（1）首先从上下文中获取当前请求Request对象，注意这种方式在Spring Web中很常见，下面也给出获取Response对象的代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取当前请求</span><br><span class="line">HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">//获取当前响应</span><br><span class="line">HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br></pre></td></tr></tbody></table></figure></div>
<p>（2）接着获取用户通过表单输入的验证码字符串，使用的方法就是<code>request.getParameter()</code>方式；<br>（3）从session中获取生成的验证码字符串，之后判断（2）和（3）中的对象是否相等，如果不等则直接抛出异常；<br>（4）最后调用父类的<code>additionalAuthenticationChecks()</code>方法，其实就是<code>DaoAuthenticationProvider</code>类的方法，用于进行密码的校验逻辑。</p>
<p>前面多次提到，验证码的验证工作是在用户名+密码验证之前进行的，因此这里就是先进行验证码验证，后进行用户名+密码校验。</p>
<h5 id="提供一个响应类对象"><a href="#提供一个响应类对象" class="headerlink" title="提供一个响应类对象"></a>提供一个响应类对象</h5><p>新建bean包，并在该包内新建一个<code>ResponseBean</code>类，其中的代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class ResponseBean {</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    private ResponseBean() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private ResponseBean(Integer status, String message, Object object) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static ResponseBean build(){</span><br><span class="line">        return new ResponseBean();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，只有信息</span><br><span class="line">    public static ResponseBean ok(String message){</span><br><span class="line">        return new ResponseBean(200,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //成功，有信息和数据</span><br><span class="line">    public static ResponseBean ok(String message,Object object){</span><br><span class="line">        return new ResponseBean(200,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，只有信息</span><br><span class="line">    public static ResponseBean error(String message){</span><br><span class="line">        return new ResponseBean(500,message,null);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //失败，有信息和数据</span><br><span class="line">    public static ResponseBean error(String message,Object object){</span><br><span class="line">        return new ResponseBean(500,message,object);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() {</span><br><span class="line">        return status;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setStatus(Integer status) {</span><br><span class="line">        this.status = status;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getMessage() {</span><br><span class="line">        return message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setMessage(String message) {</span><br><span class="line">        this.message = message;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getObject() {</span><br><span class="line">        return object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public ResponseBean setObject(Object object) {</span><br><span class="line">        this.object = object;</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>可以看到这个类中定义了3个属性，然后提供ok和error的方法，注意这两个方法都存在多个重写方法，以适应不同的需求。</p>
<h5 id="自定义SecurityConfig类"><a href="#自定义SecurityConfig类" class="headerlink" title="自定义SecurityConfig类"></a>自定义SecurityConfig类</h5><p>在前面我们自定义了<code>MyAuthenticationProvider</code>类，接下就是配置如何让自定义的<code>MyAuthenticationProvider</code>类来代替默认的<code>DaoAuthenticationProvider</code>类。</p>
<p>由于所有的<code>AuthenticationProvider</code>都是放在<code>ProviderManager</code>中进行管理，因此就需要开发者自己提供<code>ProviderManager</code>，然后将此处自定义的<code>MyAuthenticationProvider</code>注入其中。</p>
<p>在config包内新建一个<code>SecurityConfig</code>类，注意它需要继承<code>WebSecurityConfigurerAdapter</code>类，里面的代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter {</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() {</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    MyAuthenticationProvider myAuthenticationProvider() {</span><br><span class="line">        MyAuthenticationProvider myAuthenticationProvider = new MyAuthenticationProvider();</span><br><span class="line">        myAuthenticationProvider.setPasswordEncoder(passwordEncoder());</span><br><span class="line">        myAuthenticationProvider.setUserDetailsService(userDetailsService());</span><br><span class="line">        return myAuthenticationProvider;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    protected AuthenticationManager authenticationManager() throws Exception {</span><br><span class="line">        ProviderManager manager = new ProviderManager(Arrays.asList(myAuthenticationProvider()));</span><br><span class="line">        return manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    protected UserDetailsService userDetailsService() {</span><br><span class="line">        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername("envy").password("1234").roles("admin").build());</span><br><span class="line">        return manager;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception {</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers("/vercode.jpg").permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .successHandler((request, response, authentication) -> {</span><br><span class="line">                    response.setContentType("application/json;charset=utf-8");</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(new ObjectMapper().writeValueAsString(ResponseBean.ok("success", authentication.getPrincipal())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                })</span><br><span class="line">                .failureHandler((request, response, exception) -> {</span><br><span class="line">                    response.setContentType("application/json;charset=utf-8");</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(new ObjectMapper().writeValueAsString(ResponseBean.error(exception.getMessage())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                })</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>接下来分析一下上述代码的含义：<br>（1）定义一个<code>passwordEncoder</code>方法，该方法用于返回一个不对密码进行加密的<code>PasswordEncoder</code>对象；<br>（2）定义一个<code>myAuthenticationProvider</code>方法，该方法用于返回一个<code>MyAuthenticationProvider</code>对象，这个对象设置了密码编码属性和用户详细信息。<br>（3）定义一个<code>authenticationManager</code>方法，该方法用于返回一个<code>AuthenticationManager</code>对象，请注意这个方法里面先构建一个<code>ProviderManager</code>对象，然后将之前自定义的<code>MyAuthenticationProvider</code>注入其中。<br>（4）定义一个<code>userDetailsService</code>方法，该方法用于返回一个<code>UserDetailsService</code>对象。请注意这里为了简单起见，我直接将用户存在了内存中，当然如果开发者想将其存在数据库中，可以参考之前的《Spring Data JPA操作数据库》一文。<br>（5）<code>configure(HttpSecurity http)</code>方法就是对资源进行控制，注意这个<code>/vercode.jpg</code>接口需要放开，任何人都可以访问。之后定义登录成功处理器以及失败处理器并显示对应的信息。</p>
<p>通过以上内容的配置，我们就能在不修改原来过滤器链的的情况下，又将自己自定义的验证码逻辑添加进去。</p>
<h5 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h5><p>接下来启动项目，开始进行测试。打开Postman，开始进行登录，首先输入正确的用户名和密码，但是输入错误的验证码，之后点击登录，可以发现现实“验证码错误”：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-d6c8b3a2072668bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-d6c8b3a2072668bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>接下来直接访问<code>/vercode.jpg</code>接口，可以看到验证码图片显示正常：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-8160f445cabafe88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-8160f445cabafe88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>之后回到登录接口，这次输入正确的用户名+密码+验证码，可以看到用户登录成功了：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-f6362fca97333cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-f6362fca97333cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>如果用户输入正确的用户名和验证码，但是输入错误的密码时，页面会显示如下信息：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/8964398-aea8f83062bb48db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://upload-images.jianshu.io/upload_images/8964398-aea8f83062bb48db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload mediumZoom" title></a></p>
<p>ok，那么本篇关于自定义认证逻辑的学习就到此为止，后续学习其他内容。</p>
</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.top/2020/12/19/springsecurity-13-custom-authentication-logic/">http://envyzhan.top/2020/12/19/springsecurity-13-custom-authentication-logic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.top">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springsecurity/">springsecurity    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/12/20/springsecurity-14-get-additional-login-information/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>获取登录额外信息</span></div></a></div><div class="next-post pull_right"><a href="/2020/12/18/springsecurity-12-token-persistence-and-secondary-verfication/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>令牌持久化和二次验证</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/12/28/springsecurity-20-spring-security-procesing-session-in-cluster-environment/" title="集群环境下SpringSecurity处理Session"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">集群环境下SpringSecurity处理Session</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/26/springsecurity-19-defending-against-fixed-session-attacks/" title="防御固定会话攻击"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">防御固定会话攻击</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/24/springsecurity-18-bring-your-own-firewall-to-learn/" title="自带防火墙学习"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">自带防火墙学习</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/23/springsecurity-17-front-and-back-end-separation-jpa-automatically-kick-off-login-users/" title="前后端分离+JPA+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">前后端分离+JPA+自动踢掉登录用户</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/22/springsecurity-16-traditional-way-jpa-automaticallly-kick-off-login-users/" title="传统方式+JPA+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">传统方式+JPA+自动踢掉登录用户</div></div></a></div><div class="relatedPosts_item"><a href="/2020/12/21/springsecurity-15-save-users-in-memory-and-automatically-kick-off-login-users/" title="内存保存用户+自动踢掉登录用户"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-03-01</div><div class="relatedPosts_title">内存保存用户+自动踢掉登录用户</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '9996b44b488f2fc52124',
  clientSecret: '6bec0f8e9c032eeae6211a5d4cffa3c97e2d4a64',
  repo: 'blogcomment',
  owner: 'Envythink',
  admin: 'Envythink',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">Copyright &copy;2017-2021 余思博客, 版权所有</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">簡</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>