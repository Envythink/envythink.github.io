<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringBoot轻松实现接口加解密 | 余思博客</title><meta name="keywords" content="springboot"><meta name="author" content="余思"><meta name="copyright" content="余思"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开发者可以自定义过滤器，将请求和响应分别拦截并进行相应的解密与加密操作。可以看到这种方式简单粗暴，灵活度高，适应性强。不过呢，本篇决定使用另一种思录，即使用SpringMVC提供的@RequestBodyAdvice和@ResponseBodyAdvice注解来对请求和">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot轻松实现接口加解密">
<meta property="og:url" content="http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/index.html">
<meta property="og:site_name" content="余思博客">
<meta property="og:description" content="写在前面最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开发者可以自定义过滤器，将请求和响应分别拦截并进行相应的解密与加密操作。可以看到这种方式简单粗暴，灵活度高，适应性强。不过呢，本篇决定使用另一种思录，即使用SpringMVC提供的@RequestBodyAdvice和@ResponseBodyAdvice注解来对请求和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png">
<meta property="article:published_time" content="2022-06-18T09:55:30.000Z">
<meta property="article:modified_time" content="2022-09-12T08:27:28.326Z">
<meta property="article:author" content="余思">
<meta property="article:tag" content="springboot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot轻松实现接口加解密',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-12 16:27:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="余思博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">257</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">余思博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 前端</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/html/"><i class="fa-fw fa fa-cog"></i><span> HTML/CSS</span></a></li><li><a class="site-page child" href="/categories/javascript/"><i class="fa-fw fa fa-cogs"></i><span> JavaScript</span></a></li><li><a class="site-page child" href="/categories/vuejs/"><i class="fa-fw fa fa-certificate"></i><span> Vue.js</span></a></li><li><a class="site-page child" href="/categories/flutter/"><i class="fa-fw fa fa-bullseye"></i><span> Flutter</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> Java</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw fa fa-book"></i><span> Java</span></a></li><li><a class="site-page child" href="/categories/ssm/"><i class="fa-fw fa fa-cube"></i><span> SSM</span></a></li><li><a class="site-page child" href="/categories/springboot/"><i class="fa-fw fa fa-cubes"></i><span> SpringBoot</span></a></li><li><a class="site-page child" href="/categories/springcloud/"><i class="fa-fw fa fa-cloud"></i><span> SpringCloud</span></a></li><li><a class="site-page child" href="/categories/springsecurity/"><i class="fa-fw fa fa-bullseye"></i><span> SpringSecurity</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 运维</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/pythonbase/"><i class="fa-fw fa fa-book"></i><span> Python</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw fa fa-google-plus"></i><span> Golang</span></a></li><li><a class="site-page child" href="/categories/devops/"><i class="fa-fw fa fa-road"></i><span> DevOps</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 中间件</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/mysql/"><i class="fa-fw fa fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/categories/redis/"><i class="fa-fw fa fa-random"></i><span> Redis</span></a></li><li><a class="site-page child" href="/categories/other/"><i class="fa-fw fa fa-location-arrow"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-bell"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/datastructs/"><i class="fa-fw fa fa-plug"></i><span> 算法结构</span></a></li><li><a class="site-page child" href="/categories/tools/"><i class="fa-fw fa fa-hourglass"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-address-book"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/onenote/"><i class="fa-fw fa fa-laptop"></i><span> 个人随笔</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot轻松实现接口加解密</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-18T09:55:30.000Z" title="发表于 2022-06-18 17:55:30">2022-06-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-12T08:27:28.326Z" title="更新于 2022-09-12 16:27:28">2022-09-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/springboot/">springboot</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近负责一个前后端分离架构下新项目的搭建工作，需要考虑到后台接口的加密与解密工作。其实接口的加密与解密是一个很常见的需求，开发者可以自定义过滤器，将请求和响应分别拦截并进行相应的解密与加密操作。可以看到这种方式简单粗暴，灵活度高，适应性强。不过呢，本篇决定使用另一种思录，即使用SpringMVC提供的<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理（预处理）。</p>
<p>本篇尝试利用<code>@RequestBodyAdvice</code>和<code>@ResponseBodyAdvice</code>注解来对请求和响应进行增强处理，并在此基础上对请求和响应进行解密和加密操作，接着将其制作成一个starter并发布到jitPack中，最后新建一个项目来尝试使用该starter。</p>
<h1 id="编写加解密场景启动器"><a href="#编写加解密场景启动器" class="headerlink" title="编写加解密场景启动器"></a>编写加解密场景启动器</h1><p>第一步，新建一个名为<code>encrypt-spring-boot-starter</code>的SpringBoot项目，在其POM文件中新增如下依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>由于此项目用于接口的加解密，适用于Web环境，因此此处必须添加Web依赖，同时可设置scope值为provided。</p>
<p>第二步，新建model包，并在该包内新建一个名为ResultBean的响应结果类，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class ResultBean &#123;</span><br><span class="line">    private Integer status;</span><br><span class="line">    private String message;</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    public Integer getStatus() &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setStatus(Integer status) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getObject() &#123;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setObject(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ResultBean(Integer status, String message, Object object) &#123;</span><br><span class="line">        this.status = status;</span><br><span class="line">        this.message = message;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean build()&#123;</span><br><span class="line">        return new ResultBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(200,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean ok(String message)&#123;</span><br><span class="line">        return new ResultBean(200,message,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message,Object object)&#123;</span><br><span class="line">        return new ResultBean(500,message,object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ResultBean error(String message)&#123;</span><br><span class="line">        return new ResultBean(500,message,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，新建annotations包，并在该包内新建一个名为Decrypt的注解，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 解密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Decrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在annotations包内新建一个名为Encrypt的注解，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 加密注解</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个注解其实是标记注解，其中<code>@Decrypt</code>注解用于标识解密，可用在方法和参数中；<code>@Encrypt</code>注解用于标识加密，可用在方法上。一般来说，我们是对请求或者请求中的参数进行解密，而对响应进行加密。</p>
<p>第四步，新建config包，并在该包内新建一个名为EncryptProperties的属性配置类，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptProperties &#123;</span><br><span class="line">    private final static String DEFAULT_KEY = &quot;www.kenbings.top&quot;;</span><br><span class="line">    private String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    public String getKey() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKey(String key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于用户可能会配置自己的加密key，因此我们需要定义EncryptProperties类，用于将用户在<code>application.properties</code>配置文件中设置的参数进行映射。注意这个加密key必须是16位的字符串，笔者的博客域名刚好满足这个条件。如果开发者没有在<code>application.properties</code>配置文件中配置自己的加密key，那么就会默认使用笔者的博客域名作为默认的加密key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kenbings.encrypt.key=www.kenbings.top</span><br></pre></td></tr></table></figure>
<p>第五步，新建utils包，并在该包内新建一个名为Base64Utils的工具类，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Base64Utils &#123;</span><br><span class="line">    public Base64Utils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decode(byte[] data)&#123;</span><br><span class="line">        return Base64.getDecoder().decode(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 编码</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encode(byte[] data)&#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里我们定义了两个方法，decode方法用于解码，因为请求或者参数是先解码，转换成可读数据字节数组，之后才进行解密。而encode方法用于编码，注意响应先是先加密，然后在编码为Base64字符串。</p>
<p>接着在utils包内新建一个名为AESUtils的加解密类，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class AESUtils &#123;</span><br><span class="line">    private static final String AES_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回一个Cipher</span><br><span class="line">     * @param key</span><br><span class="line">     * @param model</span><br><span class="line">     * @return Cipher密码对象</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    private static Cipher getCipher(byte[] key,int model) throws Exception &#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = new SecretKeySpec(key,&quot;AES&quot;);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model,secretKeySpec);</span><br><span class="line">        return cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES解密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static byte[] decrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.DECRYPT_MODE);</span><br><span class="line">        return cipher.doFinal(Base64Utils.decode(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * AES加密</span><br><span class="line">     * @param key</span><br><span class="line">     * @param data</span><br><span class="line">     * @return Base64字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static String encrypt(byte[] key,byte[] data) throws Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key,Cipher.ENCRYPT_MODE);</span><br><span class="line">        return Base64Utils.encode(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里我们选择了对称加密，且使用了AES算法，采用的是Java自带的Cipher来实现对称加密。这个<code>AES_ALGORITHM</code>变量必须是一个包含三部分的字符串，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p>
<p>第六步，新建request包，并在该包内新建一个名为DecryptRequest的类，该类用于对接口进行解密，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口解密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class DecryptRequest extends RequestBodyAdviceAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return methodParameter.hasMethodAnnotation(Decrypt.class)|| methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        byte[] body = new byte[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        try&#123;</span><br><span class="line">            byte[] decrypt = AESUtils.decrypt(encryptProperties.getKey().getBytes(), body);</span><br><span class="line">            final ByteArrayInputStream bais = new ByteArrayInputStream(decrypt);</span><br><span class="line">            return new HttpInputMessage() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public InputStream getBody() throws IOException &#123;</span><br><span class="line">                    return bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public HttpHeaders getHeaders() &#123;</span><br><span class="line">                    return inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return super.beforeBodyRead(inputMessage,parameter,targetType,converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下上述代码的含义：<br>（1）<code>DecryptRequest</code>类继承了<code>RequestBodyAdviceAdapter</code>类，并重写了其中的<code>supports</code>和<code>beforeBodyRead</code>方法，当然了也可以实现<code>RequestBodyAdvice</code>接口，因为<code>RequestBodyAdviceAdapter</code>类其实也是实现了<code>RequestBodyAdvice</code>接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RequestBodyAdviceAdapter implements RequestBodyAdvice &#123;</span><br><span class="line">    public RequestBodyAdviceAdapter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HttpInputMessage beforeBodyRead(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) throws IOException &#123;</span><br><span class="line">        return inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object afterBodyRead(Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    public Object handleEmptyBody(@Nullable Object body, HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然实现<code>RequestBodyAdvice</code>接口或者继承<code>RequestBodyAdviceAdapter</code>类都可以，那么我们应该使用哪种方式呢？这个很简单，你就看自己需要重写什么方法，如果你只想重写<code>supports</code>和<code>beforeBodyRead</code>方法，那么只需继承<code>RequestBodyAdviceAdapter</code>类，其他方法使用父类的实现即可。<br>（2）<code>supports</code>方法用于判断哪些接口或者参数需要解密，这里的逻辑如果方法上或者方法参数中使用了<code>@Decrypt</code>注解，就表示需要进行解密。<br>（3）<code>beforeBodyRead</code>方法会在参数转换成具体的对象之前执行，这里我们先从流中加载数据，接着对数据进行解密，解密之后构造<code>HttpInputMessage</code>对象并进行返回。<br>（4）注意自定义的RequestBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对请求进行预处理。</p>
<p>第七步，新建response包，并在该包内新建一个名为EncryptResponse的类，该类用于对接口进行加密，里面的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口加密</span><br><span class="line"> */</span><br><span class="line">@EnableConfigurationProperties(EncryptProperties.class)</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class EncryptResponse implements ResponseBodyAdvice&lt;ResultBean&gt; &#123;</span><br><span class="line">    ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EncryptProperties encryptProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;</span><br><span class="line">        return returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ResultBean beforeBodyWrite(ResultBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123;</span><br><span class="line">        byte[] keyBytes = encryptProperties.getKey().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        try &#123;</span><br><span class="line">            String bodyMessage = body.getMessage();</span><br><span class="line">            if(null != bodyMessage)&#123;</span><br><span class="line">                body.setMessage(AESUtils.encrypt(keyBytes,bodyMessage.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">            &#125;</span><br><span class="line">            Object bodyObject = body.getObject();</span><br><span class="line">            if(null != bodyObject)&#123;</span><br><span class="line">                body.setObject(AESUtils.encrypt(keyBytes,objectMapper.writeValueAsBytes(bodyObject)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下上述代码的含义：<br>（1）<code>EncryptResponse</code>类实现了<code>ResponseBodyAdvice</code>接口，并重写了其中的<code>supports</code>和<code>beforeBodyWrite</code>方法。这个<code>ResponseBodyAdvice</code>接口就不存在对应的实现类了。<br>（2）<code>supports</code>方法用于判断哪些接口需要加密，参数returnType表示返回类型，这里的逻辑如果方法上使用了<code>@Encrypt</code>注解，就表示需要进行加密。<br>（3）<code>beforeBodyWrite</code>方法会在数据响应之前执行，即先对响应数据进行处理，之后才转换为JSON数据进行返回。这里处理逻辑非常简单，如果返回的ResultBean对象中的message和object对象不为空，那么就将这些信息进行加密，状态码这个就无需加密，之后将加密后的数据设置回ResultBean对象中。<br>（4）注意自定义的ResponseBodyAdvice实现类上也需要添加<code>@ControllerAdvice</code>注解表示来对响应进行预处理。</p>
<p>第八步，回到config包中，在里面定义一个名为<code>EncryptAutoConfiguration</code>的自动配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.kenbings.encrypt&quot;)</span><br><span class="line">public class EncryptAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类需要添加<code>@ComponentScan</code>注解，并将当前项目下的所有包都交由SpringIOC容器来管理。</p>
<p>第九步，定义<code>spring.factories</code>文件。在项目的resource目录下新建一个名为<code>META-INF</code>的目录，然后在该目录下新建一个名为<code>spring.factories</code>的配置文件，将在第八步定义好的<code>EncryptAutoConfiguration</code>自动配置类的全路径放在里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.kenbings.encrypt.config.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>这样我们就完成了自定义场景启动器的定义工作。</p>
<h1 id="项目本地打包"><a href="#项目本地打包" class="headerlink" title="项目本地打包"></a>项目本地打包</h1><p>第十步，一般来说我们会将自定义的场景启动器打包，然后上传到Maven私服，以供其他同事使用，这里笔者就不上传了，直接本地打包并安装了。点击IDEA中的Maven插件，选择Lifecycle，然后先clean一下，再install一下，这样自定义场景启动器就安装到本地仓库了。</p>
<h1 id="应用测试"><a href="#应用测试" class="headerlink" title="应用测试"></a>应用测试</h1><p>接下来我们新建一个SpringBoot项目，然后在其中引入web依赖以及上面自定义的场景启动器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.kenbings&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>接着新建一个名为Book的实体类，这样便于后续进行测试传参和解密：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新建一个名为<code>BookController</code>的接口类，里面需要提供两个方法，一个是添加新书籍，另一个则是查询书籍信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(BookController.class);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean getBook()&#123;</span><br><span class="line">        Book book = new Book();</span><br><span class="line">        book.setName(&quot;三国演义&quot;);</span><br><span class="line">        book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">        return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/book&quot;)</span><br><span class="line">    public ResultBean addBook(@RequestBody Book book)&#123;</span><br><span class="line">       logger.info(&quot;book is=&#123;&#125;&quot;,book);</span><br><span class="line">        return ResultBean.ok(&quot;成功添加该书籍&quot;,book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们就可以启动项目进行测试，先来测试一下查询书籍信息的getBook方法，可以看到返回信息如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-0082c41d387bd908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后再来测试一下添加新书籍的addBook方法，以JSON形式传递一个Book对象，添加成功后返回如下信息：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-b9969f1084f8d11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>接下来我们对上述接口进行改造。对于查询书籍信息的getBook方法，我们可以对返回的响应数据进行加密，因此在该方法上添加<code>@Encrypt</code>注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/book&quot;)</span><br><span class="line">@Encrypt</span><br><span class="line">public ResultBean getBook()&#123;</span><br><span class="line">    Book book = new Book();</span><br><span class="line">    book.setName(&quot;三国演义&quot;);</span><br><span class="line">    book.setAuthor(&quot;罗贯中&quot;);</span><br><span class="line">    return ResultBean.ok(&quot;成功找到该书籍&quot;,book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后重启项目，重新访问一下该接口，可以看到页面返回信息如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-a8e7c265562fe10f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以看到响应中的信息都被加密了。接下来我们再来看一下用于添加新书籍的addBook方法，该方法以JSON形式传递一个Book对象，接下来我们使用<code>@Decrypt</code>注解来对请求中的参数进行解密，这里直接将上面接口返回的object数据作为参数进行传入，可以看到方法返回结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-85aa87d0d8bd81ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这也就说明接口数据解密成功了。</p>
<h1 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h1><p>接下来我们就来看一下前面使用的<code>AES/ECB/PKCS5Padding</code>这个算法字符串。该字符串包含三部分，其中第一部分是算法，此处使用AES算法；第二部分是模式，此处设置ECB模式；第三部分是填充方式，此处设置PKCS5Padding，注意此时秘钥的长度必须为128个比特位，即16个字符长度。</p>
<p>ECB模式是最简单的工作模式，它直接将明文进行分组，然后每组分别加密，这样使得每个分组独立且前后无任何关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * AES/ECB/PKCS5Padding (128)</span><br><span class="line">  * AES加密 ECB模式 PKCS5填充方式 密钥长度必须为16个字节(128位)</span><br><span class="line">  */</span><br><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line">     //密钥生成器</span><br><span class="line">     KeyGenerator kgen = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">     //设置密钥长度128位</span><br><span class="line">     kgen.init(128, new SecureRandom());</span><br><span class="line">     //生成key</span><br><span class="line">     SecretKey key = kgen.generateKey();</span><br><span class="line"></span><br><span class="line">     //长度为16的二进制数组，密钥我们自己生成也可以.</span><br><span class="line">     byte[] keyBytes = key.getEncoded();</span><br><span class="line">     System.out.println(&quot;keyBytes长度是16 = &quot; + keyBytes.length);</span><br><span class="line"></span><br><span class="line">     //创建AES的密钥</span><br><span class="line">     SecretKeySpec aesKey = new SecretKeySpec(keyBytes, &quot;AES&quot;);</span><br><span class="line"></span><br><span class="line">     //加密 模式 填充方式</span><br><span class="line">     Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);</span><br><span class="line">     cipher.init(Cipher.ENCRYPT_MODE, aesKey);</span><br><span class="line"></span><br><span class="line">     //对abc进行加密，因为明文长度不固定，所以需要先分组在加密，每一组长度16个字节</span><br><span class="line">     //不够16的需要进行填充，abc的长度是3个字节，所以要填充13个字节在进行加密</span><br><span class="line">     //所以encrypt的长度为16，因为在加密之前填充了</span><br><span class="line">     //如果长度正好为16个字节，那么也要新填充一个16长度的组，那么加密后的encrypt的长度为32</span><br><span class="line">     byte[] encrypt = cipher.doFinal(&quot;abc&quot;.getBytes());</span><br><span class="line">     System.out.println(encrypt.length);</span><br><span class="line"></span><br><span class="line">     cipher.init(Cipher.DECRYPT_MODE, aesKey);</span><br><span class="line">     byte[] decrypt = cipher.doFinal(encrypt);</span><br><span class="line">     System.out.println(new String(decrypt));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>整个加密和解密过程如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8964398-83541dcae149f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章通过对RequestBodyAdvice和ResponseBodyAdvice的介绍让我们知道了如何对请求和响应进行预处理操作，同时结合平常使用的接口加解密需求来实践该知识点。当然了本篇所介绍的接口加解密非常简单，后续笔者会在此基础上扩展加解密方式、支持类上加解密（类中所有接口加解密）、接口动态实现加解密以及定义一个加解密可视化平台。感兴趣的小伙伴可以关注公众号“啃饼思录”，笔者会在那里更新该场景启动器的开发进度信息。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://envyzhan.asia">余思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/">http://envyzhan.asia/2022/06/18/14-springboot-easily-implements-interface-encryptioon-and-decryption/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://envyzhan.asia" target="_blank">余思博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springboot/">springboot</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/28/2022-k8s-2-simple-environment-construction/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kubernetes基础知识</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/06/13-spring-boot-implements-graphic-verification-code/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot实现图形验证码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/26/11-springboot-implements-timed-tasks/" title="SpringBoot实现定时任务"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-26</div><div class="title">SpringBoot实现定时任务</div></div></a></div><div><a href="/2022/06/01/12-springboot-realizes-the-repeated-reading-of-json-data/" title="SpringBoot实现JSON数据重复读取"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-01</div><div class="title">SpringBoot实现JSON数据重复读取</div></div></a></div><div><a href="/2022/08/02/15-springboot-integrates-canal-to-realize-data-incremental-synchronization/" title="SpringBoot整合Canal实现数据增量同步"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-02</div><div class="title">SpringBoot整合Canal实现数据增量同步</div></div></a></div><div><a href="/2022/03/20/4-dynamic-switching-of-visual-multiple-data-sources/" title="可视化多数据源动态切换"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-20</div><div class="title">可视化多数据源动态切换</div></div></a></div><div><a href="/2022/03/24/5-an-annotation-cooperates-with-redis-to-realize-interface-current-limition/" title="一个注解配合Redis实现接口限流"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-24</div><div class="title">一个注解配合Redis实现接口限流</div></div></a></div><div><a href="/2019/09/25/springboot-21-project-build-and-development/" title="项目构建与部署"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-25</div><div class="title">项目构建与部署</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">余思</div><div class="author-info__description">记录成长路上的点滴</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">257</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:envyzhan@aliyun.com" target="_blank" title=""><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问余思博客，一个技术博主的成长试验田！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%9C%BA%E6%99%AF%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">编写加解密场景启动器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">项目本地打包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">应用测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ECB%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">ECB模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/27/2024-6-mult-tenant-architecture-design-and-practice/" title="多租户架构设计与实践"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多租户架构设计与实践"/></a><div class="content"><a class="title" href="/2024/04/27/2024-6-mult-tenant-architecture-design-and-practice/" title="多租户架构设计与实践">多租户架构设计与实践</a><time datetime="2024-04-27T11:55:30.000Z" title="发表于 2024-04-27 19:55:30">2024-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/" title="详解MySQL中的JSON数据类型"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="详解MySQL中的JSON数据类型"/></a><div class="content"><a class="title" href="/2024/03/23/2024-3-detailed-explanation-of-json-data-types-in-mysql/" title="详解MySQL中的JSON数据类型">详解MySQL中的JSON数据类型</a><time datetime="2024-03-23T10:55:30.000Z" title="发表于 2024-03-23 18:55:30">2024-03-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/" title="聊一聊六种常用的属性配置读取方式"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="聊一聊六种常用的属性配置读取方式"/></a><div class="content"><a class="title" href="/2024/03/02/2024-2-six-common-configuration-methods-for-reading-properties/" title="聊一聊六种常用的属性配置读取方式">聊一聊六种常用的属性配置读取方式</a><time datetime="2024-03-02T02:55:30.000Z" title="发表于 2024-03-02 10:55:30">2024-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/" title="聊一聊九种常用的分布式ID生成方案"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="聊一聊九种常用的分布式ID生成方案"/></a><div class="content"><a class="title" href="/2024/02/03/2024-1-nine-commonly-used-distributed-id-generation-schemes/" title="聊一聊九种常用的分布式ID生成方案">聊一聊九种常用的分布式ID生成方案</a><time datetime="2024-02-03T06:55:27.000Z" title="发表于 2024-02-03 14:55:27">2024-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/" title="巧用分页列表缓存，快速响应用户请求"><img src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="巧用分页列表缓存，快速响应用户请求"/></a><div class="content"><a class="title" href="/2023/05/28/2023-104-cleverly-using-paginated-list-caching-to-quickly-respond-to-user-requests/" title="巧用分页列表缓存，快速响应用户请求">巧用分页列表缓存，快速响应用户请求</a><time datetime="2023-05-28T08:55:30.000Z" title="发表于 2023-05-28 16:55:30">2023-05-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2024  余思博客,记录成长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '9996b44b488f2fc52124',
      clientSecret: '6bec0f8e9c032eeae6211a5d4cffa3c97e2d4a64',
      repo: 'blogcomment',
      owner: 'Envythink',
      admin: ['Envythink'],
      id: '70e560405c7f8ef9a13e574419d28bfe',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>